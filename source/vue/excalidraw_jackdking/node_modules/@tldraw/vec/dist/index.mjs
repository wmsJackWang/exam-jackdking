var h=Object.defineProperty;var d=(s,n,r)=>n in s?h(s,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):s[n]=r;var m=(s,n,r)=>(d(s,typeof n!="symbol"?n+"":n,r),r);var t=class{static clamp(n,r,u){return Math.max(r,typeof u!="undefined"?Math.min(n,u):n)}static clampV(n,r,u){return n.map(b=>u?t.clamp(b,r,u):t.clamp(b,r))}static cross(n,r,u){return(r[0]-n[0])*(u[1]-n[1])-(u[0]-n[0])*(r[1]-n[1])}static snap(n,r=1){return[Math.round(n[0]/r)*r,Math.round(n[1]/r)*r]}},e=t;m(e,"neg",n=>[-n[0],-n[1]]),m(e,"add",(n,r)=>[n[0]+r[0],n[1]+r[1]]),m(e,"addScalar",(n,r)=>[n[0]+r,n[1]+r]),m(e,"sub",(n,r)=>[n[0]-r[0],n[1]-r[1]]),m(e,"subScalar",(n,r)=>[n[0]-r,n[1]-r]),m(e,"vec",(n,r)=>[r[0]-n[0],r[1]-n[1]]),m(e,"mul",(n,r)=>[n[0]*r,n[1]*r]),m(e,"mulV",(n,r)=>[n[0]*r[0],n[1]*r[1]]),m(e,"div",(n,r)=>[n[0]/r,n[1]/r]),m(e,"divV",(n,r)=>[n[0]/r[0],n[1]/r[1]]),m(e,"per",n=>[n[1],-n[0]]),m(e,"dpr",(n,r)=>n[0]*r[0]+n[1]*r[1]),m(e,"cpr",(n,r)=>n[0]*r[1]-r[0]*n[1]),m(e,"len2",n=>n[0]*n[0]+n[1]*n[1]),m(e,"len",n=>Math.hypot(n[0],n[1])),m(e,"pry",(n,r)=>t.dpr(n,r)/t.len(r)),m(e,"uni",n=>t.div(n,t.len(n))),m(e,"normalize",n=>t.uni(n)),m(e,"tangent",(n,r)=>t.uni(t.sub(n,r))),m(e,"dist2",(n,r)=>t.len2(t.sub(n,r))),m(e,"dist",(n,r)=>Math.hypot(n[1]-r[1],n[0]-r[0])),m(e,"fastDist",(n,r)=>{let u=[r[0]-n[0],r[1]-n[1]],b=[Math.abs(u[0]),Math.abs(u[1])],a=1/Math.max(b[0],b[1]);return a=a*(1.29289-(b[0]+b[1])*a*.29289),[u[0]*a,u[1]*a]}),m(e,"ang",(n,r)=>Math.atan2(t.cpr(n,r),t.dpr(n,r))),m(e,"angle",(n,r)=>Math.atan2(r[1]-n[1],r[0]-n[0])),m(e,"med",(n,r)=>t.mul(t.add(n,r),.5)),m(e,"rot",(n,r=0)=>[n[0]*Math.cos(r)-n[1]*Math.sin(r),n[0]*Math.sin(r)+n[1]*Math.cos(r)]),m(e,"rotWith",(n,r,u=0)=>{if(u===0)return n;let b=Math.sin(u),a=Math.cos(u),i=n[0]-r[0],o=n[1]-r[1],c=i*a-o*b,l=i*b+o*a;return[c+r[0],l+r[1]]}),m(e,"isEqual",(n,r)=>n[0]===r[0]&&n[1]===r[1]),m(e,"lrp",(n,r,u)=>t.add(n,t.mul(t.sub(r,n),u))),m(e,"int",(n,r,u,b,a=1)=>{let i=(t.clamp(u,b)-u)/(b-u);return t.add(t.mul(n,1-i),t.mul(r,a))}),m(e,"ang3",(n,r,u)=>{let b=t.vec(r,n),a=t.vec(r,u);return t.ang(b,a)}),m(e,"abs",n=>[Math.abs(n[0]),Math.abs(n[1])]),m(e,"rescale",(n,r)=>{let u=t.len(n);return[r*n[0]/u,r*n[1]/u]}),m(e,"isLeft",(n,r,u)=>(r[0]-n[0])*(u[1]-n[1])-(u[0]-n[0])*(r[1]-n[1])),m(e,"clockwise",(n,r,u)=>t.isLeft(n,r,u)>0),m(e,"toFixed",n=>n.map(r=>Math.round(r*100)/100)),m(e,"nearestPointOnLineThroughPoint",(n,r,u)=>t.add(n,t.mul(r,t.pry(t.sub(u,n),r)))),m(e,"distanceToLineThroughPoint",(n,r,u)=>t.dist(u,t.nearestPointOnLineThroughPoint(n,r,u))),m(e,"nearestPointOnLineSegment",(n,r,u,b=!0)=>{let a=t.uni(t.sub(r,n)),i=t.add(n,t.mul(a,t.pry(t.sub(u,n),a)));if(b){if(i[0]<Math.min(n[0],r[0]))return n[0]<r[0]?n:r;if(i[0]>Math.max(n[0],r[0]))return n[0]>r[0]?n:r;if(i[1]<Math.min(n[1],r[1]))return n[1]<r[1]?n:r;if(i[1]>Math.max(n[1],r[1]))return n[1]>r[1]?n:r}return i}),m(e,"distanceToLineSegment",(n,r,u,b=!0)=>t.dist(u,t.nearestPointOnLineSegment(n,r,u,b))),m(e,"nearestPointOnBounds",(n,r)=>[t.clamp(r[0],n.minX,n.maxX),t.clamp(r[1],n.minY,n.maxY)]),m(e,"distanceToBounds",(n,r)=>t.dist(r,t.nearestPointOnBounds(n,r))),m(e,"nudge",(n,r,u)=>t.isEqual(n,r)?n:t.add(n,t.mul(t.uni(t.sub(r,n)),u))),m(e,"nudgeAtAngle",(n,r,u)=>[Math.cos(r)*u+n[0],Math.sin(r)*u+n[1]]),m(e,"toPrecision",(n,r=4)=>[+n[0].toPrecision(r),+n[1].toPrecision(r)]),m(e,"pointsBetween",(n,r,u=6)=>Array.from(Array(u)).map((b,a)=>{let i=a/(u-1),o=Math.min(1,.5+Math.abs(.5-i));return[...t.lrp(n,r,i),o]})),m(e,"slope",(n,r)=>n[0]===r[0]?NaN:(n[1]-r[1])/(n[0]-r[0])),m(e,"max",(...n)=>[Math.max(...n.map(r=>r[0])),Math.max(...n.map(r=>r[1]))]),m(e,"min",(...n)=>[Math.min(...n.map(r=>r[0])),Math.min(...n.map(r=>r[1]))]);var p=e;export{e as Vec,p as default};
//# sourceMappingURL=index.mjs.map
