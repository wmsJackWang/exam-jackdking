import 'reflect-metadata';

function stringify(token) {
    if (typeof token === 'string') {
        return token;
    }
    if (Array.isArray(token)) {
        return '[' + token.map(stringify).join(', ') + ']';
    }
    if (token == null) {
        return '' + token;
    }
    if (token.name) {
        return "".concat(token.name);
    }
    if (token.token) {
        return "".concat(token.token);
    }
    var res = token.toString();
    if (res == null) {
        return '' + res;
    }
    var newLineIndex = res.indexOf('\n');
    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}

function makeInjectError(name) {
    return function injectError(token) {
        var error = new Error("No provide for `".concat(stringify(token), "`!"));
        error.name = name;
        return error;
    };
}
function makeProvideScopeError(name) {
    return function provideError(token) {
        var error = new Error("Can not found provide scope `".concat(stringify(token), "`!"));
        error.name = name;
        return error;
    };
}

/**
 * 用于保存 class 的元数据
 */
var Annotations = /** @class */ (function () {
    function Annotations() {
        this.classes = new Map();
        this.props = new Map();
        this.methods = new Map();
        this.params = new Map();
    }
    Annotations.prototype.setClassMetadata = function (token, params) {
        this.classes.set(token, params);
    };
    Annotations.prototype.getClassMetadata = function (token) {
        return this.classes.get(token);
    };
    Annotations.prototype.getClassMetadataKeys = function () {
        return Array.from(this.classes.keys());
    };
    Annotations.prototype.pushParamMetadata = function (token, params) {
        if (!this.params.has(token)) {
            this.params.set(token, [params]);
        }
        else {
            this.params.get(token).push(params);
        }
    };
    Annotations.prototype.getParamMetadata = function (token) {
        return this.params.get(token);
    };
    Annotations.prototype.getParamMetadataKeys = function () {
        return Array.from(this.params.keys());
    };
    Annotations.prototype.getPropMetadataKeys = function () {
        return Array.from(this.props.keys());
    };
    Annotations.prototype.pushPropMetadata = function (token, params) {
        if (!this.props.has(token)) {
            this.props.set(token, [params]);
        }
        else {
            this.props.get(token).push(params);
        }
    };
    Annotations.prototype.getPropMetadata = function (token) {
        return this.props.get(token);
    };
    Annotations.prototype.pushMethodMetadata = function (token, params) {
        if (!this.methods.has(token)) {
            this.methods.set(token, [params]);
        }
        else {
            this.methods.get(token).push(params);
        }
    };
    Annotations.prototype.getMethodMetadata = function (token) {
        return this.methods.get(token);
    };
    return Annotations;
}());

/**
 * 创建参数装饰器的工厂函数
 */
function makeParamDecorator(token, metadata) {
    return function (target, propertyKey, parameterIndex) {
        var annotations = getAnnotations(target);
        annotations.pushParamMetadata(token, {
            propertyKey: propertyKey,
            parameterIndex: parameterIndex,
            metadata: metadata
        });
    };
}
/**
 * 创建属性装饰器的工厂函数
 */
function makePropertyDecorator(token, injectToken, contextCallback) {
    return function (target, propertyKey) {
        var annotations = getAnnotations(target.constructor);
        annotations.pushPropMetadata(token, {
            injectToken: injectToken || Reflect.getMetadata('design:type', target, propertyKey),
            propertyKey: propertyKey,
            contextCallback: contextCallback
        });
    };
}
/**
 * 创建方法装饰器的工厂函数
 */
function makeMethodDecorator(token) {
    var params = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        params[_i - 1] = arguments[_i];
    }
    return function (target, methodName) {
        var annotations = getAnnotations(target.constructor);
        annotations.pushMethodMetadata(token, {
            methodName: methodName,
            params: params
        });
    };
}
/**
 * 创建类装饰器的工厂函数
 */
function makeClassDecorator(token, metadata) {
    return function (target) {
        var annotations = getAnnotations(target);
        annotations.setClassMetadata(token, {
            paramTypes: Reflect.getMetadata('design:paramtypes', target),
            metadata: metadata
        });
    };
}
/**
 * 获取类注解的工具函数
 */
function getAnnotations(target) {
    var key = '__annotations__';
    // eslint-disable-next-line no-prototype-builtins
    if (!target.hasOwnProperty(key)) {
        target[key] = new Annotations();
    }
    return target[key];
}

var ForwardRef = /** @class */ (function () {
    function ForwardRef(forwardRefFn) {
        this.forwardRefFn = forwardRefFn;
    }
    ForwardRef.prototype.getRef = function () {
        return this.forwardRefFn();
    };
    return ForwardRef;
}());
/**
 * 引用后声明的类的工具函数
 * @param fn
 */
function forwardRef(fn) {
    return new ForwardRef(fn);
}

var Scope = /** @class */ (function () {
    function Scope(name) {
        this.name = name;
    }
    Scope.prototype.toString = function () {
        return this.name || '[anonymous provide scope]';
    };
    return Scope;
}());
/**
 * 可注入类的装饰器
 */
var Injectable = function InjectableDecorator(options) {
    if (this instanceof InjectableDecorator) {
        this.provideIn = (options === null || options === void 0 ? void 0 : options.provideIn) || null;
    }
    else {
        return makeClassDecorator(Injectable, new Injectable(options));
    }
};

/**
 * 生成自定义依赖注入 token 的类
 */
var InjectionToken = /** @class */ (function () {
    function InjectionToken(description) {
        this.description = description;
    }
    InjectionToken.prototype.toString = function () {
        return this.description || '[anonymous injection token]';
    };
    return InjectionToken;
}());

/**
 * 查找规则
 */
var InjectFlags;
(function (InjectFlags) {
    /** 默认查找规则 */
    InjectFlags["Default"] = "Default";
    /** 锁定当前容器 */
    InjectFlags["Self"] = "Self";
    /** 跳过当前容器 */
    InjectFlags["SkipSelf"] = "SkipSelf";
    /** 可选查找 */
    InjectFlags["Optional"] = "Optional";
})(InjectFlags || (InjectFlags = {}));
/**
 * DI 容器抽象基类
 */
var Injector = /** @class */ (function () {
    function Injector() {
    }
    return Injector;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var THROW_IF_NOT_FOUND = {
    __debug_value__: 'THROW_IF_NOT_FOUND'
};
var nullInjectorErrorFn = makeInjectError('NullInjectorError');
var NullInjector = /** @class */ (function (_super) {
    __extends(NullInjector, _super);
    function NullInjector() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.parentInjector = null;
        return _this;
    }
    NullInjector.prototype.get = function (token, notFoundValue) {
        if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
        if (notFoundValue === THROW_IF_NOT_FOUND) {
            throw nullInjectorErrorFn(token);
        }
        return notFoundValue;
    };
    return NullInjector;
}(Injector));

/**
 * 构造函数参数装饰器，用于改变注入 token
 */
var Inject = function InjectDecorator(token) {
    if (this instanceof Inject) {
        this.token = token;
    }
    else {
        return makeParamDecorator(Inject, new Inject(token));
    }
};
var Self = function SelfDecorator() {
    if (!(this instanceof Self)) {
        return makeParamDecorator(Self, new Self());
    }
};
var SkipSelf = function SkipSelfDecorator() {
    if (!(this instanceof SkipSelf)) {
        return makeParamDecorator(SkipSelf, new SkipSelf());
    }
};
var Optional = function OptionalDecorator() {
    if (!(this instanceof Optional)) {
        return makeParamDecorator(Optional, new Optional());
    }
};
var Prop = function PropDecorator(token, notFoundValue, flags) {
    if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
    if (!(this instanceof Prop)) {
        return makePropertyDecorator(Prop, token, function (instance, propertyName, token, injector) {
            instance[propertyName] = injector.get(token instanceof ForwardRef ? token.getRef() : token, notFoundValue, flags);
        });
    }
};

/**
 * 标准化 provide，并返回统一数据结构
 * @param provider
 */
function normalizeProvider(provider) {
    if (provider.useValue) {
        return normalizeValueProviderFactory(provider);
    }
    if (provider.useClass) {
        return normalizeClassProviderFactory(provider);
    }
    if (provider.useExisting) {
        return normalizeExistingProviderFactory(provider);
    }
    if (provider.useFactory) {
        return normalizeFactoryProviderFactory(provider);
    }
    if (provider.provide) {
        if (provider.provide instanceof InjectionToken) {
            return normalizeValueProviderFactory(provider);
        }
        return normalizeConstructorProviderFactory(provider);
    }
    return normalizeTypeProviderFactory(provider);
}
function normalizeValueProviderFactory(provider) {
    return {
        provide: provider.provide,
        scope: null,
        generateFactory: function () {
            return function () {
                return provider.useValue;
            };
        },
        deps: []
    };
}
function normalizeClassProviderFactory(provider) {
    var deps;
    var provideIn;
    if (provider.deps) {
        deps = normalizeDeps(provider.provide, provider.deps);
    }
    else {
        var resolvedClass = resolveClassParams(provider.useClass);
        provideIn = resolvedClass.scope;
        deps = normalizeDeps(provider.provide, resolvedClass.deps);
    }
    return {
        provide: provider.provide,
        scope: provideIn,
        deps: deps,
        generateFactory: function (injector, cacheFn) {
            return function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var instance = new ((_a = provider.useClass).bind.apply(_a, __spreadArray([void 0], __read(args), false)))();
                cacheFn(provider.provide, instance);
                var propMetadataKeys = getAnnotations(provider.useClass).getPropMetadataKeys();
                propMetadataKeys.forEach(function (key) {
                    var propsMetadata = getAnnotations(provider.useClass).getPropMetadata(key) || [];
                    propsMetadata.forEach(function (item) {
                        item.contextCallback(instance, item.propertyKey, item.injectToken, injector);
                    });
                });
                return instance;
            };
        }
    };
}
function normalizeExistingProviderFactory(provider) {
    return {
        provide: provider.provide,
        scope: null,
        generateFactory: function (injector) {
            return function () {
                return injector.get(provider.useExisting);
            };
        },
        deps: []
    };
}
function normalizeFactoryProviderFactory(provider) {
    return {
        provide: provider.provide,
        scope: null,
        generateFactory: function () {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return provider.useFactory.apply(provider, __spreadArray([], __read(args), false));
            };
        },
        deps: normalizeDeps(provider.provide, provider.deps || [])
    };
}
function normalizeConstructorProviderFactory(provider) {
    return normalizeClassProviderFactory(__assign(__assign({}, provider), { useClass: provider.provide }));
}
function normalizeTypeProviderFactory(provider) {
    return normalizeClassProviderFactory({
        provide: provider,
        useClass: provider
    });
}
function resolveClassParams(construct) {
    var annotations = getAnnotations(construct);
    var metadata = annotations.getClassMetadata(Injectable);
    if (typeof metadata === 'undefined') {
        throw new Error("Class `".concat(stringify(construct), "` is not injectable!"));
    }
    var deps = (metadata.paramTypes || []).map(function (i) { return [i]; });
    var metadataKeys = [Inject, Self, SkipSelf, Optional];
    metadataKeys.forEach(function (key) {
        (annotations.getParamMetadata(key) || []).forEach(function (item) {
            deps[item.parameterIndex].push(item.metadata);
        });
    });
    return {
        scope: metadata.metadata.provideIn,
        deps: deps
    };
}
function normalizeDeps(provide, deps) {
    return deps.map(function (dep, index) {
        var r = {
            injectKey: null,
            optional: false,
            visibility: null
        };
        if (!Array.isArray(dep)) {
            r.injectKey = dep;
        }
        else {
            for (var i = 0; i < dep.length; i++) {
                var item = dep[i];
                if (item instanceof Inject) {
                    r.injectKey = item.token;
                }
                else if (item instanceof Self || item instanceof SkipSelf) {
                    r.visibility = item;
                }
                else if (item instanceof Optional) {
                    r.optional = true;
                }
                else {
                    r.injectKey = item;
                }
            }
        }
        if (typeof r.injectKey === 'undefined') {
            throw new Error("The ".concat(index, " th dependent parameter type of `").concat(stringify(provide), "` was not obtained,\nif the dependency is declared later, you can refer to it using `constructor(@Inject(forwardRef(() => [Type|InjectionToken])) paramName: [Type]) {}`"));
        }
        return r;
    });
}

var reflectiveInjectorErrorFn = makeInjectError('ReflectiveInjectorError');
var provideScopeError = makeProvideScopeError('ProvideScopeError');
/**
 * 反射注入器
 */
var ReflectiveInjector = /** @class */ (function (_super) {
    __extends(ReflectiveInjector, _super);
    function ReflectiveInjector(parentInjector, staticProviders, scope) {
        var _this = _super.call(this) || this;
        _this.parentInjector = parentInjector;
        _this.staticProviders = staticProviders;
        _this.scope = scope;
        _this.recordValues = new Map();
        _this.normalizedProviders = staticProviders.map(function (provide) {
            return normalizeProvider(provide);
        });
        return _this;
    }
    /**
     * 用于获取当前注入器上下文内的实例、对象或数据
     * @param token 访问 token
     * @param notFoundValue 如未查找到的返回值
     * @param flags 查询规则
     */
    ReflectiveInjector.prototype.get = function (token, notFoundValue, flags) {
        var _a;
        if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
        flags = flags || InjectFlags.Default;
        if (flags === InjectFlags.SkipSelf) {
            if (this.parentInjector) {
                return this.parentInjector.get(token, notFoundValue);
            }
            if (notFoundValue !== THROW_IF_NOT_FOUND) {
                return notFoundValue;
            }
            throw reflectiveInjectorErrorFn(token);
        }
        if (this.recordValues.has(token)) {
            return this.recordValues.get(token);
        }
        for (var i = 0; i < this.normalizedProviders.length; i++) {
            var normalizedProvider = this.normalizedProviders[i];
            if (normalizedProvider.provide === token) {
                return this.getValue(token, THROW_IF_NOT_FOUND, normalizedProvider);
            }
        }
        if (!(token instanceof InjectionToken)) {
            var scope = (_a = getAnnotations(token).getClassMetadata(Injectable)) === null || _a === void 0 ? void 0 : _a.metadata.provideIn;
            if (scope) {
                var normalizedProvider = normalizeProvider(token);
                if (this.scope === scope) {
                    this.normalizedProviders.push(normalizedProvider);
                    return this.getValue(token, THROW_IF_NOT_FOUND, normalizedProvider);
                }
                var parentInjector = this.parentInjector;
                if (!parentInjector || parentInjector instanceof NullInjector) {
                    if (normalizedProvider.scope === 'root') {
                        this.normalizedProviders.push(normalizedProvider);
                        return this.getValue(token, THROW_IF_NOT_FOUND, normalizedProvider);
                    }
                    if (notFoundValue !== THROW_IF_NOT_FOUND) {
                        return notFoundValue;
                    }
                    throw provideScopeError(normalizedProvider.scope);
                }
            }
        }
        if (flags === InjectFlags.Self) {
            if (notFoundValue === THROW_IF_NOT_FOUND) {
                throw reflectiveInjectorErrorFn(token);
            }
            return notFoundValue;
        }
        if (this.parentInjector) {
            return this.parentInjector.get(token, notFoundValue, flags === InjectFlags.Optional ? InjectFlags.Optional : InjectFlags.Default);
        }
        if (notFoundValue === THROW_IF_NOT_FOUND) {
            throw reflectiveInjectorErrorFn(token);
        }
        return notFoundValue;
    };
    ReflectiveInjector.prototype.getValue = function (token, notFoundValue, normalizedProvider) {
        var _this = this;
        if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
        var generateFactory = normalizedProvider.generateFactory, deps = normalizedProvider.deps;
        var params = this.resolveDeps(deps || [], notFoundValue);
        var value = this.recordValues.get(token);
        if (value) {
            return value;
        }
        var factory = generateFactory(this, function (token, value) {
            _this.recordValues.set(token, value);
        });
        value = factory.apply(void 0, __spreadArray([], __read(params), false));
        this.recordValues.set(token, value);
        return value;
    };
    /**
     * 解决并获取依赖参数
     * @param deps 依赖规则
     * @param notFoundValue 未查找到时的返回值
     * @private
     */
    ReflectiveInjector.prototype.resolveDeps = function (deps, notFoundValue) {
        var _this = this;
        return deps.map(function (dep) {
            var reflectiveValue;
            var tryValue = {};
            var injectToken = dep.injectKey instanceof ForwardRef ? dep.injectKey.getRef() : dep.injectKey;
            if (dep.visibility instanceof Self) {
                reflectiveValue = _this.get(injectToken, tryValue, InjectFlags.Self);
            }
            else if (dep.visibility instanceof SkipSelf) {
                if (_this.parentInjector) {
                    reflectiveValue = _this.parentInjector.get(injectToken, tryValue);
                }
                else {
                    if (dep.optional) {
                        if (notFoundValue === THROW_IF_NOT_FOUND) {
                            return null;
                        }
                    }
                    throw reflectiveInjectorErrorFn(injectToken);
                }
            }
            else {
                reflectiveValue = _this.get(injectToken, tryValue);
            }
            if (reflectiveValue === tryValue) {
                if (dep.optional) {
                    if (notFoundValue === THROW_IF_NOT_FOUND) {
                        return null;
                    }
                    return notFoundValue;
                }
                throw reflectiveInjectorErrorFn(injectToken);
            }
            return reflectiveValue;
        });
    };
    return ReflectiveInjector;
}(Injector));

var Type = Function;

export { Annotations, ForwardRef, Inject, InjectFlags, Injectable, InjectionToken, Injector, NullInjector, Optional, Prop, ReflectiveInjector, Scope, Self, SkipSelf, THROW_IF_NOT_FOUND, Type, forwardRef, getAnnotations, makeClassDecorator, makeInjectError, makeMethodDecorator, makeParamDecorator, makePropertyDecorator, makeProvideScopeError, normalizeProvider, stringify };
