class Subscriber {
    constructor(destinationOrNext) {
        Object.defineProperty(this, "closed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "syncErrorThrowable", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "destinationOrNext", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (typeof destinationOrNext === 'function') {
            this.destinationOrNext = {
                next: destinationOrNext
            };
        }
        else {
            this.destinationOrNext = destinationOrNext;
        }
    }
    next(value) {
        if (this.closed) {
            return;
        }
        if (this.destinationOrNext.next) {
            this.syncErrorThrowable = false;
            this.destinationOrNext.next(value);
            this.syncErrorThrowable = true;
        }
    }
    error(err) {
        if (this.closed) {
            return;
        }
        this.closed = true;
        if (this.destinationOrNext.error) {
            this.syncErrorThrowable = false;
            this.destinationOrNext.error(err);
            this.syncErrorThrowable = true;
            this.destinationOrNext = null;
            return;
        }
        this.syncErrorThrowable = false;
        this.destinationOrNext = null;
        throw err;
    }
    complete() {
        if (this.closed) {
            return;
        }
        this.closed = true;
        if (this.destinationOrNext.complete) {
            this.syncErrorThrowable = false;
            this.destinationOrNext.complete();
            this.syncErrorThrowable = true;
        }
        this.destinationOrNext = null;
    }
}

function noop() {
    //
}
class Subscription {
    constructor(unsubscribeCallback) {
        Object.defineProperty(this, "unsubscribeCallback", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: unsubscribeCallback
        });
        Object.defineProperty(this, "subs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "isStopped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    add(...subscriptions) {
        if (this.isStopped) {
            return this;
        }
        this.subs.push(...subscriptions);
        return this;
    }
    unsubscribe() {
        this.isStopped = true;
        if (this.unsubscribeCallback) {
            this.unsubscribeCallback();
            this.unsubscribeCallback = noop;
        }
        this.subs.forEach(i => i.unsubscribe());
        this.subs = [];
    }
}

class Observable {
    constructor(source = observer => {
        observer.complete();
    }) {
        Object.defineProperty(this, "source", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: source
        });
    }
    pipe(...operators) {
        if (operators.length === 0) {
            return this;
        }
        return operators.reduce((stream, nextOperator) => {
            return nextOperator(new Observable(subscriber => {
                return stream.subscribe(subscriber);
            }));
        }, this);
    }
    subscribe(observer = noop) {
        const subscriber = this.toSubscriber(observer);
        return this.trySubscribe(subscriber);
    }
    toPromise() {
        return new Promise((resolve, reject) => {
            this.subscribe({
                next(value) {
                    resolve(value);
                },
                error(err) {
                    reject(err);
                }
            });
        });
    }
    toSubscriber(observer) {
        if (typeof observer === 'function') {
            return new Subscriber({
                next: observer
            });
        }
        return new Subscriber(observer);
    }
    trySubscribe(subscriber) {
        let s;
        try {
            s = this.source(subscriber);
        }
        catch (e) {
            if (subscriber.syncErrorThrowable) {
                subscriber.error(e);
            }
            else {
                throw e;
            }
        }
        if (typeof s === 'function') {
            return new Subscription(function () {
                subscriber.closed = true;
                s();
            });
        }
        else if (s instanceof Subscription) {
            return new Subscription(function () {
                subscriber.closed = true;
                s.unsubscribe();
            });
        }
        return new Subscription(function () {
            subscriber.closed = true;
        });
    }
}

class Subject extends Observable {
    constructor() {
        super(subscriber => {
            this.subscribers.push(subscriber);
        });
        Object.defineProperty(this, "subscribers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    asObservable() {
        return new Observable(subscriber => {
            this.subscribe(subscriber);
        });
    }
    next(newValue) {
        [...this.subscribers].forEach(subscriber => {
            try {
                subscriber.next(newValue);
            }
            catch (e) {
                if (subscriber.syncErrorThrowable) {
                    subscriber.error(e);
                }
                else {
                    throw e;
                }
            }
        });
    }
    error(err) {
        [...this.subscribers].forEach(observer => {
            observer.error(err);
        });
    }
    complete() {
        [...this.subscribers].forEach(observer => {
            observer.complete();
        });
    }
}

class BehaviorSubject extends Subject {
    constructor(defaultValue) {
        super();
        Object.defineProperty(this, "currentValue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.currentValue = defaultValue;
    }
    next(newValue) {
        this.currentValue = newValue;
        super.next(newValue);
    }
    subscribe(observer = function () {
        //
    }) {
        const subscriber = this.toSubscriber(observer);
        const subscription = this.trySubscribe(subscriber);
        subscriber.next(this.currentValue);
        return subscription;
    }
}

/**
 * 创建一个马上完成的可观察对象
 */
function empty() {
    return new Observable(subscriber => {
        subscriber.complete();
    });
}

/**
 * 绑定 DOM 事件，并转换为数据流
 * @param source 要绑定事件的 DOM 元素
 * @param type 事件名
 * @param capture 是否使用事件捕获
 */
function fromEvent(source, type, capture = false) {
    return new Observable(subscriber => {
        function listenFn(event) {
            return subscriber.next(event);
        }
        source.addEventListener(type, listenFn, capture);
        return function () {
            source.removeEventListener(type, listenFn);
        };
    });
}

/**
 * 将 Promise 转换为数据流
 * @param input
 */
function fromPromise(input) {
    return new Observable(subscriber => {
        input.then(v => {
            subscriber.next(v);
            subscriber.complete();
        }).catch(e => {
            subscriber.error(e);
        });
    });
}

/**
 * 创建间隔固定时间，发送新值的数据流
 * @param period 间隔的时间
 */
function interval(period = 1000) {
    return new Observable(subscriber => {
        let timer;
        let i = 0;
        function next() {
            timer = setTimeout(function () {
                subscriber.next(i);
                next();
                i++;
            }, period);
        }
        next();
        return function () {
            clearTimeout(timer);
        };
    });
}

function merge(...inputs) {
    return new Observable(subscriber => {
        if (inputs.length === 0) {
            subscriber.complete();
        }
        const marks = inputs.map(i => {
            return {
                source: i,
                isComplete: false
            };
        });
        const subs = marks.map(s => {
            return s.source.subscribe({
                next(value) {
                    subscriber.next(value);
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    s.isComplete = true;
                    if (marks.every(i => i.isComplete)) {
                        subscriber.complete();
                    }
                }
            });
        });
        return function () {
            subs.forEach(i => i.unsubscribe());
        };
    });
}

function of(...data) {
    return new Observable(subscriber => {
        data.forEach(i => subscriber.next(i));
        subscriber.complete();
    });
}

function race(...inputs) {
    return new Observable(subscriber => {
        if (inputs.length === 0) {
            subscriber.complete();
            return;
        }
        let canPublish = true;
        const subs = [];
        for (const input of inputs) {
            if (!canPublish) {
                break;
            }
            subs.push(input.subscribe({
                next(value) {
                    if (canPublish) {
                        canPublish = false;
                        subscriber.next(value);
                        subscriber.complete();
                    }
                },
                error(err) {
                    if (canPublish) {
                        subscriber.error(err);
                    }
                },
                complete() {
                    subs.forEach(i => i.unsubscribe());
                    subscriber.complete();
                }
            }));
        }
        return function () {
            subs.forEach(i => i.unsubscribe());
        };
    });
}

/**
 * 创建一个发出错误的可观察对象
 * @param err
 */
function throwError(err) {
    return new Observable(subscriber => {
        subscriber.error(err || new Error());
    });
}

/**
 * 延迟一段时间发送数据
 * @param delay 要延迟的时间
 * @param data 要发送的值
 */
function timeout(delay = 1000, data = 0) {
    return new Observable(subscriber => {
        const timer = setTimeout(function () {
            subscriber.next(data);
            subscriber.complete();
        }, delay);
        return function () {
            clearTimeout(timer);
        };
    });
}

function zip(...inputs) {
    return new Observable(subscriber => {
        if (inputs.length === 0) {
            subscriber.complete();
            return;
        }
        const marks = inputs.map(source => {
            return {
                source,
                values: [],
                isComplete: false
            };
        });
        const subscription = new Subscription();
        function handleComplete() {
            for (const i of marks) {
                if (i.isComplete && i.values.length === 0) {
                    subscriber.complete();
                    subscription.unsubscribe();
                    break;
                }
            }
        }
        marks.forEach((config) => {
            subscription.add(config.source.subscribe({
                next(value) {
                    const values = config.values;
                    values.push(value);
                    if (marks.every(i => i.values.length)) {
                        subscriber.next(marks.map(item => {
                            return item.values.shift();
                        }));
                        handleComplete();
                    }
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    config.isComplete = true;
                    handleComplete();
                }
            }));
        });
        return subscription;
    });
}

/**
 * 当有新值时，记录值，并延迟一段时间，发送记录的值
 * @param time 要延迟的时间
 */
function auditTime(time) {
    return function (source) {
        return new Observable(subscriber => {
            let canPublish = true;
            let timer = null;
            let value;
            let isComplete = false;
            let hasError = false;
            const sub = source.subscribe({
                next(v) {
                    if (canPublish) {
                        value = v;
                        canPublish = false;
                        timer = setTimeout(() => {
                            timer = null;
                            canPublish = true;
                            subscriber.next(value);
                            if (isComplete) {
                                subscriber.complete();
                            }
                        }, time);
                    }
                },
                error(err) {
                    hasError = true;
                    if (sub) {
                        sub.unsubscribe();
                    }
                    subscriber.error(err);
                },
                complete() {
                    if (timer === null) {
                        subscriber.complete();
                    }
                    else {
                        isComplete = true;
                    }
                }
            });
            if (hasError) {
                sub.unsubscribe();
            }
            return function () {
                clearTimeout(timer);
                sub.unsubscribe();
            };
        });
    };
}

/**
 * 当有新值时，延迟指定的时间，并收集这段时间中所有的值，在时间到达之后，把所有收集到的值一并发送
 * @param time 要延迟的时间
 */
function bufferTime(time) {
    return function (source) {
        return new Observable(subscriber => {
            let values = [];
            let isStart = false;
            let timer = null;
            let isComplete = false;
            const subscription = source.subscribe({
                next(value) {
                    values.push(value);
                    if (!isStart) {
                        isStart = true;
                        timer = setTimeout(() => {
                            const v = values;
                            values = [];
                            isStart = false;
                            subscriber.next(v);
                            if (isComplete) {
                                subscriber.complete();
                            }
                        }, time);
                    }
                },
                error(err) {
                    clearTimeout(timer);
                    subscriber.error(err);
                },
                complete() {
                    isComplete = true;
                    if (values.length) {
                        return;
                    }
                    subscriber.complete();
                }
            });
            return function () {
                clearTimeout(timer);
                subscription.unsubscribe();
            };
        });
    };
}

function concat(...inputs) {
    return function (source) {
        return new Observable(subscriber => {
            const streams = [source, ...inputs];
            let sub;
            let isUnsubscribe = false;
            function toNext() {
                const stream = streams.shift();
                sub = stream.subscribe({
                    next(value) {
                        subscriber.next(value);
                    },
                    error(err) {
                        subscriber.error(err);
                    },
                    complete() {
                        if (isUnsubscribe) {
                            return;
                        }
                        if (streams.length === 0) {
                            subscriber.complete();
                            return;
                        }
                        toNext();
                    }
                });
            }
            toNext();
            return function () {
                isUnsubscribe = true;
                sub.unsubscribe();
            };
        });
    };
}

/**
 * 在一段时间内，没有新值时，才发送最新的值
 * @param time
 */
function debounceTime(time) {
    return function (source) {
        return new Observable(subscriber => {
            let timer = null;
            let isComplete = false;
            const sub = source.subscribe({
                next(v) {
                    clearTimeout(timer);
                    timer = setTimeout(function () {
                        timer = null;
                        subscriber.next(v);
                        if (isComplete) {
                            subscriber.complete();
                        }
                    }, time);
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    if (timer === null) {
                        subscriber.complete();
                    }
                    else {
                        isComplete = true;
                    }
                }
            });
            return function () {
                timer = null;
                clearTimeout(timer);
                sub.unsubscribe();
            };
        });
    };
}

/**
 * 将源数据流延迟一段时间再发送
 * @param time
 */
function delay(time = 0) {
    return function (source) {
        return new Observable(subscriber => {
            const timers = [];
            let isComplete = false;
            const sub = source.subscribe({
                next(v) {
                    timers.push(setTimeout(function () {
                        timers.shift();
                        subscriber.next(v);
                        if (isComplete && timers.length === 0) {
                            subscriber.complete();
                        }
                    }, time));
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    isComplete = true;
                }
            });
            return function () {
                timers.forEach(i => clearTimeout(i));
                sub.unsubscribe();
            };
        });
    };
}

/**
 * 当前置 Observable 完成时，才发送之后产生的值
 * @param prerequisite
 */
function delayWhen(prerequisite) {
    return function (source) {
        return new Observable(subscriber => {
            const sub = new Subscription();
            const sub1 = source.subscribe({
                next(v) {
                    sub.add(prerequisite(v).subscribe({
                        complete() {
                            subscriber.next(v);
                        }
                    }));
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    sub.unsubscribe();
                    subscriber.complete();
                }
            });
            return function () {
                sub.unsubscribe();
                sub1.unsubscribe();
            };
        });
    };
}

/**
 * 过滤连续重复的值
 */
function distinctUntilChanged(comparator) {
    return function (source) {
        return new Observable(subscriber => {
            let lastValue = {};
            let isFirst = true;
            return source.subscribe({
                next(value) {
                    if (isFirst) {
                        isFirst = false;
                        lastValue = value;
                        subscriber.next(value);
                        return;
                    }
                    if (comparator) {
                        const b = comparator(lastValue, value);
                        lastValue = value;
                        if (b) {
                            subscriber.next(value);
                        }
                    }
                    else if (value !== lastValue) {
                        lastValue = value;
                        subscriber.next(value);
                    }
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    subscriber.complete();
                }
            });
        });
    };
}

/**
 * 当所有数据都满足条件时，才发送 true
 * @param test
 */
function every(test) {
    return function (source) {
        return new Observable(subscriber => {
            const sub = source.subscribe({
                next(value) {
                    const b = test(value);
                    if (!b) {
                        subscriber.next(false);
                        subscriber.complete();
                        sub.unsubscribe();
                    }
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    subscriber.next(true);
                    subscriber.complete();
                }
            });
            return sub;
        });
    };
}

/**
 * 过滤源数据流，只发送返回为 true 时的数据
 * @param handle
 */
function filter(handle) {
    return function (source) {
        return new Observable(subscriber => {
            return source.subscribe({
                next(value) {
                    if (handle(value)) {
                        subscriber.next(value);
                    }
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    subscriber.complete();
                }
            });
        });
    };
}

/**
 * 将源数据转换成另外一种数据，再发送出去
 * @param handle 转换函数
 */
function map(handle) {
    return function (source) {
        return new Observable(subscriber => {
            return source.subscribe({
                next(value) {
                    subscriber.next(handle(value));
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    subscriber.complete();
                }
            });
        });
    };
}

/**
 * 创建一个微任务，并收集周期内所有的值，当微任务执行时，把所有缓存的值全部向后发送。
 */
function microTask() {
    return function (source) {
        return new Observable(subscriber => {
            let values = [];
            let task = null;
            let isComplete = false;
            return source.subscribe({
                next(v) {
                    values.push(v);
                    if (!task) {
                        task = Promise.resolve().then(() => {
                            const nextValues = values;
                            values = [];
                            task = null;
                            subscriber.next(nextValues);
                            if (isComplete) {
                                subscriber.complete();
                            }
                        });
                    }
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    if (task === null) {
                        subscriber.complete();
                    }
                    else {
                        isComplete = true;
                    }
                }
            });
        });
    };
}

/**
 * 当数据源发生错误时，重新尝试订阅
 * @param count
 */
function retry(count) {
    return function (source) {
        return new Observable(subscriber => {
            let i = 0;
            let hasError = false;
            function subscribe() {
                return source.subscribe({
                    next(value) {
                        subscriber.next(value);
                    },
                    error(err) {
                        if (i < count) {
                            i++;
                            subscription = subscribe();
                        }
                        else {
                            hasError = true;
                            subscriber.error(err);
                        }
                    },
                    complete() {
                        subscriber.complete();
                    }
                });
            }
            let subscription = subscribe();
            if (hasError) {
                subscription.unsubscribe();
            }
            return function () {
                subscription.unsubscribe();
            };
        });
    };
}

/**
 * 忽略源值，并延迟一段时间，发送最新的值
 * @param time 要延迟的时间
 */
function sampleTime(time) {
    return function (source) {
        return new Observable(subscriber => {
            let canPublish = true;
            let timer = null;
            let value;
            let isComplete = false;
            let hasError = false;
            const sub = source.subscribe({
                next(v) {
                    value = v;
                    if (canPublish) {
                        canPublish = false;
                        timer = setTimeout(() => {
                            canPublish = true;
                            timer = null;
                            subscriber.next(value);
                            if (isComplete) {
                                subscriber.complete();
                            }
                        }, time);
                    }
                },
                error(err) {
                    hasError = true;
                    if (sub) {
                        sub.unsubscribe();
                    }
                    subscriber.error(err);
                },
                complete() {
                    if (timer === null) {
                        subscriber.complete();
                    }
                    else {
                        isComplete = true;
                    }
                }
            });
            if (hasError) {
                sub.unsubscribe();
            }
            return function () {
                clearTimeout(timer);
                sub.unsubscribe();
            };
        });
    };
}

/**
 * 让多个订阅共享同一个数据源，而不是创建新的
 */
function share() {
    return function (source) {
        const subject = new Subject();
        source.subscribe({
            next(value) {
                subject.next(value);
            },
            error(err) {
                subject.error(err);
            },
            complete() {
                subject.complete();
            }
        });
        return subject;
    };
}

/**
 * 跳过指定次数的数据，然后发送后面的值
 * @param count 要跳过的次数
 */
function skip(count) {
    return function (source) {
        return new Observable(subscriber => {
            let i = 0;
            const subscribe = {
                next(value) {
                    if (i < count) {
                        i++;
                        return;
                    }
                    subscriber.next(value);
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    subscriber.complete();
                }
            };
            return source.subscribe(subscribe);
        });
    };
}

/**
 * 返回一个新的数据流，并以新数据流的订阅结果，发送出去
 * @param handle
 */
function switchMap(handle) {
    return function (source) {
        return new Observable(subscriber => {
            const sub = new Subscription();
            let isComplete = false;
            const obs = {
                next(value) {
                    sub.add(handle(value).subscribe({
                        next(value2) {
                            subscriber.next(value2);
                            if (isComplete) {
                                subscriber.complete();
                            }
                        },
                        error(err) {
                            subscriber.error(err);
                        },
                        complete() {
                            subscriber.complete();
                        }
                    }));
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    isComplete = true;
                }
            };
            source.subscribe(obs);
            return sub;
        });
    };
}

/**
 * 指定源数据流最多发送几次
 * @param count
 */
function take(count) {
    return function (source) {
        return new Observable(subscriber => {
            let i = 0;
            const subscription = new Subscription();
            let isComplete = false;
            const obs = {
                next(value) {
                    if (i < count) {
                        subscriber.next(value);
                        i++;
                        if (i === count) {
                            isComplete = true;
                            subscription.unsubscribe();
                            subscriber.complete();
                        }
                        return;
                    }
                    isComplete = true;
                    subscriber.complete();
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    subscriber.complete();
                }
            };
            subscription.add(source.subscribe(obs));
            if (isComplete) {
                subscription.unsubscribe();
            }
            return subscription;
        });
    };
}

/**
 * 在数据流中添加副作用
 * @param callback 副作用函数
 */
function tap(callback) {
    return function (source) {
        return new Observable(subscriber => {
            return source.subscribe({
                next(v) {
                    callback(v);
                    subscriber.next(v);
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    subscriber.complete();
                }
            });
        });
    };
}

/**
 * 发出最先到达的值，并忽略一段时间内的新值，然后再发送时间到达之后最新到达的值
 * @param time
 */
function throttleTime(time) {
    return function (source) {
        return new Observable(subscriber => {
            let canPublish = true;
            let timer;
            const sub = source.subscribe({
                next(v) {
                    if (canPublish) {
                        canPublish = false;
                        subscriber.next(v);
                        timer = setTimeout(() => {
                            canPublish = true;
                        }, time);
                    }
                },
                error(err) {
                    subscriber.error(err);
                },
                complete() {
                    subscriber.complete();
                }
            });
            return function () {
                clearTimeout(timer);
                sub.unsubscribe();
            };
        });
    };
}

export { BehaviorSubject, Observable, Subject, Subscriber, Subscription, auditTime, bufferTime, concat, debounceTime, delay, delayWhen, distinctUntilChanged, empty, every, filter, fromEvent, fromPromise, interval, map, merge, microTask, noop, of, race, retry, sampleTime, share, skip, switchMap, take, tap, throttleTime, throwError, timeout, zip };
