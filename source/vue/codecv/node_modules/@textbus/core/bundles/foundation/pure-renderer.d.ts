import { ComponentInstance, FormatItem, FormatTree, RenderMode, Slot, SlotRenderFactory, VElement, VTextNode } from '../model/_api';
/**
 * 虚拟 DOM 节点在数据内的范围
 */
export interface VNodeLocation {
    startIndex: number;
    endIndex: number;
    slot: Slot;
}
export interface ComponentRenderFn {
    (component: ComponentInstance, renderMode: RenderMode): VElement;
}
/**
 * 无副作用的渲染器，用于把组件或插槽渲染为虚拟 DOM
 */
export declare class PureRenderer {
    /**
     * 组件渲染方法
     * @param component 要渲染的组件
     * @param renderMode 渲染模式
     * @example
     * ```ts
     * const vDom = pureRenderer.componentRender(componentInstance, RenderMode.Output)
     * ```
     */
    componentRender(component: ComponentInstance, renderMode: RenderMode): VElement;
    /**
     * 插槽渲染方法
     * @param slot 要渲染的插槽
     * @param renderMode 渲染模式
     * @param slotRenderFactory 渲染插槽的工厂函数
     * @example
     * ```tsx
     * const slot = new Slot([
     *   ContentType.Text
     * ])
     *
     * slot.insert('hello world!')
     *
     * const vDom = pureRenderer.slotRender(slot, RenderMode.Output, children => {
     *   return (
     *     <div>{children}</div>
     *   )
     * })
     * ```
     */
    slotRender(slot: Slot, renderMode: RenderMode, slotRenderFactory: SlotRenderFactory): VElement;
    static createVDomByFormatTree(slot: Slot, formats: FormatTree<any>[], renderMode: RenderMode, componentRender: ComponentRenderFn, setVNodeLocation?: (vNode: VElement | VTextNode, location: VNodeLocation) => void): (VTextNode | VElement)[];
    static createVDomByOverlapFormats(formats: (FormatItem<any>)[], children: Array<VElement | VTextNode>, slot: Slot, renderMode: RenderMode, setVNodeLocation?: (vNode: VElement | VTextNode, location: VNodeLocation) => void): VElement;
    static createVDomByContent(slot: Slot, startIndex: number, endIndex: number, renderMode: RenderMode, componentRender: ComponentRenderFn, setVNodeLocation?: (vNode: VElement | VTextNode, location: VNodeLocation) => void): Array<VTextNode | VElement>;
}
