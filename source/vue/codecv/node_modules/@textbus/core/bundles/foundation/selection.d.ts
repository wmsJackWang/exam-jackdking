import { Observable } from '@tanbo/stream';
import { ComponentInstance, Slot, SlotRange } from '../model/_api';
import { RootComponentRef } from './_injection-tokens';
import { Controller } from './controller';
/**
 * 选区锚点和焦点位置
 */
export interface AbstractSelection {
    focusSlot: Slot;
    anchorSlot: Slot;
    focusOffset: number;
    anchorOffset: number;
}
/**
 * 选区开始和结果位置
 */
export interface Range {
    startSlot: Slot;
    endSlot: Slot;
    startOffset: number;
    endOffset: number;
}
/**
 * 选中组件的子插槽范围
 */
export interface SelectedSlotRange {
    startOffset: number;
    endOffset: number;
    component: ComponentInstance;
}
/**
 * 原生选区连接器
 */
export interface NativeSelectionConnector {
    /**
     * 当原生选区变化时，生成对应的 Textbus 选区，并传入 Textbus 选区
     * @param abstractSelection 对应原生选区在 Textbus 中的选区
     */
    setSelection(abstractSelection: AbstractSelection | null): void;
}
/**
 * 插槽偏移量
 */
export interface SelectionPosition {
    slot: Slot;
    offset: number;
}
/**
 * 选中选区在组件树中的位置
 */
export interface CommonAncestorSlotScope {
    startOffset: number;
    startSlot: Slot;
    startChildComponent: ComponentInstance | null;
    endOffset: number;
    endSlot: Slot;
    endChildComponent: ComponentInstance | null;
    startChildSlot: Slot;
    endChildSlot: Slot;
}
/**
 * 用于跨平台实现的原生选区抽象类
 */
export declare abstract class NativeSelectionBridge {
    /**
     * 连接方法，Textbus 在需要桥接原生选区时调用，并传入连接器
     * @param connector
     */
    abstract connect(connector: NativeSelectionConnector): void;
    /**
     * 取消连接方法，Textbus 会在不需要桥接选区时调用
     */
    abstract disConnect(): void;
    /**
     * Textbus 选区变化时调用，同时传入选区位置，用于原生选区实现具体平台的拖蓝效果
     * @param range
     * @param changeFromLocal 是否是本地引起的变化
     */
    abstract restore(range: AbstractSelection | null, changeFromLocal: boolean): void;
    /**
     * 获取上一行光标位置
     * @param position
     */
    abstract getPreviousLinePositionByCurrent(position: SelectionPosition): SelectionPosition | null;
    /**
     * 获取下一行光标位置
     * @param position
     */
    abstract getNextLinePositionByCurrent(position: SelectionPosition): SelectionPosition | null;
}
/**
 * 选区锚点和焦点的绝对路径
 */
export interface SelectionPaths {
    anchor: number[];
    focus: number[];
}
/**
 * 选区快照
 */
export interface SelectionSnapshot {
    /**
     * 恢复选区
     * @param syncNative 是否同步原生选区
     */
    restore(syncNative?: boolean): void;
}
/**
 * Textbus 选区实现类，用于选择 Textbus 文档内的内容
 */
export declare class Selection {
    private root;
    private controller;
    private bridge;
    /** 当选区变化时触发 */
    onChange: Observable<AbstractSelection | null>;
    /** 当前是否有选区 */
    get isSelected(): boolean;
    /** 当前选区是否闭合 */
    get isCollapsed(): boolean;
    /** 选区开始插槽 */
    get startSlot(): Slot<any> | null;
    /** 选区开始位置在开始插槽中的索引 */
    get startOffset(): number | null;
    /** 选区结束插槽 */
    get endSlot(): Slot<any> | null;
    /** 选区结束位置在线束插槽中的索引 */
    get endOffset(): number | null;
    /** 锚点插槽 */
    get anchorSlot(): Slot<any> | null;
    /** 锚点插槽偏移量 */
    get anchorOffset(): number | null;
    /** 焦点插槽 */
    get focusSlot(): Slot<any> | null;
    /** 焦点插槽偏移量 */
    get focusOffset(): number | null;
    /**
     * 选区的公共父插槽
     */
    get commonAncestorSlot(): Slot | null;
    /**
     * 选区的公共父组件
     */
    get commonAncestorComponent(): ComponentInstance | null;
    /**
     * 是否代理原生选区
     */
    get nativeSelectionDelegate(): boolean;
    set nativeSelectionDelegate(v: boolean);
    private connector;
    private _commonAncestorSlot;
    private _commonAncestorComponent;
    private _startSlot;
    private _endSlot;
    private _startOffset;
    private _endOffset;
    private _anchorSlot;
    private _anchorOffset;
    private _focusSlot;
    private _focusOffset;
    private changeEvent;
    private _nativeSelectionDelegate;
    private subscriptions;
    private customRanges;
    private changeFromUpdateCustomRanges;
    constructor(root: RootComponentRef, controller: Controller);
    /**
     * 创建选区快照，并可在需要时恢复选区，前提是缓存的插槽和位置还在文档中存在
     */
    createSnapshot(): SelectionSnapshot;
    /**
     * 销毁选区
     */
    destroy(): void;
    /**
     * 设置自定义选中的区间
     * @param ranges
     */
    setSelectedRanges(ranges: SlotRange[]): void;
    /**
     * 设置锚点和焦点的位置
     * @param anchorSlot 锚点插槽
     * @param anchorOffset 锚点偏移量
     * @param focusSlot 焦点插槽
     * @param focusOffset 焦点偏移量
     */
    setBaseAndExtent(anchorSlot: Slot, anchorOffset: number, focusSlot: Slot, focusOffset: number): void;
    /**
     * 获取选区内的选择范围，一般情况下为一个。组件可以 onGetRanges 勾子函数中定制范围个数，如表格中可能为多个
     */
    getRanges(): Range[];
    /**
     * 设置选区的锚点位置
     * @param slot 锚点位置的插槽
     * @param offset 锚点位置索引
     */
    setAnchor(slot: Slot, offset: number): void;
    /**
     * 设置选区焦点位置
     * @param slot 焦点位置的插槽
     * @param offset 焦点位置的索引
     */
    setFocus(slot: Slot, offset: number): void;
    /**
     * 设置选区位置
     * @param slot 选区所以插槽
     * @param offset 选区位置索引
     */
    setPosition(slot: Slot, offset: number): void;
    /**
     * 设置选区选择插槽的全部内容
     * @param slot
     */
    selectSlot(slot: Slot): void;
    /**
     * 设置选区为组件的第一个位置
     * @param componentInstance
     * @param isRestore
     */
    selectFirstPosition(componentInstance: ComponentInstance, isRestore?: boolean): void;
    /**
     * 设置选区为组件的最后一个位置
     * @param componentInstance
     * @param isRestore
     */
    selectLastPosition(componentInstance: ComponentInstance, isRestore?: boolean): void;
    /**
     * 把选区设置在组件之前
     * @param componentInstance
     * @param isRestore
     */
    selectComponentFront(componentInstance: ComponentInstance, isRestore?: boolean): void;
    /**
     * 把选区设置在组件之后
     * @param componentInstance
     * @param isRestore
     */
    selectComponentEnd(componentInstance: ComponentInstance, isRestore?: boolean): void;
    /**
     * 选中组件所有的子插槽
     * @param componentInstance
     * @param isRestore
     */
    selectChildSlots(componentInstance: ComponentInstance, isRestore?: boolean): void;
    /**
     * 设置选区选择一个组件
     * @param componentInstance 要选择的组件
     * @param isRestore 是否同步触发原生选区，默认为 `false`
     */
    selectComponent(componentInstance: ComponentInstance, isRestore?: boolean): void;
    /**
     * 获取选区所选择的块的集合
     * @param decompose 是否按块分解已选中的区域
     */
    getSelectedScopes(decompose?: boolean): SlotRange[];
    /**
     * 把光标移动到前一个位置
     */
    toPrevious(): void;
    /**
     * 把光标移动到后一个位置
     */
    toNext(): void;
    /**
     * 把光标移动到上一行
     */
    toPreviousLine(): void;
    /**
     * 把光标移动到下一行
     */
    toNextLine(): void;
    /**
     * 向右框选
     */
    wrapToAfter(): void;
    /**
     * 向左框选
     */
    wrapToBefore(): void;
    /**
     * 向上一行框选
     */
    wrapToPreviousLine(): void;
    /**
     * 向下一行框选
     */
    wrapToNextLine(): void;
    /**
     * 闭合选区
     * @param toStart 是否闭合到结束位置
     */
    collapse(toStart?: boolean): void;
    /**
     * 立即同步 Textbus 选区到原生选区
     */
    restore(fromLocal?: boolean): void;
    /**
     * 获取当前选区在文档中的路径
     */
    getPaths(): SelectionPaths;
    /**
     * 把选区设置为指定的路径
     * @param paths
     */
    usePaths(paths: SelectionPaths): void;
    /**
     * 取消选区
     */
    unSelect(): void;
    /**
     * 选择整个文档
     */
    selectAll(): void;
    /**
     * 获取下一个选区位置。
     */
    getNextPosition(): SelectionPosition | null;
    /**
     * 获取上一个选区位置。
     */
    getPreviousPosition(): SelectionPosition | null;
    /**
     * 根据路径获取对应的插槽
     * @param paths
     */
    findSlotByPaths(paths: number[]): Slot | null;
    /**
     * 根据路径获取对应的组件
     * @param paths
     */
    findComponentByPaths(paths: number[]): ComponentInstance | null;
    /**
     * 获取选区内所有的块集合
     */
    getBlocks(): SlotRange[];
    /**
     * 获取开始插槽和结束插槽在公共组件内的下标范围
     */
    getSlotRangeInCommonAncestorComponent(): SelectedSlotRange | null;
    /**
     * 获取当前选区在开始和结束位置均扩展到最大行内内容位置是的块
     */
    getGreedyRanges(): SlotRange[];
    /**
     * 查找插槽内最深的第一个光标位置
     * @param slot
     * @param toChild
     */
    findFirstPosition(slot: Slot, toChild?: boolean): SelectionPosition;
    /**
     * 查的插槽内最深的最后一个光标位置
     * @param slot
     * @param toChild
     */
    findLastPosition(slot: Slot, toChild?: boolean): SelectionPosition;
    /**
     * 获取当前选区在公共插槽的位置
     */
    getCommonAncestorSlotScope(): CommonAncestorSlotScope | null;
    /**
     * 获取插槽在文档中的绝对路径
     * @param slot
     */
    getPathsBySlot(slot: Slot): number[] | null;
    /**
     * 根据当前位置获取下一个光标位置
     * @param slot
     * @param offset
     */
    getNextPositionByPosition(slot: Slot, offset: number): SelectionPosition;
    /**
     * 根据当前位置，获取下一个光标位置
     * @param slot
     * @param offset
     */
    getPreviousPositionByPosition(slot: Slot, offset: number): SelectionPosition;
    /**
     * 根据指定的开始位置和结束位置，获取选区中片段
     * @param startSlot
     * @param startIndex
     * @param endSlot
     * @param endIndex
     * @param discardEmptyScope
     */
    getScopes(startSlot: Slot, startIndex: number, endSlot: Slot, endIndex: number, discardEmptyScope?: boolean): SlotRange[];
    /**
     * 根据开始插槽和结束插槽获取最近的公共父组件
     * @param startSlot
     * @param endSlot
     */
    static getCommonAncestorComponent(startSlot: Slot | null, endSlot: Slot | null): ComponentInstance<import("../model/component").ComponentExtends, any, unknown> | null;
    /**
     * 根据开始插槽和结束插槽获取最近的公共父插槽
     * @param startSlot
     * @param endSlot
     */
    static getCommonAncestorSlot(startSlot: Slot | null, endSlot: Slot | null): Slot<any> | null;
    /**
     * 比较两个绝对路径的前后，当 minPaths 小于 maxPaths 时，返回 true，否则返回 false
     * @param minPaths 假定的小路径
     * @param maxPaths 假定的大路径
     * @param canEqual minPaths 和 maxPaths 是否可以相等
     */
    static compareSelectionPaths(minPaths: number[], maxPaths: number[], canEqual?: boolean): boolean;
    /**
     * 获取插槽指定位置之前的非 BlockComponent 内容
     * @param slot
     * @param index
     */
    static getInlineContentStartIndex(slot: Slot, index: number): number;
    /**
     * 获取插槽指定位置之后的非 BlockComponent 内容
     * @param slot
     * @param index
     */
    static getInlineContentEndIndex(slot: Slot, index: number): number;
    private decomposeSlotRange;
    private resetStartAndEndPosition;
    private wrapTo;
    private findPositionByPath;
    private broadcastChanged;
    private getScopesByRange;
    private static findTreeNode;
}
