'use strict';

var reflectMetadata = require('reflect-metadata');
var di = require('@tanbo/di');
var stream = require('@tanbo/stream');
var immer = require('immer');

function makeError(name) {
    return function textbusError(message) {
        const error = new Error(message);
        error.name = `[TextbusError: ${name}]`;
        error.stack = error.stack.replace(/\n.*?(?=\n)/, '');
        return error;
    };
}

/**
 * 原生渲染器抽象类，由具体平台提供具体实现
 */
class NativeRenderer {
}
/**
 * 根节点及原生根元素节点引用类
 */
class RootComponentRef {
}
/**
 * @internal Textbus 组件列表注入 token
 */
const COMPONENT_LIST = new di.InjectionToken('COMPONENT_LIST');
/**
 * @internal Textbus 格式列表注入 token
 */
const FORMATTER_LIST = new di.InjectionToken('FORMATTER_LIST');
/**
 * @internal Textbus 插槽属性注入列表
 */
const ATTRIBUTE_LIST = new di.InjectionToken('ATTRIBUTE_LIST');
/**
 * 开启 Zen Coding 支持
 */
const ZEN_CODING_DETECT = new di.InjectionToken('ZEN_CODING_DETECT');
/**
 * 最大历史记录栈大小
 */
const HISTORY_STACK_SIZE = new di.InjectionToken('HISTORY_STACK_SIZE');
/**
 * 是否只读
 */
const READONLY = new di.InjectionToken('READONLY');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/**
 * 用来标识组件或插槽的数据变化
 */
class ChangeMarker {
    get dirty() {
        return this._dirty;
    }
    get changed() {
        return this._changed;
    }
    get outputDirty() {
        return this._outputDirty;
    }
    get outputChanged() {
        return this._outputChanged;
    }
    constructor() {
        this._dirty = true;
        this._changed = true;
        this._outputDirty = true;
        this._outputChanged = true;
        this.changeEvent = new stream.Subject();
        this.childComponentRemovedEvent = new stream.Subject();
        this.forceChangeEvent = new stream.Subject();
        this.onChange = this.changeEvent.asObservable();
        this.onChildComponentRemoved = this.childComponentRemovedEvent.asObservable();
        this.onForceChange = this.forceChangeEvent.asObservable();
    }
    forceMarkDirtied() {
        if (this._dirty) {
            return;
        }
        this._dirty = true;
        this.forceMarkChanged();
    }
    forceMarkChanged() {
        if (this._changed) {
            return;
        }
        this._changed = true;
        this.forceChangeEvent.next();
    }
    markAsDirtied(operation) {
        this._dirty = true;
        this._outputDirty = true;
        this.markAsChanged(operation);
    }
    markAsChanged(operation) {
        this._changed = true;
        this._outputChanged = true;
        this.changeEvent.next(operation);
    }
    rendered() {
        this._dirty = this._changed = false;
    }
    outputRendered() {
        this._outputDirty = this._outputChanged = false;
    }
    reset() {
        this._changed = this._dirty = this._outputChanged = this._outputDirty = true;
    }
    recordComponentRemoved(instance) {
        this.childComponentRemovedEvent.next(instance);
    }
}

/**
 * Textbus 内容管理类
 * Content 属于 Slot 的私有属性，在实际场景中，开发者不需在关注此类，也不需要访问或操作此类
 */
class Content {
    constructor() {
        this.segmenter = new Intl.Segmenter();
        this.data = [];
    }
    /**
     * 内容的长度
     */
    get length() {
        return this.data.reduce((p, n) => p + n.length, 0);
    }
    /**
     * 修复 index，由于 emoji 长度不固定，当 index 在 emoji 中时，操作数据会产生意外的数据
     * @param index 当前的 index
     * @param toEnd 当需要变更 index 时，是向后还是向前移动
     */
    correctIndex(index, toEnd) {
        if (index === 0 || index === this.length) {
            return index;
        }
        let i = 0;
        for (const item of this.data) {
            const itemLength = item.length;
            if (typeof item === 'string') {
                if (index > i && index < i + itemLength) {
                    const offsetIndex = index - i;
                    const startIndex = Math.max(0, offsetIndex - 15);
                    const endIndex = Math.min(startIndex + 30, item.length);
                    const fragment = item.slice(startIndex, endIndex);
                    const segments = this.segmenter.segment(fragment);
                    let offset = startIndex;
                    for (const p of segments) {
                        const segmentLength = p.segment.length;
                        if (index > i + offset && index < i + offset + segmentLength) {
                            return toEnd ? i + offset + segmentLength : i + offset;
                        }
                        offset += segmentLength;
                        if (i + offset >= index) {
                            break;
                        }
                    }
                    return index;
                }
            }
            i += itemLength;
            if (i >= index) {
                break;
            }
        }
        return index;
    }
    /**
     * 在指定下标位置插入内容
     * @param index
     * @param content
     */
    insert(index, content) {
        if (index >= this.length) {
            this.append(content);
        }
        else {
            let i = 0; // 当前内容下标
            let ii = 0; // 当前数组元素下标
            for (const el of this.data) {
                if (index >= i) {
                    if (typeof el === 'string') {
                        if (index >= i && index < i + el.length) {
                            const cc = [el.slice(0, index - i), content, el.slice(index - i)].filter(i => i);
                            if (typeof content === 'string') {
                                this.data.splice(ii, 1, cc.join(''));
                            }
                            else {
                                this.data.splice(ii, 1, ...cc);
                            }
                            break;
                        }
                    }
                    else if (index === i) {
                        const prev = this.data[ii - 1];
                        if (typeof prev === 'string' && typeof content === 'string') {
                            this.data[ii - 1] = prev + content;
                        }
                        else if (i === 0) {
                            this.data.unshift(content);
                        }
                        else {
                            this.data.splice(ii, 0, content);
                        }
                        break;
                    }
                }
                ii++;
                i += el.length;
            }
        }
    }
    /**
     * 把内容添加到最后
     * @param content
     */
    append(content) {
        const lastChildIndex = this.data.length - 1;
        const lastChild = this.data[lastChildIndex];
        if (typeof lastChild === 'string' && typeof content === 'string') {
            this.data[lastChildIndex] = lastChild + content;
        }
        else {
            this.data.push(content);
        }
    }
    cut(startIndex = 0, endIndex = this.length) {
        if (endIndex <= startIndex) {
            return [];
        }
        const discardedContents = this.slice(startIndex, endIndex);
        const elements = this.slice(0, startIndex).concat(this.slice(endIndex, this.length));
        this.data = [];
        elements.forEach(item => this.append(item));
        return discardedContents;
    }
    slice(startIndex = 0, endIndex = this.length) {
        if (startIndex >= endIndex) {
            return [];
        }
        startIndex = this.correctIndex(startIndex, false);
        endIndex = this.correctIndex(endIndex, true);
        let index = 0;
        const result = [];
        for (const el of this.data) {
            const fragmentStartIndex = index;
            const len = el.length;
            const fragmentEndIndex = index + len;
            index += len;
            if (startIndex < fragmentEndIndex && endIndex > fragmentStartIndex) {
                if (typeof el === 'string') {
                    const min = Math.max(0, startIndex - fragmentStartIndex);
                    const max = Math.min(fragmentEndIndex, endIndex) - fragmentStartIndex;
                    result.push(el.slice(min, max));
                }
                else {
                    result.push(el);
                }
            }
        }
        return result;
    }
    toJSON() {
        return this.data.map(i => {
            if (typeof i === 'string') {
                return i;
            }
            return i.toJSON();
        });
    }
    indexOf(element) {
        let index = 0;
        for (const item of this.data) {
            if (item === element) {
                return index;
            }
            index += item.length;
        }
        return -1;
    }
    getContentAtIndex(index) {
        return this.slice(index, index + 1)[0];
    }
    toGrid() {
        const splitPoints = [0];
        let index = 0;
        this.data.forEach(i => {
            index += i.length;
            splitPoints.push(index);
        });
        return [...splitPoints];
    }
    toString() {
        return this.data.map(i => {
            if (typeof i === 'string') {
                return i;
            }
            return i.toString();
        }).join('');
    }
}

/**
 * Textbus 管理组件内部插槽增删改查的类
 */
class Slots {
    /** 子插槽的个数 */
    get length() {
        return this.slots.length;
    }
    /** 最后一个子插槽 */
    get last() {
        return this.slots[this.length - 1] || null;
    }
    /** 第一个子插槽 */
    get first() {
        return this.slots[0] || null;
    }
    get index() {
        return this._index;
    }
    constructor(host, slots = []) {
        this.host = host;
        this.slots = [];
        this._index = 0;
        this.changeEvent = new stream.Subject();
        this.childSlotChangeEvent = new stream.Subject();
        this.childSlotRemoveEvent = new stream.Subject();
        this.changeListeners = new WeakMap();
        this.onChange = this.changeEvent.asObservable();
        this.onChildSlotChange = this.childSlotChangeEvent.asObservable();
        this.onChildSlotRemove = this.childSlotRemoveEvent.asObservable();
        this.insert(...Array.from(new Set(slots)));
    }
    /**
     * 获取子插槽的下标位置
     * @param slot
     */
    indexOf(slot) {
        return this.slots.indexOf(slot);
    }
    /**
     * 删除指定插槽
     * @param slot
     */
    remove(slot) {
        const index = this.slots.indexOf(slot);
        if (index > -1) {
            this.retain(index);
            this.delete(1);
            return true;
        }
        return false;
    }
    /**
     * 把新插槽插入到指定插槽的后面
     * @param slots
     * @param ref
     */
    insertAfter(slots, ref) {
        const index = this.slots.indexOf(ref);
        if (index > -1) {
            this.insertByIndex(slots, index + 1);
        }
    }
    /**
     * 把新插槽插入到指定插槽的前面
     * @param slots
     * @param ref
     */
    insertBefore(slots, ref) {
        const index = this.slots.indexOf(ref);
        if (index > -1) {
            this.insertByIndex(slots, index);
        }
    }
    /**
     * 把新插槽插入到指定下标位置
     * @param slots
     * @param index
     */
    insertByIndex(slots, index) {
        if (index < 0) {
            index = 0;
        }
        if (index > this.slots.length) {
            index = this.slots.length;
        }
        this.retain(index);
        const s = Array.isArray(slots) ? slots : [slots];
        this.insert(...s);
    }
    /**
     * 把新插槽添加到最后
     * @param slots
     */
    push(...slots) {
        this.retain(this.length);
        this.insert(...slots);
    }
    /**
     * 删除最后一个插槽并返回
     */
    pop() {
        if (this.length > 0) {
            const last = this.last;
            this.retain(this.length - 1);
            this.delete(1);
            return last;
        }
        return null;
    }
    /**
     * 删除第一个插槽并返回
     */
    shift() {
        if (this.length > 0) {
            const first = this.first;
            this.retain(0);
            this.delete(1);
            return first;
        }
        return null;
    }
    /**
     * 把新插槽添加到最前
     * @param slots
     */
    unshift(...slots) {
        this.retain(0);
        this.insert(...slots);
    }
    /**
     * 获取指定下标位置的插槽
     * @param index
     */
    get(index) {
        return this.slots[index] || null;
    }
    /**
     * 替换插槽
     * @param oldSlot 被替换的插槽
     * @param newSlot 新的插槽
     */
    replace(oldSlot, newSlot) {
        const index = this.indexOf(oldSlot);
        if (index > 0) {
            this.retain(index);
            this.delete(1);
            this.insert(newSlot);
        }
    }
    /**
     * 把所有子插槽转换为 JSON
     */
    toJSON() {
        return this.slots.map(i => i.toJSON());
    }
    /**
     * 把当前插槽集合转换为数组
     */
    toArray() {
        return [...this.slots];
    }
    /**
     * 清空子插槽
     */
    clean() {
        this.retain(0);
        this.delete(this.length);
    }
    /**
     * 插入新的子插槽
     * @param slots
     */
    insert(...slots) {
        if (slots.length === 0) {
            return;
        }
        const index = this._index;
        this.slots.splice(index, 0, ...slots);
        slots.forEach(i => {
            if (i.parent) {
                i.parent.slots.remove(i);
            }
            i.changeMarker.reset();
            i.parent = this.host;
            const sub = i.changeMarker.onChange.subscribe(operation => {
                operation.path.unshift(this.indexOf(i));
                if (i.changeMarker.dirty) {
                    this.host.changeMarker.markAsDirtied(operation);
                }
                else {
                    this.host.changeMarker.markAsChanged(operation);
                }
                this.childSlotChangeEvent.next(i);
            });
            sub.add(i.changeMarker.onChildComponentRemoved.subscribe(instance => {
                this.host.changeMarker.recordComponentRemoved(instance);
            }));
            sub.add(i.changeMarker.onForceChange.subscribe(() => {
                if (i.changeMarker.dirty) {
                    this.host.changeMarker.forceMarkDirtied();
                }
                else {
                    this.host.changeMarker.forceMarkChanged();
                }
            }));
            this.changeListeners.set(i, sub);
        });
        this._index += slots.length;
        this.changeEvent.next({
            path: [],
            apply: [{
                    type: 'retain',
                    offset: index
                }, ...slots.map(i => {
                    return {
                        type: 'insertSlot',
                        slot: i.toJSON(),
                        ref: i,
                    };
                })],
            unApply: [{
                    type: 'retain',
                    offset: index
                }, {
                    type: 'delete',
                    count: slots.length
                }]
        });
    }
    /**
     * 设置新的下标
     * @param index
     */
    retain(index) {
        if (index < 0) {
            this._index = 0;
        }
        else if (index > this.length) {
            this._index = this.length;
        }
        else {
            this._index = index;
        }
    }
    /**
     * 从下标位置向后删除指定数量的子插槽
     * @param count
     */
    delete(count) {
        const startIndex = this._index;
        const deletedSlots = this.slots.splice(startIndex, count);
        deletedSlots.forEach(i => {
            var _a;
            i.sliceContent().forEach(content => {
                if (typeof content !== 'string') {
                    this.host.changeMarker.recordComponentRemoved(content);
                }
            });
            (_a = this.changeListeners.get(i)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            this.changeListeners.delete(i);
        });
        this.changeEvent.next({
            path: [],
            apply: [{
                    type: 'retain',
                    offset: startIndex
                }, {
                    type: 'delete',
                    count
                }],
            unApply: deletedSlots.map((slot, i) => {
                slot.parent = null;
                return [{
                        type: 'retain',
                        offset: startIndex + i
                    }, {
                        type: 'insertSlot',
                        slot: slot.toJSON(),
                        ref: slot
                    }];
            }).flat()
        });
        this.childSlotRemoveEvent.next(deletedSlots);
    }
    /**
     * 剪切子插槽
     * @param startIndex
     * @param endIndex
     */
    cut(startIndex = 0, endIndex = this.length) {
        if (startIndex >= endIndex) {
            return [];
        }
        const deletedSlots = this.slots.slice(startIndex, endIndex);
        this.retain(startIndex);
        this.delete(endIndex - startIndex);
        return deletedSlots;
    }
    /**
     * 根据范围切分出一组子插槽
     * @param startIndex
     * @param endIndex
     */
    slice(startIndex, endIndex) {
        return this.slots.slice(startIndex, endIndex);
    }
    /**
     * 当前集合是否包含指定插槽
     * @param slot
     */
    has(slot) {
        return this.indexOf(slot) > -1;
    }
    toString() {
        return this.slots.map(i => {
            return i.toString();
        }).join('');
    }
}

immer.enablePatches();
const componentErrorFn = makeError('DefineComponent');
class Ref {
    constructor(current = null) {
        this.current = current;
    }
}
class EventCache {
    constructor() {
        this.listeners = new Map();
    }
    add(eventType, callback) {
        let callbacks = this.listeners.get(eventType);
        if (!callbacks) {
            callbacks = [];
            this.listeners.set(eventType, callbacks);
        }
        callbacks.push(callback);
    }
    get(eventType) {
        return this.listeners.get(eventType) || [];
    }
    clean(eventType) {
        this.listeners.delete(eventType);
    }
}
const eventCacheMap = new WeakMap();
const contextStack = [];
function getCurrentContext() {
    const current = contextStack[contextStack.length - 1];
    if (!current) {
        throw componentErrorFn('cannot be called outside the component!');
    }
    return current;
}
/**
 * Textbus 扩展组件方法
 * @param options
 */
function defineComponent(options) {
    const component = {
        name: options.name,
        separable: !!options.separable,
        instanceType: options.type,
        zenCoding: options.zenCoding,
        createInstance(contextInjector, initData) {
            const marker = new ChangeMarker();
            const stateChangeSubject = new stream.Subject();
            const onStateChange = stateChangeSubject.asObservable();
            const changeController = {
                update(fn, record = true) {
                    return componentInstance.updateState(fn, record);
                },
                onChange: onStateChange.pipe(stream.map(i => i.newState))
            };
            const componentInstance = {
                name: component.name,
                type: component.instanceType,
                separable: component.separable,
                changeMarker: marker,
                parent: null,
                get parentComponent() {
                    var _a;
                    return ((_a = componentInstance.parent) === null || _a === void 0 ? void 0 : _a.parent) || null;
                },
                get state() {
                    return state;
                },
                length: 1,
                onStateChange,
                slots: null,
                extends: null,
                shortcutList: null,
                updateState(fn, record = true) {
                    let changes;
                    let inverseChanges;
                    const oldState = state;
                    const newState = immer.produce(oldState, fn, (p, ip) => {
                        changes = p;
                        inverseChanges = ip;
                    });
                    if (changes.length === 0 && inverseChanges.length === 0) {
                        return oldState;
                    }
                    state = newState;
                    marker.markAsDirtied({
                        path: [],
                        apply: [{
                                type: 'apply',
                                patches: changes,
                                value: newState,
                                record
                            }],
                        unApply: [{
                                type: 'apply',
                                patches: inverseChanges,
                                value: oldState,
                                record
                            }]
                    });
                    stateChangeSubject.next({
                        oldState: oldState,
                        newState,
                        record
                    });
                    return newState;
                },
                toJSON() {
                    return {
                        name: component.name,
                        state: state !== null && state !== void 0 ? state : null,
                        slots: componentInstance.slots.toJSON()
                    };
                },
                toString() {
                    return componentInstance.slots.toString();
                }
            };
            const context = {
                contextInjector,
                changeController,
                componentInstance: componentInstance,
                dynamicShortcut: [],
                eventCache: new EventCache(),
            };
            contextStack.push(context);
            componentInstance.extends = options.setup(initData);
            onDestroy(() => {
                eventCacheMap.delete(componentInstance);
                subscriptions.forEach(i => i.unsubscribe());
            });
            eventCacheMap.set(componentInstance, context.eventCache);
            contextStack.pop();
            componentInstance.slots = context.slots || new Slots(componentInstance);
            componentInstance.shortcutList = context.dynamicShortcut;
            let state = Reflect.has(context, 'initState') ? context.initState : initData === null || initData === void 0 ? void 0 : initData.state;
            const subscriptions = [
                componentInstance.slots.onChange.subscribe(ops => {
                    marker.markAsDirtied(ops);
                })
            ];
            return componentInstance;
        }
    };
    return component;
}
function useContext(token = di.Injector, noFoundValue, flags) {
    const context = getCurrentContext();
    return context.contextInjector.get(token, noFoundValue, flags);
}
/**
 * 组件 setup 方法内获取组件实例的勾子
 */
function useSelf() {
    const context = getCurrentContext();
    return context.componentInstance;
}
/**
 * 组件使用子插槽的方法
 * @param slots 子插槽数组
 */
function useSlots(slots) {
    const context = getCurrentContext();
    if (Reflect.has(context, 'slots')) {
        throw componentErrorFn('only one unique slots is allowed for a component!');
    }
    const s = new Slots(context.componentInstance, slots);
    context.slots = s;
    return s;
}
/**
 * 组件注册状态管理器的勾子
 * @param initState
 */
function useState(initState) {
    const context = getCurrentContext();
    if (Reflect.has(context, 'initState')) {
        throw componentErrorFn('only one unique state is allowed for a component!');
    }
    context.initState = initState;
    return context.changeController;
}
/**
 * 组件单元素引用勾子
 */
function useRef(initValue = null) {
    return new Ref(initValue);
}
/**
 * 组件注册动态快捷键的勾子
 * @param config
 */
function useDynamicShortcut(config) {
    const context = getCurrentContext();
    context.dynamicShortcut.push(config);
}
/**
 * Textbus 事件对象
 */
class Event {
    get isPrevented() {
        return this._isPrevented;
    }
    constructor(target, data) {
        this.target = target;
        this.data = data;
        this._isPrevented = false;
    }
    preventDefault() {
        this._isPrevented = true;
    }
}
class ContextMenuEvent extends Event {
    constructor(target, getMenus) {
        super(target, null);
        this.getMenus = getMenus;
        this.isStopped = false;
    }
    get stopped() {
        return this.isStopped;
    }
    stopPropagation() {
        this.isStopped = true;
    }
    useMenus(menus) {
        this.getMenus(menus);
    }
}
class GetRangesEvent extends Event {
    constructor(target, getRanges) {
        super(target, null);
        this.getRanges = getRanges;
    }
    useRanges(ranges) {
        this.getRanges(ranges);
    }
}
function invokeListener(target, eventType, event) {
    if (typeof target !== 'object' || target === null) {
        return;
    }
    const cache = eventCacheMap.get(target);
    if (cache) {
        const callbacks = cache.get(eventType);
        callbacks.forEach(fn => {
            return fn(event);
        });
        if (eventType === 'onViewChecked') {
            const viewInitCallbacks = cache.get('onViewInit');
            cache.clean('onViewInit');
            viewInitCallbacks.forEach(fn => {
                fn(event);
            });
        }
        if (eventType === 'onDestroy') {
            eventCacheMap.delete(target);
        }
    }
}
function makeEventHook(type) {
    return function (listener) {
        const context = getCurrentContext();
        if (context) {
            context.eventCache.add(type, listener);
        }
    };
}
/**
 * 根据组件触发上下文菜单
 * @param component
 */
function triggerContextMenu(component) {
    var _a;
    let comp = component;
    const menuItems = [];
    while (comp) {
        const event = new ContextMenuEvent(comp, (menus) => {
            menuItems.push(menus);
        });
        invokeListener(comp, 'onContextMenu', event);
        if (event.stopped) {
            break;
        }
        comp = ((_a = comp.parent) === null || _a === void 0 ? void 0 : _a.parent) || null;
    }
    return menuItems;
}
/**
 * 当已选中组件未选中或选区不只选中已选中组件时触发
 */
const onUnselect = makeEventHook('onUnselect');
/**
 * 当选区刚好选中一个组件
 */
const onSelected = makeEventHook('onSelected');
/**
 * 当光标从前面进入组件
 */
const onSelectionFromFront = makeEventHook('onSelectionFromFront');
/**
 * 当光标从后面进入组件
 */
const onSelectionFromEnd = makeEventHook('onSelectionFromEnd');
/**
 * 组件获取焦点事件的勾子
 */
const onFocus = makeEventHook('onFocus');
/**
 * 组件失去焦点事件的勾子
 */
const onBlur = makeEventHook('onBlur');
/**
 * 组件或子组件获取焦点事件的勾子
 */
const onFocusIn = makeEventHook('onFocusIn');
/**
 * 组件或子组件失去焦点事件的勾子
 */
const onFocusOut = makeEventHook('onFocusOut');
/**
 * 组件内粘贴事件勾子
 */
const onPaste = makeEventHook('onPaste');
/**
 * 组件右键菜单事件勾子
 */
const onContextMenu = makeEventHook('onContextMenu');
/**
 * 组件视图更新后的勾子
 */
const onViewChecked = makeEventHook('onViewChecked');
/**
 * 组件第一次渲染后的勾子
 */
const onViewInit = makeEventHook('onViewInit');
/**
 * 组件子插槽删除时的勾子
 */
const onSlotRemove = makeEventHook('onSlotRemove');
/**
 * 组件子插槽删除完成时的勾子
 */
const onSlotRemoved = makeEventHook('onSlotRemoved');
/**
 * 组件子插槽内容删除时的勾子
 */
const onContentDelete = makeEventHook('onContentDelete');
/**
 * 组件子插槽内容删除完成时的勾子
 */
const onContentDeleted = makeEventHook('onContentDeleted');
/**
 * 组件子插槽换行时的勾子
 */
const onBreak = makeEventHook('onBreak');
/**
 * 组件子插槽插入内容时的勾子
 */
const onContentInsert = makeEventHook('onContentInsert');
/**
 * 组件子插槽插入内容后时的勾子
 */
const onContentInserted = makeEventHook('onContentInserted');
/**
 * 组件销毁时的勾子
 */
const onDestroy = makeEventHook('onDestroy');
/**
 * 当组件为选区公共父组件时的勾子
 */
const onGetRanges = makeEventHook('onGetRanges');
/**
 * 当 diff 视图时，检测到有脏节点时调用的勾子
 */
const onDirtyViewClean = makeEventHook('onDirtyViewClean');
/**
 * 当插槽组合输入前触发
 */
const onCompositionStart = makeEventHook('onCompositionStart');
/**
 * 当插槽组合输入时触发
 */
const onCompositionUpdate = makeEventHook('onCompositionUpdate');
/**
 * 当插槽组合输入结束触发
 */
const onCompositionEnd = makeEventHook('onCompositionEnd');
/**
 * 当组件的父插槽数据发生更新后触发
 */
const onParentSlotUpdated = makeEventHook('onParentSlotUpdated');

var _a, _b;
const vElementErrorFn = makeError('VElement');
const parentNode = Symbol('parentNode');
/**
 * Textbus 虚拟 DOM 文本节点
 */
class VTextNode {
    get parentNode() {
        return this[parentNode];
    }
    constructor(textContent = '') {
        this.textContent = textContent;
        this[_a] = null;
    }
}
_a = parentNode;
function Fragment(fragment) {
    return new VFragment(fragment.children);
}
function jsx(tagName, props = {}) {
    const children = props.children;
    Reflect.deleteProperty(props, 'children');
    if (children) {
        return VElement.createElement(tagName, props, children);
    }
    return VElement.createElement(tagName, props);
}
function jsxs(tagName, props = {}) {
    return jsx(tagName, props);
}
class VFragment {
    constructor(children) {
        this.children = children;
    }
}
function append(children, node) {
    if (node instanceof VElement) {
        children.push(node);
    }
    else if (node instanceof VTextNode) {
        if (node.textContent) {
            children.push(node);
        }
    }
    else if (typeof node === 'string' && node.length > 0) {
        children.push(new VTextNode(node));
    }
    else if (node instanceof VFragment) {
        for (const item of node.children.flat()) {
            append(children, item);
        }
    }
    else if (node !== false && node !== true && node !== null && typeof node !== 'undefined') {
        children.push(new VTextNode(String(node)));
    }
}
/**
 * Textbus 虚拟 DOM 元素节点
 */
class VElement {
    static createElement(tagName, attrs = null, ...childNodes) {
        const children = [];
        childNodes.flat(2).forEach(i => {
            append(children, i);
        });
        if (typeof tagName === 'function') {
            return tagName(Object.assign(Object.assign({}, attrs), { children }));
        }
        return new VElement(tagName, attrs, children);
    }
    get parentNode() {
        return this[parentNode];
    }
    get children() {
        return [...this._children];
    }
    constructor(tagName, attrs = null, children = []) {
        this.tagName = tagName;
        this[_b] = null;
        this.attrs = new Map();
        this.styles = new Map();
        this.classes = new Set();
        this.listeners = {};
        this._children = [];
        attrs = attrs || {};
        Object.keys(attrs).forEach(key => {
            if (key === 'class') {
                const className = (attrs.class || '').trim();
                this.classes = new Set(className ? className.split(/\s+/g) : []);
            }
            else if (key === 'style') {
                const style = attrs.style || '';
                if (typeof style === 'string') {
                    style.split(';').map(s => s.split(':')).forEach(v => {
                        if (!v[0] || !v[1]) {
                            return;
                        }
                        this.styles.set(v[0].trim(), v[1].trim());
                    });
                }
                else if (typeof style === 'object') {
                    Object.keys(style).forEach(key => {
                        this.styles.set(key, style[key]);
                    });
                }
            }
            else if (/^on[A-Z]/.test(key)) {
                const listener = attrs[key];
                if (typeof listener === 'function') {
                    this.listeners[key.replace(/^on/, '').toLowerCase()] = listener;
                }
            }
            else {
                this.attrs.set(key, attrs[key]);
            }
        });
        this.appendChild(...children);
    }
    /**
     * 在最后位置添加一个子节点。
     * @param newNodes
     */
    appendChild(...newNodes) {
        newNodes.forEach(node => {
            var _c;
            (_c = node.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node);
            node[parentNode] = this;
            this._children.push(node);
        });
    }
    removeChild(node) {
        const index = this._children.indexOf(node);
        if (index > -1) {
            this._children.splice(index, 1);
            node[parentNode] = null;
            return;
        }
        throw vElementErrorFn('node to be deleted is not a child of the current node.');
    }
    replaceChild(newNode, oldNode) {
        var _c;
        const index = this._children.indexOf(oldNode);
        if (index > -1) {
            (_c = newNode.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(newNode);
            this._children.splice(index, 1, newNode);
            oldNode[parentNode] = null;
            newNode[parentNode] = this;
            return;
        }
        throw vElementErrorFn('node to be replaced is not a child of the current node.');
    }
}
_b = parentNode;

function isVoid(data) {
    return data === null || typeof data === 'undefined';
}
/**
 * Textbus 格式管理类
 * Format 类为 Slot 的私有属性，在实际场景中，开发者不需在关注此类，也不需要访问或操作此类
 */
class Format {
    constructor(slot) {
        this.slot = slot;
        this.map = new Map();
    }
    /**
     * 将新样式合并到现有样式中
     * @param formatter
     * @param value
     * @param background
     */
    merge(formatter, value, background = false) {
        let ranges = this.map.get(formatter);
        if (!ranges) {
            const v = value.value;
            if (isVoid(v)) {
                return this;
            }
            ranges = [value];
            this.map.set(formatter, ranges);
            return this;
        }
        const newRanges = this.normalizeFormatRange(background, ranges, value);
        if (newRanges.length) {
            this.map.set(formatter, newRanges);
        }
        else {
            this.map.delete(formatter);
        }
        return this;
    }
    /**
     * 将 index 后的样式起始和结束位置均增加 count 大小
     * @param index
     * @param count
     */
    stretch(index, count) {
        this.map.forEach(values => {
            values.forEach(range => {
                if (range.endIndex < index) {
                    return;
                }
                range.endIndex += count;
                if (range.startIndex >= index) {
                    range.startIndex += count;
                }
            });
        });
        return this;
    }
    /**
     * 将指定 index 位置后的样式向后平移 distance 长度
     * @param index
     * @param distance
     */
    split(index, distance) {
        const expandedValues = Array.from({ length: distance });
        Array.from(this.map).forEach(([key, formatRanges]) => {
            const values = this.tileRanges(formatRanges);
            values.splice(index, 0, ...expandedValues);
            const newRanges = Format.toRanges(values);
            this.map.set(key, newRanges);
        });
        return this;
    }
    /**
     * 从指定 index 位置的样式删除 count
     * @param startIndex
     * @param count
     */
    shrink(startIndex, count) {
        this.map.forEach(values => {
            values.forEach(range => {
                if (range.endIndex <= startIndex) {
                    return;
                }
                range.endIndex = Math.max(startIndex, range.endIndex - count);
                if (range.startIndex > startIndex) {
                    range.startIndex = Math.max(startIndex, range.startIndex - count);
                }
            });
        });
        Array.from(this.map.keys()).forEach(key => {
            const oldRanges = this.map.get(key);
            const newRanges = this.normalizeFormatRange(false, oldRanges);
            if (newRanges.length) {
                this.map.set(key, newRanges);
            }
            else {
                this.map.delete(key);
            }
        });
        return this;
    }
    /**
     * 提取指定范围内的样式
     * @param startIndex
     * @param endIndex
     */
    extract(startIndex, endIndex) {
        const format = new Format(this.slot);
        this.map.forEach((ranges, key) => {
            const extractRanges = this.extractFormatRangesByFormatter(startIndex, endIndex, key);
            if (extractRanges.length) {
                format.map.set(key, extractRanges);
            }
        });
        return format;
    }
    /**
     * 生成一个重置位置的 format
     * @param slot
     * @param startIndex
     * @param endIndex
     */
    createFormatByRange(slot, startIndex, endIndex) {
        const format = new Format(slot);
        this.map.forEach((ranges, key) => {
            const extractRanges = this.extractFormatRangesByFormatter(startIndex, endIndex, key);
            if (extractRanges.length) {
                format.map.set(key, extractRanges.map(i => {
                    i.startIndex -= startIndex;
                    i.endIndex -= startIndex;
                    return i;
                }));
            }
        });
        return format;
    }
    /**
     * 通过 formatter 提取指定范围内的样式数据
     * @param startIndex
     * @param endIndex
     * @param formatter
     */
    extractFormatRangesByFormatter(startIndex, endIndex, formatter) {
        const extractRanges = [];
        const ranges = this.map.get(formatter) || [];
        ranges.forEach(range => {
            if (range.startIndex > endIndex || range.endIndex < startIndex) {
                return;
            }
            const s = Math.max(range.startIndex, startIndex);
            const n = Math.min(range.endIndex, endIndex);
            if (s < n) {
                extractRanges.push({
                    startIndex: s,
                    endIndex: n,
                    value: range.value
                });
            }
        });
        return extractRanges;
    }
    /**
     * 丢弃指定范围内的样式
     * @param formatter
     * @param startIndex
     * @param endIndex
     */
    discard(formatter, startIndex, endIndex) {
        const oldRanges = this.map.get(formatter);
        if (oldRanges) {
            this.normalizeFormatRange(false, oldRanges, {
                startIndex,
                endIndex,
                value: null
            });
        }
        return this;
    }
    extractFormatsByIndex(index) {
        const formats = [];
        if (index === 0) {
            this.map.forEach((ranges, formatter) => {
                ranges.forEach(i => {
                    if (i.startIndex === 0) {
                        formats.push([
                            formatter,
                            i.value
                        ]);
                    }
                });
            });
        }
        else {
            this.map.forEach((ranges, formatter) => {
                ranges.forEach(i => {
                    if (i.startIndex < index && i.endIndex >= index) {
                        formats.push([
                            formatter,
                            i.value
                        ]);
                    }
                });
            });
        }
        return formats;
    }
    toGrid() {
        const splitPoints = new Set();
        splitPoints.add(0);
        splitPoints.add(this.slot.length);
        this.map.forEach(ranges => {
            ranges.forEach(item => {
                splitPoints.add(item.startIndex);
                splitPoints.add(item.endIndex);
            });
        });
        return [...splitPoints].sort((a, b) => a - b);
    }
    toJSON() {
        const json = {};
        this.map.forEach((value, formatter) => {
            json[formatter.name] = value.map(i => (Object.assign({}, i)));
        });
        return json;
    }
    toTree(startIndex, endIndex) {
        const copyFormat = this.extract(startIndex, endIndex);
        const tree = {
            startIndex,
            endIndex,
        };
        let nextStartIndex = endIndex;
        let nextEndIndex = startIndex;
        const formats = [];
        const columnedFormats = [];
        Array.from(copyFormat.map.keys()).forEach(formatter => {
            const ranges = copyFormat.map.get(formatter);
            ranges.forEach(range => {
                if (range.startIndex === startIndex && range.endIndex === endIndex) {
                    if (formatter.columned) {
                        columnedFormats.push(Object.assign({ formatter }, range));
                    }
                    else {
                        formats.push(Object.assign({ formatter }, range));
                        copyFormat.map.delete(formatter);
                    }
                }
                else if (range.startIndex < nextStartIndex) {
                    nextStartIndex = range.startIndex;
                    nextEndIndex = range.endIndex;
                }
                else if (range.startIndex === nextStartIndex) {
                    nextEndIndex = Math.max(nextEndIndex, range.endIndex);
                }
            });
        });
        const hasChildren = copyFormat.map.size > columnedFormats.length;
        if (hasChildren) {
            tree.children = [];
            if (startIndex < nextStartIndex) {
                if (columnedFormats.length) {
                    const childTree = copyFormat.extract(startIndex, nextStartIndex).toTree(startIndex, nextStartIndex);
                    tree.children.push(childTree);
                }
                else {
                    tree.children.push({
                        startIndex,
                        endIndex: nextStartIndex
                    });
                }
            }
            const push = function (tree, childTree) {
                if (childTree.formats) {
                    tree.children.push(childTree);
                }
                else if (childTree.children) {
                    tree.children.push(...childTree.children);
                }
                else {
                    tree.children.push(childTree);
                }
            };
            const nextTree = copyFormat.toTree(nextStartIndex, nextEndIndex);
            push(tree, nextTree);
            if (nextEndIndex < endIndex) {
                const afterFormat = copyFormat.extract(nextEndIndex, endIndex);
                const afterTree = afterFormat.toTree(nextEndIndex, endIndex);
                push(tree, afterTree);
            }
        }
        else {
            formats.push(...columnedFormats);
        }
        if (formats.length) {
            tree.formats = formats.sort((a, b) => {
                return a.formatter.priority - b.formatter.priority;
            });
        }
        return tree;
    }
    toArray() {
        const list = [];
        Array.from(this.map).forEach(i => {
            const formatter = i[0];
            i[1].forEach(range => {
                list.push(Object.assign(Object.assign({}, range), { formatter }));
            });
        });
        return list;
    }
    normalizeFormatRange(background, oldRanges, newRange) {
        if (newRange) {
            oldRanges = background ? [newRange, ...oldRanges] : [...oldRanges, newRange];
        }
        const formatValues = this.tileRanges(oldRanges);
        return Format.toRanges(formatValues);
    }
    tileRanges(ranges) {
        const formatValues = [];
        ranges.forEach(range => {
            formatValues.length = Math.max(formatValues.length, range.endIndex);
            formatValues.fill(range.value, range.startIndex, range.endIndex);
        });
        formatValues.length = Math.min(formatValues.length, this.slot.length);
        return formatValues;
    }
    static toRanges(values) {
        const newRanges = [];
        let range = null;
        for (let i = 0; i < values.length; i++) {
            const item = values[i];
            if (isVoid(item)) {
                range = null;
                continue;
            }
            if (Format.equal(range === null || range === void 0 ? void 0 : range.value, item)) {
                range.endIndex = i + 1;
                continue;
            }
            range = {
                startIndex: i,
                endIndex: i + 1,
                value: item
            };
            newRanges.push(range);
        }
        return newRanges;
    }
    static equal(left, right) {
        if (left === right) {
            return true;
        }
        if (typeof left === 'object' && typeof right === 'object') {
            const leftKeys = Object.keys(left);
            const rightKeys = Object.keys(right);
            if (leftKeys.length === rightKeys.length) {
                return leftKeys.every(key => {
                    return rightKeys.includes(key) && right[key] === left[key];
                });
            }
        }
        return false;
    }
}

/**
 * Textbus 动态格式扩展接口
 * Formatter 可以在任意插槽的任意区域内生效，常用于行内样式或其它需要标记插槽内一部分内容的情况
 */
class Formatter {
    /**
     * 构造函数
     * @param name 格式的名字，在同一个编辑器实例内不可重复
     * @param columned 格式是否列对齐，默认情况下，Textbus 会采用最少节点的策略进行渲染，
     *                 但在某些情况下是不适用的，你可以通过设置 columned 值为 true，让
     *                 Textbus 从格式变更处生成新的节点
     * @param priority 渲染优先级，值越小则越先渲染
     * @protected
     */
    constructor(name, columned, priority) {
        this.name = name;
        this.columned = columned;
        this.priority = 0;
        if (typeof priority === 'number') {
            this.priority = priority;
        }
    }
}
/**
 * Textbus 动态属性扩展接口
 * Attribute 可以在任意插槽的整体生效，常用于块级样式或给事个插槽附加信息的情况
 */
class Attribute {
    /**
     * 构建函数
     * @param name 属性的名字，在同一个编辑器实例内不可重复
     * @protected
     */
    constructor(name) {
        this.name = name;
    }
}

exports.ContentType = void 0;
(function (ContentType) {
    ContentType[ContentType["Text"] = 1] = "Text";
    ContentType[ContentType["InlineComponent"] = 2] = "InlineComponent";
    ContentType[ContentType["BlockComponent"] = 3] = "BlockComponent";
})(exports.ContentType || (exports.ContentType = {}));
class DeltaLite extends Array {
    constructor() {
        super(...arguments);
        this.attributes = new Map();
    }
}
/**
 * Textbus 插槽类，用于管理组件、文本及格式的增删改查
 */
class Slot {
    static get emptyPlaceholder() {
        // return this.schema.includes(ContentType.BlockComponent) ? '\n' : '\u200b'
        return '\n';
    }
    get parentSlot() {
        var _a;
        return ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent) || null;
    }
    /** 插槽内容长度 */
    get length() {
        return this.content.length;
    }
    /** 插槽内容是否为空 */
    get isEmpty() {
        return this.length === 1 && this.getContentAtIndex(0) === Slot.emptyPlaceholder;
    }
    /** 插槽当前下标位置 */
    get index() {
        return this.isEmpty ? 0 : this._index;
    }
    constructor(schema, state) {
        this.state = state;
        /** 插槽所属的组件 */
        this.parent = null;
        /** 插槽变更标记器 */
        this.changeMarker = new ChangeMarker();
        this.componentChangeListeners = new WeakMap();
        this.childComponentRemoveEvent = new stream.Subject();
        /**
         * @internal
         * 插槽的 id，用于优化 diff 算法
         */
        this.id = Math.random();
        this._index = 0;
        this.content = new Content();
        this.format = new Format(this);
        this.attributes = new Map();
        this.contentChangeEvent = new stream.Subject();
        this.stateChangeEvent = new stream.Subject();
        this.applyFormatCoverChild = false;
        this.schema = schema.sort();
        this.onContentChange = this.contentChangeEvent.asObservable();
        this.onStateChange = this.stateChangeEvent.asObservable();
        this.onChildComponentRemove = this.childComponentRemoveEvent.asObservable();
        this.content.append(Slot.emptyPlaceholder);
        this._index = 0;
    }
    /**
     * 设置属性
     * @param attribute
     * @param value
     */
    setAttribute(attribute, value) {
        const has = this.attributes.has(attribute);
        const v = this.attributes.get(attribute);
        this.attributes.set(attribute, value);
        const applyActions = [{
                type: 'attrSet',
                name: attribute.name,
                value
            }];
        this.sliceContent().forEach(item => {
            if (typeof item !== 'string') {
                item.slots.toArray().forEach(slot => {
                    slot.setAttribute(attribute, value);
                });
            }
        });
        this.changeMarker.markAsDirtied({
            path: [],
            apply: applyActions,
            unApply: [has ? {
                    type: 'attrSet',
                    name: attribute.name,
                    value: v
                } : {
                    type: 'attrRemove',
                    name: attribute.name
                }]
        });
        this.contentChangeEvent.next(applyActions);
    }
    /**
     * 获取属性
     * @param attribute
     */
    getAttribute(attribute) {
        var _a;
        return (_a = this.attributes.get(attribute)) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * 获取所有属性
     */
    getAttributes() {
        return Array.from(this.attributes.entries());
    }
    /**
     * 删除属性
     * @param attribute
     */
    removeAttribute(attribute) {
        this.sliceContent().forEach(item => {
            if (typeof item !== 'string') {
                item.slots.toArray().forEach(slot => {
                    slot.removeAttribute(attribute);
                });
            }
        });
        const has = this.attributes.has(attribute);
        if (!has) {
            return;
        }
        const v = this.attributes.get(attribute);
        this.attributes.delete(attribute);
        const applyActions = [{
                type: 'attrRemove',
                name: attribute.name
            }];
        this.changeMarker.markAsDirtied({
            path: [],
            apply: applyActions,
            unApply: [{
                    type: 'attrSet',
                    name: attribute.name,
                    value: v
                }]
        });
        this.contentChangeEvent.next(applyActions);
    }
    /**
     * 根据是否包含指定 Attribute
     * @param attribute
     */
    hasAttribute(attribute) {
        return this.attributes.has(attribute);
    }
    /**
     * 更新插槽状态的方法
     * @param fn
     * @param record
     */
    updateState(fn, record = true) {
        let changes;
        let inverseChanges;
        const oldState = this.state;
        const newState = immer.produce(oldState, fn, (p, ip) => {
            changes = p;
            inverseChanges = ip;
        });
        if (changes.length === 0 && inverseChanges.length === 0) {
            return oldState;
        }
        this.state = newState;
        const applyAction = {
            type: 'apply',
            patches: changes,
            value: newState,
            record
        };
        this.changeMarker.markAsDirtied({
            path: [],
            apply: [applyAction],
            unApply: [{
                    type: 'apply',
                    patches: inverseChanges,
                    value: oldState,
                    record
                }]
        });
        this.stateChangeEvent.next({
            newState: newState,
            oldState: oldState,
            record
        });
        return newState;
    }
    write(content, formatter, value) {
        const index = this.index;
        const expandFormat = (this.isEmpty || index === 0) ? this.format.extract(0, 1) : this.format.extract(index - 1, index);
        const formats = expandFormat.toArray().map(i => {
            return [
                i.formatter,
                i.value
            ];
        });
        if (formatter) {
            if (Array.isArray(formatter)) {
                formats.push(...formatter);
            }
            else {
                formats.push([formatter, value]);
            }
        }
        return this.insert(content, formats);
    }
    insert(content, formatter, value) {
        const contentType = typeof content === 'string' ? exports.ContentType.Text : content.type;
        if (!this.schema.includes(contentType)) {
            return false;
        }
        const prevContent = this.getContentAtIndex(this.index - 1);
        if (prevContent === Slot.placeholder) {
            this.retain(this.index - 1);
            this.delete(1);
        }
        const isEmpty = this.isEmpty;
        let actionData;
        let length;
        const startIndex = this.index;
        if (typeof content === 'string') {
            if (content.length === 0) {
                return true;
            }
            actionData = content;
            length = content.length;
        }
        else {
            length = 1;
            actionData = content.toJSON();
            if (content.parent) {
                content.parent.removeComponent(content);
            }
            content.parent = this;
            const sub = content.changeMarker.onChange.subscribe(ops => {
                ops.path.unshift(this.indexOf(content));
                this.changeMarker.markAsChanged(ops);
            });
            sub.add(content.changeMarker.onChildComponentRemoved.subscribe(instance => {
                this.changeMarker.recordComponentRemoved(instance);
            }));
            sub.add(content.changeMarker.onForceChange.subscribe(() => {
                this.changeMarker.forceMarkChanged();
            }));
            this.componentChangeListeners.set(content, sub);
        }
        let formats = [];
        if (formatter) {
            if (Array.isArray(formatter)) {
                formats = formatter;
            }
            else {
                formats.push([formatter, value]);
            }
        }
        this.format.split(startIndex, length);
        this.content.insert(startIndex, content);
        this.applyFormats(formats, startIndex, length, false);
        if (isEmpty) {
            const len = this.length - 1;
            this.content.cut(len);
            this.format.shrink(len, 1);
        }
        this._index = startIndex + length;
        const applyActions = [{
                type: 'retain',
                offset: startIndex
            }, formats.length ? {
                type: 'insert',
                content: actionData,
                ref: content,
                formats: formats.reduce((opt, next) => {
                    opt[next[0].name] = next[1];
                    return opt;
                }, {})
            } : {
                type: 'insert',
                content: actionData,
                ref: content
            }];
        this.changeMarker.markAsDirtied({
            path: [],
            apply: applyActions,
            unApply: [{
                    type: 'retain',
                    offset: startIndex
                }, {
                    type: 'delete',
                    count: length
                }]
        });
        this.contentChangeEvent.next(applyActions);
        return true;
    }
    retain(offset, formatter, value) {
        let formats = [];
        if (formatter) {
            if (Array.isArray(formatter)) {
                if (formatter.length === 0) {
                    return true;
                }
                formats = formatter;
            }
            else {
                formats.push([formatter, value]);
            }
        }
        const len = this.length;
        if (formats.length === 0) {
            if (offset < 0) {
                offset = 0;
            }
            if (offset > len) {
                offset = len;
            }
            this._index = this.content.correctIndex(offset, false);
            return true;
        }
        const startIndex = this._index;
        let endIndex = this.content.correctIndex(startIndex + offset, true);
        if (endIndex > len) {
            endIndex = len;
        }
        let index = startIndex;
        const applyActions = [];
        const unApplyActions = [];
        const formatsObj = formats.reduce((opt, next) => {
            opt[next[0].name] = next[1];
            return opt;
        }, {});
        const resetFormatObj = formats.reduce((opt, next) => {
            opt[next[0].name] = null;
            return opt;
        }, {});
        if (endIndex - startIndex === 1) {
            const content = this.getContentAtIndex(startIndex);
            if (typeof content !== 'string' && content.type === exports.ContentType.InlineComponent) {
                content.changeMarker.forceMarkDirtied();
            }
        }
        this.content.slice(startIndex, endIndex).forEach(content => {
            const offset = content.length;
            if (typeof content === 'string' || content.type !== exports.ContentType.BlockComponent) {
                const deletedFormat = this.format.extract(index, index + offset);
                this.applyFormats(formats, index, offset, this.applyFormatCoverChild);
                applyActions.push({
                    type: 'retain',
                    offset: index
                }, {
                    type: 'retain',
                    offset: offset,
                    formats: Object.assign({}, formatsObj)
                });
                unApplyActions.push({
                    type: 'retain',
                    offset: index
                }, {
                    type: 'retain',
                    offset: offset,
                    formats: resetFormatObj
                }, ...Slot.createActionByFormat(deletedFormat));
            }
            else {
                content.slots.toArray().forEach(slot => {
                    if (this.applyFormatCoverChild) {
                        slot.background(() => {
                            slot.retain(0);
                            slot.retain(slot.length, formats);
                        });
                    }
                    else {
                        slot.retain(0);
                        slot.retain(slot.length, formats);
                    }
                });
            }
            index += offset;
        });
        if (applyActions.length || unApplyActions.length) {
            this.changeMarker.markAsDirtied({
                path: [],
                apply: applyActions,
                unApply: unApplyActions
            });
            if (applyActions.length) {
                this.contentChangeEvent.next(applyActions);
            }
        }
        return true;
    }
    /**
     * 从当前位置向后删除指定长度的内容
     * @param count
     */
    delete(count) {
        if (count <= 0) {
            return false;
        }
        const startIndex = this._index;
        let endIndex = this.content.correctIndex(this._index + count, true);
        count = endIndex - startIndex;
        if (endIndex > this.length) {
            endIndex = this.length;
        }
        const deletedData = this.content.cut(startIndex, endIndex);
        const deletedFormat = this.format.extract(startIndex, endIndex);
        this.format.shrink(startIndex, count);
        if (this.length === 0) {
            this.content.append(Slot.emptyPlaceholder);
            this.format = deletedFormat.extract(0, 1);
        }
        const applyActions = [{
                type: 'retain',
                offset: startIndex
            }, {
                type: 'delete',
                count
            }];
        const deletedComponents = [];
        this.changeMarker.markAsDirtied({
            path: [],
            apply: applyActions,
            unApply: [{
                    type: 'retain',
                    offset: startIndex
                }, ...deletedData.map(item => {
                    var _a;
                    if (typeof item === 'string') {
                        return {
                            type: 'insert',
                            content: item,
                            ref: item
                        };
                    }
                    deletedComponents.push(item);
                    this.changeMarker.recordComponentRemoved(item);
                    (_a = this.componentChangeListeners.get(item)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                    this.componentChangeListeners.delete(item);
                    item.parent = null;
                    return {
                        type: 'insert',
                        content: item.toJSON(),
                        ref: item
                    };
                }), ...Slot.createActionByFormat(deletedFormat)]
        });
        this.contentChangeEvent.next(applyActions);
        if (deletedComponents.length) {
            this.childComponentRemoveEvent.next(deletedComponents);
        }
        return true;
    }
    /**
     * 给插槽应用新的格式，如果为块级样式，则应用到整个插槽，否则根据参数配置的范围应用
     * @param formatter
     * @param data
     */
    applyFormat(formatter, data) {
        this.retain(data.startIndex);
        this.retain(data.endIndex - data.startIndex, formatter, data.value);
    }
    /**
     * 在当前插槽内删除指定的组件
     * @param component
     */
    removeComponent(component) {
        const index = this.indexOf(component);
        if (index > -1) {
            this.retain(index);
            return this.delete(1);
        }
        return false;
    }
    /**
     * 剪切插槽内指定范围的内容
     * @param startIndex
     * @param endIndex
     */
    cut(startIndex = 0, endIndex = this.length) {
        return this.cutTo(new Slot([...this.schema], this.state), startIndex, endIndex);
    }
    /**
     * 把当前插槽内指定范围的内容剪切到新插槽
     * @param slot 新插槽
     * @param startIndex
     * @param endIndex
     */
    cutTo(slot, startIndex = 0, endIndex = this.length) {
        if (startIndex < 0) {
            startIndex = 0;
        }
        const length = this.length;
        if (endIndex > length) {
            endIndex = length;
        }
        if (startIndex > endIndex) {
            return slot;
        }
        if (slot.isEmpty) {
            this.attributes.forEach((value, key) => {
                slot.setAttribute(key, value);
            });
        }
        startIndex = this.content.correctIndex(startIndex, false);
        endIndex = this.content.correctIndex(endIndex, true);
        if (this.isEmpty) {
            slot.format = this.format.createFormatByRange(slot, 0, 1);
            this.retain(startIndex);
            this.delete(endIndex - startIndex);
            return slot;
        }
        if (startIndex === length || startIndex === length - 1 && this.content.getContentAtIndex(length - 1) === '\n') {
            slot.format = this.format.createFormatByRange(slot, startIndex - 1, startIndex);
            this.retain(startIndex);
            this.delete(endIndex - startIndex);
            return slot;
        }
        this.retain(startIndex);
        const deletedData = this.content.slice(this.index, endIndex);
        const deletedFormat = this.format.createFormatByRange(slot, this.index, endIndex);
        this.delete(endIndex - this.index);
        const temporarySlot = new Slot([
            ...slot.schema
        ]);
        deletedData.forEach(i => {
            temporarySlot.insert(i);
        });
        temporarySlot.format = deletedFormat.createFormatByRange(temporarySlot, 0, temporarySlot.length);
        temporarySlot.toDelta().forEach(item => {
            slot.insert(item.insert, item.formats);
        });
        // if (this.isEmpty) {
        //   this.cleanAttributes()
        // }
        return slot;
    }
    /**
     * 查找组件在插槽内的索引
     * @param component
     */
    indexOf(component) {
        return this.content.indexOf(component);
    }
    /**
     * 查找指定下标位置的内容
     * @param index
     */
    getContentAtIndex(index) {
        return this.content.getContentAtIndex(index);
    }
    /**
     * 切分出插槽内指定范围的内容
     * @param startIndex
     * @param endIndex
     */
    sliceContent(startIndex = 0, endIndex = this.length) {
        return this.content.slice(startIndex, endIndex);
    }
    /**
     * 根据插槽的格式数据，生成格式树
     */
    createFormatTree() {
        return this.format.toTree(0, this.length);
        // if (this.attributes.size) {
        //   if (!tree.formats) {
        //     tree.formats = []
        //   }
        //   this.getAttributes().forEach(item => {
        //     tree.formats!.push({
        //       formatter: item[0],
        //       value: item[1],
        //       startIndex: 0,
        //       endIndex: this.length
        //     })
        //   })
        // }
        // return tree
    }
    /**
     * 获取传入格式在插槽指定内范围的集合
     * @param formatter 指定的格式
     * @param startIndex
     * @param endIndex
     */
    getFormatRangesByFormatter(formatter, startIndex, endIndex) {
        return this.format.extractFormatRangesByFormatter(startIndex, endIndex, formatter);
    }
    /**
     * 获取插槽格式的数组集合
     */
    getFormats() {
        return this.format.toArray();
    }
    /**
     * 提取 index 下标位置的格式
     * @param index
     */
    extractFormatsByIndex(index) {
        return this.format.extractFormatsByIndex(index);
    }
    /**
     * 把插槽内容转换为 JSON
     */
    toJSON() {
        var _a;
        const attrs = {};
        this.attributes.forEach((value, key) => {
            attrs[key.name] = value;
        });
        return {
            schema: this.schema,
            content: this.content.toJSON(),
            attributes: attrs,
            formats: this.format.toJSON(),
            state: (_a = this.state) !== null && _a !== void 0 ? _a : null
        };
    }
    toString() {
        return this.content.toString();
    }
    /**
     * 将插槽数据转换为 delta 表示
     */
    toDelta() {
        const deltaList = new DeltaLite();
        if (this.length === 0) {
            return deltaList;
        }
        const formatGrid = this.format.toGrid();
        const contentGrid = this.content.toGrid();
        const gridSet = new Set([...formatGrid, ...contentGrid]);
        const grid = [...gridSet].sort((a, b) => a - b);
        this.attributes.forEach((value, key) => {
            deltaList.attributes.set(key, value);
        });
        let startIndex = grid.shift();
        while (grid.length) {
            const endIndex = grid.shift();
            deltaList.push({
                insert: this.content.slice(startIndex, endIndex)[0],
                formats: this.format.extract(startIndex, endIndex).toArray().map(i => {
                    return [i.formatter, i.value];
                })
            });
            startIndex = endIndex;
        }
        return deltaList;
    }
    /**
     * 根据 delta 插入内容
     * @param delta
     */
    insertDelta(delta) {
        delta.attributes.forEach((value, key) => {
            this.setAttribute(key, value);
        });
        while (delta.length) {
            const first = delta[0];
            const is = this.insert(first.insert, first.formats);
            if (is) {
                delta.shift();
            }
            else {
                break;
            }
        }
        return delta;
    }
    /**
     * 清除插槽格式
     * @param excludeFormats 要排除的格式
     * @param startIndex 开始位置
     * @param endIndex 结束位置
     */
    cleanFormats(excludeFormats = [], startIndex = 0, endIndex = this.length) {
        const formats = this.getFormats();
        if (formats.length) {
            formats.forEach(item => {
                if (typeof excludeFormats === 'function' ? excludeFormats(item.formatter) : excludeFormats.includes(item.formatter)) {
                    return;
                }
                this.retain(startIndex);
                this.retain(endIndex - startIndex, item.formatter, null);
            });
        }
        else {
            this.sliceContent(startIndex, endIndex).forEach(item => {
                if (typeof item !== 'string') {
                    item.slots.toArray().forEach(slot => {
                        slot.cleanFormats(excludeFormats);
                    });
                }
            });
        }
    }
    /**
     * 当在回调函数中应用样式时，将把应用的样式作为子插槽的最低优化级合并
     * @param fn
     */
    background(fn) {
        this.applyFormatCoverChild = true;
        fn();
        this.applyFormatCoverChild = false;
    }
    /**
     * 清除插槽属性
     * @param excludeAttributes 要排除的属性
     */
    cleanAttributes(excludeAttributes = []) {
        Array.from(this.attributes.keys()).forEach(item => {
            if (typeof excludeAttributes === 'function' ? excludeAttributes(item) : excludeAttributes.includes(item)) {
                return;
            }
            this.removeAttribute(item);
        });
        this.sliceContent().forEach(item => {
            if (typeof item !== 'string') {
                item.slots.toArray().forEach(slot => {
                    slot.cleanAttributes(excludeAttributes);
                });
            }
        });
    }
    applyFormats(formats, startIndex, offset, background) {
        formats.forEach(keyValue => {
            const key = keyValue[0];
            const value = keyValue[1];
            this.format.merge(key, {
                startIndex,
                endIndex: startIndex + offset,
                value
            }, background);
        });
    }
    static createActionByFormat(format) {
        return format.toArray().map(item => {
            return [{
                    type: 'retain',
                    offset: item.startIndex
                }, {
                    type: 'retain',
                    offset: item.endIndex - item.startIndex,
                    formats: {
                        [item.formatter.name]: item.value
                    }
                }];
        }).flat();
    }
}
Slot.placeholder = '\u200b';

exports.RenderMode = void 0;
(function (RenderMode) {
    RenderMode["Output"] = "Output";
    RenderMode["Readonly"] = "Readonly";
    RenderMode["Editing"] = "Editing";
})(exports.RenderMode || (exports.RenderMode = {}));

/**
 * Textbus 控制器
 */
exports.Controller = class Controller {
    /** 是否只读 */
    get readonly() {
        return this._readonly;
    }
    set readonly(b) {
        this._readonly = b;
        this.readonlyStateChangeEvent.next(b);
    }
    constructor(readonly) {
        this._readonly = false;
        this.readonlyStateChangeEvent = new stream.Subject();
        this.onReadonlyStateChange = this.readonlyStateChangeEvent.asObservable().pipe(stream.distinctUntilChanged());
        this._readonly = readonly;
    }
};
exports.Controller = __decorate([
    di.Injectable(),
    __param(0, di.Inject(READONLY)),
    __metadata("design:paramtypes", [Boolean])
], exports.Controller);

var Selection_1;
/**
 * 用于跨平台实现的原生选区抽象类
 */
class NativeSelectionBridge {
}
/**
 * Textbus 选区实现类，用于选择 Textbus 文档内的内容
 */
exports.Selection = Selection_1 = class Selection {
    /** 当前是否有选区 */
    get isSelected() {
        return ![this.startSlot, this.startOffset, this.endSlot, this.endOffset].includes(null);
    }
    /** 当前选区是否闭合 */
    get isCollapsed() {
        return this.isSelected && this.startSlot === this.endSlot && this.startOffset === this.endOffset;
    }
    /** 选区开始插槽 */
    get startSlot() {
        return this._startSlot;
    }
    /** 选区开始位置在开始插槽中的索引 */
    get startOffset() {
        return this._startOffset;
    }
    /** 选区结束插槽 */
    get endSlot() {
        return this._endSlot;
    }
    /** 选区结束位置在线束插槽中的索引 */
    get endOffset() {
        return this._endOffset;
    }
    /** 锚点插槽 */
    get anchorSlot() {
        return this._anchorSlot;
    }
    /** 锚点插槽偏移量 */
    get anchorOffset() {
        return this._anchorOffset;
    }
    /** 焦点插槽 */
    get focusSlot() {
        return this._focusSlot;
    }
    /** 焦点插槽偏移量 */
    get focusOffset() {
        return this._focusOffset;
    }
    /**
     * 选区的公共父插槽
     */
    get commonAncestorSlot() {
        return this._commonAncestorSlot;
    }
    /**
     * 选区的公共父组件
     */
    get commonAncestorComponent() {
        return this._commonAncestorComponent;
    }
    /**
     * 是否代理原生选区
     */
    get nativeSelectionDelegate() {
        return this._nativeSelectionDelegate;
    }
    set nativeSelectionDelegate(v) {
        if (v === this._nativeSelectionDelegate) {
            return;
        }
        this._nativeSelectionDelegate = v;
        if (this.controller.readonly) {
            return;
        }
        if (v) {
            this.bridge.connect(this.connector);
        }
        else {
            // this.unSelect()
            this.bridge.disConnect();
        }
    }
    constructor(root, controller) {
        this.root = root;
        this.controller = controller;
        this.connector = {
            setSelection: (range) => {
                if (range === null) {
                    if (null === this.startSlot && null === this.endSlot && null === this.startOffset && null === this.endOffset) {
                        return;
                    }
                    this.unSelect();
                    return;
                }
                const { focusOffset, focusSlot, anchorOffset, anchorSlot } = range;
                if (focusSlot === this.focusSlot &&
                    anchorSlot === this.anchorSlot &&
                    focusOffset === this.focusOffset &&
                    anchorOffset === this.anchorOffset) {
                    return;
                }
                this.setBaseAndExtent(anchorSlot, anchorOffset, focusSlot, focusOffset);
            }
        };
        this._commonAncestorSlot = null;
        this._commonAncestorComponent = null;
        this._startSlot = null;
        this._endSlot = null;
        this._startOffset = null;
        this._endOffset = null;
        this._anchorSlot = null;
        this._anchorOffset = null;
        this._focusSlot = null;
        this._focusOffset = null;
        this.changeEvent = new stream.Subject();
        this._nativeSelectionDelegate = false;
        this.subscriptions = [];
        this.customRanges = null;
        this.changeFromUpdateCustomRanges = false;
        let prevFocusComponent;
        this.onChange = this.changeEvent.asObservable().pipe(stream.distinctUntilChanged((previous, current) => {
            if (previous && current) {
                return !(previous.focusOffset === current.focusOffset &&
                    previous.anchorOffset === current.anchorOffset &&
                    previous.focusSlot === current.focusSlot &&
                    previous.anchorSlot === current.anchorSlot);
            }
            return previous !== current;
        }), stream.share());
        let selectedComponent = null;
        const focusInComponents = [];
        this.subscriptions.push(controller.onReadonlyStateChange.subscribe(b => {
            if (b) {
                this.bridge.disConnect();
            }
            else {
                this.bridge.connect(this.connector);
            }
        }), this.onChange.pipe(stream.map(() => {
            return this.commonAncestorComponent;
        }), stream.distinctUntilChanged()).subscribe(component => {
            while (focusInComponents.length) {
                const focusOutComponent = focusInComponents.shift();
                let parentComponent = focusOutComponent;
                while (parentComponent) {
                    if (parentComponent === root.component) {
                        invokeListener(focusOutComponent, 'onFocusOut');
                    }
                    parentComponent = parentComponent.parentComponent;
                }
            }
            while (component) {
                focusInComponents.push(component);
                invokeListener(component, 'onFocusIn');
                component = component.parentComponent;
            }
        }), this.onChange.pipe(stream.map(() => {
            return this.commonAncestorComponent;
        })).subscribe(commonAncestorComponent => {
            let ranges = null;
            if (commonAncestorComponent) {
                invokeListener(commonAncestorComponent, 'onGetRanges', new GetRangesEvent(commonAncestorComponent, (rgs) => {
                    ranges = rgs;
                }));
            }
            if (!this.changeFromUpdateCustomRanges) {
                this.customRanges = ranges;
            }
        }), this.onChange.pipe(stream.map(() => {
            var _a, _b, _c;
            if (((_a = this.startSlot) === null || _a === void 0 ? void 0 : _a.parent) === ((_b = this.endSlot) === null || _b === void 0 ? void 0 : _b.parent)) {
                return ((_c = this.startSlot) === null || _c === void 0 ? void 0 : _c.parent) || null;
            }
            return null;
        }), stream.distinctUntilChanged()).subscribe(component => {
            if (prevFocusComponent) {
                let parentComponent = prevFocusComponent;
                while (parentComponent) {
                    if (parentComponent === root.component) {
                        invokeListener(prevFocusComponent, 'onBlur');
                    }
                    parentComponent = parentComponent.parentComponent;
                }
            }
            if (component) {
                invokeListener(component, 'onFocus');
            }
            prevFocusComponent = component;
        }), this.onChange.pipe(stream.map(() => {
            if (selectedComponent) {
                let p = selectedComponent.parentComponent;
                while (p) {
                    if (p === root.component) {
                        invokeListener(selectedComponent, 'onUnselect');
                    }
                    p = p.parentComponent;
                }
                selectedComponent = null;
            }
            if (!this.isSelected) {
                return null;
            }
            if (this.startSlot === this.endSlot && this.endOffset - this.startOffset === 1) {
                const content = this.startSlot.getContentAtIndex(this.startOffset);
                if (typeof content !== 'string') {
                    return content;
                }
            }
            return null;
        }), stream.distinctUntilChanged()).subscribe(component => {
            if (component) {
                invokeListener(component, 'onSelected');
                selectedComponent = component;
            }
        }));
        Promise.resolve().then(() => this.nativeSelectionDelegate = true);
    }
    /**
     * 创建选区快照，并可在需要时恢复选区，前提是缓存的插槽和位置还在文档中存在
     */
    createSnapshot() {
        const { anchorSlot, anchorOffset, focusSlot, focusOffset } = this;
        return {
            restore: (syncNative) => {
                this._anchorSlot = anchorSlot;
                this._anchorOffset = anchorOffset;
                this._focusSlot = focusSlot;
                this._focusOffset = focusOffset;
                this.resetStartAndEndPosition();
                if (syncNative) {
                    this.restore(true);
                }
            }
        };
    }
    /**
     * 销毁选区
     */
    destroy() {
        this.subscriptions.forEach(i => i.unsubscribe());
        this.subscriptions = [];
    }
    /**
     * 设置自定义选中的区间
     * @param ranges
     */
    setSelectedRanges(ranges) {
        this.changeFromUpdateCustomRanges = true;
        this.customRanges = ranges;
        this.broadcastChanged();
        this.changeFromUpdateCustomRanges = false;
    }
    /**
     * 设置锚点和焦点的位置
     * @param anchorSlot 锚点插槽
     * @param anchorOffset 锚点偏移量
     * @param focusSlot 焦点插槽
     * @param focusOffset 焦点偏移量
     */
    setBaseAndExtent(anchorSlot, anchorOffset, focusSlot, focusOffset) {
        if (this.controller.readonly) {
            return;
        }
        this._anchorSlot = anchorSlot;
        anchorSlot.retain(anchorOffset);
        this._anchorOffset = anchorSlot.index;
        this._focusSlot = focusSlot;
        focusSlot.retain(focusOffset);
        this._focusOffset = focusSlot.index;
        this.resetStartAndEndPosition();
    }
    /**
     * 获取选区内的选择范围，一般情况下为一个。组件可以 onGetRanges 勾子函数中定制范围个数，如表格中可能为多个
     */
    getRanges() {
        if (this.customRanges) {
            return this.customRanges.map(i => {
                return {
                    startOffset: i.startIndex,
                    endOffset: i.endIndex,
                    startSlot: i.slot,
                    endSlot: i.slot
                };
            });
        }
        return this.isSelected ? [{
                startSlot: this.startSlot,
                endSlot: this.endSlot,
                startOffset: this.startOffset,
                endOffset: this.endOffset
            }] : [];
    }
    /**
     * 设置选区的锚点位置
     * @param slot 锚点位置的插槽
     * @param offset 锚点位置索引
     */
    setAnchor(slot, offset) {
        if (this.controller.readonly) {
            return;
        }
        this._anchorSlot = slot;
        slot.retain(offset);
        this._anchorOffset = slot.index;
        this.resetStartAndEndPosition();
    }
    /**
     * 设置选区焦点位置
     * @param slot 焦点位置的插槽
     * @param offset 焦点位置的索引
     */
    setFocus(slot, offset) {
        if (this.controller.readonly) {
            return;
        }
        this._focusSlot = slot;
        slot.retain(offset);
        this._focusOffset = slot.index;
        this.resetStartAndEndPosition();
    }
    /**
     * 设置选区位置
     * @param slot 选区所以插槽
     * @param offset 选区位置索引
     */
    setPosition(slot, offset) {
        if (this.controller.readonly) {
            return;
        }
        this._focusSlot = this._anchorSlot = slot;
        slot.retain(offset);
        this._focusOffset = this._anchorOffset = slot.index;
        this.resetStartAndEndPosition();
    }
    /**
     * 设置选区选择插槽的全部内容
     * @param slot
     */
    selectSlot(slot) {
        this.setBaseAndExtent(slot, 0, slot, slot.length);
    }
    /**
     * 设置选区为组件的第一个位置
     * @param componentInstance
     * @param isRestore
     */
    selectFirstPosition(componentInstance, isRestore = false) {
        const slots = componentInstance.slots;
        if (slots.length) {
            const first = slots.first;
            const { slot, offset } = this.findFirstPosition(first, false);
            this.setBaseAndExtent(slot, offset, slot, offset);
        }
        else {
            this.selectComponentFront(componentInstance);
        }
        if (isRestore) {
            this.restore();
        }
    }
    /**
     * 设置选区为组件的最后一个位置
     * @param componentInstance
     * @param isRestore
     */
    selectLastPosition(componentInstance, isRestore = false) {
        const slots = componentInstance.slots;
        if (slots.length) {
            const last = slots.last;
            const { slot, offset } = this.findLastPosition(last, false);
            this.setBaseAndExtent(slot, offset, slot, offset);
        }
        else {
            this.selectComponentEnd(componentInstance);
        }
        if (isRestore) {
            this.restore();
        }
    }
    /**
     * 把选区设置在组件之前
     * @param componentInstance
     * @param isRestore
     */
    selectComponentFront(componentInstance, isRestore = false) {
        const parent = componentInstance.parent;
        if (parent) {
            const index = parent.indexOf(componentInstance);
            this.setBaseAndExtent(parent, index, parent, index);
        }
        else {
            this.unSelect();
        }
        if (isRestore) {
            this.restore();
        }
    }
    /**
     * 把选区设置在组件之后
     * @param componentInstance
     * @param isRestore
     */
    selectComponentEnd(componentInstance, isRestore = false) {
        const parent = componentInstance.parent;
        if (parent) {
            const index = parent.indexOf(componentInstance);
            this.setBaseAndExtent(parent, index + 1, parent, index + 1);
        }
        else {
            this.unSelect();
        }
        if (isRestore) {
            this.restore();
        }
    }
    /**
     * 选中组件所有的子插槽
     * @param componentInstance
     * @param isRestore
     */
    selectChildSlots(componentInstance, isRestore = false) {
        const slots = componentInstance.slots;
        if (slots.length) {
            const firstPosition = this.findFirstPosition(slots.first, false);
            const lastPosition = this.findLastPosition(slots.last, false);
            this.setBaseAndExtent(firstPosition.slot, firstPosition.offset, lastPosition.slot, lastPosition.offset);
        }
        else {
            this.selectComponent(componentInstance, false);
        }
        if (isRestore) {
            this.restore();
        }
    }
    /**
     * 设置选区选择一个组件
     * @param componentInstance 要选择的组件
     * @param isRestore 是否同步触发原生选区，默认为 `false`
     */
    selectComponent(componentInstance, isRestore = false) {
        const parent = componentInstance.parent;
        if (parent) {
            const index = parent.indexOf(componentInstance);
            this.setBaseAndExtent(parent, index, parent, index + 1);
            if (isRestore) {
                this.restore();
            }
        }
    }
    /**
     * 获取选区所选择的块的集合
     * @param decompose 是否按块分解已选中的区域
     */
    getSelectedScopes(decompose = false) {
        if (!this.isSelected) {
            return [];
        }
        if (this.isCollapsed) {
            return [{
                    slot: this.startSlot,
                    startIndex: this.startOffset,
                    endIndex: this.startOffset,
                }];
        }
        const scopes = this.getScopes(this.startSlot, this.startOffset, this.endSlot, this.endOffset, true);
        if (decompose) {
            const ranges = [];
            scopes.forEach(i => {
                ranges.push(...this.decomposeSlotRange(i.slot, i.startIndex, i.endIndex));
            });
            return ranges;
        }
        return scopes;
    }
    /**
     * 把光标移动到前一个位置
     */
    toPrevious() {
        var _a, _b;
        if (!this.isCollapsed) {
            this.collapse(true);
            this.restore();
            return;
        }
        const { startSlot, startOffset } = this;
        const position = this.getPreviousPosition();
        if (position) {
            this.setPosition(position.slot, position.offset);
            let content = null;
            if (startSlot === this.startSlot) {
                if (startOffset === this.startOffset) {
                    const first = this.root.component.slots.first;
                    this.setPosition(first, 0);
                }
                else if (startOffset - this.startOffset === 1) {
                    content = startSlot.getContentAtIndex(this.startOffset);
                }
            }
            else if ((startSlot === null || startSlot === void 0 ? void 0 : startSlot.parent) !== ((_a = this.startSlot) === null || _a === void 0 ? void 0 : _a.parent)) {
                content = ((_b = this.endSlot) === null || _b === void 0 ? void 0 : _b.parent) || null;
            }
            if (content && typeof content !== 'string') {
                const event = new Event(content, null);
                invokeListener(content, 'onSelectionFromEnd', event);
                if (!event.isPrevented) {
                    if (content.slots.length === 0) {
                        this.selectComponent(content);
                    }
                }
                else {
                    this.setPosition(startSlot, startOffset);
                }
            }
            this.restore();
        }
    }
    /**
     * 把光标移动到后一个位置
     */
    toNext() {
        var _a, _b;
        if (!this.isCollapsed) {
            this.collapse();
            this.restore();
            return;
        }
        const { endSlot, endOffset } = this;
        const position = this.getNextPosition();
        if (position) {
            let offset = position.offset;
            const slot = position.slot;
            while (offset <= slot.length) {
                this.setPosition(slot, offset);
                if (slot.index < offset) {
                    offset++;
                }
                else {
                    break;
                }
            }
            let content = null;
            if (endSlot === this.endSlot) {
                if (endOffset === this.endOffset) {
                    const last = this.root.component.slots.last;
                    this.setPosition(last, last.length);
                }
                else if (this.endOffset - endOffset === 1) {
                    content = endSlot.getContentAtIndex(endOffset);
                }
            }
            else if ((endSlot === null || endSlot === void 0 ? void 0 : endSlot.parent) !== ((_a = this.endSlot) === null || _a === void 0 ? void 0 : _a.parent)) {
                content = ((_b = this.endSlot) === null || _b === void 0 ? void 0 : _b.parent) || null;
            }
            if (content && typeof content !== 'string') {
                const event = new Event(content, null);
                invokeListener(content, 'onSelectionFromFront', event);
                if (!event.isPrevented) {
                    if (content.slots.length === 0) {
                        this.selectComponent(content);
                    }
                }
                else {
                    this.setPosition(endSlot, endOffset);
                }
            }
            this.restore();
        }
    }
    /**
     * 把光标移动到上一行
     */
    toPreviousLine() {
        const previousLinePosition = this.bridge.getPreviousLinePositionByCurrent({
            slot: this.focusSlot,
            offset: this.focusOffset
        });
        if (previousLinePosition) {
            this.setPosition(previousLinePosition.slot, previousLinePosition.offset);
            this.restore();
        }
    }
    /**
     * 把光标移动到下一行
     */
    toNextLine() {
        const nextLinePosition = this.bridge.getNextLinePositionByCurrent({
            slot: this.focusSlot,
            offset: this.focusOffset
        });
        if (nextLinePosition) {
            this.setPosition(nextLinePosition.slot, nextLinePosition.offset);
            this.restore();
        }
    }
    /**
     * 向右框选
     */
    wrapToAfter() {
        this.wrapTo(false);
    }
    /**
     * 向左框选
     */
    wrapToBefore() {
        this.wrapTo(true);
    }
    /**
     * 向上一行框选
     */
    wrapToPreviousLine() {
        const previousLinePosition = this.bridge.getPreviousLinePositionByCurrent({
            slot: this.focusSlot,
            offset: this.focusOffset
        });
        if (previousLinePosition) {
            this.setFocus(previousLinePosition.slot, previousLinePosition.offset);
            this.restore();
        }
    }
    /**
     * 向下一行框选
     */
    wrapToNextLine() {
        const nextLinePosition = this.bridge.getNextLinePositionByCurrent({
            slot: this.focusSlot,
            offset: this.focusOffset
        });
        if (nextLinePosition) {
            this.setFocus(nextLinePosition.slot, nextLinePosition.offset);
            this.restore();
        }
    }
    /**
     * 闭合选区
     * @param toStart 是否闭合到结束位置
     */
    collapse(toStart = false) {
        if (toStart) {
            this.setPosition(this.startSlot, this.startOffset);
        }
        else {
            this.setPosition(this.endSlot, this.endOffset);
        }
    }
    /**
     * 立即同步 Textbus 选区到原生选区
     */
    restore(fromLocal = true) {
        if (this.nativeSelectionDelegate) {
            const focusSlot = this.focusSlot;
            const focusOffset = this.focusOffset;
            const anchorSlot = this.anchorSlot;
            const anchorOffset = this.anchorOffset;
            if (focusSlot && anchorSlot) {
                focusSlot.retain(focusOffset);
                anchorSlot.retain(anchorOffset);
                this.bridge.restore({
                    focusOffset: focusOffset,
                    focusSlot: focusSlot,
                    anchorOffset: anchorOffset,
                    anchorSlot: anchorSlot
                }, fromLocal);
            }
            else {
                this.bridge.restore(null, fromLocal);
            }
        }
    }
    /**
     * 获取当前选区在文档中的路径
     */
    getPaths() {
        if (!this.isSelected) {
            return {
                anchor: [],
                focus: [],
            };
        }
        const anchor = this.getPathsBySlot(this.anchorSlot) || [];
        anchor.push(this.anchorOffset);
        const focus = this.getPathsBySlot(this.focusSlot) || [];
        focus.push(this.focusOffset);
        return {
            anchor,
            focus,
        };
    }
    /**
     * 把选区设置为指定的路径
     * @param paths
     */
    usePaths(paths) {
        const anchorPosition = this.findPositionByPath(paths.anchor);
        const focusPosition = this.findPositionByPath(paths.focus);
        if (anchorPosition && focusPosition) {
            this.setBaseAndExtent(anchorPosition.slot, anchorPosition.offset, focusPosition.slot, focusPosition.offset);
        }
    }
    /**
     * 取消选区
     */
    unSelect() {
        this._anchorSlot = this._focusSlot = this._anchorOffset = this._focusOffset = null;
        this.resetStartAndEndPosition();
        this.restore();
    }
    /**
     * 选择整个文档
     */
    selectAll() {
        const slot = this.root.component.slots.get(0);
        this.setBaseAndExtent(slot, 0, slot, slot.length);
        this.restore();
    }
    /**
     * 获取下一个选区位置。
     */
    getNextPosition() {
        if (!this.isSelected) {
            return null;
        }
        return this.getNextPositionByPosition(this.focusSlot, this.focusOffset);
    }
    /**
     * 获取上一个选区位置。
     */
    getPreviousPosition() {
        if (!this.isSelected) {
            return null;
        }
        return this.getPreviousPositionByPosition(this.focusSlot, this.focusOffset);
    }
    /**
     * 根据路径获取对应的插槽
     * @param paths
     */
    findSlotByPaths(paths) {
        const result = Selection_1.findTreeNode(paths, this.root.component);
        if (result instanceof Slot) {
            return result;
        }
        return null;
    }
    /**
     * 根据路径获取对应的组件
     * @param paths
     */
    findComponentByPaths(paths) {
        if (paths.length === 0) {
            return this.root.component;
        }
        const result = Selection_1.findTreeNode(paths, this.root.component);
        if (result instanceof Slot) {
            return null;
        }
        return result;
    }
    /**
     * 获取选区内所有的块集合
     */
    getBlocks() {
        const blocks = [];
        if (!this.isSelected) {
            return blocks;
        }
        const scopes = this.getGreedyRanges();
        scopes.forEach(i => {
            blocks.push(...this.decomposeSlotRange(i.slot, i.startIndex, i.endIndex));
        });
        return blocks;
    }
    /**
     * 获取开始插槽和结束插槽在公共组件内的下标范围
     */
    getSlotRangeInCommonAncestorComponent() {
        const ancestorComponent = this.commonAncestorComponent;
        if (!ancestorComponent) {
            return null;
        }
        let startSlot = this.startSlot;
        let endSlot = this.endSlot;
        let startOffset;
        let endOffset;
        while (true) {
            const parent = startSlot.parent;
            if (parent === ancestorComponent) {
                startOffset = parent.slots.indexOf(startSlot);
                break;
            }
            if (parent === null || parent === void 0 ? void 0 : parent.parent) {
                startSlot = parent.parent;
            }
            else {
                return null;
            }
        }
        while (true) {
            const parent = endSlot.parent;
            if (parent === ancestorComponent) {
                endOffset = parent.slots.indexOf(endSlot) + 1;
                break;
            }
            if (parent === null || parent === void 0 ? void 0 : parent.parent) {
                endSlot = parent.parent;
            }
            else {
                return null;
            }
        }
        if (startOffset >= 0 && endOffset >= 1) {
            return {
                startOffset,
                endOffset,
                component: ancestorComponent
            };
        }
        return null;
    }
    /**
     * 获取当前选区在开始和结束位置均扩展到最大行内内容位置是的块
     */
    getGreedyRanges() {
        if (!this.isSelected) {
            return [];
        }
        return this.getScopes(this.startSlot, Selection_1.getInlineContentStartIndex(this.startSlot, this.startOffset), this.endSlot, Selection_1.getInlineContentEndIndex(this.endSlot, this.endOffset));
    }
    /**
     * 查找插槽内最深的第一个光标位置
     * @param slot
     * @param toChild
     */
    findFirstPosition(slot, toChild = true) {
        const first = slot.getContentAtIndex(0);
        if (toChild && first && typeof first !== 'string') {
            const firstChildSlot = first.slots.first;
            if (firstChildSlot) {
                return this.findFirstPosition(firstChildSlot);
            }
        }
        return {
            offset: 0,
            slot: slot
        };
    }
    /**
     * 查的插槽内最深的最后一个光标位置
     * @param slot
     * @param toChild
     */
    findLastPosition(slot, toChild = true) {
        const last = slot.getContentAtIndex(slot.length - 1);
        if (toChild && last && typeof last !== 'string') {
            const lastChildSlot = last.slots.last;
            if (lastChildSlot) {
                return this.findLastPosition(lastChildSlot);
            }
        }
        return {
            offset: last === '\n' ?
                slot.length - 1 :
                slot.length,
            slot: slot
        };
    }
    /**
     * 获取当前选区在公共插槽的位置
     */
    getCommonAncestorSlotScope() {
        if (!this.isSelected) {
            return null;
        }
        let startSlot = this.startSlot;
        let endSlot = this.endSlot;
        let startChildSlot = this.startSlot;
        let endChildSlot = this.endSlot;
        let startOffset = this.startOffset;
        let endOffset = this.endOffset;
        const commonAncestorSlot = this.commonAncestorSlot;
        const commonAncestorComponent = this.commonAncestorComponent;
        let startChildComponent = null;
        let endChildComponent = null;
        while (startSlot !== commonAncestorSlot) {
            startChildComponent = startSlot.parent;
            if (startChildComponent === commonAncestorComponent) {
                startChildSlot = startSlot;
            }
            startSlot = startChildComponent.parent;
            startOffset = startSlot.indexOf(startChildComponent);
        }
        while (endSlot !== commonAncestorSlot) {
            endChildComponent = endSlot.parent;
            if (endChildComponent === commonAncestorComponent) {
                endChildSlot = endSlot;
            }
            endSlot = endChildComponent.parent;
            endOffset = endSlot.indexOf(endChildComponent);
        }
        return {
            startOffset: startOffset,
            startSlot,
            startChildComponent,
            endOffset: endOffset + 1,
            endSlot,
            endChildComponent,
            startChildSlot,
            endChildSlot
        };
    }
    /**
     * 获取插槽在文档中的绝对路径
     * @param slot
     */
    getPathsBySlot(slot) {
        const paths = [];
        while (true) {
            const parentComponent = slot.parent;
            if (!parentComponent) {
                return null;
            }
            const slotIndex = parentComponent.slots.indexOf(slot);
            paths.push(slotIndex);
            const parentSlot = parentComponent.parent;
            if (!parentSlot) {
                if (parentComponent !== this.root.component) {
                    return null;
                }
                break;
            }
            const componentIndex = parentSlot.indexOf(parentComponent);
            paths.push(componentIndex);
            slot = parentSlot;
        }
        return paths.length ? paths.reverse() : null;
    }
    /**
     * 根据当前位置获取下一个光标位置
     * @param slot
     * @param offset
     */
    getNextPositionByPosition(slot, offset) {
        if (offset === slot.length - 1) {
            const current = slot.getContentAtIndex(offset);
            if (current === '\n') {
                offset++;
            }
        }
        if (offset < slot.length) {
            const current = slot.getContentAtIndex(offset);
            if (typeof current !== 'string') {
                const firstChildSlot = current.slots.get(0);
                if (firstChildSlot) {
                    return this.findFirstPosition(firstChildSlot);
                }
            }
            return {
                slot,
                offset: offset + current.length
            };
        }
        // 循环向后找最后一个子 slot，但有可能当前这个就是最后一个，这时循环
        // 向上会找不到，那么就使用当前的 slot
        const cacheSlot = slot;
        while (slot) {
            const parentComponent = slot.parent;
            const slotIndex = parentComponent.slots.indexOf(slot);
            if (slotIndex < parentComponent.slots.length - 1) {
                return this.findFirstPosition(parentComponent.slots.get(slotIndex + 1));
            }
            const parentSlot = parentComponent.parent;
            if (!parentSlot) {
                const len = cacheSlot.length;
                const last = cacheSlot.getContentAtIndex(len - 1);
                return {
                    slot: cacheSlot,
                    offset: last === '\n' ? len - 1 : len
                };
            }
            const componentIndex = parentSlot.indexOf(parentComponent);
            if (componentIndex < parentSlot.length) {
                if (parentComponent.type !== exports.ContentType.BlockComponent) {
                    return {
                        slot: parentSlot,
                        offset: componentIndex + 1
                    };
                }
                const nextContent = parentSlot.getContentAtIndex(componentIndex + 1);
                if (nextContent) {
                    if (typeof nextContent !== 'string') {
                        const nextFirstSlot = nextContent.slots.first;
                        if (nextFirstSlot) {
                            return this.findFirstPosition(nextFirstSlot);
                        }
                    }
                    return {
                        slot: parentSlot,
                        offset: componentIndex + 1
                    };
                }
            }
            slot = parentSlot;
        }
        return {
            slot: cacheSlot,
            offset: this.endOffset
        };
    }
    /**
     * 根据当前位置，获取下一个光标位置
     * @param slot
     * @param offset
     */
    getPreviousPositionByPosition(slot, offset) {
        if (offset > 0) {
            const prev = slot.getContentAtIndex(offset - 1);
            if (prev && typeof prev !== 'string') {
                const lastChildSlot = prev.slots.last;
                if (lastChildSlot) {
                    return this.findLastPosition(lastChildSlot);
                }
            }
            return {
                slot: slot,
                offset: offset - prev.length
            };
        }
        // 循环向前找第一个子 slot，但有可能当前这个就是第一个，这时循环向上会找不到，那么就使用当前的 slot
        let cacheSlot = slot;
        while (slot) {
            const parentComponent = slot.parent;
            const slots = parentComponent.slots;
            const slotIndex = slots.indexOf(slot);
            if (slotIndex > 0) {
                return this.findLastPosition(slots.get(slotIndex - 1));
            }
            const parentSlot = parentComponent.parent;
            if (!parentSlot) {
                return {
                    slot: cacheSlot,
                    offset: 0
                };
            }
            const componentIndex = parentSlot.indexOf(parentComponent);
            if (componentIndex > 0) {
                const prevContent = parentSlot.getContentAtIndex(componentIndex - 1);
                if (prevContent && typeof prevContent !== 'string') {
                    const lastChildSlot = prevContent.slots.last;
                    if (lastChildSlot) {
                        return this.findLastPosition(lastChildSlot);
                    }
                }
                return {
                    slot: parentSlot,
                    offset: prevContent === '\n' ? componentIndex - 1 : componentIndex
                };
            }
            slot = parentSlot;
            cacheSlot = slot;
        }
        return {
            slot: cacheSlot,
            offset: 0
        };
    }
    /**
     * 根据指定的开始位置和结束位置，获取选区中片段
     * @param startSlot
     * @param startIndex
     * @param endSlot
     * @param endIndex
     * @param discardEmptyScope
     */
    getScopes(startSlot, startIndex, endSlot, endIndex, discardEmptyScope = false) {
        const commonAncestorSlot = Selection_1.getCommonAncestorSlot(startSlot, endSlot);
        const commonAncestorComponent = Selection_1.getCommonAncestorComponent(startSlot, endSlot);
        return this.getScopesByRange(startSlot, startIndex, endSlot, endIndex, commonAncestorSlot, commonAncestorComponent, discardEmptyScope);
    }
    /**
     * 根据开始插槽和结束插槽获取最近的公共父组件
     * @param startSlot
     * @param endSlot
     */
    static getCommonAncestorComponent(startSlot, endSlot) {
        let startComponent = startSlot === null || startSlot === void 0 ? void 0 : startSlot.parent;
        let endComponent = endSlot === null || endSlot === void 0 ? void 0 : endSlot.parent;
        if (startComponent === endComponent) {
            return startComponent || null;
        }
        const startPaths = [];
        const endPaths = [];
        while (startComponent) {
            startPaths.push(startComponent);
            const parentSlot = startComponent.parent;
            if (!parentSlot) {
                break;
            }
            startComponent = parentSlot.parent;
        }
        while (endComponent) {
            endPaths.push(endComponent);
            const parentSlot = endComponent.parent;
            if (!parentSlot) {
                break;
            }
            endComponent = parentSlot.parent;
        }
        let f = null;
        while (startPaths.length && endPaths.length) {
            const s = startPaths.pop();
            const e = endPaths.pop();
            if (s === e) {
                f = s;
            }
            else {
                break;
            }
        }
        return f;
    }
    /**
     * 根据开始插槽和结束插槽获取最近的公共父插槽
     * @param startSlot
     * @param endSlot
     */
    static getCommonAncestorSlot(startSlot, endSlot) {
        if (startSlot === endSlot) {
            return startSlot;
        }
        const startPaths = [];
        const endPaths = [];
        while (startSlot) {
            startPaths.push(startSlot);
            const parentComponent = startSlot.parent;
            if (!parentComponent) {
                break;
            }
            startSlot = parentComponent.parent;
        }
        while (endSlot) {
            endPaths.push(endSlot);
            const parentComponent = endSlot.parent;
            if (!parentComponent) {
                break;
            }
            endSlot = parentComponent.parent;
        }
        let f = null;
        while (startPaths.length && endPaths.length) {
            const s = startPaths.pop();
            const e = endPaths.pop();
            if (s === e) {
                f = s;
            }
            else {
                break;
            }
        }
        return f;
    }
    /**
     * 比较两个绝对路径的前后，当 minPaths 小于 maxPaths 时，返回 true，否则返回 false
     * @param minPaths 假定的小路径
     * @param maxPaths 假定的大路径
     * @param canEqual minPaths 和 maxPaths 是否可以相等
     */
    static compareSelectionPaths(minPaths, maxPaths, canEqual = true) {
        let minIsStart = true;
        let i = 0;
        while (true) {
            if (i < maxPaths.length) {
                if (i < minPaths.length) {
                    const min = minPaths[i];
                    const max = maxPaths[i];
                    if (min === max) {
                        if (i === maxPaths.length - 1 && i === minPaths.length - 1) {
                            return canEqual;
                        }
                        i++;
                        continue;
                    }
                    minIsStart = min < max;
                    break;
                }
                else {
                    minIsStart = true;
                    break;
                }
            }
            else {
                minIsStart = false;
                break;
            }
        }
        return minIsStart;
    }
    /**
     * 获取插槽指定位置之前的非 BlockComponent 内容
     * @param slot
     * @param index
     */
    static getInlineContentStartIndex(slot, index) {
        const contents = slot.sliceContent(0, index);
        const len = contents.length;
        for (let i = len - 1; i >= 0; i--) {
            const item = contents[i];
            if (typeof item !== 'string' && item.type === exports.ContentType.BlockComponent) {
                break;
            }
            index -= item.length;
        }
        return index;
    }
    /**
     * 获取插槽指定位置之后的非 BlockComponent 内容
     * @param slot
     * @param index
     */
    static getInlineContentEndIndex(slot, index) {
        const contents = slot.sliceContent(index);
        for (let i = 0; i < contents.length; i++) {
            const item = contents[i];
            if (typeof item !== 'string' && item.type === exports.ContentType.BlockComponent) {
                break;
            }
            index += item.length;
        }
        return index;
    }
    decomposeSlotRange(slot, startIndex, endIndex) {
        const scopes = [];
        if (startIndex >= endIndex) {
            return scopes;
        }
        let newScope = null;
        let i = 0;
        const contents = slot.sliceContent(startIndex, endIndex);
        contents.forEach(c => {
            if (typeof c !== 'string' && c.type === exports.ContentType.BlockComponent && c.slots.length !== 0) {
                newScope = null;
                c.slots.toArray().forEach(s => {
                    scopes.push(...this.decomposeSlotRange(s, 0, s.length));
                });
            }
            else if (!newScope) {
                newScope = {
                    startIndex: startIndex + i,
                    endIndex: startIndex + i + c.length,
                    slot: slot
                };
                scopes.push(newScope);
            }
            else {
                newScope.endIndex = startIndex + i + c.length;
            }
            i += c.length;
        });
        return scopes;
    }
    resetStartAndEndPosition() {
        let focusPaths = [];
        let anchorPaths = [];
        if (this.focusSlot) {
            const _focusPaths = this.getPathsBySlot(this.focusSlot);
            if (_focusPaths) {
                focusPaths = _focusPaths;
                focusPaths.push(this.focusOffset);
            }
            else {
                this._focusSlot = this._focusOffset = null;
            }
        }
        if (this.anchorSlot) {
            const _anchorPaths = this.getPathsBySlot(this.anchorSlot);
            if (_anchorPaths) {
                anchorPaths = _anchorPaths;
                anchorPaths.push(this.anchorOffset);
            }
            else {
                this._anchorSlot = this._anchorOffset = null;
            }
        }
        const anchorSlotIsStart = Selection_1.compareSelectionPaths(anchorPaths, focusPaths);
        if (anchorSlotIsStart) {
            this._startSlot = this.anchorSlot;
            this._startOffset = this.anchorOffset;
            this._endSlot = this.focusSlot;
            this._endOffset = this.focusOffset;
        }
        else {
            this._endSlot = this.anchorSlot;
            this._endOffset = this.anchorOffset;
            this._startSlot = this.focusSlot;
            this._startOffset = this.focusOffset;
        }
        this._commonAncestorSlot = Selection_1.getCommonAncestorSlot(this.startSlot, this.endSlot);
        this._commonAncestorComponent = Selection_1.getCommonAncestorComponent(this.startSlot, this.endSlot);
        this.broadcastChanged();
    }
    wrapTo(toLeft) {
        if (!this.isSelected) {
            return;
        }
        const position = toLeft ?
            this.getPreviousPositionByPosition(this.focusSlot, this.focusOffset) :
            this.getNextPositionByPosition(this.focusSlot, this.focusOffset);
        this.setBaseAndExtent(this.anchorSlot, this.anchorOffset, position.slot, position.offset);
        this.restore();
    }
    findPositionByPath(paths) {
        const startPaths = [...paths];
        const offset = startPaths.pop();
        const slot = this.findSlotByPaths(startPaths);
        if (slot) {
            return {
                slot,
                offset
            };
        }
        return null;
    }
    broadcastChanged() {
        this.changeEvent.next(this.isSelected ? {
            focusSlot: this.focusSlot,
            anchorSlot: this.anchorSlot,
            focusOffset: this.focusOffset,
            anchorOffset: this.anchorOffset
        } : null);
    }
    getScopesByRange(startSlot, startIndex, endSlot, endIndex, commonAncestorSlot, commonAncestorComponent, discardEmptyScope = false) {
        const start = [];
        const end = [];
        let startParentComponent = null;
        let endParentComponent = null;
        let startSlotRefIndex = null;
        let endSlotRefIndex = null;
        if (this.customRanges) {
            return this.customRanges;
        }
        while (startSlot !== commonAncestorSlot) {
            start.push({
                startIndex,
                endIndex: startSlot.length,
                slot: startSlot
            });
            startParentComponent = startSlot.parent;
            const childSlots = startParentComponent.slots;
            const end = childSlots.indexOf(endSlot);
            startSlotRefIndex = childSlots.indexOf(startSlot);
            if (startParentComponent !== commonAncestorComponent && end === -1) {
                start.push(...childSlots.slice(startSlotRefIndex + 1, childSlots.length).map(slot => {
                    return {
                        startIndex: 0,
                        endIndex: slot.length,
                        slot
                    };
                }));
            }
            if (!startParentComponent.parent) {
                break;
            }
            startSlot = startParentComponent.parent;
            startIndex = startSlot.indexOf(startParentComponent) + 1;
        }
        while (endSlot !== commonAncestorSlot) {
            end.push({
                startIndex: 0,
                endIndex,
                slot: endSlot
            });
            endParentComponent = endSlot.parent;
            if (!endParentComponent) {
                break;
            }
            const childSlots = endParentComponent.slots;
            const index = childSlots.indexOf(startSlot);
            endSlotRefIndex = childSlots.indexOf(endSlot);
            if (endParentComponent !== commonAncestorComponent && index === -1) {
                end.push(...childSlots.slice(0, endSlotRefIndex).map(slot => {
                    return {
                        startIndex: 0,
                        endIndex: slot.length,
                        slot
                    };
                }).reverse());
            }
            if (!endParentComponent.parent) {
                break;
            }
            endSlot = endParentComponent.parent;
            endIndex = endSlot.indexOf(endParentComponent);
        }
        const result = [...start];
        if (startParentComponent && startParentComponent === endParentComponent) {
            const slots = startParentComponent.slots.slice(startSlotRefIndex + 1, endSlotRefIndex);
            result.push(...slots.map(slot => {
                return {
                    startIndex: 0,
                    endIndex: slot.length,
                    slot
                };
            }));
        }
        else {
            result.push({
                startIndex,
                endIndex,
                slot: commonAncestorSlot
            });
        }
        result.push(...end.reverse());
        if (discardEmptyScope) {
            return result.filter(item => {
                return item.slot && item.startIndex < item.endIndex;
            });
        }
        return result;
    }
    static findTreeNode(paths, component) {
        if (typeof component !== 'object') {
            return null;
        }
        const firstSlotRefIndex = paths.shift();
        const slot = component.slots.get(firstSlotRefIndex);
        if (paths.length === 0 || !slot) {
            return slot || null;
        }
        const position = paths.shift();
        component = slot.getContentAtIndex(position);
        if (paths.length === 0 || !component) {
            return component || null;
        }
        return Selection_1.findTreeNode(paths, component);
    }
};
__decorate([
    di.Prop(),
    __metadata("design:type", NativeSelectionBridge
    /** 当选区变化时触发 */
    )
], exports.Selection.prototype, "bridge", void 0);
exports.Selection = Selection_1 = __decorate([
    di.Injectable(),
    __metadata("design:paramtypes", [RootComponentRef,
        exports.Controller])
], exports.Selection);

/**
 * 注册表
 * 用于缓存一个 Textbus 实例内可用的 Component、Formatter、Attribute。
 * Registry 也可以根据数据创建组件或插槽的实例
 */
exports.Registry = class Registry {
    constructor(contextInjector, components, attributes, formatters) {
        this.contextInjector = contextInjector;
        this.components = components;
        this.attributes = attributes;
        this.formatters = formatters;
        this.componentMap = new Map();
        this.formatMap = new Map();
        this.attributeMap = new Map();
        components.reverse().forEach(f => {
            this.componentMap.set(f.name, f);
        });
        attributes.reverse().forEach(f => {
            this.attributeMap.set(f.name, f);
        });
        formatters.reverse().forEach(f => {
            this.formatMap.set(f.name, f);
        });
    }
    /**
     * 根据组件名获取组件
     * @param name 组件名
     */
    getComponent(name) {
        return this.componentMap.get(name) || null;
    }
    /**
     * 根据格式名获取格式
     * @param name 格式名
     */
    getFormatter(name) {
        return this.formatMap.get(name) || null;
    }
    /**
     * 根据名字获取 Attribute 实例
     * @param name
     */
    getAttribute(name) {
        return this.attributeMap.get(name) || null;
    }
    /**
     * 根据组件名和数据创建组件
     * @param name
     * @param data
     */
    createComponentByData(name, data) {
        const factory = this.getComponent(name);
        if (factory) {
            return factory.createInstance(this.contextInjector, data);
        }
        return null;
    }
    /**
     * 根据插槽数据生成插槽实例
     * @param slotLiteral
     * @param customComponentCreator
     */
    createSlot(slotLiteral, customComponentCreator) {
        const slot = new Slot(slotLiteral.schema, slotLiteral.state);
        return this.loadSlot(slot, slotLiteral, customComponentCreator);
    }
    /**
     * 根据组件数据生成组件实例
     * @param componentLiteral
     * @param customSlotCreator
     */
    createComponent(componentLiteral, customSlotCreator) {
        const factory = this.getComponent(componentLiteral.name);
        if (factory) {
            return this.createComponentByFactory(componentLiteral, factory, customSlotCreator);
        }
        return null;
    }
    /**
     * 指定组件创建实例
     * @param componentLiteral
     * @param factory
     * @param customSlotCreator
     */
    createComponentByFactory(componentLiteral, factory, customSlotCreator) {
        const slots = componentLiteral.slots.map(customSlotCreator || ((i) => this.createSlot(i)));
        return factory.createInstance(this.contextInjector, {
            state: componentLiteral.state,
            slots
        });
    }
    /**
     * 将插槽数据填充到指定的插槽
     * @param source
     * @param target
     */
    fillSlot(source, target) {
        return this.loadSlot(target, source);
    }
    loadSlot(slot, slotLiteral, customComponentCreator) {
        slotLiteral.content.forEach((item, index) => {
            if (typeof item !== 'string') {
                const component = customComponentCreator ? customComponentCreator(item, index) : this.createComponent(item);
                if (component) {
                    slot.insert(component);
                }
                return;
            }
            slot.insert(item);
        });
        Object.keys(slotLiteral.formats).forEach(key => {
            const formatter = this.getFormatter(key);
            if (formatter) {
                slotLiteral.formats[key].forEach(i => {
                    slot.retain(i.startIndex);
                    slot.retain(i.endIndex - i.startIndex, formatter, i.value);
                });
            }
        });
        if (slotLiteral.attributes !== null && typeof slotLiteral.attributes === 'object') {
            Object.keys(slotLiteral.attributes).forEach(key => {
                const attribute = this.attributeMap.get(key);
                if (attribute) {
                    slot.setAttribute(attribute, slotLiteral.attributes[key]);
                }
            });
        }
        return slot;
    }
};
exports.Registry = __decorate([
    di.Injectable(),
    __param(1, di.Inject(COMPONENT_LIST)),
    __param(2, di.Inject(ATTRIBUTE_LIST)),
    __param(3, di.Inject(FORMATTER_LIST)),
    __metadata("design:paramtypes", [di.Injector, Array, Array, Array])
], exports.Registry);

function getInsertPosition(slot, offset, content, excludeSlots = []) {
    if (canInsert(content, slot)) {
        return {
            slot,
            offset
        };
    }
    excludeSlots.push(slot);
    return getNextInsertPosition(slot, content, excludeSlots);
}
function canInsert(content, target) {
    const insertType = typeof content === 'string' ? exports.ContentType.Text : content.type;
    return target.schema.includes(insertType);
}
function getNextInsertPosition(currentSlot, content, excludeSlots) {
    const parentComponent = currentSlot.parent;
    const slotIndex = parentComponent.slots.indexOf(currentSlot);
    if (currentSlot !== parentComponent.slots.last) {
        return getInsertPosition(parentComponent.slots.get(slotIndex + 1), 0, content, excludeSlots);
    }
    const parentSlot = parentComponent.parent;
    if (!parentSlot) {
        return null;
    }
    if (excludeSlots.includes(parentSlot)) {
        return getNextInsertPosition(parentSlot, content, excludeSlots);
    }
    const index = parentSlot.indexOf(parentComponent);
    const position = getInsertPosition(parentSlot, index + 1, content, excludeSlots);
    if (position) {
        return position;
    }
    excludeSlots.push(parentSlot);
    const afterContent = parentSlot.sliceContent(index + 1);
    const firstComponent = afterContent.filter((i) => {
        return typeof i !== 'string';
    }).shift();
    if (firstComponent && firstComponent.slots.length) {
        return getInsertPosition(firstComponent.slots.get(0), 0, content, excludeSlots);
    }
    return getNextInsertPosition(parentSlot, content, excludeSlots);
}
function deleteUpBySlot(selection, slot, offset, rootComponent, deleteBefore) {
    const parentComponent = slot.parent;
    if (!parentComponent) {
        return {
            slot,
            offset
        };
    }
    const parentSlot = parentComponent.parent;
    if (!parentSlot) {
        return {
            slot,
            offset
        };
    }
    const index = parentSlot.indexOf(parentComponent);
    // 单插槽组件
    if (parentComponent.slots.length === 1) {
        if (parentComponent === rootComponent) {
            return {
                slot,
                offset
            };
        }
        const event = new Event(parentSlot, {
            index,
            count: 1,
            toEnd: !deleteBefore,
            actionType: 'delete'
        });
        invokeListener(parentSlot.parent, 'onContentDelete', event);
        if (event.isPrevented) {
            return {
                slot,
                offset
            };
        }
        parentSlot.retain(index);
        parentSlot.delete(1);
        invokeListener(parentSlot.parent, 'onContentDeleted', new Event(parentSlot, null));
        if (parentSlot.isEmpty) {
            return deleteUpBySlot(selection, parentSlot, index, rootComponent, deleteBefore);
        }
        return {
            slot: parentSlot,
            offset: parentSlot.index
        };
    }
    // 多插槽组件
    const slotIndex = parentComponent.slots.indexOf(slot);
    const position = slotIndex === 0 ? {
        slot: parentSlot,
        offset: index
    } : selection.findLastPosition(parentComponent.slots.get(slotIndex - 1), true);
    const event = new Event(parentComponent, {
        index: slotIndex,
        count: 1,
        toEnd: !deleteBefore,
        actionType: 'delete'
    });
    invokeListener(parentComponent, 'onSlotRemove', event);
    if (!event.isPrevented) {
        const isSuccess = parentComponent.slots.remove(slot);
        if (isSuccess) {
            invokeListener(parentComponent, 'onSlotRemoved', new Event(parentComponent, null));
        }
        return position;
    }
    return {
        slot,
        offset
    };
}
function deltaToSlots(selection, source, delta, rule, abstractSelection, offset) {
    const parentComponent = source.parent;
    const context = {
        slotState: source.state,
        parentComponentName: parentComponent.name,
        parentComponentState: parentComponent.state
    };
    let newSlot = rule.slotFactory(context);
    delta.attributes.forEach((value, key) => {
        newSlot.setAttribute(key, value);
    });
    const newSlots = [newSlot];
    let index = 0;
    while (delta.length) {
        const { insert, formats } = delta.shift();
        const b = canInsert(insert, newSlot);
        const oldIndex = index;
        index += insert.length;
        if (b) {
            newSlot.insert(insert, formats);
            if (source === abstractSelection.anchorSlot &&
                abstractSelection.anchorOffset - offset >= oldIndex &&
                abstractSelection.anchorOffset - offset <= index) {
                abstractSelection.anchorSlot = newSlot;
                abstractSelection.anchorOffset -= offset;
            }
            if (source === abstractSelection.focusSlot &&
                abstractSelection.focusOffset - offset >= oldIndex &&
                abstractSelection.focusOffset - offset <= index) {
                abstractSelection.focusSlot = newSlot;
                abstractSelection.focusOffset -= offset;
            }
            continue;
        }
        if (abstractSelection.anchorOffset > index) {
            abstractSelection.anchorOffset -= index;
        }
        if (abstractSelection.focusOffset > index) {
            abstractSelection.focusOffset -= index;
        }
        if (typeof insert !== 'string') {
            const slots = insert.slots.toArray().map(childSlot => {
                return deltaToSlots(selection, source, childSlot.toDelta(), rule, abstractSelection, offset);
            }).flat();
            newSlots.push(...slots);
        }
        newSlot = rule.slotFactory(context);
        delta.attributes.forEach((value, key) => {
            newSlot.setAttribute(key, value);
        });
    }
    return newSlots;
}
function slotsToComponents(injector, slots, rule) {
    var _a;
    const componentInstances = [];
    if (!slots.length) {
        return componentInstances;
    }
    if (rule.multipleSlot) {
        componentInstances.push(rule.target.createInstance(injector, {
            state: (_a = rule.stateFactory) === null || _a === void 0 ? void 0 : _a.call(rule),
            slots
        }));
    }
    else {
        slots.forEach(childSlot => {
            var _a;
            componentInstances.push(rule.target.createInstance(injector, {
                state: (_a = rule.stateFactory) === null || _a === void 0 ? void 0 : _a.call(rule),
                slots: [childSlot]
            }));
        });
    }
    return componentInstances;
}
function getBlockRangeToBegin(selection, slot, offset) {
    let startIndex = offset;
    const content = slot.sliceContent(0, offset);
    while (content.length) {
        const item = content.pop();
        if (typeof item !== 'string' && item.type === exports.ContentType.BlockComponent) {
            break;
        }
        startIndex -= item.length;
    }
    return {
        slot,
        startIndex,
        endIndex: offset
    };
}
exports.Commander = class Commander {
    constructor(selection, injector, registry, rootComponentRef) {
        this.selection = selection;
        this.injector = injector;
        this.registry = registry;
        this.rootComponentRef = rootComponentRef;
    }
    /**
     * 将选区内容转换为指定组件
     * @param rule
     */
    transform(rule) {
        const selection = this.selection;
        if (!selection.isSelected) {
            return false;
        }
        const abstractSelection = {
            anchorSlot: selection.anchorSlot,
            anchorOffset: selection.anchorOffset,
            focusSlot: selection.focusSlot,
            focusOffset: selection.focusOffset
        };
        const ranges = selection.getRanges();
        for (let i = 0; i < ranges.length; i++) {
            const range = ranges[i];
            const isTransformed = this.transformByRange(rule, abstractSelection, range);
            if (!isTransformed) {
                break;
            }
        }
        selection.setBaseAndExtent(abstractSelection.anchorSlot, abstractSelection.anchorOffset, abstractSelection.focusSlot, abstractSelection.focusOffset);
        return true;
    }
    write(content, formatter, value) {
        const selection = this.selection;
        const canInsert = selection.isCollapsed ? true : this.delete();
        if (!canInsert) {
            return false;
        }
        const position = getInsertPosition(selection.startSlot, selection.startOffset, content);
        if (!position) {
            return false;
        }
        let formats = position.slot.extractFormatsByIndex(position.offset);
        if (formatter) {
            if (Array.isArray(formatter)) {
                formats = [
                    ...formats,
                    ...formatter
                ];
            }
            else {
                formats.push([formatter, value]);
            }
        }
        return this.insert(content, formats);
    }
    insert(content, formatter, value) {
        const selection = this.selection;
        const canInsert = selection.isCollapsed ? true : this.delete();
        if (!canInsert) {
            return false;
        }
        let formats = [];
        if (formatter) {
            if (Array.isArray(formatter)) {
                formats = formatter;
            }
            else {
                formats.push([formatter, value]);
            }
        }
        const position = getInsertPosition(selection.startSlot, selection.startOffset, content);
        if (!position) {
            return false;
        }
        const { slot, offset } = position;
        const event = new Event(slot, {
            index: offset,
            content,
            formats
        });
        invokeListener(slot.parent, 'onContentInsert', event);
        if (!event.isPrevented) {
            slot.retain(offset);
            slot.insert(content, formats);
            const insertedEvent = new Event(slot, {
                index: offset,
                content,
                formats
            });
            invokeListener(slot.parent, 'onContentInserted', insertedEvent);
            if (!insertedEvent.isPrevented) {
                selection.setBaseAndExtent(slot, slot.index, slot, slot.index);
            }
        }
        return !event.isPrevented;
    }
    delete(receiver, deleteBefore = true) {
        if (typeof receiver === 'boolean') {
            deleteBefore = receiver;
            receiver = function () {
                //
            };
        }
        else if (typeof receiver !== 'function') {
            receiver = function () {
                //
            };
        }
        const selection = this.selection;
        if (!selection.isSelected) {
            return false;
        }
        let endSlot = selection.endSlot;
        let endOffset = selection.endOffset;
        let startSlot = selection.startSlot;
        let startOffset = selection.startOffset;
        let isDeleteRanges = true;
        if (selection.isCollapsed) {
            if (deleteBefore) {
                if (startOffset === 0) {
                    isDeleteRanges = false;
                }
                const prevPosition = selection.getPreviousPosition();
                startSlot = prevPosition.slot;
                startOffset = prevPosition.offset;
            }
            else {
                const nextPosition = selection.getNextPosition();
                endSlot = nextPosition.slot;
                endOffset = nextPosition.offset;
            }
        }
        if (startSlot === endSlot && startOffset === endOffset) {
            if (startSlot.isEmpty) {
                receiver(startSlot.cut());
                const position = deleteUpBySlot(selection, startSlot, startOffset, this.rootComponentRef.component, deleteBefore);
                selection.setBaseAndExtent(position.slot, position.offset, position.slot, position.offset);
                return position.slot !== startSlot || position.offset !== startOffset;
            }
            return false;
        }
        const scopes = selection.getScopes(startSlot, startOffset, endSlot, endOffset, true);
        let endCutIndex = endOffset;
        while (isDeleteRanges && scopes.length) {
            const lastScope = scopes.pop();
            const { slot, startIndex } = lastScope;
            const endIndex = lastScope.endIndex;
            const isFocusEnd = selection.focusSlot === slot && selection.focusOffset === endIndex;
            const event = new Event(slot, {
                index: startIndex,
                count: endIndex - startIndex,
                toEnd: !deleteBefore,
                actionType: 'delete'
            });
            invokeListener(slot.parent, 'onContentDelete', event);
            if (event.isPrevented) {
                return false;
            }
            const deletedSlot = slot.cut(startIndex, endIndex);
            receiver(deletedSlot);
            const deletedEvent = new Event(slot, null);
            invokeListener(slot.parent, 'onContentDeleted', deletedEvent);
            if (deletedEvent.isPrevented) {
                if (isFocusEnd) {
                    selection.setFocus(slot, endIndex);
                }
                else {
                    selection.setAnchor(slot, endIndex);
                }
                return false;
            }
            if (slot === endSlot) {
                endCutIndex = startIndex;
            }
            if (slot !== startSlot && slot !== endSlot && slot.isEmpty) {
                const position = deleteUpBySlot(selection, slot, startIndex, this.rootComponentRef.component, deleteBefore);
                if (position.slot === endSlot) {
                    endCutIndex = position.offset;
                }
            }
        }
        if (startSlot !== endSlot) {
            const event = new Event(endSlot, {
                index: endCutIndex,
                count: endSlot.length,
                toEnd: !deleteBefore,
                actionType: 'move'
            });
            invokeListener(endSlot.parent, 'onContentDelete', event);
            if (event.isPrevented) {
                return false;
            }
            const deletedSlot = endSlot.cut(endCutIndex);
            receiver(deletedSlot);
            const deletedEvent = new Event(endSlot, null);
            invokeListener(endSlot.parent, 'onContentDeleted', deletedEvent);
            if (!deletedEvent.isPrevented) {
                if (endSlot.isEmpty) {
                    deleteUpBySlot(selection, endSlot, 0, this.rootComponentRef.component, deleteBefore);
                }
            }
            if (!deletedSlot.isEmpty) {
                // const formats = deletedSlot.extractFormatsByIndex(0)
                // formats.forEach(item => {
                //   if (item[0].type === FormatType.Block) {
                //     deletedSlot.removeAttribute(item[0])
                //   }
                // })
                const deletedDelta = deletedSlot.toDelta();
                selection.setPosition(startSlot, startOffset);
                deletedDelta.forEach(item => {
                    this.insert(item.insert, item.formats);
                });
            }
            if (deletedEvent.isPrevented) {
                return false;
            }
        }
        selection.setBaseAndExtent(startSlot, startOffset, startSlot, startOffset);
        return true;
    }
    /**
     * 在当前选区内触发换行操作，如果选区未闭合，则先删除选区内容，再触发回车操作
     */
    break() {
        const selection = this.selection;
        if (!selection.isSelected) {
            return false;
        }
        if (!selection.isCollapsed) {
            const isCollapsed = this.delete(false);
            if (!isCollapsed) {
                return false;
            }
        }
        const startSlot = this.selection.startSlot;
        const event = new Event(startSlot, {
            index: this.selection.startOffset
        });
        invokeListener(startSlot.parent, 'onBreak', event);
        if (!event.isPrevented) {
            const startOffset = this.selection.startOffset;
            const isToEnd = startOffset === startSlot.length || startSlot.isEmpty;
            const content = isToEnd ? '\n\n' : '\n';
            const isInserted = this.write(content);
            if (isInserted && isToEnd) {
                this.selection.setPosition(startSlot, startOffset + 1);
            }
        }
        return !event.isPrevented;
    }
    /**
     * 在指定组件前插入新的组件
     * @param newChild 要插入的组件
     * @param ref 新组件插入组件位置的引用
     */
    insertBefore(newChild, ref) {
        const parentSlot = ref === null || ref === void 0 ? void 0 : ref.parent;
        if (parentSlot) {
            const index = parentSlot.indexOf(ref);
            this.selection.setBaseAndExtent(parentSlot, index, parentSlot, index);
            return this.insert(newChild);
        }
        return false;
    }
    /**
     * 在指定组件后插入新的组件
     * @param newChild 要插入的组件
     * @param ref 新组件插入组件位置的引用
     */
    insertAfter(newChild, ref) {
        const parentSlot = ref === null || ref === void 0 ? void 0 : ref.parent;
        if (parentSlot) {
            const index = parentSlot.indexOf(ref) + 1;
            this.selection.setBaseAndExtent(parentSlot, index, parentSlot, index);
            return this.insert(newChild);
        }
        return false;
    }
    /**
     * 用新组件替换旧组件
     * @param oldComponent 要删除的组件
     * @param newComponent 新插入的组件
     */
    replaceComponent(oldComponent, newComponent) {
        const b = this.removeComponent(oldComponent);
        if (b) {
            return this.insert(newComponent);
        }
        return false;
    }
    /**
     * 复制当前选区内容
     */
    copy() {
        this.injector.get(NativeRenderer).copy();
    }
    /**
     * 剪切当前选区内容
     */
    cut() {
        this.copy();
        if (this.selection.isCollapsed) {
            return false;
        }
        return this.delete();
    }
    /**
     * 在当前选区粘贴新内容，当选区未闭合时，会先删除选区内容，再粘贴新内容
     * @param pasteSlot 要粘贴的数据
     * @param text 要粘贴的文本
     */
    paste(pasteSlot, text) {
        if (pasteSlot.isEmpty) {
            return false;
        }
        const selection = this.selection;
        if (!selection.isSelected) {
            return false;
        }
        if (!selection.isCollapsed) {
            this.delete();
        }
        const component = selection.commonAncestorComponent;
        const slot = selection.commonAncestorSlot;
        const event = new Event(slot, {
            index: selection.startOffset,
            data: pasteSlot,
            text
        });
        invokeListener(component, 'onPaste', event);
        if (!event.isPrevented) {
            const delta = pasteSlot.toDelta();
            const afterDelta = new DeltaLite();
            while (delta.length) {
                const { insert, formats } = delta.shift();
                const commonAncestorSlot = selection.commonAncestorSlot;
                if (canInsert(insert, commonAncestorSlot)) {
                    this.insert(insert, formats);
                    continue;
                }
                afterDelta.push(...commonAncestorSlot.cut(selection.startOffset).toDelta());
                const parentComponent = commonAncestorSlot.parent;
                if (commonAncestorSlot === parentComponent.slots.last) {
                    this.insert(insert, formats);
                    continue;
                }
                if (parentComponent.separable) {
                    const index = parentComponent.slots.indexOf(commonAncestorSlot);
                    const nextSlots = parentComponent.slots.cut(index + 1);
                    const nextComponent = this.registry.createComponentByData(parentComponent.name, {
                        state: typeof parentComponent.state === 'object' && parentComponent.state !== null ?
                            JSON.parse(JSON.stringify(parentComponent.state)) :
                            parentComponent.state,
                        slots: nextSlots
                    });
                    afterDelta.push({
                        insert: nextComponent,
                        formats: []
                    });
                    this.insert(insert, formats);
                    continue;
                }
                if (typeof insert === 'string') {
                    this.insert(insert, formats);
                    continue;
                }
                for (const childSlot of insert.slots.toArray()) {
                    delta.unshift(...childSlot.toDelta());
                }
            }
            const snapshot = this.selection.createSnapshot();
            while (afterDelta.length) {
                const { insert, formats } = afterDelta.shift();
                this.insert(insert, formats);
            }
            snapshot.restore();
            const currentContent = selection.startSlot.getContentAtIndex(selection.startOffset);
            if (currentContent &&
                typeof currentContent !== 'string' &&
                currentContent.type === exports.ContentType.BlockComponent &&
                currentContent.slots.length > 0) {
                selection.toNext();
            }
        }
        return !event.isPrevented;
    }
    /**
     * 清除当前选区的所有格式
     * @param excludeFormatters 在清除格式时，排除的格式
     */
    cleanFormats(excludeFormatters = []) {
        this.selection.getSelectedScopes().forEach(scope => {
            const slot = scope.slot;
            if (scope.startIndex === 0) {
                if (scope.endIndex === slot.length - 1) {
                    const lastContent = slot.getContentAtIndex(slot.length - 1);
                    if (lastContent === '\n') {
                        scope.endIndex++;
                    }
                }
            }
            slot.cleanFormats(excludeFormatters, scope.startIndex, scope.endIndex);
        });
    }
    /**
     * 给当前选区应用新的格式
     * @param formatter 要应用的格式
     * @param value 当前格式要应用的值
     */
    applyFormat(formatter, value) {
        if (this.selection.isCollapsed) {
            const slot = this.selection.commonAncestorSlot;
            if (slot.isEmpty) {
                slot.retain(0);
                slot.retain(slot.length, formatter, value);
            }
            else {
                this.write(Slot.placeholder);
                const startOffset = this.selection.startOffset;
                slot.retain(startOffset - 1);
                slot.retain(1, formatter, value);
            }
            return;
        }
        this.selection.getSelectedScopes().forEach(i => {
            i.slot.retain(i.startIndex);
            i.slot.retain(i.endIndex - i.startIndex, formatter, value);
        });
    }
    /**
     * 清除当前选区特定的格式
     * @param formatter 要清除的格式
     */
    unApplyFormat(formatter) {
        if (this.selection.isCollapsed) {
            const slot = this.selection.commonAncestorSlot;
            if (slot.isEmpty) {
                slot.retain(0);
                slot.retain(slot.length, formatter, null);
            }
            else {
                const startOffset = this.selection.startOffset;
                const prevContent = slot.getContentAtIndex(startOffset - 1);
                if (prevContent === Slot.placeholder) {
                    slot.retain(startOffset - 1);
                    slot.retain(1, formatter, null);
                }
                else {
                    this.write(Slot.placeholder);
                    slot.retain(startOffset);
                    slot.retain(1, formatter, null);
                }
            }
            return;
        }
        this.selection.getSelectedScopes().forEach(i => {
            i.slot.retain(i.startIndex);
            i.slot.retain(i.endIndex - i.startIndex, formatter, null);
        });
    }
    /**
     * 根据选区应用插槽属性
     * @param attribute
     * @param value
     */
    applyAttribute(attribute, value) {
        if (this.selection.isCollapsed) {
            const slot = this.selection.commonAncestorSlot;
            slot.setAttribute(attribute, value);
            return;
        }
        this.selection.getSelectedScopes().forEach(i => {
            const contents = i.slot.sliceContent(i.startIndex, i.endIndex);
            const childComponents = [];
            let hasInlineContent = false;
            contents.forEach(item => {
                if (typeof item === 'string' || item.type === exports.ContentType.InlineComponent) {
                    hasInlineContent = true;
                }
                else {
                    childComponents.push(item);
                }
            });
            if (hasInlineContent) {
                i.slot.setAttribute(attribute, value);
            }
            else {
                childComponents.forEach(i => {
                    i.slots.toArray().forEach(slot => {
                        slot.setAttribute(attribute, value);
                    });
                });
            }
        });
    }
    /**
     * 根据选区清除插槽属性
     * @param attribute
     */
    unApplyAttribute(attribute) {
        if (this.selection.isCollapsed) {
            const slot = this.selection.commonAncestorSlot;
            slot.removeAttribute(attribute);
            return;
        }
        this.selection.getSelectedScopes().forEach(i => {
            const contents = i.slot.sliceContent(i.startIndex, i.endIndex);
            const childComponents = [];
            let hasString = false;
            contents.forEach(item => {
                if (typeof item !== 'string') {
                    childComponents.push(item);
                }
                else {
                    hasString = true;
                }
            });
            if (hasString) {
                i.slot.removeAttribute(attribute);
            }
            else {
                childComponents.forEach(i => {
                    i.slots.toArray().forEach(slot => {
                        slot.removeAttribute(attribute);
                    });
                });
            }
        });
    }
    /**
     * 根据选区清除属性
     */
    cleanAttributes(excludeAttributes = []) {
        this.selection.getSelectedScopes().forEach(i => {
            const contents = i.slot.sliceContent(i.startIndex, i.endIndex);
            const childComponents = [];
            let hasString = false;
            contents.forEach(item => {
                if (typeof item !== 'string') {
                    childComponents.push(item);
                }
                else {
                    hasString = true;
                }
            });
            if (hasString) {
                i.slot.cleanAttributes(excludeAttributes);
            }
            else {
                childComponents.forEach(i => {
                    i.slots.toArray().forEach(slot => {
                        slot.cleanAttributes(excludeAttributes);
                    });
                });
            }
        });
    }
    /**
     * 删除指定组件
     * @param component
     */
    removeComponent(component) {
        const parentSlot = component === null || component === void 0 ? void 0 : component.parent;
        if (parentSlot) {
            const index = parentSlot.indexOf(component);
            this.selection.setBaseAndExtent(parentSlot, index, parentSlot, index + 1);
            return this.delete();
        }
        return false;
    }
    transformByRange(rule, abstractSelection, range) {
        const { startSlot, startOffset, endSlot, endOffset } = range;
        const selection = this.selection;
        const commonAncestorSlot = exports.Selection.getCommonAncestorSlot(startSlot, endSlot);
        const commonAncestorComponent = exports.Selection.getCommonAncestorComponent(startSlot, endSlot);
        if (!commonAncestorSlot || !commonAncestorComponent) {
            return false;
        }
        let stoppedComponent;
        if (commonAncestorSlot.parent !== commonAncestorComponent ||
            (abstractSelection.anchorSlot === commonAncestorSlot && abstractSelection.focusSlot === commonAncestorSlot)) {
            stoppedComponent = commonAncestorComponent.parentComponent;
        }
        else {
            stoppedComponent = commonAncestorComponent;
        }
        const stoppedScope = {
            slot: startSlot,
            offset: exports.Selection.getInlineContentStartIndex(startSlot, startOffset)
        };
        let startScope = {
            slot: endSlot,
            offset: exports.Selection.getInlineContentEndIndex(endSlot, endOffset)
        };
        const parentComponent = startScope.slot.parent;
        if (parentComponent.separable) {
            if (startScope.slot !== parentComponent.slots.last) {
                const slotIndex = parentComponent.slots.indexOf(startScope.slot);
                const count = parentComponent.slots.length - slotIndex;
                const event = new Event(parentComponent, {
                    index: slotIndex + 1,
                    count: count - 1,
                    toEnd: false
                });
                invokeListener(parentComponent, 'onSlotRemove', event);
                if (!event.isPrevented) {
                    const deletedSlots = parentComponent.slots.cut(slotIndex + 1, slotIndex + count);
                    const newState = typeof parentComponent.state === 'object' ?
                        JSON.parse(JSON.stringify(parentComponent.state)) :
                        parentComponent.state;
                    let afterComponent = null;
                    if (typeof rule.existingComponentTransformer === 'function') {
                        afterComponent = rule.existingComponentTransformer(parentComponent.name, deletedSlots, newState) || null;
                    }
                    if (!afterComponent) {
                        afterComponent = this.registry.createComponentByData(parentComponent.name, {
                            state: newState,
                            slots: deletedSlots
                        });
                    }
                    this.insertAfter(afterComponent, parentComponent);
                }
            }
        }
        let slots = [];
        let position = null;
        while (true) {
            const endPaths = selection.getPathsBySlot(startScope.slot);
            if (!endPaths) {
                break;
            }
            endPaths.push(startScope.offset);
            const startPaths = selection.getPathsBySlot(stoppedScope.slot);
            if (!startPaths) {
                break;
            }
            startPaths.push(stoppedScope.offset);
            if (!exports.Selection.compareSelectionPaths(startPaths, endPaths)) {
                break;
            }
            const scope = startScope.slot.isEmpty ? {
                slot: startScope.slot,
                startIndex: 0,
                endIndex: 0
            } : getBlockRangeToBegin(selection, startScope.slot, startScope.offset);
            const { slot, startIndex, endIndex } = scope;
            const parentComponent = slot.parent;
            if (!parentComponent.separable && parentComponent.slots.length > 1 && !slot.schema.includes(rule.target.instanceType)) {
                // 无法转换的情况
                const componentInstances = slotsToComponents(this.injector, slots, rule);
                componentInstances.forEach(instance => {
                    this.insert(instance);
                });
                slots = [];
                startScope = selection.getPreviousPositionByPosition(slot, 0);
                position = null;
                continue;
            }
            selection.setBaseAndExtent(slot, startIndex, slot, endIndex);
            if (slot.isEmpty) {
                startScope = selection.getPreviousPositionByPosition(slot, 0);
                if (startScope.slot === slot && startScope.offset === startIndex) {
                    if (position) {
                        selection.setPosition(position.slot, position.offset);
                    }
                    break;
                }
                if (parentComponent.separable || parentComponent.slots.length === 1) {
                    const delta = slot.toDelta();
                    slots.unshift(...deltaToSlots(selection, slot, delta, rule, abstractSelection, 0));
                    position = deleteUpBySlot(selection, slot, 0, stoppedComponent, false);
                }
                else {
                    const componentInstances = slotsToComponents(this.injector, slots, rule);
                    slots = [];
                    selection.selectComponentEnd(parentComponent);
                    componentInstances.forEach(instance => {
                        this.insert(instance);
                    });
                    position = null;
                }
            }
            else {
                startScope = selection.getPreviousPositionByPosition(slot, startIndex);
                if (startScope.slot === slot && startScope.offset === startIndex) {
                    if (position) {
                        selection.setPosition(position.slot, position.offset);
                    }
                    break;
                }
                if (startIndex === endIndex) {
                    const componentInstances = slotsToComponents(this.injector, slots, rule);
                    slots = [];
                    componentInstances.forEach(instance => {
                        this.insert(instance);
                    });
                    continue;
                }
                this.delete(deletedSlot => {
                    if (parentComponent.separable || parentComponent.slots.length === 1) {
                        const delta = deletedSlot.toDelta();
                        slots.unshift(...deltaToSlots(selection, slot, delta, rule, abstractSelection, startIndex));
                        if (startIndex > 0) {
                            startScope = selection.getPreviousPositionByPosition(slot, startIndex);
                            position = {
                                slot,
                                offset: startIndex
                            };
                            return;
                        }
                        position = deleteUpBySlot(selection, slot, 0, stoppedComponent, false);
                        return;
                    }
                    position = null;
                    let componentInstances = slotsToComponents(this.injector, slots, rule);
                    slots = [];
                    selection.selectComponentEnd(parentComponent);
                    componentInstances.forEach(instance => {
                        this.insert(instance);
                    });
                    const delta = deletedSlot.toDelta();
                    const dumpSlots = deltaToSlots(selection, slot, delta, rule, abstractSelection, startIndex);
                    componentInstances = slotsToComponents(this.injector, dumpSlots, rule);
                    componentInstances.forEach((instance, index) => {
                        selection.setPosition(slot, index + startIndex);
                        this.insert(instance);
                    });
                    if (startIndex > 0) {
                        startScope = selection.getPreviousPositionByPosition(slot, startIndex);
                        position = {
                            slot,
                            offset: startIndex
                        };
                    }
                });
            }
            if (position) {
                selection.setPosition(position.slot, position.offset);
            }
            if (scope.slot === stoppedScope.slot && scope.endIndex === stoppedScope.offset) {
                break;
            }
        }
        const componentInstances = slotsToComponents(this.injector, slots, rule);
        componentInstances.forEach(instance => {
            this.insert(instance);
        });
        return true;
    }
};
exports.Commander = __decorate([
    di.Injectable(),
    __metadata("design:paramtypes", [exports.Selection,
        di.Injector,
        exports.Registry,
        RootComponentRef])
], exports.Commander);

var PureRenderer_1;
const pureRendererErrorFn = makeError('PureRenderer');
/**
 * 无副作用的渲染器，用于把组件或插槽渲染为虚拟 DOM
 */
exports.PureRenderer = PureRenderer_1 = class PureRenderer {
    /**
     * 组件渲染方法
     * @param component 要渲染的组件
     * @param renderMode 渲染模式
     * @example
     * ```ts
     * const vDom = pureRenderer.componentRender(componentInstance, RenderMode.Output)
     * ```
     */
    componentRender(component, renderMode) {
        return component.extends.render((slot, factory) => {
            return this.slotRender(slot, renderMode, factory);
        }, renderMode);
    }
    /**
     * 插槽渲染方法
     * @param slot 要渲染的插槽
     * @param renderMode 渲染模式
     * @param slotRenderFactory 渲染插槽的工厂函数
     * @example
     * ```tsx
     * const slot = new Slot([
     *   ContentType.Text
     * ])
     *
     * slot.insert('hello world!')
     *
     * const vDom = pureRenderer.slotRender(slot, RenderMode.Output, children => {
     *   return (
     *     <div>{children}</div>
     *   )
     * })
     * ```
     */
    slotRender(slot, renderMode, slotRenderFactory) {
        const formatTree = slot.createFormatTree();
        const componentRender = (component, renderMode) => {
            return this.componentRender(component, renderMode);
        };
        let children = formatTree.children ?
            PureRenderer_1.createVDomByFormatTree(slot, formatTree.children, renderMode, componentRender) :
            PureRenderer_1.createVDomByContent(slot, formatTree.startIndex, formatTree.endIndex, renderMode, componentRender);
        if (formatTree.formats) {
            children = [PureRenderer_1.createVDomByOverlapFormats(formatTree.formats, children, slot, renderMode)];
        }
        const root = slotRenderFactory(children);
        for (const [attribute, value] of slot.getAttributes()) {
            attribute.render(root, value, renderMode);
        }
        return root;
    }
    static createVDomByFormatTree(slot, formats, renderMode, componentRender, setVNodeLocation) {
        var _a;
        const nodes = [];
        for (const child of formats) {
            if ((_a = child.formats) === null || _a === void 0 ? void 0 : _a.length) {
                const children = child.children ?
                    PureRenderer_1.createVDomByFormatTree(slot, child.children, renderMode, componentRender, setVNodeLocation) :
                    PureRenderer_1.createVDomByContent(slot, child.startIndex, child.endIndex, renderMode, componentRender, setVNodeLocation);
                const nextChildren = PureRenderer_1.createVDomByOverlapFormats(child.formats, children, slot, renderMode, setVNodeLocation);
                nodes.push(nextChildren);
            }
            else {
                nodes.push(...PureRenderer_1.createVDomByContent(slot, child.startIndex, child.endIndex, renderMode, componentRender, setVNodeLocation));
            }
        }
        return nodes;
    }
    static createVDomByOverlapFormats(formats, children, slot, renderMode, setVNodeLocation) {
        const hostBindings = [];
        let host = null;
        for (let i = formats.length - 1; i > -1; i--) {
            const item = formats[i];
            const next = item.formatter.render(children, item.value, renderMode);
            if (!next) {
                throw pureRendererErrorFn(`Formatter \`${item.formatter.name}\` must return an VElement!`);
            }
            if (!(next instanceof VElement)) {
                hostBindings.push({
                    item,
                    render: next
                });
                continue;
            }
            host = next;
            setVNodeLocation === null || setVNodeLocation === void 0 ? void 0 : setVNodeLocation(next, {
                slot,
                startIndex: item.startIndex,
                endIndex: item.endIndex
            });
            children = [next];
        }
        for (const binding of hostBindings) {
            const { render, item } = binding;
            if (!host) {
                host = jsx(render.fallbackTagName);
                host.appendChild(...children);
                setVNodeLocation === null || setVNodeLocation === void 0 ? void 0 : setVNodeLocation(host, {
                    slot,
                    startIndex: item.startIndex,
                    endIndex: item.endIndex
                });
            }
            render.attach(host);
        }
        return host;
    }
    static createVDomByContent(slot, startIndex, endIndex, renderMode, componentRender, setVNodeLocation) {
        const elements = slot.sliceContent(startIndex, endIndex).map(i => {
            if (typeof i === 'string') {
                return i.match(/\n|[^\n]+/g);
            }
            return i;
        }).flat();
        return elements.map(item => {
            let vNode;
            let length;
            if (typeof item === 'string') {
                if (item === '\n') {
                    vNode = new VElement('br');
                    length = 1;
                }
                else {
                    vNode = new VTextNode(item);
                    length = item.length;
                }
            }
            else {
                length = 1;
                vNode = componentRender(item, renderMode);
            }
            setVNodeLocation === null || setVNodeLocation === void 0 ? void 0 : setVNodeLocation(vNode, {
                slot,
                startIndex,
                endIndex: startIndex + length
            });
            startIndex += length;
            return vNode;
        });
    }
};
exports.PureRenderer = PureRenderer_1 = __decorate([
    di.Injectable()
], exports.PureRenderer);

const rendererErrorFn = makeError('Renderer');
function setEditable(vElement, isSlot) {
    vElement.attrs.set(isSlot ? 'textbus-slot-root' : 'textbus-component-root', '');
}
function getObjectChanges(target, source) {
    const changes = {
        remove: [],
        add: []
    };
    Object.keys(target).forEach(key => {
        const leftValue = target[key];
        if (!Reflect.has(source, key)) {
            changes.add.push([key, leftValue]);
            return;
        }
        const rightValue = source[key];
        if (leftValue === rightValue) {
            return;
        }
        changes.add.push([key, leftValue]);
        changes.remove.push([key, rightValue]);
    });
    Object.keys(source).forEach(key => {
        if (!Reflect.has(target, key)) {
            changes.remove.push([key, source[key]]);
        }
    });
    return changes;
}
function getMapChanges(target, source) {
    const changes = {
        remove: [],
        set: []
    };
    target.forEach((value, key) => {
        const rightValue = source.get(key);
        if (value === rightValue) {
            return;
        }
        changes.set.push([key, value]);
    });
    source.forEach((value, key) => {
        if (!target.has(key)) {
            changes.remove.push(key);
        }
    });
    return changes;
}
function getSetChanges(left, right) {
    const changes = {
        add: [],
        remove: []
    };
    left.forEach(i => {
        if (!right.has(i)) {
            changes.add.push(i);
        }
    });
    right.forEach(i => {
        if (!left.has(i)) {
            changes.remove.push(i);
        }
    });
    return changes;
}
function getNodeChanges(newVDom, oldVDom) {
    const styleChanges = getMapChanges(newVDom.styles, oldVDom.styles);
    const attrChanges = getMapChanges(newVDom.attrs, oldVDom.attrs);
    const classesChanges = getSetChanges(newVDom.classes, oldVDom.classes);
    const listenerChanges = getObjectChanges(newVDom.listeners, oldVDom.listeners);
    return {
        styleChanges,
        attrChanges,
        classesChanges,
        listenerChanges,
        isChanged: [
            attrChanges.set.length,
            attrChanges.remove.length,
            styleChanges.set.length,
            styleChanges.remove.length,
            classesChanges.add.length,
            classesChanges.remove.length,
            listenerChanges.add.length,
            listenerChanges.remove.length
        ].join('') !== '0'.repeat(8)
    };
}
function createBidirectionalMapping(isA) {
    const a2b = new WeakMap();
    const b2a = new WeakMap();
    function set(key, value) {
        if (get(key)) {
            remove(key);
        }
        if (get(value)) {
            remove(value);
        }
        if (isA(key)) {
            a2b.set(key, value);
            b2a.set(value, key);
        }
        else {
            a2b.set(value, key);
            b2a.set(key, value);
        }
    }
    function get(key) {
        if (isA(key)) {
            return a2b.get(key);
        }
        return b2a.get(key);
    }
    function remove(key) {
        if (isA(key)) {
            const v = a2b.get(key);
            a2b.delete(key);
            b2a.delete(v);
        }
        else {
            const v = b2a.get(key);
            b2a.delete(key);
            a2b.delete(v);
        }
    }
    return {
        set,
        get,
        remove
    };
}
/**
 * Textbus 编辑渲染器，负责组件的渲染，生成 DOM，并根据数据变化，更新 DOM
 */
exports.Renderer = class Renderer {
    constructor(controller, rootComponentRef) {
        this.controller = controller;
        this.rootComponentRef = rootComponentRef;
        this.slotRootVNodeCaches = new WeakMap();
        this.vNodeLocation = new WeakMap();
        this.renderedVNode = new WeakMap();
        this.slotVNodesCaches = new WeakMap();
        this.slotRenderFactory = new WeakMap();
        this.componentVNode = createBidirectionalMapping(v => {
            return v instanceof VElement;
        });
        this.nativeNodeCaches = createBidirectionalMapping(v => {
            return v instanceof VElement || v instanceof VTextNode;
        });
        this.viewUpdatedEvent = new stream.Subject();
        this.viewUpdateBeforeEvent = new stream.Subject();
        this.oldVDom = null;
        this.slotIdAttrKey = '__textbus-slot-id__';
        this.readonlyStateChanged = false;
        this.subscription = new stream.Subscription();
        this.renderedComponents = [];
        this.firstRending = true;
        this.onViewUpdated = this.viewUpdatedEvent.asObservable();
        this.onViewUpdateBefore = this.viewUpdateBeforeEvent.asObservable();
        this.subscription = controller.onReadonlyStateChange.subscribe(() => {
            if (rootComponentRef.component) {
                this.readonlyStateChanged = true;
                this.render();
                this.readonlyStateChanged = false;
            }
        });
    }
    /**
     * 以编辑模式渲染当前文档
     */
    render() {
        const component = this.rootComponentRef.component;
        this.viewUpdateBeforeEvent.next();
        if (component.changeMarker.changed || this.readonlyStateChanged) {
            const dirty = component.changeMarker.dirty;
            const root = this.componentRender(component);
            // hack 防止根节点替换插件时，没有父级虚拟 DOM 节点
            new VElement('html', null, [root]);
            // hack end
            if (dirty || this.readonlyStateChanged) {
                if (this.oldVDom) {
                    const oldNativeNode = this.nativeNodeCaches.get(this.oldVDom);
                    const newNativeNode = this.diffAndUpdate(root, this.oldVDom, component);
                    if (oldNativeNode !== newNativeNode) {
                        this.nativeRenderer.replace(newNativeNode, oldNativeNode);
                    }
                }
                else {
                    const el = this.patch(root);
                    this.nativeRenderer.appendChild(this.rootComponentRef.host, el);
                }
            }
            this.oldVDom = root;
        }
        this.firstRending = false;
        Promise.resolve().then(() => {
            for (const item of this.renderedComponents) {
                invokeListener(item, 'onViewChecked');
            }
            this.renderedComponents = [];
            this.viewUpdatedEvent.next();
        });
    }
    /**
     * 获取组件对应的虚拟 DOM 节点
     * @param component
     */
    getVNodeByComponent(component) {
        return this.componentVNode.get(component);
    }
    /**
     * 根据虚拟 DOM 节点，获取当前所属的组件
     * @param vNode
     */
    getComponentByVNode(vNode) {
        let n = vNode;
        while (n) {
            const instance = this.componentVNode.get(vNode);
            if (instance) {
                return instance;
            }
            n = n.parentNode;
        }
        return null;
    }
    /**
     * 根据原生节点，获取当前所属的组件
     * @param nativeNode
     */
    getComponentByNativeNode(nativeNode) {
        let vNode = this.getVNodeByNativeNode(nativeNode);
        if (vNode instanceof VTextNode) {
            vNode = vNode.parentNode;
        }
        if (vNode instanceof VElement) {
            return this.getComponentByVNode(vNode);
        }
        return null;
    }
    /**
     * 获取插槽 对应的虚拟 DOM 节点
     * @param slot
     */
    getVNodeBySlot(slot) {
        return this.slotRootVNodeCaches.get(slot);
    }
    /**
     * 通过虚拟 DOM 节点获取对应的原生节点
     * @param vNode
     */
    getNativeNodeByVNode(vNode) {
        return this.nativeNodeCaches.get(vNode);
    }
    /**
     * 获取原生节点对应的虚拟 DOM 节点
     * @param nativeNode
     */
    getVNodeByNativeNode(nativeNode) {
        return this.nativeNodeCaches.get(nativeNode);
    }
    /**
     * 获取虚拟 DOM 节点的原始数据在文档中的位置
     * @param node
     */
    getLocationByVNode(node) {
        if (node instanceof Slot) {
            node = this.slotRootVNodeCaches.get(node);
        }
        return this.vNodeLocation.get(node);
    }
    /**
     * 获取原生节点的原始数据在文档中的位置
     * @param node
     */
    getLocationByNativeNode(node) {
        const vNode = this.nativeNodeCaches.get(node);
        return this.vNodeLocation.get(vNode) || null;
    }
    /**
     * 获取插槽内容节点集合
     * @param slot
     */
    getVNodesBySlot(slot) {
        return this.slotVNodesCaches.get(slot) || [];
    }
    /**
     * 销毁渲染器
     */
    destroy() {
        this.subscription.unsubscribe();
    }
    sortAndCleanNativeNode(parent, children, component) {
        let index = 0;
        while (true) {
            const node = children[index];
            if (!node) {
                break;
            }
            const current = this.nativeRenderer.getChildByIndex(parent, index);
            index++;
            if (!current) {
                this.nativeRenderer.appendChild(parent, node);
                continue;
            }
            if (current !== node) {
                this.nativeRenderer.insertBefore(node, current);
            }
        }
        while (true) {
            const current = this.nativeRenderer.getChildByIndex(parent, index);
            if (!current) {
                break;
            }
            const event = new Event(component, current);
            invokeListener(component, 'onDirtyViewClean', event);
            if (event.isPrevented) {
                index++;
                continue;
            }
            this.nativeRenderer.remove(current);
        }
        return parent;
    }
    diffAndUpdate(newVDom, oldVDom, component) {
        const newNativeNode = this.diffNodeAndUpdate(newVDom, oldVDom);
        const children = this.diffChildrenAndUpdate(newVDom, oldVDom, component);
        return this.sortAndCleanNativeNode(newNativeNode, children, component);
    }
    diffChildrenAndUpdate(newVDom, oldVDom, component) {
        const newChildren = newVDom.children;
        const oldChildren = oldVDom.children;
        const beginIdenticalNodes = this.diffIdenticalChildrenToEnd(newChildren, oldChildren, component);
        const endIdenticalNodes = this.diffIdenticalChildrenToBegin(newChildren, oldChildren, component);
        const beginNodes = this.diffChildrenToEnd(newChildren, oldChildren, component);
        const endNodes = this.diffChildrenToBegin(newChildren, oldChildren, component);
        oldChildren.forEach(i => {
            const native = this.nativeNodeCaches.get(i);
            if (native) {
                this.nativeRenderer.remove(native);
            }
        });
        return [
            ...beginIdenticalNodes,
            ...beginNodes,
            ...newChildren.map(i => {
                if (this.renderedVNode.has(i)) {
                    return this.nativeNodeCaches.get(i);
                }
                return this.patch(i);
            }),
            ...endNodes,
            ...endIdenticalNodes
        ];
    }
    diffIdenticalChildrenToEnd(newChildren, oldChildren, component) {
        const children = [];
        while (newChildren.length && oldChildren.length) {
            const newFirstVNode = newChildren[0];
            const oldFirstVNode = oldChildren[0];
            if (newFirstVNode instanceof VElement && oldFirstVNode instanceof VElement) {
                if (this.renderedVNode.has(newFirstVNode)) {
                    newChildren.shift();
                    children.push(this.nativeNodeCaches.get(newFirstVNode));
                    continue;
                }
                if (newFirstVNode.tagName !== oldFirstVNode.tagName) {
                    break;
                }
                const { isChanged } = getNodeChanges(newFirstVNode, oldFirstVNode);
                if (isChanged) {
                    break;
                }
                newChildren.shift();
                oldChildren.shift();
                let nativeNode = this.nativeNodeCaches.get(oldFirstVNode);
                if (nativeNode) {
                    this.nativeNodeCaches.set(newFirstVNode, nativeNode);
                    this.renderedVNode.set(newFirstVNode, true);
                }
                else {
                    nativeNode = this.createElement(newFirstVNode);
                }
                component = this.componentVNode.get(newFirstVNode) || component;
                const cc = this.diffChildrenAndUpdate(newFirstVNode, oldFirstVNode, component);
                children.push(this.sortAndCleanNativeNode(nativeNode, cc, component));
            }
            else {
                break;
            }
        }
        return children;
    }
    diffIdenticalChildrenToBegin(newChildren, oldChildren, component) {
        const children = [];
        while (newChildren.length && oldChildren.length) {
            const newLastVNode = newChildren[newChildren.length - 1];
            const oldLastVNode = oldChildren[oldChildren.length - 1];
            if (newLastVNode instanceof VElement && oldLastVNode instanceof VElement) {
                if (this.renderedVNode.has(newLastVNode)) {
                    newChildren.pop();
                    children.push(this.nativeNodeCaches.get(newLastVNode));
                    continue;
                }
                if (newLastVNode.tagName !== oldLastVNode.tagName) {
                    break;
                }
                const { isChanged } = getNodeChanges(newLastVNode, oldLastVNode);
                if (isChanged) {
                    break;
                }
                newChildren.pop();
                oldChildren.pop();
                let nativeNode = this.nativeNodeCaches.get(oldLastVNode);
                if (nativeNode) {
                    this.nativeNodeCaches.set(newLastVNode, nativeNode);
                    this.renderedVNode.set(newLastVNode, true);
                }
                else {
                    nativeNode = this.createElement(newLastVNode);
                }
                component = this.componentVNode.get(newLastVNode) || component;
                const cc = this.diffChildrenAndUpdate(newLastVNode, oldLastVNode, component);
                children.push(this.sortAndCleanNativeNode(nativeNode, cc, component));
            }
            else {
                break;
            }
        }
        return children.reverse();
    }
    diffChildrenToEnd(newChildren, oldChildren, component) {
        const children = [];
        while (newChildren.length && oldChildren.length) {
            const newFirstVNode = newChildren[0];
            const oldFirstVNode = oldChildren[0];
            if (newFirstVNode instanceof VElement) {
                if (this.renderedVNode.has(newFirstVNode)) {
                    newChildren.shift();
                    children.push(this.nativeNodeCaches.get(newFirstVNode));
                    continue;
                }
                if (oldFirstVNode instanceof VElement && newFirstVNode.tagName === oldFirstVNode.tagName) {
                    component = this.componentVNode.get(newFirstVNode) || component;
                    const nativeNode = this.diffAndUpdate(newFirstVNode, oldFirstVNode, component);
                    children.push(nativeNode);
                    newChildren.shift();
                    oldChildren.shift();
                }
                else {
                    break;
                }
            }
            else {
                if (this.renderedVNode.has(newFirstVNode)) {
                    newChildren.shift();
                    children.push(this.nativeNodeCaches.get(newFirstVNode));
                    continue;
                }
                if (oldFirstVNode instanceof VTextNode && newFirstVNode.textContent === oldFirstVNode.textContent) {
                    const nativeNode = this.nativeNodeCaches.get(oldFirstVNode);
                    this.nativeNodeCaches.set(newFirstVNode, nativeNode);
                    children.push(nativeNode);
                    this.nativeRenderer.syncTextContent(nativeNode, newFirstVNode.textContent);
                    newChildren.shift();
                    oldChildren.shift();
                }
                else {
                    break;
                }
            }
        }
        return children;
    }
    diffChildrenToBegin(newChildren, oldChildren, component) {
        const children = [];
        while (newChildren.length && oldChildren.length) {
            const newLastVNode = newChildren[newChildren.length - 1];
            const oldLastVNode = oldChildren[oldChildren.length - 1];
            if (newLastVNode instanceof VElement) {
                if (this.renderedVNode.has(newLastVNode)) {
                    newChildren.pop();
                    children.push(this.nativeNodeCaches.get(newLastVNode));
                    continue;
                }
                if (oldLastVNode instanceof VElement && newLastVNode.tagName === oldLastVNode.tagName) {
                    component = this.componentVNode.get(newLastVNode) || component;
                    const nativeNode = this.diffAndUpdate(newLastVNode, oldLastVNode, component);
                    children.push(nativeNode);
                    newChildren.pop();
                    oldChildren.pop();
                }
                else {
                    break;
                }
            }
            else {
                if (this.renderedVNode.has(newLastVNode)) {
                    newChildren.pop();
                    children.push(this.nativeNodeCaches.get(newLastVNode));
                    continue;
                }
                if (oldLastVNode instanceof VTextNode && newLastVNode.textContent === oldLastVNode.textContent) {
                    const nativeNode = this.nativeNodeCaches.get(oldLastVNode);
                    this.nativeNodeCaches.set(newLastVNode, nativeNode);
                    children.push(nativeNode);
                    this.nativeRenderer.syncTextContent(nativeNode, newLastVNode.textContent);
                    newChildren.pop();
                    oldChildren.pop();
                }
                else {
                    break;
                }
            }
        }
        return children.reverse();
    }
    diffNodeAndUpdate(newVDom, oldVDom) {
        let nativeNode = this.nativeNodeCaches.get(oldVDom);
        if (oldVDom.tagName !== newVDom.tagName) {
            nativeNode = this.createElement(newVDom);
        }
        else {
            const { styleChanges, attrChanges, classesChanges, listenerChanges } = getNodeChanges(newVDom, oldVDom);
            styleChanges.remove.forEach(i => this.nativeRenderer.removeStyle(nativeNode, i));
            styleChanges.set.forEach(i => this.nativeRenderer.setStyle(nativeNode, i[0], i[1]));
            attrChanges.remove.forEach(i => this.nativeRenderer.removeAttribute(nativeNode, i));
            attrChanges.set.forEach(([key, value]) => {
                if (key === this.slotIdAttrKey) {
                    return;
                }
                if (key === 'ref' && value instanceof Ref) {
                    value.current = nativeNode;
                    return;
                }
                this.nativeRenderer.setAttribute(nativeNode, key, value);
            });
            classesChanges.remove.forEach(i => this.nativeRenderer.removeClass(nativeNode, i));
            classesChanges.add.forEach(i => this.nativeRenderer.addClass(nativeNode, i));
            listenerChanges.remove.forEach(i => {
                this.nativeRenderer.unListen(nativeNode, i[0], i[1]);
            });
            listenerChanges.add.forEach(i => {
                this.nativeRenderer.listen(nativeNode, i[0], i[1]);
            });
            this.renderedVNode.set(newVDom, true);
            this.nativeNodeCaches.set(newVDom, nativeNode);
        }
        return nativeNode;
    }
    patch(vDom) {
        if (vDom instanceof VElement) {
            const el = this.createElement(vDom);
            vDom.children.forEach(child => {
                if (this.renderedVNode.get(child)) {
                    this.nativeRenderer.appendChild(el, this.nativeNodeCaches.get(child));
                }
                else {
                    this.nativeRenderer.appendChild(el, this.patch(child));
                }
            });
            return el;
        }
        return this.createTextNode(vDom);
    }
    extractVNodesBySlot(slot, tree, vNodes) {
        for (const child of tree) {
            const position = this.getLocationByVNode(child);
            if (position) {
                if (position.slot === slot) {
                    vNodes.push(child);
                }
                else {
                    break;
                }
                if (child instanceof VElement) {
                    this.extractVNodesBySlot(slot, child.children, vNodes);
                }
            }
        }
        return vNodes;
    }
    componentRender(component) {
        if (component.changeMarker.dirty || this.readonlyStateChanged) {
            const node = component.extends.render((slot, factory) => {
                return this.slotRender(component, slot, children => {
                    const vNodes = this.extractVNodesBySlot(slot, children, []);
                    this.slotVNodesCaches.set(slot, vNodes);
                    return factory(children);
                });
            }, this.controller.readonly ? exports.RenderMode.Readonly : exports.RenderMode.Editing);
            if (!(node instanceof VElement)) {
                throw rendererErrorFn(`component \`${component.name}\` rendering does not return a VElement.`);
            }
            setEditable(node, false);
            this.componentVNode.set(component, node);
            component.changeMarker.rendered();
            this.renderedComponents.push(component);
            return node;
        }
        if (component.changeMarker.changed) {
            const oldComponentVNode = this.componentVNode.get(component);
            component.slots.toArray().forEach(slot => {
                if (!slot.changeMarker.changed) {
                    return;
                }
                const dirty = slot.changeMarker.dirty;
                const oldVNode = this.slotRootVNodeCaches.get(slot);
                const factory = this.slotRenderFactory.get(slot);
                const vNode = this.slotRender(component, slot, factory);
                if (!(vNode instanceof VElement)) {
                    throw rendererErrorFn(`component \`${component.name}\` slot rendering does not return a VElement.`);
                }
                if (dirty) {
                    if (oldComponentVNode === oldVNode) {
                        this.componentVNode.set(component, vNode);
                        setEditable(vNode, false);
                    }
                    oldVNode.parentNode.replaceChild(vNode, oldVNode);
                    const oldNativeNode = this.nativeNodeCaches.get(oldVNode);
                    const newNativeNode = this.diffAndUpdate(vNode, oldVNode, component);
                    this.nativeNodeCaches.set(newNativeNode, vNode);
                    this.slotRootVNodeCaches.set(slot, vNode);
                    if (oldNativeNode !== newNativeNode) {
                        this.nativeRenderer.replace(newNativeNode, oldNativeNode);
                    }
                }
            });
            component.changeMarker.rendered();
        }
        this.renderedComponents.push(component);
        return this.componentVNode.get(component);
    }
    slotRender(component, slot, slotRenderFactory) {
        if (!(slot instanceof Slot)) {
            throw rendererErrorFn(`${slot} of the component \`${component.name}\` is not a Slot instance.`);
        }
        if (typeof slotRenderFactory !== 'function') {
            throw rendererErrorFn(`component \`${component.name}\` slot render is not a function.`);
        }
        if (slot.changeMarker.dirty || this.readonlyStateChanged) {
            this.slotRenderFactory.set(slot, slotRenderFactory);
            const formatTree = slot.createFormatTree();
            const renderMode = this.controller.readonly ? exports.RenderMode.Readonly : exports.RenderMode.Editing;
            const componentRender = (component) => {
                const componentVNode = this.componentRender(component);
                if (!this.firstRending) {
                    invokeListener(component, 'onParentSlotUpdated');
                }
                return componentVNode;
            };
            const setLocation = (vNode, location) => {
                this.vNodeLocation.set(vNode, location);
            };
            let children = formatTree.children ?
                exports.PureRenderer.createVDomByFormatTree(slot, formatTree.children, renderMode, componentRender, setLocation) :
                exports.PureRenderer.createVDomByContent(slot, formatTree.startIndex, formatTree.endIndex, renderMode, componentRender, setLocation);
            if (formatTree.formats) {
                children = [exports.PureRenderer.createVDomByOverlapFormats(formatTree.formats, children, slot, renderMode, setLocation)];
            }
            const root = slotRenderFactory(children);
            if (!(root instanceof VElement)) {
                throw rendererErrorFn(`component \`${component.name}\` slot rendering does not return a VElement.`);
            }
            for (const [attribute, value] of slot.getAttributes()) {
                attribute.render(root, value, renderMode);
            }
            root.attrs.set(this.slotIdAttrKey, slot.id);
            setEditable(root, true);
            this.vNodeLocation.set(root, {
                slot: slot,
                startIndex: 0,
                endIndex: slot.length
            });
            slot.changeMarker.rendered();
            this.slotRootVNodeCaches.set(slot, root);
            return root;
        }
        slot.sliceContent().filter((i) => {
            return typeof i !== 'string';
        }).forEach(component => {
            if (!component.changeMarker.changed) {
                return;
            }
            const dirty = component.changeMarker.dirty;
            const oldVNode = this.componentVNode.get(component);
            const vNode = this.componentRender(component);
            const startIndex = slot.indexOf(component);
            this.vNodeLocation.set(vNode, {
                slot,
                startIndex,
                endIndex: startIndex + 1
            });
            if (dirty) {
                oldVNode.parentNode.replaceChild(vNode, oldVNode);
                const oldNativeNode = this.nativeNodeCaches.get(oldVNode);
                const newNativeNode = this.diffAndUpdate(vNode, oldVNode, component);
                if (oldNativeNode !== newNativeNode) {
                    this.nativeRenderer.replace(newNativeNode, oldNativeNode);
                }
            }
        });
        slot.changeMarker.rendered();
        return this.slotRootVNodeCaches.get(slot);
    }
    createElement(vDom) {
        this.renderedVNode.set(vDom, true);
        const el = this.nativeRenderer.createElement(vDom.tagName);
        vDom.attrs.forEach((value, key) => {
            if (key === this.slotIdAttrKey) {
                return;
            }
            if (key === 'ref') {
                if (value instanceof Ref) {
                    value.current = el;
                }
                return;
            }
            this.nativeRenderer.setAttribute(el, key, value);
        });
        vDom.styles.forEach((value, key) => {
            this.nativeRenderer.setStyle(el, key, value);
        });
        vDom.classes.forEach(k => this.nativeRenderer.addClass(el, k));
        Object.keys(vDom.listeners).forEach(type => {
            this.nativeRenderer.listen(el, type, vDom.listeners[type]);
        });
        this.nativeNodeCaches.set(el, vDom);
        return el;
    }
    createTextNode(vDom) {
        this.renderedVNode.set(vDom, true);
        const el = this.nativeRenderer.createTextNode(vDom.textContent);
        this.nativeNodeCaches.set(el, vDom);
        return el;
    }
};
__decorate([
    di.Prop(),
    __metadata("design:type", NativeRenderer)
], exports.Renderer.prototype, "nativeRenderer", void 0);
exports.Renderer = __decorate([
    di.Injectable(),
    __metadata("design:paramtypes", [exports.Controller,
        RootComponentRef])
], exports.Renderer);

var Scheduler_1;
/**
 * 数据变更源
 */
exports.ChangeOrigin = void 0;
(function (ChangeOrigin) {
    ChangeOrigin[ChangeOrigin["History"] = 0] = "History";
    ChangeOrigin[ChangeOrigin["Local"] = 1] = "Local";
    ChangeOrigin[ChangeOrigin["Remote"] = 2] = "Remote";
})(exports.ChangeOrigin || (exports.ChangeOrigin = {}));
/**
 * Textbus 调度器，用于控制文档内容的更新及渲染
 */
exports.Scheduler = Scheduler_1 = class Scheduler {
    /**
     * 最后一次文档变更是否包含本地变更
     */
    get lastChangesHasLocalUpdate() {
        return this._lastChangesHasLocalUpdate;
    }
    /**
     * 最后一次文档变更是否包含远程变更
     */
    get lastChangesHasRemoteUpdate() {
        return this._lastChangesHasRemoteUpdate;
    }
    constructor(rootComponentRef, selection, renderer) {
        this.rootComponentRef = rootComponentRef;
        this.selection = selection;
        this.renderer = renderer;
        this._lastChangesHasLocalUpdate = true;
        this._lastChangesHasRemoteUpdate = false;
        this.changeFromRemote = false;
        this.changeFromHistory = false;
        this.instanceList = new Set();
        this.docChangedEvent = new stream.Subject();
        this.docChangeEvent = new stream.Subject();
        this.localChangeBeforeEvent = new stream.Subject();
        this.subs = [];
        this.onDocChanged = this.docChangedEvent.asObservable();
        this.onDocChange = this.docChangeEvent.asObservable();
        this.onLocalChangeBefore = this.localChangeBeforeEvent.asObservable();
        this.onDocFirstChangeFromLocal = this.onLocalChangeBefore.pipe(stream.take(1));
    }
    /**
     * 远程更新文档事务
     * @param task 事务处理函数
     */
    remoteUpdateTransact(task) {
        this.changeFromRemote = true;
        task();
        this.changeFromRemote = false;
    }
    /**
     * 历史记录更新文档事务
     * @param task 事务处理函数
     */
    historyApplyTransact(task) {
        this.changeFromHistory = true;
        task();
        this.changeFromHistory = false;
    }
    /**
     * 启动调度器，并兼听文档变更自动渲染文档
     */
    run() {
        const rootComponent = this.rootComponentRef.component;
        const changeMarker = rootComponent.changeMarker;
        this.renderer.render();
        let isRendered = true;
        this.subs.push(changeMarker.onForceChange.pipe(stream.microTask()).subscribe(() => {
            this.renderer.render();
        }), changeMarker.onChange.pipe(stream.map(op => {
            const from = this.changeFromRemote ? exports.ChangeOrigin.Remote :
                this.changeFromHistory ? exports.ChangeOrigin.History : exports.ChangeOrigin.Local;
            if (isRendered) {
                isRendered = false;
                if (from === exports.ChangeOrigin.Local) {
                    this.localChangeBeforeEvent.next();
                }
                this.docChangeEvent.next();
            }
            return {
                from,
                operation: op
            };
        }), stream.microTask()).subscribe(ops => {
            isRendered = true;
            this.renderer.render();
            this._lastChangesHasRemoteUpdate = false;
            this._lastChangesHasLocalUpdate = false;
            ops.forEach(i => {
                if (i.from === exports.ChangeOrigin.Remote) {
                    this._lastChangesHasRemoteUpdate = true;
                }
                else {
                    this._lastChangesHasLocalUpdate = true;
                }
            });
            this.selection.restore(this._lastChangesHasLocalUpdate);
            this.docChangedEvent.next(ops);
        }), changeMarker.onChildComponentRemoved.subscribe(instance => {
            this.instanceList.add(instance);
        }), this.renderer.onViewUpdated.subscribe(() => {
            this.instanceList.forEach(instance => {
                let comp = instance;
                while (comp) {
                    const parent = comp.parentComponent;
                    if (parent) {
                        comp = parent;
                    }
                    else {
                        break;
                    }
                }
                if (comp !== rootComponent) {
                    Scheduler_1.invokeChildComponentDestroyHook(comp);
                }
            });
            this.instanceList.clear();
        }));
    }
    /**
     * 销毁调度器
     */
    destroy() {
        this.subs.forEach(i => i.unsubscribe());
        const component = this.rootComponentRef.component;
        if (component) {
            Scheduler_1.invokeChildComponentDestroyHook(component);
        }
        this.subs = [];
    }
    static invokeChildComponentDestroyHook(parent) {
        parent.slots.toArray().forEach(slot => {
            slot.sliceContent().forEach(i => {
                if (typeof i !== 'string') {
                    Scheduler_1.invokeChildComponentDestroyHook(i);
                }
            });
        });
        invokeListener(parent, 'onDestroy');
    }
};
exports.Scheduler = Scheduler_1 = __decorate([
    di.Injectable(),
    __metadata("design:paramtypes", [RootComponentRef,
        exports.Selection,
        exports.Renderer])
], exports.Scheduler);

/**
 * 历史记录抽象类，实现以下接口即可完成 Textbus 历史记录
 */
class History {
}
function objToFormats(formatsObj, registry) {
    const formats = [];
    Object.keys(formatsObj).forEach(i => {
        const formatter = registry.getFormatter(i);
        if (formatter) {
            const value = formatsObj[i];
            if (Array.isArray(value)) {
                value.forEach(item => {
                    formats.push([formatter, item]);
                });
            }
            else {
                formats.push([formatter, formatsObj[i]]);
            }
        }
    });
    return formats;
}
const historyErrorFn = makeError('History');
/**
 * Textbus 历史记录管理类
 */
exports.LocalHistory = class LocalHistory extends History {
    /**
     * 历史记录是否可回退
     */
    get canBack() {
        return this.historySequence.length > 0 && this.index > 0;
    }
    /**
     * 历史记录是否可重做
     */
    get canForward() {
        return this.historySequence.length > 0 && this.index < this.historySequence.length;
    }
    constructor(stackSize, root, scheduler, selection, registry) {
        super();
        this.stackSize = stackSize;
        this.root = root;
        this.scheduler = scheduler;
        this.selection = selection;
        this.registry = registry;
        this.index = 0;
        this.historySequence = [];
        this.changeEvent = new stream.Subject();
        this.backEvent = new stream.Subject();
        this.forwardEvent = new stream.Subject();
        this.pushEvent = new stream.Subject();
        this.subscription = null;
        this.forceChangeSubscription = null;
        this.onChange = this.changeEvent.asObservable();
        this.onBack = this.backEvent.asObservable();
        this.onForward = this.forwardEvent.asObservable();
        this.onPush = this.pushEvent.asObservable();
    }
    /**
     * 监听数据变化，并记录操作历史
     */
    listen() {
        this.record();
    }
    /**
     * 重做历史记录
     */
    forward() {
        if (this.canForward) {
            this.scheduler.historyApplyTransact(() => {
                const item = this.historySequence[this.index];
                this.apply(item, false);
                this.selection.usePaths(item.afterPaths);
            });
            this.index++;
            this.forwardEvent.next();
            this.changeEvent.next();
        }
    }
    /**
     * 撤消操作
     */
    back() {
        if (this.canBack) {
            this.scheduler.historyApplyTransact(() => {
                const item = this.historySequence[this.index - 1];
                this.apply(item, true);
                this.selection.usePaths(item.beforePaths);
            });
            this.index--;
            this.backEvent.next();
            this.changeEvent.next();
        }
    }
    /**
     * 清除历史记录
     */
    clear() {
        this.historySequence = [];
        this.index = 0;
        this.changeEvent.next();
    }
    /**
     * 销毁历史记录实例
     */
    destroy() {
        var _a;
        this.historySequence = [];
        (_a = this.forceChangeSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    record() {
        let beforePaths = this.selection.getPaths();
        this.subscription = this.scheduler.onLocalChangeBefore.subscribe(() => {
            beforePaths = this.selection.getPaths();
        }).add(this.scheduler.onDocChanged.pipe(stream.map(i => {
            const operations = [];
            for (const item of i) {
                if (item.from !== exports.ChangeOrigin.Local) {
                    continue;
                }
                const operation = item.operation;
                const apply = operation.apply.filter(i => {
                    return i.type !== 'apply' || i.record;
                });
                const unApply = operation.unApply.filter(i => {
                    return i.type !== 'apply' || i.record;
                });
                if (apply.length && unApply.length) {
                    operations.push({
                        path: operation.path,
                        apply,
                        unApply
                    });
                }
            }
            return operations;
        })).subscribe((operations) => {
            if (!operations.length) {
                return;
            }
            this.historySequence.length = this.index;
            this.index++;
            const afterPaths = this.selection.getPaths();
            this.historySequence.push({
                operations: operations.map(i => {
                    return {
                        path: [...i.path],
                        apply: i.apply.map(j => {
                            if (j.type === 'insert' || j.type === 'insertSlot') {
                                return Object.assign(Object.assign({}, j), { ref: null });
                            }
                            return j;
                        }),
                        unApply: i.unApply.map(j => {
                            if (j.type === 'insert' || j.type === 'insertSlot') {
                                return Object.assign(Object.assign({}, j), { ref: null });
                            }
                            return j;
                        })
                    };
                }),
                beforePaths,
                afterPaths
            });
            if (this.historySequence.length > this.stackSize) {
                this.historySequence.shift();
                this.index--;
            }
            beforePaths = afterPaths;
            this.pushEvent.next();
            this.changeEvent.next();
        }));
    }
    apply(historyItem, back) {
        let operations = historyItem.operations;
        if (back) {
            operations = [...operations].reverse();
        }
        operations.forEach(op => {
            const path = [...op.path];
            const isFindSlot = path.length % 2 === 1;
            const actions = back ? op.unApply : op.apply;
            if (isFindSlot) {
                const slot = this.selection.findSlotByPaths(path);
                actions.forEach(action => {
                    if (action.type === 'retain') {
                        const formatsObj = action.formats;
                        if (formatsObj) {
                            const formats = objToFormats(formatsObj, this.registry);
                            slot.retain(action.offset, formats);
                        }
                        else {
                            slot.retain(action.offset);
                        }
                        return;
                    }
                    if (action.type === 'delete') {
                        slot.delete(action.count);
                        return;
                    }
                    if (action.type === 'apply') {
                        slot.updateState(draft => {
                            immer.applyPatches(draft, action.patches);
                        });
                        return;
                    }
                    if (action.type === 'attrSet') {
                        const attribute = this.registry.getAttribute(action.name);
                        if (attribute) {
                            slot.setAttribute(attribute, action.value);
                        }
                        return;
                    }
                    if (action.type === 'attrRemove') {
                        const attribute = this.registry.getAttribute(action.name);
                        if (attribute) {
                            slot.removeAttribute(attribute);
                        }
                        return;
                    }
                    if (action.type === 'insert') {
                        const formatsObj = action.formats;
                        let formats;
                        if (formatsObj) {
                            formats = objToFormats(formatsObj, this.registry);
                        }
                        if (typeof action.content === 'string') {
                            formats ? slot.insert(action.content, formats) : slot.insert(action.content);
                        }
                        else {
                            const instance = this.registry.createComponent(action.content);
                            if (!instance) {
                                // eslint-disable-next-line max-len
                                throw historyErrorFn(`component \`${action.content.name}\` not registered, please add \`${action.content.name}\` component to the components configuration item.`);
                            }
                            formats ? slot.insert(instance, formats) : slot.insert(instance);
                        }
                    }
                });
            }
            else {
                const component = this.selection.findComponentByPaths(path);
                actions.forEach(action => {
                    if (action.type === 'retain') {
                        component.slots.retain(action.offset);
                        return;
                    }
                    if (action.type === 'delete') {
                        component.slots.delete(action.count);
                        return;
                    }
                    if (action.type === 'insertSlot') {
                        const slot = this.registry.createSlot(action.slot);
                        component.slots.insert(slot);
                        return;
                    }
                    if (action.type === 'apply') {
                        component.updateState(draft => {
                            return immer.applyPatches(draft, action.patches);
                        });
                    }
                });
            }
        });
    }
};
exports.LocalHistory = __decorate([
    di.Injectable(),
    __param(0, di.Inject(HISTORY_STACK_SIZE)),
    __metadata("design:paramtypes", [Number, RootComponentRef,
        exports.Scheduler,
        exports.Selection,
        exports.Registry])
], exports.LocalHistory);

/**
 * Textbus 键盘管理
 */
exports.Keyboard = class Keyboard {
    constructor(components, markdownDetect, commander, injector, selection) {
        this.components = components;
        this.markdownDetect = markdownDetect;
        this.commander = commander;
        this.injector = injector;
        this.selection = selection;
        this.shortcutList = [];
        this.zenCodingInterceptors = [];
        components.forEach(component => {
            const config = component.zenCoding;
            if (Array.isArray(config)) {
                config.forEach(i => this.zenCodingInterceptors.push(this.createZenCodingEx(component, i)));
            }
            else if (config) {
                this.zenCodingInterceptors.push(this.createZenCodingEx(component, config));
            }
        });
    }
    /**
     * 注册输入语法糖
     * @param interceptor
     */
    addZenCodingInterceptor(interceptor) {
        this.zenCodingInterceptors.push(interceptor);
        return {
            remove: () => {
                const index = this.zenCodingInterceptors.indexOf(interceptor);
                if (index > -1) {
                    this.zenCodingInterceptors.splice(index, 1);
                }
            }
        };
    }
    /**
     * 调用快捷键
     * @param keymapState 快捷键配置
     */
    execShortcut(keymapState) {
        if (!this.selection.isSelected) {
            return false;
        }
        const key = keymapState.key;
        // const reg = /\w+/.test(key) ? new RegExp(`^${key}$`, 'i') : new RegExp(`^[${key.replace(/([-^\\\]\[])/g, '\\$1')}]$`, 'i')
        const commonAncestorSlot = this.selection.commonAncestorSlot;
        if (this.markdownDetect &&
            !keymapState.ctrlKey &&
            !keymapState.shiftKey &&
            !keymapState.altKey &&
            commonAncestorSlot === this.selection.startSlot &&
            commonAncestorSlot === this.selection.endSlot) {
            for (let i = this.zenCodingInterceptors.length - 1; i > -1; i--) {
                const interceptor = this.zenCodingInterceptors[i];
                const matchKey = interceptor.try(key);
                if (matchKey) {
                    const activeSlotContents = commonAncestorSlot.sliceContent();
                    let content = activeSlotContents[0];
                    if (activeSlotContents.length > 1 || typeof content !== 'string') {
                        continue;
                    }
                    content = content.replace(/\n$/, '');
                    const matchContent = interceptor.match(content);
                    if (matchContent) {
                        const r = interceptor.action(content);
                        if (!r) {
                            break;
                        }
                        return true;
                    }
                }
            }
        }
        const commonAncestorComponent = this.selection.commonAncestorComponent;
        if (commonAncestorComponent) {
            const is = this.handleShortcut(keymapState, commonAncestorComponent.shortcutList.map(s => this.createShortcutEx(s)));
            if (is) {
                return true;
            }
        }
        return this.handleShortcut(keymapState, this.shortcutList);
    }
    /**
     * 注册快捷键
     * @param shortcut 快捷键配置
     */
    addShortcut(shortcut) {
        const shortcutEx = this.createShortcutEx(shortcut);
        this.shortcutList.push(shortcutEx);
        return {
            remove: () => {
                const index = this.shortcutList.indexOf(shortcutEx);
                if (index > -1) {
                    this.shortcutList.splice(index, 1);
                }
            }
        };
    }
    handleShortcut(keymap, shortcutList) {
        for (let i = shortcutList.length - 1; i > -1; i--) {
            const ex = shortcutList[i];
            const config = ex.config;
            if (ex.test(keymap.key) &&
                !!config.keymap.altKey === keymap.altKey &&
                !!config.keymap.shiftKey === keymap.shiftKey &&
                !!config.keymap.ctrlKey === keymap.ctrlKey) {
                const b = config.action(keymap.key);
                if (b !== false) {
                    return true;
                }
            }
        }
        return false;
    }
    createZenCodingEx(component, config) {
        const selection = this.selection;
        const commander = this.commander;
        return {
            match(content) {
                return typeof config.match === 'function' ? config.match(content) : config.match.test(content);
            },
            try(key) {
                if (typeof config.key === 'string') {
                    return key.toLowerCase() === config.key.toLowerCase();
                }
                if (typeof config.key === 'function') {
                    return config.key(key);
                }
                if (Array.isArray(config.key)) {
                    return config.key.some(item => item.toLowerCase() === key.toLowerCase());
                }
                return config.key.test(key);
            },
            action: (content) => {
                const commonAncestorSlot = selection.commonAncestorSlot;
                const initData = config.generateInitData(content, this.injector);
                const newInstance = component.createInstance(this.injector, initData);
                if (commonAncestorSlot.schema.includes(newInstance.type)) {
                    selection.selectSlot(commonAncestorSlot);
                    commander.delete();
                    commander.insert(newInstance);
                }
                else {
                    const parentComponent = commonAncestorSlot.parent;
                    if (parentComponent && parentComponent.slots.length > 1) {
                        return false;
                    }
                    const parentSlot = parentComponent === null || parentComponent === void 0 ? void 0 : parentComponent.parent;
                    if (!parentSlot) {
                        return false;
                    }
                    selection.selectComponent(parentComponent);
                    commander.delete();
                    commander.insert(newInstance);
                }
                const newSlot = newInstance.slots.first;
                if (newSlot) {
                    selection.setPosition(newSlot, 0);
                }
                else if (newInstance.parent) {
                    const index = newInstance.parent.indexOf(newInstance);
                    selection.setPosition(newInstance.parent, index + 1);
                }
                return true;
            }
        };
    }
    createShortcutEx(config) {
        const key = config.keymap.key;
        return {
            config,
            test(k) {
                if (typeof key === 'string') {
                    return k.toLowerCase() === key.toLowerCase();
                }
                else if (Array.isArray(key)) {
                    return key.some(v => {
                        return k.toLowerCase() === v.toLowerCase();
                    });
                }
                else if (typeof key.match === 'function') {
                    return key.match(k);
                }
                return key.match.test(k);
            }
        };
    }
};
exports.Keyboard = __decorate([
    di.Injectable(),
    __param(0, di.Inject(COMPONENT_LIST)),
    __param(1, di.Inject(ZEN_CODING_DETECT)),
    __metadata("design:paramtypes", [Array, Boolean, exports.Commander,
        di.Injector,
        exports.Selection])
], exports.Keyboard);

/**
 * Textbus 输出渲染器
 */
exports.OutputRenderer = class OutputRenderer {
    constructor(rootComponentRef) {
        this.rootComponentRef = rootComponentRef;
        this.componentVNode = new WeakMap();
        this.slotVNodeCaches = new WeakMap();
        this.slotRenderFactory = new WeakMap();
    }
    /**
     * 以输出模式渲染当前文档
     */
    render() {
        const root = this.componentRender(this.rootComponentRef.component);
        new VElement('body', null, [root]);
        return root;
    }
    componentRender(component) {
        if (component.changeMarker.outputDirty) {
            const node = component.extends.render((slot, factory) => {
                return this.slotRender(slot, factory);
            }, exports.RenderMode.Output);
            component.changeMarker.outputRendered();
            this.componentVNode.set(component, node);
            return node;
        }
        const oldComponentVNode = this.componentVNode.get(component);
        component.slots.toArray().forEach(slot => {
            if (!slot.changeMarker.outputChanged) {
                return;
            }
            const dirty = slot.changeMarker.outputDirty;
            const oldVNode = this.slotVNodeCaches.get(slot);
            const factory = this.slotRenderFactory.get(slot);
            const vNode = this.slotRender(slot, factory);
            if (dirty) {
                if (oldComponentVNode === oldVNode) {
                    this.componentVNode.set(component, vNode);
                }
                oldVNode.parentNode.replaceChild(vNode, oldVNode);
                this.slotVNodeCaches.set(slot, vNode);
            }
        });
        component.changeMarker.outputRendered();
        return this.componentVNode.get(component);
    }
    slotRender(slot, slotRenderFactory) {
        if (slot.changeMarker.outputDirty) {
            this.slotRenderFactory.set(slot, slotRenderFactory);
            const formatTree = slot.createFormatTree();
            const componentRender = (component) => {
                return this.componentRender(component);
            };
            let children = formatTree.children ?
                exports.PureRenderer.createVDomByFormatTree(slot, formatTree.children, exports.RenderMode.Output, componentRender) :
                exports.PureRenderer.createVDomByContent(slot, formatTree.startIndex, formatTree.endIndex, exports.RenderMode.Output, componentRender);
            if (formatTree.formats) {
                children = [exports.PureRenderer.createVDomByOverlapFormats(formatTree.formats, children, slot, exports.RenderMode.Output)];
            }
            const root = slotRenderFactory(children);
            for (const [attribute, value] of slot.getAttributes()) {
                attribute.render(root, value, exports.RenderMode.Output);
            }
            slot.changeMarker.outputRendered();
            this.slotVNodeCaches.set(slot, root);
            return root;
        }
        slot.sliceContent().filter((i) => {
            return typeof i !== 'string';
        }).forEach(component => {
            if (!component.changeMarker.outputChanged) {
                return;
            }
            const dirty = component.changeMarker.outputDirty;
            const oldVNode = this.componentVNode.get(component);
            const vNode = this.componentRender(component);
            if (dirty) {
                oldVNode.parentNode.replaceChild(vNode, oldVNode);
            }
        });
        slot.changeMarker.outputRendered();
        return this.slotVNodeCaches.get(slot);
    }
};
exports.OutputRenderer = __decorate([
    di.Injectable(),
    __metadata("design:paramtypes", [RootComponentRef])
], exports.OutputRenderer);

/**
 * Textbus 状态查询状态枚举
 */
exports.QueryStateType = void 0;
(function (QueryStateType) {
    /** 正常 */
    QueryStateType["Normal"] = "Normal";
    /** 当前不可用 */
    QueryStateType["Disabled"] = "Disabled";
    /** 当前状态为生效 */
    QueryStateType["Enabled"] = "Enabled";
})(exports.QueryStateType || (exports.QueryStateType = {}));
/**
 * Textbus 状态查询类，用于查询组件或格式在当前选区的状态
 */
exports.Query = class Query {
    constructor(selection) {
        this.selection = selection;
    }
    /**
     * 查询格式在当前选区的状态
     * @param formatter 要查询的格式
     */
    queryFormat(formatter) {
        if (!this.selection.isSelected) {
            return {
                state: exports.QueryStateType.Normal,
                value: null
            };
        }
        const states = this.selection.getSelectedScopes().map(i => {
            return this.getStatesByRange(i.slot, formatter, i.startIndex, i.endIndex);
        });
        return this.mergeState(states);
    }
    /**
     * 查询属性在当前选区的状态
     * @param attribute
     */
    queryAttribute(attribute) {
        if (!this.selection.isSelected) {
            return {
                state: exports.QueryStateType.Normal,
                value: null
            };
        }
        let ranges;
        if (this.selection.isCollapsed) {
            const c = this.selection.commonAncestorSlot;
            ranges = [{
                    slot: c,
                    startIndex: 0,
                    endIndex: c.length
                }];
        }
        else {
            ranges = this.selection.getSelectedScopes();
        }
        const states = ranges.map(i => {
            const contents = i.slot.sliceContent(i.startIndex, i.endIndex);
            const childComponents = [];
            let hasString = false;
            contents.forEach(item => {
                if (typeof item !== 'string') {
                    childComponents.push(item);
                }
                else {
                    hasString = true;
                }
            });
            if (hasString) {
                if (i.slot.hasAttribute(attribute)) {
                    return {
                        state: exports.QueryStateType.Enabled,
                        value: i.slot.getAttribute(attribute)
                    };
                }
                return {
                    state: exports.QueryStateType.Normal,
                    value: null
                };
            }
            const states = [];
            for (const component of childComponents) {
                const slots = component.slots;
                if (slots.length === 0) {
                    if (i.slot.hasAttribute(attribute)) {
                        states.push({
                            state: exports.QueryStateType.Enabled,
                            value: i.slot.getAttribute(attribute)
                        });
                    }
                    else {
                        return {
                            state: exports.QueryStateType.Normal,
                            value: null
                        };
                    }
                }
                for (const slot of slots.toArray()) {
                    if (slot.hasAttribute(attribute)) {
                        states.push({
                            state: exports.QueryStateType.Enabled,
                            value: slot.getAttribute(attribute)
                        });
                    }
                    else {
                        return {
                            state: exports.QueryStateType.Normal,
                            value: null
                        };
                    }
                }
            }
            return this.mergeState(states);
        });
        return this.mergeState(states);
    }
    /**
     * 查询组件在选区内的状态
     * @param component 要查询的组件
     * @param filter 查询结构过滤函数，过滤不需要的数据
     */
    queryComponent(component, filter) {
        if (!this.selection.isSelected) {
            return {
                state: exports.QueryStateType.Normal,
                value: null
            };
        }
        const ranges = this.selection.getRanges();
        const states = ranges.map(item => {
            var _a;
            let parent = exports.Selection.getCommonAncestorComponent(item.startSlot, item.endSlot);
            while (parent) {
                if (parent.name === component.name) {
                    if (!filter || filter(parent)) {
                        return {
                            state: exports.QueryStateType.Enabled,
                            value: parent
                        };
                    }
                }
                parent = ((_a = parent.parent) === null || _a === void 0 ? void 0 : _a.parent) || null;
            }
            return {
                state: exports.QueryStateType.Normal,
                value: null
            };
        });
        return this.mergeState(states);
    }
    /**
     * 查询当前选区是否包含在组件内
     * @param component 要查询的组件
     */
    queryWrappedComponent(component) {
        const selection = this.selection;
        if (!selection.isSelected || selection.isCollapsed) {
            return {
                state: exports.QueryStateType.Normal,
                value: null
            };
        }
        const ranges = selection.getRanges();
        const instances = [];
        for (const range of ranges) {
            const { startSlot, endSlot, startOffset, endOffset } = range;
            if (startSlot !== endSlot ||
                endOffset - startOffset > 1) {
                return {
                    state: exports.QueryStateType.Normal,
                    value: null
                };
            }
            const instance = startSlot.getContentAtIndex(startOffset);
            if (typeof instance !== 'string' && instance.name === component.name) {
                instances.push(instance);
            }
            else {
                return {
                    state: exports.QueryStateType.Normal,
                    value: null
                };
            }
        }
        return {
            state: exports.QueryStateType.Enabled,
            value: instances[0]
        };
    }
    getStatesByRange(slot, formatter, startIndex, endIndex) {
        if (startIndex === endIndex) {
            const format = startIndex === 0 ?
                slot.getFormatRangesByFormatter(formatter, 0, 1).shift() :
                slot.getFormatRangesByFormatter(formatter, startIndex - 1, endIndex).shift();
            if (format) {
                return {
                    state: exports.QueryStateType.Enabled,
                    value: format.value
                };
            }
            return null;
        }
        const childContents = slot.sliceContent(startIndex, endIndex);
        const states = [];
        let index = startIndex;
        for (const child of childContents) {
            if (typeof child === 'string' || child.slots.length === 0) {
                const formats = slot.getFormatRangesByFormatter(formatter, index, index + child.length);
                let s = index;
                for (const f of formats) {
                    if (s !== f.startIndex) {
                        return {
                            state: exports.QueryStateType.Normal,
                            value: null
                        };
                    }
                    states.push({
                        state: exports.QueryStateType.Enabled,
                        value: f.value
                    });
                    s = f.endIndex;
                }
                if (s !== index + child.length) {
                    return {
                        state: exports.QueryStateType.Normal,
                        value: null
                    };
                }
            }
            else {
                child.slots.toArray().forEach(i => {
                    states.push(this.getStatesByRange(i, formatter, 0, i.length));
                });
            }
            index += child.length;
        }
        return this.mergeState(states);
    }
    mergeState(states) {
        const states1 = states.filter(i => i);
        const states2 = states1.filter(i => i.state !== exports.QueryStateType.Normal);
        if (states.length !== states2.length) {
            return {
                state: exports.QueryStateType.Normal,
                value: null
            };
        }
        if (states2.length) {
            return {
                state: exports.QueryStateType.Enabled,
                value: states2[0].value
            };
        }
        return {
            state: exports.QueryStateType.Normal,
            value: null
        };
    }
};
exports.Query = __decorate([
    di.Injectable(),
    __metadata("design:paramtypes", [exports.Selection])
], exports.Query);

const starterErrorFn = makeError('Starter');
/**
 * Textbus 内核启动器
 */
class Starter extends di.ReflectiveInjector {
    constructor(config) {
        var _a;
        super(new di.NullInjector(), [], Starter.diScope);
        this.config = config;
        this.beforeDestroyCallbacks = [];
        this.isDestroyed = false;
        const { plugins, providers } = this.mergeModules(config);
        this.plugins = plugins;
        this.staticProviders = providers;
        this.normalizedProviders = this.staticProviders.map(i => di.normalizeProvider(i));
        (_a = config.imports) === null || _a === void 0 ? void 0 : _a.forEach(module => {
            if (typeof module.beforeEach === 'function') {
                module.beforeEach(this);
            }
        });
    }
    /**
     * 启动一个 Textbus 实例，并将根组件渲染到原生节点
     * @param host 原生节点
     * @param rootComponent 根组件
     */
    mount(host, rootComponent) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const rootComponentRef = this.get(RootComponentRef);
            rootComponentRef.component = rootComponent;
            rootComponentRef.host = host;
            const callbacks = [];
            (_a = this.config.imports) === null || _a === void 0 ? void 0 : _a.forEach(i => {
                if (typeof i.setup === 'function') {
                    const callback = i.setup(this);
                    callbacks.push(callback || null);
                }
            });
            callbacks.push(((_c = (_b = this.config).setup) === null || _c === void 0 ? void 0 : _c.call(_b, this)) || null);
            const fns = yield Promise.all(callbacks);
            if (this.isDestroyed) {
                return this;
            }
            fns.forEach(i => {
                if (i) {
                    this.beforeDestroyCallbacks.push(i);
                }
            });
            const scheduler = this.get(exports.Scheduler);
            const history = this.get(History);
            history.listen();
            scheduler.run();
            this.plugins.forEach(i => i.setup(this));
            return this;
        });
    }
    /**
     * 销毁 Textbus 实例
     */
    destroy() {
        this.isDestroyed = true;
        this.plugins.forEach(i => { var _a; return (_a = i.onDestroy) === null || _a === void 0 ? void 0 : _a.call(i); });
        this.beforeDestroyCallbacks.forEach(i => {
            i();
        });
        [this.get(History), this.get(exports.Selection), this.get(exports.Scheduler), this.get(exports.Renderer)].forEach(i => {
            i.destroy();
        });
    }
    mergeModules(config) {
        var _a;
        const customProviders = [
            ...(config.providers || []),
        ];
        const components = [
            ...(config.components || [])
        ];
        const attributes = this.bindContext(config.attributes);
        const formatters = this.bindContext(config.formatters);
        const plugins = [
            ...(config.plugins || [])
        ];
        (_a = config.imports) === null || _a === void 0 ? void 0 : _a.forEach(module => {
            customProviders.push(...(module.providers || []));
            components.push(...(module.components || []));
            attributes.push(...this.bindContext(module.attributes));
            formatters.push(...this.bindContext(module.formatters));
            plugins.push(...(module.plugins || []));
        });
        const providers = [
            ...customProviders,
            {
                provide: READONLY,
                useValue: !!config.readonly
            },
            {
                provide: HISTORY_STACK_SIZE,
                useValue: typeof config.historyStackSize === 'number' ? config.historyStackSize : 500
            },
            {
                provide: COMPONENT_LIST,
                useValue: components
            }, {
                provide: ATTRIBUTE_LIST,
                useValue: attributes
            }, {
                provide: FORMATTER_LIST,
                useValue: formatters
            }, {
                provide: ZEN_CODING_DETECT,
                useValue: config.zenCoding
            }, {
                provide: RootComponentRef,
                useValue: {}
            },
            {
                provide: History,
                useClass: exports.LocalHistory
            },
            exports.Controller,
            exports.Scheduler,
            exports.Commander,
            exports.Keyboard,
            exports.OutputRenderer,
            exports.PureRenderer,
            exports.Query,
            exports.Renderer,
            exports.Selection,
            exports.Registry,
            {
                provide: Starter,
                useFactory: () => this
            },
            {
                provide: di.Injector,
                useFactory: () => {
                    return this;
                }
            }, {
                provide: NativeSelectionBridge,
                useFactory() {
                    throw starterErrorFn('You must implement the `NativeSelectionBridge` interface to start Textbus!');
                }
            }, {
                provide: NativeRenderer,
                useFactory() {
                    throw starterErrorFn('You must implement the `NativeRenderer` interface to start Textbus!');
                }
            }
        ];
        return {
            providers,
            plugins: plugins.map(i => {
                if (typeof i === 'function') {
                    return i();
                }
                return i;
            })
        };
    }
    bindContext(list = []) {
        return list.map(item => {
            if (typeof item === 'function') {
                return item(this);
            }
            return item;
        });
    }
}
Starter.diScope = new di.Scope('Textbus');

exports.ATTRIBUTE_LIST = ATTRIBUTE_LIST;
exports.Attribute = Attribute;
exports.COMPONENT_LIST = COMPONENT_LIST;
exports.ChangeMarker = ChangeMarker;
exports.Content = Content;
exports.ContextMenuEvent = ContextMenuEvent;
exports.DeltaLite = DeltaLite;
exports.Event = Event;
exports.FORMATTER_LIST = FORMATTER_LIST;
exports.Format = Format;
exports.Formatter = Formatter;
exports.Fragment = Fragment;
exports.GetRangesEvent = GetRangesEvent;
exports.HISTORY_STACK_SIZE = HISTORY_STACK_SIZE;
exports.History = History;
exports.NativeRenderer = NativeRenderer;
exports.NativeSelectionBridge = NativeSelectionBridge;
exports.READONLY = READONLY;
exports.Ref = Ref;
exports.RootComponentRef = RootComponentRef;
exports.Slot = Slot;
exports.Slots = Slots;
exports.Starter = Starter;
exports.VElement = VElement;
exports.VFragment = VFragment;
exports.VTextNode = VTextNode;
exports.ZEN_CODING_DETECT = ZEN_CODING_DETECT;
exports.defineComponent = defineComponent;
exports.invokeListener = invokeListener;
exports.jsx = jsx;
exports.jsxs = jsxs;
exports.makeError = makeError;
exports.onBlur = onBlur;
exports.onBreak = onBreak;
exports.onCompositionEnd = onCompositionEnd;
exports.onCompositionStart = onCompositionStart;
exports.onCompositionUpdate = onCompositionUpdate;
exports.onContentDelete = onContentDelete;
exports.onContentDeleted = onContentDeleted;
exports.onContentInsert = onContentInsert;
exports.onContentInserted = onContentInserted;
exports.onContextMenu = onContextMenu;
exports.onDestroy = onDestroy;
exports.onDirtyViewClean = onDirtyViewClean;
exports.onFocus = onFocus;
exports.onFocusIn = onFocusIn;
exports.onFocusOut = onFocusOut;
exports.onGetRanges = onGetRanges;
exports.onParentSlotUpdated = onParentSlotUpdated;
exports.onPaste = onPaste;
exports.onSelected = onSelected;
exports.onSelectionFromEnd = onSelectionFromEnd;
exports.onSelectionFromFront = onSelectionFromFront;
exports.onSlotRemove = onSlotRemove;
exports.onSlotRemoved = onSlotRemoved;
exports.onUnselect = onUnselect;
exports.onViewChecked = onViewChecked;
exports.onViewInit = onViewInit;
exports.triggerContextMenu = triggerContextMenu;
exports.useContext = useContext;
exports.useDynamicShortcut = useDynamicShortcut;
exports.useRef = useRef;
exports.useSelf = useSelf;
exports.useSlots = useSlots;
exports.useState = useState;
Object.keys(reflectMetadata).forEach(function (k) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return reflectMetadata[k]; }
    });
});
Object.keys(di).forEach(function (k) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return di[k]; }
    });
});
Object.keys(stream).forEach(function (k) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return stream[k]; }
    });
});
