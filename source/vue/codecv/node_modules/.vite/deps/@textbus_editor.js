import {
  __commonJS,
  __toESM
} from "./chunk-HUBM7RA2.js";

// node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "node_modules/prismjs/prism.js"(exports, module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism2 = function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _2 = {
        manual: _self2.Prism && _self2.Prism.manual,
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token2) {
              return new Token2(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          type: function(o2) {
            return Object.prototype.toString.call(o2).slice(8, -1);
          },
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          clone: function deepClone(o2, visited) {
            visited = visited || {};
            var clone;
            var id;
            switch (_2.util.type(o2)) {
              case "Object":
                id = _2.util.objId(o2);
                if (visited[id]) {
                  return visited[id];
                }
                clone = {};
                visited[id] = clone;
                for (var key in o2) {
                  if (o2.hasOwnProperty(key)) {
                    clone[key] = deepClone(o2[key], visited);
                  }
                }
                return clone;
              case "Array":
                id = _2.util.objId(o2);
                if (visited[id]) {
                  return visited[id];
                }
                clone = [];
                visited[id] = clone;
                o2.forEach(function(v2, i2) {
                  clone[i2] = deepClone(v2, visited);
                });
                return clone;
              default:
                return o2;
            }
          },
          getLanguage: function(element) {
            while (element) {
              var m2 = lang.exec(element.className);
              if (m2) {
                return m2[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return document.currentScript;
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i2 in scripts) {
                  if (scripts[i2].src == src) {
                    return scripts[i2];
                  }
                }
              }
              return null;
            }
          },
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        languages: {
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          extend: function(id, redef) {
            var lang2 = _2.util.clone(_2.languages[id]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          insertBefore: function(inside, before, insert, root) {
            root = root || _2.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _2.languages.DFS(_2.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          DFS: function DFS(o2, callback, type, visited) {
            visited = visited || {};
            var objId = _2.util.objId;
            for (var i2 in o2) {
              if (o2.hasOwnProperty(i2)) {
                callback.call(o2, i2, o2[i2], type || i2);
                var property = o2[i2];
                var propertyType = _2.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i2, visited);
                }
              }
            }
          }
        },
        plugins: {},
        highlightAll: function(async, callback) {
          _2.highlightAllUnder(document, async, callback);
        },
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _2.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _2.hooks.run("before-all-elements-highlight", env);
          for (var i2 = 0, element; element = env.elements[i2++]; ) {
            _2.highlightElement(element, async === true, env.callback);
          }
        },
        highlightElement: function(element, async, callback) {
          var language = _2.util.getLanguage(element);
          var grammar = _2.languages[language];
          _2.util.setLanguage(element, language);
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _2.util.setLanguage(parent, language);
          }
          var code = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _2.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _2.hooks.run("after-highlight", env);
            _2.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _2.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _2.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _2.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_2.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_2.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_2.highlight(env.code, env.grammar, env.language));
          }
        },
        highlight: function(text2, grammar, language) {
          var env = {
            code: text2,
            grammar,
            language
          };
          _2.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _2.tokenize(env.code, env.grammar);
          _2.hooks.run("after-tokenize", env);
          return Token2.stringify(_2.util.encode(env.tokens), env.language);
        },
        tokenize: function(text2, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text2);
          matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        hooks: {
          all: {},
          add: function(name, callback) {
            var hooks = _2.hooks.all;
            hooks[name] = hooks[name] || [];
            hooks[name].push(callback);
          },
          run: function(name, env) {
            var callbacks = _2.hooks.all[name];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i2 = 0, callback; callback = callbacks[i2++]; ) {
              callback(env);
            }
          }
        },
        Token: Token2
      };
      _self2.Prism = _2;
      function Token2(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token2.stringify = function stringify2(o2, language) {
        if (typeof o2 == "string") {
          return o2;
        }
        if (Array.isArray(o2)) {
          var s2 = "";
          o2.forEach(function(e) {
            s2 += stringify2(e, language);
          });
          return s2;
        }
        var env = {
          type: o2.type,
          content: stringify2(o2.content, language),
          tag: "span",
          classes: ["token", o2.type],
          attributes: {},
          language
        };
        var aliases = o2.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _2.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
          attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text2, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text2);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j2 = 0; j2 < patterns.length; ++j2) {
            if (rematch && rematch.cause == token + "," + j2) {
              return;
            }
            var patternObj = patterns[j2];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text2.length) {
                return;
              }
              if (str instanceof Token2) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text2, lookbehind);
                if (!match || match.index >= text2.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p2 = pos;
                p2 += currentNode.value.length;
                while (from >= p2) {
                  currentNode = currentNode.next;
                  p2 += currentNode.value.length;
                }
                p2 -= currentNode.value.length;
                pos = p2;
                if (currentNode.value instanceof Token2) {
                  continue;
                }
                for (var k2 = currentNode; k2 !== tokenList.tail && (p2 < to || typeof k2.value === "string"); k2 = k2.next) {
                  removeCount++;
                  p2 += k2.value.length;
                }
                removeCount--;
                str = text2.slice(pos, p2);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token2(token, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j2,
                  reach
                };
                matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i2 = 0; i2 < count && next !== list.tail; i2++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i2;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _2;
        }
        if (!_2.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_2.highlight(code, _2.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _2;
      }
      var script = _2.util.currentScript();
      if (script) {
        _2.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _2.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_2.manual) {
          _2.highlightAll();
        }
      }
      if (!_2.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _2;
    }(_self);
    if (typeof module !== "undefined" && module.exports) {
      module.exports = Prism2;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism2;
    }
    Prism2.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
    Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
    Prism2.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
      value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism2.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism2.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism2.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
      value: function(attrName, lang) {
        Prism2.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism2.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism2.languages.html = Prism2.languages.markup;
    Prism2.languages.mathml = Prism2.languages.markup;
    Prism2.languages.svg = Prism2.languages.markup;
    Prism2.languages.xml = Prism2.languages.extend("markup", {});
    Prism2.languages.ssml = Prism2.languages.xml;
    Prism2.languages.atom = Prism2.languages.xml;
    Prism2.languages.rss = Prism2.languages.xml;
    (function(Prism3) {
      var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism3.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
          }
        },
        "url": {
          pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
      var markup = Prism3.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism2);
    Prism2.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism2.languages.javascript = Prism2.languages.extend("clike", {
      "class-name": [
        Prism2.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism2.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism2.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism2.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism2.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism2.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism2.languages.markup) {
      Prism2.languages.markup.tag.addInlined("script", "javascript");
      Prism2.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism2.languages.js = Prism2.languages.javascript;
    (function() {
      if (typeof Prism2 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading\u2026";
      var FAILURE_MESSAGE = function(status, message) {
        return "\u2716 Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range) {
        var m2 = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m2) {
          var start = Number(m2[1]);
          var comma = m2[2];
          var end = m2[3];
          if (!comma) {
            return [start, start];
          }
          if (!end) {
            return [start, void 0];
          }
          return [start, Number(end)];
        }
        return void 0;
      }
      Prism2.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism2.hooks.add("before-sanity-check", function(env) {
        var pre = env.element;
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          Prism2.util.setLanguage(code, language);
          Prism2.util.setLanguage(pre, language);
          var autoloader = Prism2.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          loadFile(
            src,
            function(text2) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range = parseRange(pre.getAttribute("data-range"));
              if (range) {
                var lines = text2.split(/\r\n?|\n/g);
                var start = range[0];
                var end = range[1] == null ? lines.length : range[1];
                if (start < 0) {
                  start += lines.length;
                }
                start = Math.max(0, Math.min(start - 1, lines.length));
                if (end < 0) {
                  end += lines.length;
                }
                end = Math.max(0, Math.min(end, lines.length));
                text2 = lines.slice(start, end).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start + 1));
                }
              }
              code.textContent = text2;
              Prism2.highlightElement(code);
            },
            function(error) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code.textContent = error;
            }
          );
        }
      });
      Prism2.plugins.fileHighlight = {
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i2 = 0, element; element = elements[i2++]; ) {
            Prism2.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism2.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames2() {
        var classes = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames2.apply(null, arg);
              if (inner) {
                classes.push(inner);
              }
            }
          } else if (argType === "object") {
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
              classes.push(arg.toString());
              continue;
            }
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          }
        }
        return classes.join(" ");
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames2.default = classNames2;
        module.exports = classNames2;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames2;
        });
      } else {
        window.classNames = classNames2;
      }
    })();
  }
});

// node_modules/reflect-metadata/Reflect.js
var Reflect2;
(function(Reflect3) {
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
    var exporter = makeExporter(Reflect3);
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect3;
    } else {
      exporter = makeExporter(root.Reflect, exporter);
    }
    factory(exporter);
    function makeExporter(target, previous) {
      return function(key, value) {
        if (typeof target[key] !== "function") {
          Object.defineProperty(target, key, { configurable: true, writable: true, value });
        }
        if (previous)
          previous(key, value);
      };
    }
  })(function(exporter) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = { __proto__: [] } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({ __proto__: null });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map2, key) {
        return hasOwn.call(map2, key);
      } : function(map2, key) {
        return key in map2;
      },
      get: downLevel ? function(map2, key) {
        return hasOwn.call(map2, key) ? map2[key] : void 0;
      } : function(map2, key) {
        return map2[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var usePolyfill = typeof process === "object" && process["env"] && process["env"]["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
    var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var Metadata = new _WeakMap();
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsObject(target))
          throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError();
        if (IsNull(attributes))
          attributes = void 0;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsConstructor(target))
          throw new TypeError();
        return DecorateConstructor(decorators, target);
      }
    }
    exporter("decorate", decorate);
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter("metadata", metadata);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var metadataMap = GetOrCreateMetadataMap(target, propertyKey, false);
      if (IsUndefined(metadataMap))
        return false;
      if (!metadataMap.delete(metadataKey))
        return false;
      if (metadataMap.size > 0)
        return true;
      var targetMetadata = Metadata.get(target);
      targetMetadata.delete(propertyKey);
      if (targetMetadata.size > 0)
        return true;
      Metadata.delete(target);
      return true;
    }
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
        var decorator = decorators[i2];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
        var decorator = decorators[i2];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function GetOrCreateMetadataMap(O2, P2, Create) {
      var targetMetadata = Metadata.get(O2);
      if (IsUndefined(targetMetadata)) {
        if (!Create)
          return void 0;
        targetMetadata = new _Map();
        Metadata.set(O2, targetMetadata);
      }
      var metadataMap = targetMetadata.get(P2);
      if (IsUndefined(metadataMap)) {
        if (!Create)
          return void 0;
        metadataMap = new _Map();
        targetMetadata.set(P2, metadataMap);
      }
      return metadataMap;
    }
    function OrdinaryHasMetadata(MetadataKey, O2, P2) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O2, P2);
      if (hasOwn2)
        return true;
      var parent = OrdinaryGetPrototypeOf(O2);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P2);
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O2, P2) {
      var metadataMap = GetOrCreateMetadataMap(O2, P2, false);
      if (IsUndefined(metadataMap))
        return false;
      return ToBoolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O2, P2) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O2, P2);
      if (hasOwn2)
        return OrdinaryGetOwnMetadata(MetadataKey, O2, P2);
      var parent = OrdinaryGetPrototypeOf(O2);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P2);
      return void 0;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O2, P2) {
      var metadataMap = GetOrCreateMetadataMap(O2, P2, false);
      if (IsUndefined(metadataMap))
        return void 0;
      return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O2, P2) {
      var metadataMap = GetOrCreateMetadataMap(O2, P2, true);
      metadataMap.set(MetadataKey, MetadataValue);
    }
    function OrdinaryMetadataKeys(O2, P2) {
      var ownKeys = OrdinaryOwnMetadataKeys(O2, P2);
      var parent = OrdinaryGetPrototypeOf(O2);
      if (parent === null)
        return ownKeys;
      var parentKeys = OrdinaryMetadataKeys(parent, P2);
      if (parentKeys.length <= 0)
        return ownKeys;
      if (ownKeys.length <= 0)
        return parentKeys;
      var set = new _Set();
      var keys = [];
      for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a2 = 0, parentKeys_1 = parentKeys; _a2 < parentKeys_1.length; _a2++) {
        var key = parentKeys_1[_a2];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(O2, P2) {
      var keys = [];
      var metadataMap = GetOrCreateMetadataMap(O2, P2, false);
      if (IsUndefined(metadataMap))
        return keys;
      var keysObj = metadataMap.keys();
      var iterator = GetIterator(keysObj);
      var k2 = 0;
      while (true) {
        var next = IteratorStep(iterator);
        if (!next) {
          keys.length = k2;
          return keys;
        }
        var nextValue = IteratorValue(next);
        try {
          keys[k2] = nextValue;
        } catch (e) {
          try {
            IteratorClose(iterator);
          } finally {
            throw e;
          }
        }
        k2++;
      }
    }
    function Type(x2) {
      if (x2 === null)
        return 1;
      switch (typeof x2) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x2 === null ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x2) {
      return x2 === void 0;
    }
    function IsNull(x2) {
      return x2 === null;
    }
    function IsSymbol(x2) {
      return typeof x2 === "symbol";
    }
    function IsObject(x2) {
      return typeof x2 === "object" ? x2 !== null : typeof x2 === "function";
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    function OrdinaryToPrimitive(O2, hint) {
      if (hint === "string") {
        var toString_1 = O2.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O2);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O2.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O2);
          if (!IsObject(result))
            return result;
        }
      } else {
        var valueOf = O2.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O2);
          if (!IsObject(result))
            return result;
        }
        var toString_2 = O2.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O2);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(argument, 3);
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    function IsPropertyKey(argument) {
      switch (Type(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    function GetMethod(V, P2) {
      var func = V[P2];
      if (func === void 0 || func === null)
        return void 0;
      if (!IsCallable(func))
        throw new TypeError();
      return func;
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError();
      var iterator = method.call(obj);
      if (!IsObject(iterator))
        throw new TypeError();
      return iterator;
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IteratorStep(iterator) {
      var result = iterator.next();
      return result.done ? false : result;
    }
    function IteratorClose(iterator) {
      var f2 = iterator["return"];
      if (f2)
        f2.call(iterator);
    }
    function OrdinaryGetPrototypeOf(O2) {
      var proto = Object.getPrototypeOf(O2);
      if (typeof O2 !== "function" || O2 === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype = O2.prototype;
      var prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O2)
        return proto;
      return constructor;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = function() {
        function MapIterator2(keys, values, selector) {
          this._index = 0;
          this._keys = keys;
          this._values = values;
          this._selector = selector;
        }
        MapIterator2.prototype["@@iterator"] = function() {
          return this;
        };
        MapIterator2.prototype[iteratorSymbol] = function() {
          return this;
        };
        MapIterator2.prototype.next = function() {
          var index = this._index;
          if (index >= 0 && index < this._keys.length) {
            var result = this._selector(this._keys[index], this._values[index]);
            if (index + 1 >= this._keys.length) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            } else {
              this._index++;
            }
            return { value: result, done: false };
          }
          return { value: void 0, done: true };
        };
        MapIterator2.prototype.throw = function(error) {
          if (this._index >= 0) {
            this._index = -1;
            this._keys = arraySentinel;
            this._values = arraySentinel;
          }
          throw error;
        };
        MapIterator2.prototype.return = function(value) {
          if (this._index >= 0) {
            this._index = -1;
            this._keys = arraySentinel;
            this._values = arraySentinel;
          }
          return { value, done: true };
        };
        return MapIterator2;
      }();
      return function() {
        function Map2() {
          this._keys = [];
          this._values = [];
          this._cacheKey = cacheSentinel;
          this._cacheIndex = -2;
        }
        Object.defineProperty(Map2.prototype, "size", {
          get: function() {
            return this._keys.length;
          },
          enumerable: true,
          configurable: true
        });
        Map2.prototype.has = function(key) {
          return this._find(key, false) >= 0;
        };
        Map2.prototype.get = function(key) {
          var index = this._find(key, false);
          return index >= 0 ? this._values[index] : void 0;
        };
        Map2.prototype.set = function(key, value) {
          var index = this._find(key, true);
          this._values[index] = value;
          return this;
        };
        Map2.prototype.delete = function(key) {
          var index = this._find(key, false);
          if (index >= 0) {
            var size = this._keys.length;
            for (var i2 = index + 1; i2 < size; i2++) {
              this._keys[i2 - 1] = this._keys[i2];
              this._values[i2 - 1] = this._values[i2];
            }
            this._keys.length--;
            this._values.length--;
            if (key === this._cacheKey) {
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            }
            return true;
          }
          return false;
        };
        Map2.prototype.clear = function() {
          this._keys.length = 0;
          this._values.length = 0;
          this._cacheKey = cacheSentinel;
          this._cacheIndex = -2;
        };
        Map2.prototype.keys = function() {
          return new MapIterator(this._keys, this._values, getKey);
        };
        Map2.prototype.values = function() {
          return new MapIterator(this._keys, this._values, getValue);
        };
        Map2.prototype.entries = function() {
          return new MapIterator(this._keys, this._values, getEntry);
        };
        Map2.prototype["@@iterator"] = function() {
          return this.entries();
        };
        Map2.prototype[iteratorSymbol] = function() {
          return this.entries();
        };
        Map2.prototype._find = function(key, insert) {
          if (this._cacheKey !== key) {
            this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
          }
          if (this._cacheIndex < 0 && insert) {
            this._cacheIndex = this._keys.length;
            this._keys.push(key);
            this._values.push(void 0);
          }
          return this._cacheIndex;
        };
        return Map2;
      }();
      function getKey(key, _2) {
        return key;
      }
      function getValue(_2, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    function CreateSetPolyfill() {
      return function() {
        function Set2() {
          this._map = new _Map();
        }
        Object.defineProperty(Set2.prototype, "size", {
          get: function() {
            return this._map.size;
          },
          enumerable: true,
          configurable: true
        });
        Set2.prototype.has = function(value) {
          return this._map.has(value);
        };
        Set2.prototype.add = function(value) {
          return this._map.set(value, value), this;
        };
        Set2.prototype.delete = function(value) {
          return this._map.delete(value);
        };
        Set2.prototype.clear = function() {
          this._map.clear();
        };
        Set2.prototype.keys = function() {
          return this._map.keys();
        };
        Set2.prototype.values = function() {
          return this._map.values();
        };
        Set2.prototype.entries = function() {
          return this._map.entries();
        };
        Set2.prototype["@@iterator"] = function() {
          return this.keys();
        };
        Set2.prototype[iteratorSymbol] = function() {
          return this.keys();
        };
        return Set2;
      }();
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys = HashMap.create();
      var rootKey = CreateUniqueKey();
      return function() {
        function WeakMap2() {
          this._key = CreateUniqueKey();
        }
        WeakMap2.prototype.has = function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          return table !== void 0 ? HashMap.has(table, this._key) : false;
        };
        WeakMap2.prototype.get = function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          return table !== void 0 ? HashMap.get(table, this._key) : void 0;
        };
        WeakMap2.prototype.set = function(target, value) {
          var table = GetOrCreateWeakMapTable(target, true);
          table[this._key] = value;
          return this;
        };
        WeakMap2.prototype.delete = function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          return table !== void 0 ? delete table[this._key] : false;
        };
        WeakMap2.prototype.clear = function() {
          this._key = CreateUniqueKey();
        };
        return WeakMap2;
      }();
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create)
            return void 0;
          Object.defineProperty(target, rootKey, { value: HashMap.create() });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer, size) {
        for (var i2 = 0; i2 < size; ++i2)
          buffer[i2] = Math.random() * 255 | 0;
        return buffer;
      }
      function GenRandomBytes(size) {
        if (typeof Uint8Array === "function") {
          if (typeof crypto !== "undefined")
            return crypto.getRandomValues(new Uint8Array(size));
          if (typeof msCrypto !== "undefined")
            return msCrypto.getRandomValues(new Uint8Array(size));
          return FillRandomBytes(new Uint8Array(size), size);
        }
        return FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 79 | 64;
        data[8] = data[8] & 191 | 128;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    function MakeDictionary(obj) {
      obj.__ = void 0;
      delete obj.__;
      return obj;
    }
  });
})(Reflect2 || (Reflect2 = {}));

// node_modules/@tanbo/di/bundles/index.esm.js
function stringify(token) {
  if (typeof token === "string") {
    return token;
  }
  if (Array.isArray(token)) {
    return "[" + token.map(stringify).join(", ") + "]";
  }
  if (token == null) {
    return "" + token;
  }
  if (token.name) {
    return "".concat(token.name);
  }
  if (token.token) {
    return "".concat(token.token);
  }
  var res = token.toString();
  if (res == null) {
    return "" + res;
  }
  var newLineIndex = res.indexOf("\n");
  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}
function makeInjectError(name) {
  return function injectError(token) {
    var error = new Error("No provide for `".concat(stringify(token), "`!"));
    error.name = name;
    return error;
  };
}
function makeProvideScopeError(name) {
  return function provideError(token) {
    var error = new Error("Can not found provide scope `".concat(stringify(token), "`!"));
    error.name = name;
    return error;
  };
}
var Annotations = function() {
  function Annotations2() {
    this.classes = /* @__PURE__ */ new Map();
    this.props = /* @__PURE__ */ new Map();
    this.methods = /* @__PURE__ */ new Map();
    this.params = /* @__PURE__ */ new Map();
  }
  Annotations2.prototype.setClassMetadata = function(token, params) {
    this.classes.set(token, params);
  };
  Annotations2.prototype.getClassMetadata = function(token) {
    return this.classes.get(token);
  };
  Annotations2.prototype.getClassMetadataKeys = function() {
    return Array.from(this.classes.keys());
  };
  Annotations2.prototype.pushParamMetadata = function(token, params) {
    if (!this.params.has(token)) {
      this.params.set(token, [params]);
    } else {
      this.params.get(token).push(params);
    }
  };
  Annotations2.prototype.getParamMetadata = function(token) {
    return this.params.get(token);
  };
  Annotations2.prototype.getParamMetadataKeys = function() {
    return Array.from(this.params.keys());
  };
  Annotations2.prototype.getPropMetadataKeys = function() {
    return Array.from(this.props.keys());
  };
  Annotations2.prototype.pushPropMetadata = function(token, params) {
    if (!this.props.has(token)) {
      this.props.set(token, [params]);
    } else {
      this.props.get(token).push(params);
    }
  };
  Annotations2.prototype.getPropMetadata = function(token) {
    return this.props.get(token);
  };
  Annotations2.prototype.pushMethodMetadata = function(token, params) {
    if (!this.methods.has(token)) {
      this.methods.set(token, [params]);
    } else {
      this.methods.get(token).push(params);
    }
  };
  Annotations2.prototype.getMethodMetadata = function(token) {
    return this.methods.get(token);
  };
  return Annotations2;
}();
function makeParamDecorator(token, metadata) {
  return function(target, propertyKey, parameterIndex) {
    var annotations = getAnnotations(target);
    annotations.pushParamMetadata(token, {
      propertyKey,
      parameterIndex,
      metadata
    });
  };
}
function makePropertyDecorator(token, injectToken, contextCallback) {
  return function(target, propertyKey) {
    var annotations = getAnnotations(target.constructor);
    annotations.pushPropMetadata(token, {
      injectToken: injectToken || Reflect.getMetadata("design:type", target, propertyKey),
      propertyKey,
      contextCallback
    });
  };
}
function makeClassDecorator(token, metadata) {
  return function(target) {
    var annotations = getAnnotations(target);
    annotations.setClassMetadata(token, {
      paramTypes: Reflect.getMetadata("design:paramtypes", target),
      metadata
    });
  };
}
function getAnnotations(target) {
  var key = "__annotations__";
  if (!target.hasOwnProperty(key)) {
    target[key] = new Annotations();
  }
  return target[key];
}
var ForwardRef = function() {
  function ForwardRef2(forwardRefFn) {
    this.forwardRefFn = forwardRefFn;
  }
  ForwardRef2.prototype.getRef = function() {
    return this.forwardRefFn();
  };
  return ForwardRef2;
}();
var Scope = function() {
  function Scope2(name) {
    this.name = name;
  }
  Scope2.prototype.toString = function() {
    return this.name || "[anonymous provide scope]";
  };
  return Scope2;
}();
var Injectable = function InjectableDecorator(options) {
  if (this instanceof InjectableDecorator) {
    this.provideIn = (options === null || options === void 0 ? void 0 : options.provideIn) || null;
  } else {
    return makeClassDecorator(Injectable, new Injectable(options));
  }
};
var InjectionToken = function() {
  function InjectionToken2(description) {
    this.description = description;
  }
  InjectionToken2.prototype.toString = function() {
    return this.description || "[anonymous injection token]";
  };
  return InjectionToken2;
}();
var InjectFlags;
(function(InjectFlags2) {
  InjectFlags2["Default"] = "Default";
  InjectFlags2["Self"] = "Self";
  InjectFlags2["SkipSelf"] = "SkipSelf";
  InjectFlags2["Optional"] = "Optional";
})(InjectFlags || (InjectFlags = {}));
var Injector = function() {
  function Injector2() {
  }
  return Injector2;
}();
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign3(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var THROW_IF_NOT_FOUND = {
  __debug_value__: "THROW_IF_NOT_FOUND"
};
var nullInjectorErrorFn = makeInjectError("NullInjectorError");
var NullInjector = function(_super) {
  __extends(NullInjector2, _super);
  function NullInjector2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.parentInjector = null;
    return _this;
  }
  NullInjector2.prototype.get = function(token, notFoundValue) {
    if (notFoundValue === void 0) {
      notFoundValue = THROW_IF_NOT_FOUND;
    }
    if (notFoundValue === THROW_IF_NOT_FOUND) {
      throw nullInjectorErrorFn(token);
    }
    return notFoundValue;
  };
  return NullInjector2;
}(Injector);
var Inject = function InjectDecorator(token) {
  if (this instanceof Inject) {
    this.token = token;
  } else {
    return makeParamDecorator(Inject, new Inject(token));
  }
};
var Self = function SelfDecorator() {
  if (!(this instanceof Self)) {
    return makeParamDecorator(Self, new Self());
  }
};
var SkipSelf = function SkipSelfDecorator() {
  if (!(this instanceof SkipSelf)) {
    return makeParamDecorator(SkipSelf, new SkipSelf());
  }
};
var Optional = function OptionalDecorator() {
  if (!(this instanceof Optional)) {
    return makeParamDecorator(Optional, new Optional());
  }
};
var Prop = function PropDecorator(token, notFoundValue, flags) {
  if (notFoundValue === void 0) {
    notFoundValue = THROW_IF_NOT_FOUND;
  }
  if (!(this instanceof Prop)) {
    return makePropertyDecorator(Prop, token, function(instance, propertyName, token2, injector) {
      instance[propertyName] = injector.get(token2 instanceof ForwardRef ? token2.getRef() : token2, notFoundValue, flags);
    });
  }
};
function normalizeProvider(provider) {
  if (provider.useValue) {
    return normalizeValueProviderFactory(provider);
  }
  if (provider.useClass) {
    return normalizeClassProviderFactory(provider);
  }
  if (provider.useExisting) {
    return normalizeExistingProviderFactory(provider);
  }
  if (provider.useFactory) {
    return normalizeFactoryProviderFactory(provider);
  }
  if (provider.provide) {
    if (provider.provide instanceof InjectionToken) {
      return normalizeValueProviderFactory(provider);
    }
    return normalizeConstructorProviderFactory(provider);
  }
  return normalizeTypeProviderFactory(provider);
}
function normalizeValueProviderFactory(provider) {
  return {
    provide: provider.provide,
    scope: null,
    generateFactory: function() {
      return function() {
        return provider.useValue;
      };
    },
    deps: []
  };
}
function normalizeClassProviderFactory(provider) {
  var deps;
  var provideIn;
  if (provider.deps) {
    deps = normalizeDeps(provider.provide, provider.deps);
  } else {
    var resolvedClass = resolveClassParams(provider.useClass);
    provideIn = resolvedClass.scope;
    deps = normalizeDeps(provider.provide, resolvedClass.deps);
  }
  return {
    provide: provider.provide,
    scope: provideIn,
    deps,
    generateFactory: function(injector, cacheFn) {
      return function() {
        var _a2;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var instance = new ((_a2 = provider.useClass).bind.apply(_a2, __spreadArray([void 0], __read(args), false)))();
        cacheFn(provider.provide, instance);
        var propMetadataKeys = getAnnotations(provider.useClass).getPropMetadataKeys();
        propMetadataKeys.forEach(function(key) {
          var propsMetadata = getAnnotations(provider.useClass).getPropMetadata(key) || [];
          propsMetadata.forEach(function(item) {
            item.contextCallback(instance, item.propertyKey, item.injectToken, injector);
          });
        });
        return instance;
      };
    }
  };
}
function normalizeExistingProviderFactory(provider) {
  return {
    provide: provider.provide,
    scope: null,
    generateFactory: function(injector) {
      return function() {
        return injector.get(provider.useExisting);
      };
    },
    deps: []
  };
}
function normalizeFactoryProviderFactory(provider) {
  return {
    provide: provider.provide,
    scope: null,
    generateFactory: function() {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return provider.useFactory.apply(provider, __spreadArray([], __read(args), false));
      };
    },
    deps: normalizeDeps(provider.provide, provider.deps || [])
  };
}
function normalizeConstructorProviderFactory(provider) {
  return normalizeClassProviderFactory(__assign(__assign({}, provider), { useClass: provider.provide }));
}
function normalizeTypeProviderFactory(provider) {
  return normalizeClassProviderFactory({
    provide: provider,
    useClass: provider
  });
}
function resolveClassParams(construct) {
  var annotations = getAnnotations(construct);
  var metadata = annotations.getClassMetadata(Injectable);
  if (typeof metadata === "undefined") {
    throw new Error("Class `".concat(stringify(construct), "` is not injectable!"));
  }
  var deps = (metadata.paramTypes || []).map(function(i2) {
    return [i2];
  });
  var metadataKeys = [Inject, Self, SkipSelf, Optional];
  metadataKeys.forEach(function(key) {
    (annotations.getParamMetadata(key) || []).forEach(function(item) {
      deps[item.parameterIndex].push(item.metadata);
    });
  });
  return {
    scope: metadata.metadata.provideIn,
    deps
  };
}
function normalizeDeps(provide, deps) {
  return deps.map(function(dep, index) {
    var r2 = {
      injectKey: null,
      optional: false,
      visibility: null
    };
    if (!Array.isArray(dep)) {
      r2.injectKey = dep;
    } else {
      for (var i2 = 0; i2 < dep.length; i2++) {
        var item = dep[i2];
        if (item instanceof Inject) {
          r2.injectKey = item.token;
        } else if (item instanceof Self || item instanceof SkipSelf) {
          r2.visibility = item;
        } else if (item instanceof Optional) {
          r2.optional = true;
        } else {
          r2.injectKey = item;
        }
      }
    }
    if (typeof r2.injectKey === "undefined") {
      throw new Error("The ".concat(index, " th dependent parameter type of `").concat(stringify(provide), "` was not obtained,\nif the dependency is declared later, you can refer to it using `constructor(@Inject(forwardRef(() => [Type|InjectionToken])) paramName: [Type]) {}`"));
    }
    return r2;
  });
}
var reflectiveInjectorErrorFn = makeInjectError("ReflectiveInjectorError");
var provideScopeError = makeProvideScopeError("ProvideScopeError");
var ReflectiveInjector = function(_super) {
  __extends(ReflectiveInjector2, _super);
  function ReflectiveInjector2(parentInjector, staticProviders, scope) {
    var _this = _super.call(this) || this;
    _this.parentInjector = parentInjector;
    _this.staticProviders = staticProviders;
    _this.scope = scope;
    _this.recordValues = /* @__PURE__ */ new Map();
    _this.normalizedProviders = staticProviders.map(function(provide) {
      return normalizeProvider(provide);
    });
    return _this;
  }
  ReflectiveInjector2.prototype.get = function(token, notFoundValue, flags) {
    var _a2;
    if (notFoundValue === void 0) {
      notFoundValue = THROW_IF_NOT_FOUND;
    }
    flags = flags || InjectFlags.Default;
    if (flags === InjectFlags.SkipSelf) {
      if (this.parentInjector) {
        return this.parentInjector.get(token, notFoundValue);
      }
      if (notFoundValue !== THROW_IF_NOT_FOUND) {
        return notFoundValue;
      }
      throw reflectiveInjectorErrorFn(token);
    }
    if (this.recordValues.has(token)) {
      return this.recordValues.get(token);
    }
    for (var i2 = 0; i2 < this.normalizedProviders.length; i2++) {
      var normalizedProvider = this.normalizedProviders[i2];
      if (normalizedProvider.provide === token) {
        return this.getValue(token, THROW_IF_NOT_FOUND, normalizedProvider);
      }
    }
    if (!(token instanceof InjectionToken)) {
      var scope = (_a2 = getAnnotations(token).getClassMetadata(Injectable)) === null || _a2 === void 0 ? void 0 : _a2.metadata.provideIn;
      if (scope) {
        var normalizedProvider = normalizeProvider(token);
        if (this.scope === scope) {
          this.normalizedProviders.push(normalizedProvider);
          return this.getValue(token, THROW_IF_NOT_FOUND, normalizedProvider);
        }
        var parentInjector = this.parentInjector;
        if (!parentInjector || parentInjector instanceof NullInjector) {
          if (normalizedProvider.scope === "root") {
            this.normalizedProviders.push(normalizedProvider);
            return this.getValue(token, THROW_IF_NOT_FOUND, normalizedProvider);
          }
          if (notFoundValue !== THROW_IF_NOT_FOUND) {
            return notFoundValue;
          }
          throw provideScopeError(normalizedProvider.scope);
        }
      }
    }
    if (flags === InjectFlags.Self) {
      if (notFoundValue === THROW_IF_NOT_FOUND) {
        throw reflectiveInjectorErrorFn(token);
      }
      return notFoundValue;
    }
    if (this.parentInjector) {
      return this.parentInjector.get(token, notFoundValue, flags === InjectFlags.Optional ? InjectFlags.Optional : InjectFlags.Default);
    }
    if (notFoundValue === THROW_IF_NOT_FOUND) {
      throw reflectiveInjectorErrorFn(token);
    }
    return notFoundValue;
  };
  ReflectiveInjector2.prototype.getValue = function(token, notFoundValue, normalizedProvider) {
    var _this = this;
    if (notFoundValue === void 0) {
      notFoundValue = THROW_IF_NOT_FOUND;
    }
    var generateFactory = normalizedProvider.generateFactory, deps = normalizedProvider.deps;
    var params = this.resolveDeps(deps || [], notFoundValue);
    var value = this.recordValues.get(token);
    if (value) {
      return value;
    }
    var factory = generateFactory(this, function(token2, value2) {
      _this.recordValues.set(token2, value2);
    });
    value = factory.apply(void 0, __spreadArray([], __read(params), false));
    this.recordValues.set(token, value);
    return value;
  };
  ReflectiveInjector2.prototype.resolveDeps = function(deps, notFoundValue) {
    var _this = this;
    return deps.map(function(dep) {
      var reflectiveValue;
      var tryValue = {};
      var injectToken = dep.injectKey instanceof ForwardRef ? dep.injectKey.getRef() : dep.injectKey;
      if (dep.visibility instanceof Self) {
        reflectiveValue = _this.get(injectToken, tryValue, InjectFlags.Self);
      } else if (dep.visibility instanceof SkipSelf) {
        if (_this.parentInjector) {
          reflectiveValue = _this.parentInjector.get(injectToken, tryValue);
        } else {
          if (dep.optional) {
            if (notFoundValue === THROW_IF_NOT_FOUND) {
              return null;
            }
          }
          throw reflectiveInjectorErrorFn(injectToken);
        }
      } else {
        reflectiveValue = _this.get(injectToken, tryValue);
      }
      if (reflectiveValue === tryValue) {
        if (dep.optional) {
          if (notFoundValue === THROW_IF_NOT_FOUND) {
            return null;
          }
          return notFoundValue;
        }
        throw reflectiveInjectorErrorFn(injectToken);
      }
      return reflectiveValue;
    });
  };
  return ReflectiveInjector2;
}(Injector);

// node_modules/@tanbo/stream/bundles/index.esm.js
var Subscriber = class {
  constructor(destinationOrNext) {
    Object.defineProperty(this, "closed", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "syncErrorThrowable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "destinationOrNext", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (typeof destinationOrNext === "function") {
      this.destinationOrNext = {
        next: destinationOrNext
      };
    } else {
      this.destinationOrNext = destinationOrNext;
    }
  }
  next(value) {
    if (this.closed) {
      return;
    }
    if (this.destinationOrNext.next) {
      this.syncErrorThrowable = false;
      this.destinationOrNext.next(value);
      this.syncErrorThrowable = true;
    }
  }
  error(err) {
    if (this.closed) {
      return;
    }
    this.closed = true;
    if (this.destinationOrNext.error) {
      this.syncErrorThrowable = false;
      this.destinationOrNext.error(err);
      this.syncErrorThrowable = true;
      this.destinationOrNext = null;
      return;
    }
    this.syncErrorThrowable = false;
    this.destinationOrNext = null;
    throw err;
  }
  complete() {
    if (this.closed) {
      return;
    }
    this.closed = true;
    if (this.destinationOrNext.complete) {
      this.syncErrorThrowable = false;
      this.destinationOrNext.complete();
      this.syncErrorThrowable = true;
    }
    this.destinationOrNext = null;
  }
};
function noop() {
}
var Subscription = class {
  constructor(unsubscribeCallback) {
    Object.defineProperty(this, "unsubscribeCallback", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: unsubscribeCallback
    });
    Object.defineProperty(this, "subs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "isStopped", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
  }
  add(...subscriptions) {
    if (this.isStopped) {
      return this;
    }
    this.subs.push(...subscriptions);
    return this;
  }
  unsubscribe() {
    this.isStopped = true;
    if (this.unsubscribeCallback) {
      this.unsubscribeCallback();
      this.unsubscribeCallback = noop;
    }
    this.subs.forEach((i2) => i2.unsubscribe());
    this.subs = [];
  }
};
var Observable = class {
  constructor(source = (observer) => {
    observer.complete();
  }) {
    Object.defineProperty(this, "source", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: source
    });
  }
  pipe(...operators) {
    if (operators.length === 0) {
      return this;
    }
    return operators.reduce((stream, nextOperator) => {
      return nextOperator(new Observable((subscriber) => {
        return stream.subscribe(subscriber);
      }));
    }, this);
  }
  subscribe(observer = noop) {
    const subscriber = this.toSubscriber(observer);
    return this.trySubscribe(subscriber);
  }
  toPromise() {
    return new Promise((resolve, reject) => {
      this.subscribe({
        next(value) {
          resolve(value);
        },
        error(err) {
          reject(err);
        }
      });
    });
  }
  toSubscriber(observer) {
    if (typeof observer === "function") {
      return new Subscriber({
        next: observer
      });
    }
    return new Subscriber(observer);
  }
  trySubscribe(subscriber) {
    let s2;
    try {
      s2 = this.source(subscriber);
    } catch (e) {
      if (subscriber.syncErrorThrowable) {
        subscriber.error(e);
      } else {
        throw e;
      }
    }
    if (typeof s2 === "function") {
      return new Subscription(function() {
        subscriber.closed = true;
        s2();
      });
    } else if (s2 instanceof Subscription) {
      return new Subscription(function() {
        subscriber.closed = true;
        s2.unsubscribe();
      });
    }
    return new Subscription(function() {
      subscriber.closed = true;
    });
  }
};
var Subject = class extends Observable {
  constructor() {
    super((subscriber) => {
      this.subscribers.push(subscriber);
    });
    Object.defineProperty(this, "subscribers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
  }
  asObservable() {
    return new Observable((subscriber) => {
      this.subscribe(subscriber);
    });
  }
  next(newValue) {
    [...this.subscribers].forEach((subscriber) => {
      try {
        subscriber.next(newValue);
      } catch (e) {
        if (subscriber.syncErrorThrowable) {
          subscriber.error(e);
        } else {
          throw e;
        }
      }
    });
  }
  error(err) {
    [...this.subscribers].forEach((observer) => {
      observer.error(err);
    });
  }
  complete() {
    [...this.subscribers].forEach((observer) => {
      observer.complete();
    });
  }
};
function fromEvent(source, type, capture = false) {
  return new Observable((subscriber) => {
    function listenFn(event) {
      return subscriber.next(event);
    }
    source.addEventListener(type, listenFn, capture);
    return function() {
      source.removeEventListener(type, listenFn);
    };
  });
}
function fromPromise(input) {
  return new Observable((subscriber) => {
    input.then((v2) => {
      subscriber.next(v2);
      subscriber.complete();
    }).catch((e) => {
      subscriber.error(e);
    });
  });
}
function merge(...inputs) {
  return new Observable((subscriber) => {
    if (inputs.length === 0) {
      subscriber.complete();
    }
    const marks = inputs.map((i2) => {
      return {
        source: i2,
        isComplete: false
      };
    });
    const subs = marks.map((s2) => {
      return s2.source.subscribe({
        next(value) {
          subscriber.next(value);
        },
        error(err) {
          subscriber.error(err);
        },
        complete() {
          s2.isComplete = true;
          if (marks.every((i2) => i2.isComplete)) {
            subscriber.complete();
          }
        }
      });
    });
    return function() {
      subs.forEach((i2) => i2.unsubscribe());
    };
  });
}
function of(...data) {
  return new Observable((subscriber) => {
    data.forEach((i2) => subscriber.next(i2));
    subscriber.complete();
  });
}
function auditTime(time) {
  return function(source) {
    return new Observable((subscriber) => {
      let canPublish = true;
      let timer = null;
      let value;
      let isComplete = false;
      let hasError = false;
      const sub = source.subscribe({
        next(v2) {
          if (canPublish) {
            value = v2;
            canPublish = false;
            timer = setTimeout(() => {
              timer = null;
              canPublish = true;
              subscriber.next(value);
              if (isComplete) {
                subscriber.complete();
              }
            }, time);
          }
        },
        error(err) {
          hasError = true;
          if (sub) {
            sub.unsubscribe();
          }
          subscriber.error(err);
        },
        complete() {
          if (timer === null) {
            subscriber.complete();
          } else {
            isComplete = true;
          }
        }
      });
      if (hasError) {
        sub.unsubscribe();
      }
      return function() {
        clearTimeout(timer);
        sub.unsubscribe();
      };
    });
  };
}
function debounceTime(time) {
  return function(source) {
    return new Observable((subscriber) => {
      let timer = null;
      let isComplete = false;
      const sub = source.subscribe({
        next(v2) {
          clearTimeout(timer);
          timer = setTimeout(function() {
            timer = null;
            subscriber.next(v2);
            if (isComplete) {
              subscriber.complete();
            }
          }, time);
        },
        error(err) {
          subscriber.error(err);
        },
        complete() {
          if (timer === null) {
            subscriber.complete();
          } else {
            isComplete = true;
          }
        }
      });
      return function() {
        timer = null;
        clearTimeout(timer);
        sub.unsubscribe();
      };
    });
  };
}
function delay(time = 0) {
  return function(source) {
    return new Observable((subscriber) => {
      const timers = [];
      let isComplete = false;
      const sub = source.subscribe({
        next(v2) {
          timers.push(setTimeout(function() {
            timers.shift();
            subscriber.next(v2);
            if (isComplete && timers.length === 0) {
              subscriber.complete();
            }
          }, time));
        },
        error(err) {
          subscriber.error(err);
        },
        complete() {
          isComplete = true;
        }
      });
      return function() {
        timers.forEach((i2) => clearTimeout(i2));
        sub.unsubscribe();
      };
    });
  };
}
function distinctUntilChanged(comparator) {
  return function(source) {
    return new Observable((subscriber) => {
      let lastValue = {};
      let isFirst = true;
      return source.subscribe({
        next(value) {
          if (isFirst) {
            isFirst = false;
            lastValue = value;
            subscriber.next(value);
            return;
          }
          if (comparator) {
            const b2 = comparator(lastValue, value);
            lastValue = value;
            if (b2) {
              subscriber.next(value);
            }
          } else if (value !== lastValue) {
            lastValue = value;
            subscriber.next(value);
          }
        },
        error(err) {
          subscriber.error(err);
        },
        complete() {
          subscriber.complete();
        }
      });
    });
  };
}
function filter(handle) {
  return function(source) {
    return new Observable((subscriber) => {
      return source.subscribe({
        next(value) {
          if (handle(value)) {
            subscriber.next(value);
          }
        },
        error(err) {
          subscriber.error(err);
        },
        complete() {
          subscriber.complete();
        }
      });
    });
  };
}
function map(handle) {
  return function(source) {
    return new Observable((subscriber) => {
      return source.subscribe({
        next(value) {
          subscriber.next(handle(value));
        },
        error(err) {
          subscriber.error(err);
        },
        complete() {
          subscriber.complete();
        }
      });
    });
  };
}
function microTask() {
  return function(source) {
    return new Observable((subscriber) => {
      let values = [];
      let task = null;
      let isComplete = false;
      return source.subscribe({
        next(v2) {
          values.push(v2);
          if (!task) {
            task = Promise.resolve().then(() => {
              const nextValues = values;
              values = [];
              task = null;
              subscriber.next(nextValues);
              if (isComplete) {
                subscriber.complete();
              }
            });
          }
        },
        error(err) {
          subscriber.error(err);
        },
        complete() {
          if (task === null) {
            subscriber.complete();
          } else {
            isComplete = true;
          }
        }
      });
    });
  };
}
function share() {
  return function(source) {
    const subject = new Subject();
    source.subscribe({
      next(value) {
        subject.next(value);
      },
      error(err) {
        subject.error(err);
      },
      complete() {
        subject.complete();
      }
    });
    return subject;
  };
}
function take(count) {
  return function(source) {
    return new Observable((subscriber) => {
      let i2 = 0;
      const subscription = new Subscription();
      let isComplete = false;
      const obs = {
        next(value) {
          if (i2 < count) {
            subscriber.next(value);
            i2++;
            if (i2 === count) {
              isComplete = true;
              subscription.unsubscribe();
              subscriber.complete();
            }
            return;
          }
          isComplete = true;
          subscriber.complete();
        },
        error(err) {
          subscriber.error(err);
        },
        complete() {
          subscriber.complete();
        }
      };
      subscription.add(source.subscribe(obs));
      if (isComplete) {
        subscription.unsubscribe();
      }
      return subscription;
    });
  };
}

// node_modules/immer/dist/immer.esm.js
function n(n2) {
  for (var r2 = arguments.length, t2 = Array(r2 > 1 ? r2 - 1 : 0), e = 1; e < r2; e++)
    t2[e - 1] = arguments[e];
  if (true) {
    var i2 = Y[n2], o2 = i2 ? "function" == typeof i2 ? i2.apply(null, t2) : i2 : "unknown error nr: " + n2;
    throw Error("[Immer] " + o2);
  }
  throw Error("[Immer] minified error nr: " + n2 + (t2.length ? " " + t2.map(function(n3) {
    return "'" + n3 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r(n2) {
  return !!n2 && !!n2[Q];
}
function t(n2) {
  var r2;
  return !!n2 && (function(n3) {
    if (!n3 || "object" != typeof n3)
      return false;
    var r3 = Object.getPrototypeOf(n3);
    if (null === r3)
      return true;
    var t2 = Object.hasOwnProperty.call(r3, "constructor") && r3.constructor;
    return t2 === Object || "function" == typeof t2 && Function.toString.call(t2) === Z;
  }(n2) || Array.isArray(n2) || !!n2[L] || !!(null === (r2 = n2.constructor) || void 0 === r2 ? void 0 : r2[L]) || s(n2) || v(n2));
}
function i(n2, r2, t2) {
  void 0 === t2 && (t2 = false), 0 === o(n2) ? (t2 ? Object.keys : nn)(n2).forEach(function(e) {
    t2 && "symbol" == typeof e || r2(e, n2[e], n2);
  }) : n2.forEach(function(t3, e) {
    return r2(e, t3, n2);
  });
}
function o(n2) {
  var r2 = n2[Q];
  return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v(n2) ? 3 : 0;
}
function u(n2, r2) {
  return 2 === o(n2) ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
}
function a(n2, r2) {
  return 2 === o(n2) ? n2.get(r2) : n2[r2];
}
function f(n2, r2, t2) {
  var e = o(n2);
  2 === e ? n2.set(r2, t2) : 3 === e ? n2.add(t2) : n2[r2] = t2;
}
function c(n2, r2) {
  return n2 === r2 ? 0 !== n2 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
}
function s(n2) {
  return X && n2 instanceof Map;
}
function v(n2) {
  return q && n2 instanceof Set;
}
function p(n2) {
  return n2.o || n2.t;
}
function l(n2) {
  if (Array.isArray(n2))
    return Array.prototype.slice.call(n2);
  var r2 = rn(n2);
  delete r2[Q];
  for (var t2 = nn(r2), e = 0; e < t2.length; e++) {
    var i2 = t2[e], o2 = r2[i2];
    false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), r2);
}
function d(n2, e) {
  return void 0 === e && (e = false), y(n2) || r(n2) || !t(n2) || (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e && i(n2, function(n3, r2) {
    return d(r2, true);
  }, true)), n2;
}
function h() {
  n(2);
}
function y(n2) {
  return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
}
function b(r2) {
  var t2 = tn[r2];
  return t2 || n(18, r2), t2;
}
function m(n2, r2) {
  tn[n2] || (tn[n2] = r2);
}
function _() {
  return U || n(0), U;
}
function j(n2, r2) {
  r2 && (b("Patches"), n2.u = [], n2.s = [], n2.v = r2);
}
function g(n2) {
  O(n2), n2.p.forEach(S), n2.p = null;
}
function O(n2) {
  n2 === U && (U = n2.l);
}
function w(n2) {
  return U = { p: [], l: U, h: n2, m: true, _: 0 };
}
function S(n2) {
  var r2 = n2[Q];
  0 === r2.i || 1 === r2.i ? r2.j() : r2.g = true;
}
function P(r2, e) {
  e._ = e.p.length;
  var i2 = e.p[0], o2 = void 0 !== r2 && r2 !== i2;
  return e.h.O || b("ES5").S(e, r2, o2), o2 ? (i2[Q].P && (g(e), n(4)), t(r2) && (r2 = M(e, r2), e.l || x(e, r2)), e.u && b("Patches").M(i2[Q].t, r2, e.u, e.s)) : r2 = M(e, i2, []), g(e), e.u && e.v(e.u, e.s), r2 !== H ? r2 : void 0;
}
function M(n2, r2, t2) {
  if (y(r2))
    return r2;
  var e = r2[Q];
  if (!e)
    return i(r2, function(i2, o3) {
      return A(n2, e, r2, i2, o3, t2);
    }, true), r2;
  if (e.A !== n2)
    return r2;
  if (!e.P)
    return x(n2, e.t, true), e.t;
  if (!e.I) {
    e.I = true, e.A._--;
    var o2 = 4 === e.i || 5 === e.i ? e.o = l(e.k) : e.o, u2 = o2, a2 = false;
    3 === e.i && (u2 = new Set(o2), o2.clear(), a2 = true), i(u2, function(r3, i2) {
      return A(n2, e, o2, r3, i2, t2, a2);
    }), x(n2, o2, false), t2 && n2.u && b("Patches").N(e, t2, n2.u, n2.s);
  }
  return e.o;
}
function A(e, i2, o2, a2, c2, s2, v2) {
  if (c2 === o2 && n(5), r(c2)) {
    var p2 = M(e, c2, s2 && i2 && 3 !== i2.i && !u(i2.R, a2) ? s2.concat(a2) : void 0);
    if (f(o2, a2, p2), !r(p2))
      return;
    e.m = false;
  } else
    v2 && o2.add(c2);
  if (t(c2) && !y(c2)) {
    if (!e.h.D && e._ < 1)
      return;
    M(e, c2), i2 && i2.A.l || x(e, c2);
  }
}
function x(n2, r2, t2) {
  void 0 === t2 && (t2 = false), !n2.l && n2.h.D && n2.m && d(r2, t2);
}
function z(n2, r2) {
  var t2 = n2[Q];
  return (t2 ? p(t2) : n2)[r2];
}
function I(n2, r2) {
  if (r2 in n2)
    for (var t2 = Object.getPrototypeOf(n2); t2; ) {
      var e = Object.getOwnPropertyDescriptor(t2, r2);
      if (e)
        return e;
      t2 = Object.getPrototypeOf(t2);
    }
}
function k(n2) {
  n2.P || (n2.P = true, n2.l && k(n2.l));
}
function E(n2) {
  n2.o || (n2.o = l(n2.t));
}
function N(n2, r2, t2) {
  var e = s(r2) ? b("MapSet").F(r2, t2) : v(r2) ? b("MapSet").T(r2, t2) : n2.O ? function(n3, r3) {
    var t3 = Array.isArray(n3), e2 = { i: t3 ? 1 : 0, A: r3 ? r3.A : _(), P: false, I: false, R: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e2, o2 = en;
    t3 && (i2 = [e2], o2 = on);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
    return e2.k = f2, e2.j = a2, f2;
  }(r2, t2) : b("ES5").J(r2, t2);
  return (t2 ? t2.A : _()).p.push(e), e;
}
function R(e) {
  return r(e) || n(22, e), function n2(r2) {
    if (!t(r2))
      return r2;
    var e2, u2 = r2[Q], c2 = o(r2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b("ES5").K(u2)))
        return u2.t;
      u2.I = true, e2 = D(r2, c2), u2.I = false;
    } else
      e2 = D(r2, c2);
    return i(e2, function(r3, t2) {
      u2 && a(u2.t, r3) === t2 || f(e2, r3, n2(t2));
    }), 3 === c2 ? new Set(e2) : e2;
  }(e);
}
function D(n2, r2) {
  switch (r2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l(n2);
}
function T() {
  function e(n2) {
    if (!t(n2))
      return n2;
    if (Array.isArray(n2))
      return n2.map(e);
    if (s(n2))
      return new Map(Array.from(n2.entries()).map(function(n3) {
        return [n3[0], e(n3[1])];
      }));
    if (v(n2))
      return new Set(Array.from(n2).map(e));
    var r2 = Object.create(Object.getPrototypeOf(n2));
    for (var i2 in n2)
      r2[i2] = e(n2[i2]);
    return u(n2, L) && (r2[L] = n2[L]), r2;
  }
  function f2(n2) {
    return r(n2) ? e(n2) : n2;
  }
  var c2 = "add";
  m("Patches", { $: function(r2, t2) {
    return t2.forEach(function(t3) {
      for (var i2 = t3.path, u2 = t3.op, f3 = r2, s2 = 0; s2 < i2.length - 1; s2++) {
        var v2 = o(f3), p2 = i2[s2];
        "string" != typeof p2 && "number" != typeof p2 && (p2 = "" + p2), 0 !== v2 && 1 !== v2 || "__proto__" !== p2 && "constructor" !== p2 || n(24), "function" == typeof f3 && "prototype" === p2 && n(24), "object" != typeof (f3 = a(f3, p2)) && n(15, i2.join("/"));
      }
      var l2 = o(f3), d2 = e(t3.value), h2 = i2[i2.length - 1];
      switch (u2) {
        case "replace":
          switch (l2) {
            case 2:
              return f3.set(h2, d2);
            case 3:
              n(16);
            default:
              return f3[h2] = d2;
          }
        case c2:
          switch (l2) {
            case 1:
              return "-" === h2 ? f3.push(d2) : f3.splice(h2, 0, d2);
            case 2:
              return f3.set(h2, d2);
            case 3:
              return f3.add(d2);
            default:
              return f3[h2] = d2;
          }
        case "remove":
          switch (l2) {
            case 1:
              return f3.splice(h2, 1);
            case 2:
              return f3.delete(h2);
            case 3:
              return f3.delete(t3.value);
            default:
              return delete f3[h2];
          }
        default:
          n(17, u2);
      }
    }), r2;
  }, N: function(n2, r2, t2, e2) {
    switch (n2.i) {
      case 0:
      case 4:
      case 2:
        return function(n3, r3, t3, e3) {
          var o2 = n3.t, s2 = n3.o;
          i(n3.R, function(n4, i2) {
            var v2 = a(o2, n4), p2 = a(s2, n4), l2 = i2 ? u(o2, n4) ? "replace" : c2 : "remove";
            if (v2 !== p2 || "replace" !== l2) {
              var d2 = r3.concat(n4);
              t3.push("remove" === l2 ? { op: l2, path: d2 } : { op: l2, path: d2, value: p2 }), e3.push(l2 === c2 ? { op: "remove", path: d2 } : "remove" === l2 ? { op: c2, path: d2, value: f2(v2) } : { op: "replace", path: d2, value: f2(v2) });
            }
          });
        }(n2, r2, t2, e2);
      case 5:
      case 1:
        return function(n3, r3, t3, e3) {
          var i2 = n3.t, o2 = n3.R, u2 = n3.o;
          if (u2.length < i2.length) {
            var a2 = [u2, i2];
            i2 = a2[0], u2 = a2[1];
            var s2 = [e3, t3];
            t3 = s2[0], e3 = s2[1];
          }
          for (var v2 = 0; v2 < i2.length; v2++)
            if (o2[v2] && u2[v2] !== i2[v2]) {
              var p2 = r3.concat([v2]);
              t3.push({ op: "replace", path: p2, value: f2(u2[v2]) }), e3.push({ op: "replace", path: p2, value: f2(i2[v2]) });
            }
          for (var l2 = i2.length; l2 < u2.length; l2++) {
            var d2 = r3.concat([l2]);
            t3.push({ op: c2, path: d2, value: f2(u2[l2]) });
          }
          i2.length < u2.length && e3.push({ op: "replace", path: r3.concat(["length"]), value: i2.length });
        }(n2, r2, t2, e2);
      case 3:
        return function(n3, r3, t3, e3) {
          var i2 = n3.t, o2 = n3.o, u2 = 0;
          i2.forEach(function(n4) {
            if (!o2.has(n4)) {
              var i3 = r3.concat([u2]);
              t3.push({ op: "remove", path: i3, value: n4 }), e3.unshift({ op: c2, path: i3, value: n4 });
            }
            u2++;
          }), u2 = 0, o2.forEach(function(n4) {
            if (!i2.has(n4)) {
              var o3 = r3.concat([u2]);
              t3.push({ op: c2, path: o3, value: n4 }), e3.unshift({ op: "remove", path: o3, value: n4 });
            }
            u2++;
          });
        }(n2, r2, t2, e2);
    }
  }, M: function(n2, r2, t2, e2) {
    t2.push({ op: "replace", path: [], value: r2 === H ? void 0 : r2 }), e2.push({ op: "replace", path: [], value: n2 });
  } });
}
var G;
var U;
var W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x");
var X = "undefined" != typeof Map;
var q = "undefined" != typeof Set;
var B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect;
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q = W ? Symbol.for("immer-state") : "__$immer_state";
var Y = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n2) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n2;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n2) {
  return "Cannot apply patch, path doesn't resolve: " + n2;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n2) {
  return "Unsupported patch operation: " + n2;
}, 18: function(n2) {
  return "The plugin for '" + n2 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n2 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n2) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n2 + "'";
}, 22: function(n2) {
  return "'current' expects a draft, got: " + n2;
}, 23: function(n2) {
  return "'original' expects a draft, got: " + n2;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
var Z = "" + Object.prototype.constructor;
var nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames;
var rn = Object.getOwnPropertyDescriptors || function(n2) {
  var r2 = {};
  return nn(n2).forEach(function(t2) {
    r2[t2] = Object.getOwnPropertyDescriptor(n2, t2);
  }), r2;
};
var tn = {};
var en = { get: function(n2, r2) {
  if (r2 === Q)
    return n2;
  var e = p(n2);
  if (!u(e, r2))
    return function(n3, r3, t2) {
      var e2, i3 = I(r3, t2);
      return i3 ? "value" in i3 ? i3.value : null === (e2 = i3.get) || void 0 === e2 ? void 0 : e2.call(n3.k) : void 0;
    }(n2, e, r2);
  var i2 = e[r2];
  return n2.I || !t(i2) ? i2 : i2 === z(n2.t, r2) ? (E(n2), n2.o[r2] = N(n2.A.h, i2, n2)) : i2;
}, has: function(n2, r2) {
  return r2 in p(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p(n2));
}, set: function(n2, r2, t2) {
  var e = I(p(n2), r2);
  if (null == e ? void 0 : e.set)
    return e.set.call(n2.k, t2), true;
  if (!n2.P) {
    var i2 = z(p(n2), r2), o2 = null == i2 ? void 0 : i2[Q];
    if (o2 && o2.t === t2)
      return n2.o[r2] = t2, n2.R[r2] = false, true;
    if (c(t2, i2) && (void 0 !== t2 || u(n2.t, r2)))
      return true;
    E(n2), k(n2);
  }
  return n2.o[r2] === t2 && (void 0 !== t2 || r2 in n2.o) || Number.isNaN(t2) && Number.isNaN(n2.o[r2]) || (n2.o[r2] = t2, n2.R[r2] = true), true;
}, deleteProperty: function(n2, r2) {
  return void 0 !== z(n2.t, r2) || r2 in n2.t ? (n2.R[r2] = false, E(n2), k(n2)) : delete n2.R[r2], n2.o && delete n2.o[r2], true;
}, getOwnPropertyDescriptor: function(n2, r2) {
  var t2 = p(n2), e = Reflect.getOwnPropertyDescriptor(t2, r2);
  return e ? { writable: true, configurable: 1 !== n2.i || "length" !== r2, enumerable: e.enumerable, value: t2[r2] } : e;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n(12);
} };
var on = {};
i(en, function(n2, r2) {
  on[n2] = function() {
    return arguments[0] = arguments[0][0], r2.apply(this, arguments);
  };
}), on.deleteProperty = function(r2, t2) {
  return isNaN(parseInt(t2)) && n(13), on.set.call(this, r2, t2, void 0);
}, on.set = function(r2, t2, e) {
  return "length" !== t2 && isNaN(parseInt(t2)) && n(14), en.set.call(this, r2[0], t2, e, r2[0]);
};
var un = function() {
  function e(r2) {
    var e2 = this;
    this.O = B, this.D = true, this.produce = function(r3, i3, o2) {
      if ("function" == typeof r3 && "function" != typeof i3) {
        var u2 = i3;
        i3 = r3;
        var a2 = e2;
        return function(n2) {
          var r4 = this;
          void 0 === n2 && (n2 = u2);
          for (var t2 = arguments.length, e3 = Array(t2 > 1 ? t2 - 1 : 0), o3 = 1; o3 < t2; o3++)
            e3[o3 - 1] = arguments[o3];
          return a2.produce(n2, function(n3) {
            var t3;
            return (t3 = i3).call.apply(t3, [r4, n3].concat(e3));
          });
        };
      }
      var f2;
      if ("function" != typeof i3 && n(6), void 0 !== o2 && "function" != typeof o2 && n(7), t(r3)) {
        var c2 = w(e2), s2 = N(e2, r3, void 0), v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? g(c2) : O(c2);
        }
        return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then(function(n2) {
          return j(c2, o2), P(n2, c2);
        }, function(n2) {
          throw g(c2), n2;
        }) : (j(c2, o2), P(f2, c2));
      }
      if (!r3 || "object" != typeof r3) {
        if (void 0 === (f2 = i3(r3)) && (f2 = r3), f2 === H && (f2 = void 0), e2.D && d(f2, true), o2) {
          var p2 = [], l2 = [];
          b("Patches").M(r3, f2, p2, l2), o2(p2, l2);
        }
        return f2;
      }
      n(21, r3);
    }, this.produceWithPatches = function(n2, r3) {
      if ("function" == typeof n2)
        return function(r4) {
          for (var t3 = arguments.length, i4 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++)
            i4[o3 - 1] = arguments[o3];
          return e2.produceWithPatches(r4, function(r5) {
            return n2.apply(void 0, [r5].concat(i4));
          });
        };
      var t2, i3, o2 = e2.produce(n2, r3, function(n3, r4) {
        t2 = n3, i3 = r4;
      });
      return "undefined" != typeof Promise && o2 instanceof Promise ? o2.then(function(n3) {
        return [n3, t2, i3];
      }) : [o2, t2, i3];
    }, "boolean" == typeof (null == r2 ? void 0 : r2.useProxies) && this.setUseProxies(r2.useProxies), "boolean" == typeof (null == r2 ? void 0 : r2.autoFreeze) && this.setAutoFreeze(r2.autoFreeze);
  }
  var i2 = e.prototype;
  return i2.createDraft = function(e2) {
    t(e2) || n(8), r(e2) && (e2 = R(e2));
    var i3 = w(this), o2 = N(this, e2, void 0);
    return o2[Q].C = true, O(i3), o2;
  }, i2.finishDraft = function(r2, t2) {
    var e2 = r2 && r2[Q];
    e2 && e2.C || n(9), e2.I && n(10);
    var i3 = e2.A;
    return j(i3, t2), P(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.D = n2;
  }, i2.setUseProxies = function(r2) {
    r2 && !B && n(20), this.O = r2;
  }, i2.applyPatches = function(n2, t2) {
    var e2;
    for (e2 = t2.length - 1; e2 >= 0; e2--) {
      var i3 = t2[e2];
      if (0 === i3.path.length && "replace" === i3.op) {
        n2 = i3.value;
        break;
      }
    }
    e2 > -1 && (t2 = t2.slice(e2 + 1));
    var o2 = b("Patches").$;
    return r(n2) ? o2(n2, t2) : this.produce(n2, function(n3) {
      return o2(n3, t2);
    });
  }, e;
}();
var an = new un();
var fn = an.produce;
var cn = an.produceWithPatches.bind(an);
var sn = an.setAutoFreeze.bind(an);
var vn = an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
var ln = an.createDraft.bind(an);
var dn = an.finishDraft.bind(an);

// node_modules/@textbus/core/bundles/index.esm.js
function makeError(name) {
  return function textbusError(message) {
    const error = new Error(message);
    error.name = `[TextbusError: ${name}]`;
    error.stack = error.stack.replace(/\n.*?(?=\n)/, "");
    return error;
  };
}
var NativeRenderer = class {
};
var RootComponentRef = class {
};
var COMPONENT_LIST = new InjectionToken("COMPONENT_LIST");
var FORMATTER_LIST = new InjectionToken("FORMATTER_LIST");
var ATTRIBUTE_LIST = new InjectionToken("ATTRIBUTE_LIST");
var ZEN_CODING_DETECT = new InjectionToken("ZEN_CODING_DETECT");
var HISTORY_STACK_SIZE = new InjectionToken("HISTORY_STACK_SIZE");
var READONLY = new InjectionToken("READONLY");
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var ChangeMarker = class {
  get dirty() {
    return this._dirty;
  }
  get changed() {
    return this._changed;
  }
  get outputDirty() {
    return this._outputDirty;
  }
  get outputChanged() {
    return this._outputChanged;
  }
  constructor() {
    this._dirty = true;
    this._changed = true;
    this._outputDirty = true;
    this._outputChanged = true;
    this.changeEvent = new Subject();
    this.childComponentRemovedEvent = new Subject();
    this.forceChangeEvent = new Subject();
    this.onChange = this.changeEvent.asObservable();
    this.onChildComponentRemoved = this.childComponentRemovedEvent.asObservable();
    this.onForceChange = this.forceChangeEvent.asObservable();
  }
  forceMarkDirtied() {
    if (this._dirty) {
      return;
    }
    this._dirty = true;
    this.forceMarkChanged();
  }
  forceMarkChanged() {
    if (this._changed) {
      return;
    }
    this._changed = true;
    this.forceChangeEvent.next();
  }
  markAsDirtied(operation) {
    this._dirty = true;
    this._outputDirty = true;
    this.markAsChanged(operation);
  }
  markAsChanged(operation) {
    this._changed = true;
    this._outputChanged = true;
    this.changeEvent.next(operation);
  }
  rendered() {
    this._dirty = this._changed = false;
  }
  outputRendered() {
    this._outputDirty = this._outputChanged = false;
  }
  reset() {
    this._changed = this._dirty = this._outputChanged = this._outputDirty = true;
  }
  recordComponentRemoved(instance) {
    this.childComponentRemovedEvent.next(instance);
  }
};
var Content = class {
  constructor() {
    this.segmenter = new Intl.Segmenter();
    this.data = [];
  }
  get length() {
    return this.data.reduce((p2, n2) => p2 + n2.length, 0);
  }
  correctIndex(index, toEnd) {
    if (index === 0 || index === this.length) {
      return index;
    }
    let i2 = 0;
    for (const item of this.data) {
      const itemLength = item.length;
      if (typeof item === "string") {
        if (index > i2 && index < i2 + itemLength) {
          const offsetIndex = index - i2;
          const startIndex = Math.max(0, offsetIndex - 15);
          const endIndex = Math.min(startIndex + 30, item.length);
          const fragment = item.slice(startIndex, endIndex);
          const segments = this.segmenter.segment(fragment);
          let offset = startIndex;
          for (const p2 of segments) {
            const segmentLength = p2.segment.length;
            if (index > i2 + offset && index < i2 + offset + segmentLength) {
              return toEnd ? i2 + offset + segmentLength : i2 + offset;
            }
            offset += segmentLength;
            if (i2 + offset >= index) {
              break;
            }
          }
          return index;
        }
      }
      i2 += itemLength;
      if (i2 >= index) {
        break;
      }
    }
    return index;
  }
  insert(index, content) {
    if (index >= this.length) {
      this.append(content);
    } else {
      let i2 = 0;
      let ii = 0;
      for (const el of this.data) {
        if (index >= i2) {
          if (typeof el === "string") {
            if (index >= i2 && index < i2 + el.length) {
              const cc = [el.slice(0, index - i2), content, el.slice(index - i2)].filter((i3) => i3);
              if (typeof content === "string") {
                this.data.splice(ii, 1, cc.join(""));
              } else {
                this.data.splice(ii, 1, ...cc);
              }
              break;
            }
          } else if (index === i2) {
            const prev = this.data[ii - 1];
            if (typeof prev === "string" && typeof content === "string") {
              this.data[ii - 1] = prev + content;
            } else if (i2 === 0) {
              this.data.unshift(content);
            } else {
              this.data.splice(ii, 0, content);
            }
            break;
          }
        }
        ii++;
        i2 += el.length;
      }
    }
  }
  append(content) {
    const lastChildIndex = this.data.length - 1;
    const lastChild = this.data[lastChildIndex];
    if (typeof lastChild === "string" && typeof content === "string") {
      this.data[lastChildIndex] = lastChild + content;
    } else {
      this.data.push(content);
    }
  }
  cut(startIndex = 0, endIndex = this.length) {
    if (endIndex <= startIndex) {
      return [];
    }
    const discardedContents = this.slice(startIndex, endIndex);
    const elements = this.slice(0, startIndex).concat(this.slice(endIndex, this.length));
    this.data = [];
    elements.forEach((item) => this.append(item));
    return discardedContents;
  }
  slice(startIndex = 0, endIndex = this.length) {
    if (startIndex >= endIndex) {
      return [];
    }
    startIndex = this.correctIndex(startIndex, false);
    endIndex = this.correctIndex(endIndex, true);
    let index = 0;
    const result = [];
    for (const el of this.data) {
      const fragmentStartIndex = index;
      const len = el.length;
      const fragmentEndIndex = index + len;
      index += len;
      if (startIndex < fragmentEndIndex && endIndex > fragmentStartIndex) {
        if (typeof el === "string") {
          const min = Math.max(0, startIndex - fragmentStartIndex);
          const max = Math.min(fragmentEndIndex, endIndex) - fragmentStartIndex;
          result.push(el.slice(min, max));
        } else {
          result.push(el);
        }
      }
    }
    return result;
  }
  toJSON() {
    return this.data.map((i2) => {
      if (typeof i2 === "string") {
        return i2;
      }
      return i2.toJSON();
    });
  }
  indexOf(element) {
    let index = 0;
    for (const item of this.data) {
      if (item === element) {
        return index;
      }
      index += item.length;
    }
    return -1;
  }
  getContentAtIndex(index) {
    return this.slice(index, index + 1)[0];
  }
  toGrid() {
    const splitPoints = [0];
    let index = 0;
    this.data.forEach((i2) => {
      index += i2.length;
      splitPoints.push(index);
    });
    return [...splitPoints];
  }
  toString() {
    return this.data.map((i2) => {
      if (typeof i2 === "string") {
        return i2;
      }
      return i2.toString();
    }).join("");
  }
};
var Slots = class {
  get length() {
    return this.slots.length;
  }
  get last() {
    return this.slots[this.length - 1] || null;
  }
  get first() {
    return this.slots[0] || null;
  }
  get index() {
    return this._index;
  }
  constructor(host, slots = []) {
    this.host = host;
    this.slots = [];
    this._index = 0;
    this.changeEvent = new Subject();
    this.childSlotChangeEvent = new Subject();
    this.childSlotRemoveEvent = new Subject();
    this.changeListeners = /* @__PURE__ */ new WeakMap();
    this.onChange = this.changeEvent.asObservable();
    this.onChildSlotChange = this.childSlotChangeEvent.asObservable();
    this.onChildSlotRemove = this.childSlotRemoveEvent.asObservable();
    this.insert(...Array.from(new Set(slots)));
  }
  indexOf(slot) {
    return this.slots.indexOf(slot);
  }
  remove(slot) {
    const index = this.slots.indexOf(slot);
    if (index > -1) {
      this.retain(index);
      this.delete(1);
      return true;
    }
    return false;
  }
  insertAfter(slots, ref) {
    const index = this.slots.indexOf(ref);
    if (index > -1) {
      this.insertByIndex(slots, index + 1);
    }
  }
  insertBefore(slots, ref) {
    const index = this.slots.indexOf(ref);
    if (index > -1) {
      this.insertByIndex(slots, index);
    }
  }
  insertByIndex(slots, index) {
    if (index < 0) {
      index = 0;
    }
    if (index > this.slots.length) {
      index = this.slots.length;
    }
    this.retain(index);
    const s2 = Array.isArray(slots) ? slots : [slots];
    this.insert(...s2);
  }
  push(...slots) {
    this.retain(this.length);
    this.insert(...slots);
  }
  pop() {
    if (this.length > 0) {
      const last = this.last;
      this.retain(this.length - 1);
      this.delete(1);
      return last;
    }
    return null;
  }
  shift() {
    if (this.length > 0) {
      const first = this.first;
      this.retain(0);
      this.delete(1);
      return first;
    }
    return null;
  }
  unshift(...slots) {
    this.retain(0);
    this.insert(...slots);
  }
  get(index) {
    return this.slots[index] || null;
  }
  replace(oldSlot, newSlot) {
    const index = this.indexOf(oldSlot);
    if (index > 0) {
      this.retain(index);
      this.delete(1);
      this.insert(newSlot);
    }
  }
  toJSON() {
    return this.slots.map((i2) => i2.toJSON());
  }
  toArray() {
    return [...this.slots];
  }
  clean() {
    this.retain(0);
    this.delete(this.length);
  }
  insert(...slots) {
    if (slots.length === 0) {
      return;
    }
    const index = this._index;
    this.slots.splice(index, 0, ...slots);
    slots.forEach((i2) => {
      if (i2.parent) {
        i2.parent.slots.remove(i2);
      }
      i2.changeMarker.reset();
      i2.parent = this.host;
      const sub = i2.changeMarker.onChange.subscribe((operation) => {
        operation.path.unshift(this.indexOf(i2));
        if (i2.changeMarker.dirty) {
          this.host.changeMarker.markAsDirtied(operation);
        } else {
          this.host.changeMarker.markAsChanged(operation);
        }
        this.childSlotChangeEvent.next(i2);
      });
      sub.add(i2.changeMarker.onChildComponentRemoved.subscribe((instance) => {
        this.host.changeMarker.recordComponentRemoved(instance);
      }));
      sub.add(i2.changeMarker.onForceChange.subscribe(() => {
        if (i2.changeMarker.dirty) {
          this.host.changeMarker.forceMarkDirtied();
        } else {
          this.host.changeMarker.forceMarkChanged();
        }
      }));
      this.changeListeners.set(i2, sub);
    });
    this._index += slots.length;
    this.changeEvent.next({
      path: [],
      apply: [{
        type: "retain",
        offset: index
      }, ...slots.map((i2) => {
        return {
          type: "insertSlot",
          slot: i2.toJSON(),
          ref: i2
        };
      })],
      unApply: [{
        type: "retain",
        offset: index
      }, {
        type: "delete",
        count: slots.length
      }]
    });
  }
  retain(index) {
    if (index < 0) {
      this._index = 0;
    } else if (index > this.length) {
      this._index = this.length;
    } else {
      this._index = index;
    }
  }
  delete(count) {
    const startIndex = this._index;
    const deletedSlots = this.slots.splice(startIndex, count);
    deletedSlots.forEach((i2) => {
      var _a2;
      i2.sliceContent().forEach((content) => {
        if (typeof content !== "string") {
          this.host.changeMarker.recordComponentRemoved(content);
        }
      });
      (_a2 = this.changeListeners.get(i2)) === null || _a2 === void 0 ? void 0 : _a2.unsubscribe();
      this.changeListeners.delete(i2);
    });
    this.changeEvent.next({
      path: [],
      apply: [{
        type: "retain",
        offset: startIndex
      }, {
        type: "delete",
        count
      }],
      unApply: deletedSlots.map((slot, i2) => {
        slot.parent = null;
        return [{
          type: "retain",
          offset: startIndex + i2
        }, {
          type: "insertSlot",
          slot: slot.toJSON(),
          ref: slot
        }];
      }).flat()
    });
    this.childSlotRemoveEvent.next(deletedSlots);
  }
  cut(startIndex = 0, endIndex = this.length) {
    if (startIndex >= endIndex) {
      return [];
    }
    const deletedSlots = this.slots.slice(startIndex, endIndex);
    this.retain(startIndex);
    this.delete(endIndex - startIndex);
    return deletedSlots;
  }
  slice(startIndex, endIndex) {
    return this.slots.slice(startIndex, endIndex);
  }
  has(slot) {
    return this.indexOf(slot) > -1;
  }
  toString() {
    return this.slots.map((i2) => {
      return i2.toString();
    }).join("");
  }
};
T();
var componentErrorFn = makeError("DefineComponent");
var Ref = class {
  constructor(current = null) {
    this.current = current;
  }
};
var EventCache = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
  }
  add(eventType, callback) {
    let callbacks = this.listeners.get(eventType);
    if (!callbacks) {
      callbacks = [];
      this.listeners.set(eventType, callbacks);
    }
    callbacks.push(callback);
  }
  get(eventType) {
    return this.listeners.get(eventType) || [];
  }
  clean(eventType) {
    this.listeners.delete(eventType);
  }
};
var eventCacheMap = /* @__PURE__ */ new WeakMap();
var contextStack = [];
function getCurrentContext() {
  const current = contextStack[contextStack.length - 1];
  if (!current) {
    throw componentErrorFn("cannot be called outside the component!");
  }
  return current;
}
function defineComponent(options) {
  const component = {
    name: options.name,
    separable: !!options.separable,
    instanceType: options.type,
    zenCoding: options.zenCoding,
    createInstance(contextInjector, initData) {
      const marker = new ChangeMarker();
      const stateChangeSubject = new Subject();
      const onStateChange = stateChangeSubject.asObservable();
      const changeController = {
        update(fn2, record = true) {
          return componentInstance.updateState(fn2, record);
        },
        onChange: onStateChange.pipe(map((i2) => i2.newState))
      };
      const componentInstance = {
        name: component.name,
        type: component.instanceType,
        separable: component.separable,
        changeMarker: marker,
        parent: null,
        get parentComponent() {
          var _a2;
          return ((_a2 = componentInstance.parent) === null || _a2 === void 0 ? void 0 : _a2.parent) || null;
        },
        get state() {
          return state;
        },
        length: 1,
        onStateChange,
        slots: null,
        extends: null,
        shortcutList: null,
        updateState(fn2, record = true) {
          let changes;
          let inverseChanges;
          const oldState = state;
          const newState = fn(oldState, fn2, (p2, ip) => {
            changes = p2;
            inverseChanges = ip;
          });
          if (changes.length === 0 && inverseChanges.length === 0) {
            return oldState;
          }
          state = newState;
          marker.markAsDirtied({
            path: [],
            apply: [{
              type: "apply",
              patches: changes,
              value: newState,
              record
            }],
            unApply: [{
              type: "apply",
              patches: inverseChanges,
              value: oldState,
              record
            }]
          });
          stateChangeSubject.next({
            oldState,
            newState,
            record
          });
          return newState;
        },
        toJSON() {
          return {
            name: component.name,
            state: state !== null && state !== void 0 ? state : null,
            slots: componentInstance.slots.toJSON()
          };
        },
        toString() {
          return componentInstance.slots.toString();
        }
      };
      const context = {
        contextInjector,
        changeController,
        componentInstance,
        dynamicShortcut: [],
        eventCache: new EventCache()
      };
      contextStack.push(context);
      componentInstance.extends = options.setup(initData);
      onDestroy(() => {
        eventCacheMap.delete(componentInstance);
        subscriptions.forEach((i2) => i2.unsubscribe());
      });
      eventCacheMap.set(componentInstance, context.eventCache);
      contextStack.pop();
      componentInstance.slots = context.slots || new Slots(componentInstance);
      componentInstance.shortcutList = context.dynamicShortcut;
      let state = Reflect.has(context, "initState") ? context.initState : initData === null || initData === void 0 ? void 0 : initData.state;
      const subscriptions = [
        componentInstance.slots.onChange.subscribe((ops) => {
          marker.markAsDirtied(ops);
        })
      ];
      return componentInstance;
    }
  };
  return component;
}
function useContext(token = Injector, noFoundValue, flags) {
  const context = getCurrentContext();
  return context.contextInjector.get(token, noFoundValue, flags);
}
function useSelf() {
  const context = getCurrentContext();
  return context.componentInstance;
}
function useSlots(slots) {
  const context = getCurrentContext();
  if (Reflect.has(context, "slots")) {
    throw componentErrorFn("only one unique slots is allowed for a component!");
  }
  const s2 = new Slots(context.componentInstance, slots);
  context.slots = s2;
  return s2;
}
function useState(initState) {
  const context = getCurrentContext();
  if (Reflect.has(context, "initState")) {
    throw componentErrorFn("only one unique state is allowed for a component!");
  }
  context.initState = initState;
  return context.changeController;
}
function useRef(initValue = null) {
  return new Ref(initValue);
}
function useDynamicShortcut(config) {
  const context = getCurrentContext();
  context.dynamicShortcut.push(config);
}
var Event = class {
  get isPrevented() {
    return this._isPrevented;
  }
  constructor(target, data) {
    this.target = target;
    this.data = data;
    this._isPrevented = false;
  }
  preventDefault() {
    this._isPrevented = true;
  }
};
var ContextMenuEvent = class extends Event {
  constructor(target, getMenus) {
    super(target, null);
    this.getMenus = getMenus;
    this.isStopped = false;
  }
  get stopped() {
    return this.isStopped;
  }
  stopPropagation() {
    this.isStopped = true;
  }
  useMenus(menus) {
    this.getMenus(menus);
  }
};
var GetRangesEvent = class extends Event {
  constructor(target, getRanges) {
    super(target, null);
    this.getRanges = getRanges;
  }
  useRanges(ranges) {
    this.getRanges(ranges);
  }
};
function invokeListener(target, eventType, event) {
  if (typeof target !== "object" || target === null) {
    return;
  }
  const cache = eventCacheMap.get(target);
  if (cache) {
    const callbacks = cache.get(eventType);
    callbacks.forEach((fn2) => {
      return fn2(event);
    });
    if (eventType === "onViewChecked") {
      const viewInitCallbacks = cache.get("onViewInit");
      cache.clean("onViewInit");
      viewInitCallbacks.forEach((fn2) => {
        fn2(event);
      });
    }
    if (eventType === "onDestroy") {
      eventCacheMap.delete(target);
    }
  }
}
function makeEventHook(type) {
  return function(listener) {
    const context = getCurrentContext();
    if (context) {
      context.eventCache.add(type, listener);
    }
  };
}
function triggerContextMenu(component) {
  var _a2;
  let comp = component;
  const menuItems = [];
  while (comp) {
    const event = new ContextMenuEvent(comp, (menus) => {
      menuItems.push(menus);
    });
    invokeListener(comp, "onContextMenu", event);
    if (event.stopped) {
      break;
    }
    comp = ((_a2 = comp.parent) === null || _a2 === void 0 ? void 0 : _a2.parent) || null;
  }
  return menuItems;
}
var onUnselect = makeEventHook("onUnselect");
var onSelected = makeEventHook("onSelected");
var onSelectionFromFront = makeEventHook("onSelectionFromFront");
var onSelectionFromEnd = makeEventHook("onSelectionFromEnd");
var onFocus = makeEventHook("onFocus");
var onBlur = makeEventHook("onBlur");
var onFocusIn = makeEventHook("onFocusIn");
var onFocusOut = makeEventHook("onFocusOut");
var onPaste = makeEventHook("onPaste");
var onContextMenu = makeEventHook("onContextMenu");
var onViewChecked = makeEventHook("onViewChecked");
var onViewInit = makeEventHook("onViewInit");
var onSlotRemove = makeEventHook("onSlotRemove");
var onSlotRemoved = makeEventHook("onSlotRemoved");
var onContentDelete = makeEventHook("onContentDelete");
var onContentDeleted = makeEventHook("onContentDeleted");
var onBreak = makeEventHook("onBreak");
var onContentInsert = makeEventHook("onContentInsert");
var onContentInserted = makeEventHook("onContentInserted");
var onDestroy = makeEventHook("onDestroy");
var onGetRanges = makeEventHook("onGetRanges");
var onDirtyViewClean = makeEventHook("onDirtyViewClean");
var onCompositionStart = makeEventHook("onCompositionStart");
var onCompositionUpdate = makeEventHook("onCompositionUpdate");
var onCompositionEnd = makeEventHook("onCompositionEnd");
var onParentSlotUpdated = makeEventHook("onParentSlotUpdated");
var _a;
var _b;
var vElementErrorFn = makeError("VElement");
var parentNode = Symbol("parentNode");
var VTextNode = class {
  get parentNode() {
    return this[parentNode];
  }
  constructor(textContent = "") {
    this.textContent = textContent;
    this[_a] = null;
  }
};
_a = parentNode;
function jsx(tagName, props = {}) {
  const children = props.children;
  Reflect.deleteProperty(props, "children");
  if (children) {
    return VElement.createElement(tagName, props, children);
  }
  return VElement.createElement(tagName, props);
}
var VFragment = class {
  constructor(children) {
    this.children = children;
  }
};
function append(children, node) {
  if (node instanceof VElement) {
    children.push(node);
  } else if (node instanceof VTextNode) {
    if (node.textContent) {
      children.push(node);
    }
  } else if (typeof node === "string" && node.length > 0) {
    children.push(new VTextNode(node));
  } else if (node instanceof VFragment) {
    for (const item of node.children.flat()) {
      append(children, item);
    }
  } else if (node !== false && node !== true && node !== null && typeof node !== "undefined") {
    children.push(new VTextNode(String(node)));
  }
}
var VElement = class {
  static createElement(tagName, attrs = null, ...childNodes) {
    const children = [];
    childNodes.flat(2).forEach((i2) => {
      append(children, i2);
    });
    if (typeof tagName === "function") {
      return tagName(Object.assign(Object.assign({}, attrs), { children }));
    }
    return new VElement(tagName, attrs, children);
  }
  get parentNode() {
    return this[parentNode];
  }
  get children() {
    return [...this._children];
  }
  constructor(tagName, attrs = null, children = []) {
    this.tagName = tagName;
    this[_b] = null;
    this.attrs = /* @__PURE__ */ new Map();
    this.styles = /* @__PURE__ */ new Map();
    this.classes = /* @__PURE__ */ new Set();
    this.listeners = {};
    this._children = [];
    attrs = attrs || {};
    Object.keys(attrs).forEach((key) => {
      if (key === "class") {
        const className = (attrs.class || "").trim();
        this.classes = new Set(className ? className.split(/\s+/g) : []);
      } else if (key === "style") {
        const style = attrs.style || "";
        if (typeof style === "string") {
          style.split(";").map((s2) => s2.split(":")).forEach((v2) => {
            if (!v2[0] || !v2[1]) {
              return;
            }
            this.styles.set(v2[0].trim(), v2[1].trim());
          });
        } else if (typeof style === "object") {
          Object.keys(style).forEach((key2) => {
            this.styles.set(key2, style[key2]);
          });
        }
      } else if (/^on[A-Z]/.test(key)) {
        const listener = attrs[key];
        if (typeof listener === "function") {
          this.listeners[key.replace(/^on/, "").toLowerCase()] = listener;
        }
      } else {
        this.attrs.set(key, attrs[key]);
      }
    });
    this.appendChild(...children);
  }
  appendChild(...newNodes) {
    newNodes.forEach((node) => {
      var _c;
      (_c = node.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node);
      node[parentNode] = this;
      this._children.push(node);
    });
  }
  removeChild(node) {
    const index = this._children.indexOf(node);
    if (index > -1) {
      this._children.splice(index, 1);
      node[parentNode] = null;
      return;
    }
    throw vElementErrorFn("node to be deleted is not a child of the current node.");
  }
  replaceChild(newNode, oldNode) {
    var _c;
    const index = this._children.indexOf(oldNode);
    if (index > -1) {
      (_c = newNode.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(newNode);
      this._children.splice(index, 1, newNode);
      oldNode[parentNode] = null;
      newNode[parentNode] = this;
      return;
    }
    throw vElementErrorFn("node to be replaced is not a child of the current node.");
  }
};
_b = parentNode;
function isVoid(data) {
  return data === null || typeof data === "undefined";
}
var Format = class {
  constructor(slot) {
    this.slot = slot;
    this.map = /* @__PURE__ */ new Map();
  }
  merge(formatter, value, background = false) {
    let ranges = this.map.get(formatter);
    if (!ranges) {
      const v2 = value.value;
      if (isVoid(v2)) {
        return this;
      }
      ranges = [value];
      this.map.set(formatter, ranges);
      return this;
    }
    const newRanges = this.normalizeFormatRange(background, ranges, value);
    if (newRanges.length) {
      this.map.set(formatter, newRanges);
    } else {
      this.map.delete(formatter);
    }
    return this;
  }
  stretch(index, count) {
    this.map.forEach((values) => {
      values.forEach((range) => {
        if (range.endIndex < index) {
          return;
        }
        range.endIndex += count;
        if (range.startIndex >= index) {
          range.startIndex += count;
        }
      });
    });
    return this;
  }
  split(index, distance) {
    const expandedValues = Array.from({ length: distance });
    Array.from(this.map).forEach(([key, formatRanges]) => {
      const values = this.tileRanges(formatRanges);
      values.splice(index, 0, ...expandedValues);
      const newRanges = Format.toRanges(values);
      this.map.set(key, newRanges);
    });
    return this;
  }
  shrink(startIndex, count) {
    this.map.forEach((values) => {
      values.forEach((range) => {
        if (range.endIndex <= startIndex) {
          return;
        }
        range.endIndex = Math.max(startIndex, range.endIndex - count);
        if (range.startIndex > startIndex) {
          range.startIndex = Math.max(startIndex, range.startIndex - count);
        }
      });
    });
    Array.from(this.map.keys()).forEach((key) => {
      const oldRanges = this.map.get(key);
      const newRanges = this.normalizeFormatRange(false, oldRanges);
      if (newRanges.length) {
        this.map.set(key, newRanges);
      } else {
        this.map.delete(key);
      }
    });
    return this;
  }
  extract(startIndex, endIndex) {
    const format2 = new Format(this.slot);
    this.map.forEach((ranges, key) => {
      const extractRanges = this.extractFormatRangesByFormatter(startIndex, endIndex, key);
      if (extractRanges.length) {
        format2.map.set(key, extractRanges);
      }
    });
    return format2;
  }
  createFormatByRange(slot, startIndex, endIndex) {
    const format2 = new Format(slot);
    this.map.forEach((ranges, key) => {
      const extractRanges = this.extractFormatRangesByFormatter(startIndex, endIndex, key);
      if (extractRanges.length) {
        format2.map.set(key, extractRanges.map((i2) => {
          i2.startIndex -= startIndex;
          i2.endIndex -= startIndex;
          return i2;
        }));
      }
    });
    return format2;
  }
  extractFormatRangesByFormatter(startIndex, endIndex, formatter) {
    const extractRanges = [];
    const ranges = this.map.get(formatter) || [];
    ranges.forEach((range) => {
      if (range.startIndex > endIndex || range.endIndex < startIndex) {
        return;
      }
      const s2 = Math.max(range.startIndex, startIndex);
      const n2 = Math.min(range.endIndex, endIndex);
      if (s2 < n2) {
        extractRanges.push({
          startIndex: s2,
          endIndex: n2,
          value: range.value
        });
      }
    });
    return extractRanges;
  }
  discard(formatter, startIndex, endIndex) {
    const oldRanges = this.map.get(formatter);
    if (oldRanges) {
      this.normalizeFormatRange(false, oldRanges, {
        startIndex,
        endIndex,
        value: null
      });
    }
    return this;
  }
  extractFormatsByIndex(index) {
    const formats = [];
    if (index === 0) {
      this.map.forEach((ranges, formatter) => {
        ranges.forEach((i2) => {
          if (i2.startIndex === 0) {
            formats.push([
              formatter,
              i2.value
            ]);
          }
        });
      });
    } else {
      this.map.forEach((ranges, formatter) => {
        ranges.forEach((i2) => {
          if (i2.startIndex < index && i2.endIndex >= index) {
            formats.push([
              formatter,
              i2.value
            ]);
          }
        });
      });
    }
    return formats;
  }
  toGrid() {
    const splitPoints = /* @__PURE__ */ new Set();
    splitPoints.add(0);
    splitPoints.add(this.slot.length);
    this.map.forEach((ranges) => {
      ranges.forEach((item) => {
        splitPoints.add(item.startIndex);
        splitPoints.add(item.endIndex);
      });
    });
    return [...splitPoints].sort((a2, b2) => a2 - b2);
  }
  toJSON() {
    const json = {};
    this.map.forEach((value, formatter) => {
      json[formatter.name] = value.map((i2) => Object.assign({}, i2));
    });
    return json;
  }
  toTree(startIndex, endIndex) {
    const copyFormat = this.extract(startIndex, endIndex);
    const tree = {
      startIndex,
      endIndex
    };
    let nextStartIndex = endIndex;
    let nextEndIndex = startIndex;
    const formats = [];
    const columnedFormats = [];
    Array.from(copyFormat.map.keys()).forEach((formatter) => {
      const ranges = copyFormat.map.get(formatter);
      ranges.forEach((range) => {
        if (range.startIndex === startIndex && range.endIndex === endIndex) {
          if (formatter.columned) {
            columnedFormats.push(Object.assign({ formatter }, range));
          } else {
            formats.push(Object.assign({ formatter }, range));
            copyFormat.map.delete(formatter);
          }
        } else if (range.startIndex < nextStartIndex) {
          nextStartIndex = range.startIndex;
          nextEndIndex = range.endIndex;
        } else if (range.startIndex === nextStartIndex) {
          nextEndIndex = Math.max(nextEndIndex, range.endIndex);
        }
      });
    });
    const hasChildren = copyFormat.map.size > columnedFormats.length;
    if (hasChildren) {
      tree.children = [];
      if (startIndex < nextStartIndex) {
        if (columnedFormats.length) {
          const childTree = copyFormat.extract(startIndex, nextStartIndex).toTree(startIndex, nextStartIndex);
          tree.children.push(childTree);
        } else {
          tree.children.push({
            startIndex,
            endIndex: nextStartIndex
          });
        }
      }
      const push = function(tree2, childTree) {
        if (childTree.formats) {
          tree2.children.push(childTree);
        } else if (childTree.children) {
          tree2.children.push(...childTree.children);
        } else {
          tree2.children.push(childTree);
        }
      };
      const nextTree = copyFormat.toTree(nextStartIndex, nextEndIndex);
      push(tree, nextTree);
      if (nextEndIndex < endIndex) {
        const afterFormat = copyFormat.extract(nextEndIndex, endIndex);
        const afterTree = afterFormat.toTree(nextEndIndex, endIndex);
        push(tree, afterTree);
      }
    } else {
      formats.push(...columnedFormats);
    }
    if (formats.length) {
      tree.formats = formats.sort((a2, b2) => {
        return a2.formatter.priority - b2.formatter.priority;
      });
    }
    return tree;
  }
  toArray() {
    const list = [];
    Array.from(this.map).forEach((i2) => {
      const formatter = i2[0];
      i2[1].forEach((range) => {
        list.push(Object.assign(Object.assign({}, range), { formatter }));
      });
    });
    return list;
  }
  normalizeFormatRange(background, oldRanges, newRange) {
    if (newRange) {
      oldRanges = background ? [newRange, ...oldRanges] : [...oldRanges, newRange];
    }
    const formatValues = this.tileRanges(oldRanges);
    return Format.toRanges(formatValues);
  }
  tileRanges(ranges) {
    const formatValues = [];
    ranges.forEach((range) => {
      formatValues.length = Math.max(formatValues.length, range.endIndex);
      formatValues.fill(range.value, range.startIndex, range.endIndex);
    });
    formatValues.length = Math.min(formatValues.length, this.slot.length);
    return formatValues;
  }
  static toRanges(values) {
    const newRanges = [];
    let range = null;
    for (let i2 = 0; i2 < values.length; i2++) {
      const item = values[i2];
      if (isVoid(item)) {
        range = null;
        continue;
      }
      if (Format.equal(range === null || range === void 0 ? void 0 : range.value, item)) {
        range.endIndex = i2 + 1;
        continue;
      }
      range = {
        startIndex: i2,
        endIndex: i2 + 1,
        value: item
      };
      newRanges.push(range);
    }
    return newRanges;
  }
  static equal(left, right) {
    if (left === right) {
      return true;
    }
    if (typeof left === "object" && typeof right === "object") {
      const leftKeys = Object.keys(left);
      const rightKeys = Object.keys(right);
      if (leftKeys.length === rightKeys.length) {
        return leftKeys.every((key) => {
          return rightKeys.includes(key) && right[key] === left[key];
        });
      }
    }
    return false;
  }
};
var ContentType;
(function(ContentType2) {
  ContentType2[ContentType2["Text"] = 1] = "Text";
  ContentType2[ContentType2["InlineComponent"] = 2] = "InlineComponent";
  ContentType2[ContentType2["BlockComponent"] = 3] = "BlockComponent";
})(ContentType || (ContentType = {}));
var DeltaLite = class extends Array {
  constructor() {
    super(...arguments);
    this.attributes = /* @__PURE__ */ new Map();
  }
};
var Slot = class {
  static get emptyPlaceholder() {
    return "\n";
  }
  get parentSlot() {
    var _a2;
    return ((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.parent) || null;
  }
  get length() {
    return this.content.length;
  }
  get isEmpty() {
    return this.length === 1 && this.getContentAtIndex(0) === Slot.emptyPlaceholder;
  }
  get index() {
    return this.isEmpty ? 0 : this._index;
  }
  constructor(schema, state) {
    this.state = state;
    this.parent = null;
    this.changeMarker = new ChangeMarker();
    this.componentChangeListeners = /* @__PURE__ */ new WeakMap();
    this.childComponentRemoveEvent = new Subject();
    this.id = Math.random();
    this._index = 0;
    this.content = new Content();
    this.format = new Format(this);
    this.attributes = /* @__PURE__ */ new Map();
    this.contentChangeEvent = new Subject();
    this.stateChangeEvent = new Subject();
    this.applyFormatCoverChild = false;
    this.schema = schema.sort();
    this.onContentChange = this.contentChangeEvent.asObservable();
    this.onStateChange = this.stateChangeEvent.asObservable();
    this.onChildComponentRemove = this.childComponentRemoveEvent.asObservable();
    this.content.append(Slot.emptyPlaceholder);
    this._index = 0;
  }
  setAttribute(attribute, value) {
    const has = this.attributes.has(attribute);
    const v2 = this.attributes.get(attribute);
    this.attributes.set(attribute, value);
    const applyActions = [{
      type: "attrSet",
      name: attribute.name,
      value
    }];
    this.sliceContent().forEach((item) => {
      if (typeof item !== "string") {
        item.slots.toArray().forEach((slot) => {
          slot.setAttribute(attribute, value);
        });
      }
    });
    this.changeMarker.markAsDirtied({
      path: [],
      apply: applyActions,
      unApply: [has ? {
        type: "attrSet",
        name: attribute.name,
        value: v2
      } : {
        type: "attrRemove",
        name: attribute.name
      }]
    });
    this.contentChangeEvent.next(applyActions);
  }
  getAttribute(attribute) {
    var _a2;
    return (_a2 = this.attributes.get(attribute)) !== null && _a2 !== void 0 ? _a2 : null;
  }
  getAttributes() {
    return Array.from(this.attributes.entries());
  }
  removeAttribute(attribute) {
    this.sliceContent().forEach((item) => {
      if (typeof item !== "string") {
        item.slots.toArray().forEach((slot) => {
          slot.removeAttribute(attribute);
        });
      }
    });
    const has = this.attributes.has(attribute);
    if (!has) {
      return;
    }
    const v2 = this.attributes.get(attribute);
    this.attributes.delete(attribute);
    const applyActions = [{
      type: "attrRemove",
      name: attribute.name
    }];
    this.changeMarker.markAsDirtied({
      path: [],
      apply: applyActions,
      unApply: [{
        type: "attrSet",
        name: attribute.name,
        value: v2
      }]
    });
    this.contentChangeEvent.next(applyActions);
  }
  hasAttribute(attribute) {
    return this.attributes.has(attribute);
  }
  updateState(fn2, record = true) {
    let changes;
    let inverseChanges;
    const oldState = this.state;
    const newState = fn(oldState, fn2, (p2, ip) => {
      changes = p2;
      inverseChanges = ip;
    });
    if (changes.length === 0 && inverseChanges.length === 0) {
      return oldState;
    }
    this.state = newState;
    const applyAction = {
      type: "apply",
      patches: changes,
      value: newState,
      record
    };
    this.changeMarker.markAsDirtied({
      path: [],
      apply: [applyAction],
      unApply: [{
        type: "apply",
        patches: inverseChanges,
        value: oldState,
        record
      }]
    });
    this.stateChangeEvent.next({
      newState,
      oldState,
      record
    });
    return newState;
  }
  write(content, formatter, value) {
    const index = this.index;
    const expandFormat = this.isEmpty || index === 0 ? this.format.extract(0, 1) : this.format.extract(index - 1, index);
    const formats = expandFormat.toArray().map((i2) => {
      return [
        i2.formatter,
        i2.value
      ];
    });
    if (formatter) {
      if (Array.isArray(formatter)) {
        formats.push(...formatter);
      } else {
        formats.push([formatter, value]);
      }
    }
    return this.insert(content, formats);
  }
  insert(content, formatter, value) {
    const contentType = typeof content === "string" ? ContentType.Text : content.type;
    if (!this.schema.includes(contentType)) {
      return false;
    }
    const prevContent = this.getContentAtIndex(this.index - 1);
    if (prevContent === Slot.placeholder) {
      this.retain(this.index - 1);
      this.delete(1);
    }
    const isEmpty = this.isEmpty;
    let actionData;
    let length;
    const startIndex = this.index;
    if (typeof content === "string") {
      if (content.length === 0) {
        return true;
      }
      actionData = content;
      length = content.length;
    } else {
      length = 1;
      actionData = content.toJSON();
      if (content.parent) {
        content.parent.removeComponent(content);
      }
      content.parent = this;
      const sub = content.changeMarker.onChange.subscribe((ops) => {
        ops.path.unshift(this.indexOf(content));
        this.changeMarker.markAsChanged(ops);
      });
      sub.add(content.changeMarker.onChildComponentRemoved.subscribe((instance) => {
        this.changeMarker.recordComponentRemoved(instance);
      }));
      sub.add(content.changeMarker.onForceChange.subscribe(() => {
        this.changeMarker.forceMarkChanged();
      }));
      this.componentChangeListeners.set(content, sub);
    }
    let formats = [];
    if (formatter) {
      if (Array.isArray(formatter)) {
        formats = formatter;
      } else {
        formats.push([formatter, value]);
      }
    }
    this.format.split(startIndex, length);
    this.content.insert(startIndex, content);
    this.applyFormats(formats, startIndex, length, false);
    if (isEmpty) {
      const len = this.length - 1;
      this.content.cut(len);
      this.format.shrink(len, 1);
    }
    this._index = startIndex + length;
    const applyActions = [{
      type: "retain",
      offset: startIndex
    }, formats.length ? {
      type: "insert",
      content: actionData,
      ref: content,
      formats: formats.reduce((opt, next) => {
        opt[next[0].name] = next[1];
        return opt;
      }, {})
    } : {
      type: "insert",
      content: actionData,
      ref: content
    }];
    this.changeMarker.markAsDirtied({
      path: [],
      apply: applyActions,
      unApply: [{
        type: "retain",
        offset: startIndex
      }, {
        type: "delete",
        count: length
      }]
    });
    this.contentChangeEvent.next(applyActions);
    return true;
  }
  retain(offset, formatter, value) {
    let formats = [];
    if (formatter) {
      if (Array.isArray(formatter)) {
        if (formatter.length === 0) {
          return true;
        }
        formats = formatter;
      } else {
        formats.push([formatter, value]);
      }
    }
    const len = this.length;
    if (formats.length === 0) {
      if (offset < 0) {
        offset = 0;
      }
      if (offset > len) {
        offset = len;
      }
      this._index = this.content.correctIndex(offset, false);
      return true;
    }
    const startIndex = this._index;
    let endIndex = this.content.correctIndex(startIndex + offset, true);
    if (endIndex > len) {
      endIndex = len;
    }
    let index = startIndex;
    const applyActions = [];
    const unApplyActions = [];
    const formatsObj = formats.reduce((opt, next) => {
      opt[next[0].name] = next[1];
      return opt;
    }, {});
    const resetFormatObj = formats.reduce((opt, next) => {
      opt[next[0].name] = null;
      return opt;
    }, {});
    if (endIndex - startIndex === 1) {
      const content = this.getContentAtIndex(startIndex);
      if (typeof content !== "string" && content.type === ContentType.InlineComponent) {
        content.changeMarker.forceMarkDirtied();
      }
    }
    this.content.slice(startIndex, endIndex).forEach((content) => {
      const offset2 = content.length;
      if (typeof content === "string" || content.type !== ContentType.BlockComponent) {
        const deletedFormat = this.format.extract(index, index + offset2);
        this.applyFormats(formats, index, offset2, this.applyFormatCoverChild);
        applyActions.push({
          type: "retain",
          offset: index
        }, {
          type: "retain",
          offset: offset2,
          formats: Object.assign({}, formatsObj)
        });
        unApplyActions.push({
          type: "retain",
          offset: index
        }, {
          type: "retain",
          offset: offset2,
          formats: resetFormatObj
        }, ...Slot.createActionByFormat(deletedFormat));
      } else {
        content.slots.toArray().forEach((slot) => {
          if (this.applyFormatCoverChild) {
            slot.background(() => {
              slot.retain(0);
              slot.retain(slot.length, formats);
            });
          } else {
            slot.retain(0);
            slot.retain(slot.length, formats);
          }
        });
      }
      index += offset2;
    });
    if (applyActions.length || unApplyActions.length) {
      this.changeMarker.markAsDirtied({
        path: [],
        apply: applyActions,
        unApply: unApplyActions
      });
      if (applyActions.length) {
        this.contentChangeEvent.next(applyActions);
      }
    }
    return true;
  }
  delete(count) {
    if (count <= 0) {
      return false;
    }
    const startIndex = this._index;
    let endIndex = this.content.correctIndex(this._index + count, true);
    count = endIndex - startIndex;
    if (endIndex > this.length) {
      endIndex = this.length;
    }
    const deletedData = this.content.cut(startIndex, endIndex);
    const deletedFormat = this.format.extract(startIndex, endIndex);
    this.format.shrink(startIndex, count);
    if (this.length === 0) {
      this.content.append(Slot.emptyPlaceholder);
      this.format = deletedFormat.extract(0, 1);
    }
    const applyActions = [{
      type: "retain",
      offset: startIndex
    }, {
      type: "delete",
      count
    }];
    const deletedComponents = [];
    this.changeMarker.markAsDirtied({
      path: [],
      apply: applyActions,
      unApply: [{
        type: "retain",
        offset: startIndex
      }, ...deletedData.map((item) => {
        var _a2;
        if (typeof item === "string") {
          return {
            type: "insert",
            content: item,
            ref: item
          };
        }
        deletedComponents.push(item);
        this.changeMarker.recordComponentRemoved(item);
        (_a2 = this.componentChangeListeners.get(item)) === null || _a2 === void 0 ? void 0 : _a2.unsubscribe();
        this.componentChangeListeners.delete(item);
        item.parent = null;
        return {
          type: "insert",
          content: item.toJSON(),
          ref: item
        };
      }), ...Slot.createActionByFormat(deletedFormat)]
    });
    this.contentChangeEvent.next(applyActions);
    if (deletedComponents.length) {
      this.childComponentRemoveEvent.next(deletedComponents);
    }
    return true;
  }
  applyFormat(formatter, data) {
    this.retain(data.startIndex);
    this.retain(data.endIndex - data.startIndex, formatter, data.value);
  }
  removeComponent(component) {
    const index = this.indexOf(component);
    if (index > -1) {
      this.retain(index);
      return this.delete(1);
    }
    return false;
  }
  cut(startIndex = 0, endIndex = this.length) {
    return this.cutTo(new Slot([...this.schema], this.state), startIndex, endIndex);
  }
  cutTo(slot, startIndex = 0, endIndex = this.length) {
    if (startIndex < 0) {
      startIndex = 0;
    }
    const length = this.length;
    if (endIndex > length) {
      endIndex = length;
    }
    if (startIndex > endIndex) {
      return slot;
    }
    if (slot.isEmpty) {
      this.attributes.forEach((value, key) => {
        slot.setAttribute(key, value);
      });
    }
    startIndex = this.content.correctIndex(startIndex, false);
    endIndex = this.content.correctIndex(endIndex, true);
    if (this.isEmpty) {
      slot.format = this.format.createFormatByRange(slot, 0, 1);
      this.retain(startIndex);
      this.delete(endIndex - startIndex);
      return slot;
    }
    if (startIndex === length || startIndex === length - 1 && this.content.getContentAtIndex(length - 1) === "\n") {
      slot.format = this.format.createFormatByRange(slot, startIndex - 1, startIndex);
      this.retain(startIndex);
      this.delete(endIndex - startIndex);
      return slot;
    }
    this.retain(startIndex);
    const deletedData = this.content.slice(this.index, endIndex);
    const deletedFormat = this.format.createFormatByRange(slot, this.index, endIndex);
    this.delete(endIndex - this.index);
    const temporarySlot = new Slot([
      ...slot.schema
    ]);
    deletedData.forEach((i2) => {
      temporarySlot.insert(i2);
    });
    temporarySlot.format = deletedFormat.createFormatByRange(temporarySlot, 0, temporarySlot.length);
    temporarySlot.toDelta().forEach((item) => {
      slot.insert(item.insert, item.formats);
    });
    return slot;
  }
  indexOf(component) {
    return this.content.indexOf(component);
  }
  getContentAtIndex(index) {
    return this.content.getContentAtIndex(index);
  }
  sliceContent(startIndex = 0, endIndex = this.length) {
    return this.content.slice(startIndex, endIndex);
  }
  createFormatTree() {
    return this.format.toTree(0, this.length);
  }
  getFormatRangesByFormatter(formatter, startIndex, endIndex) {
    return this.format.extractFormatRangesByFormatter(startIndex, endIndex, formatter);
  }
  getFormats() {
    return this.format.toArray();
  }
  extractFormatsByIndex(index) {
    return this.format.extractFormatsByIndex(index);
  }
  toJSON() {
    var _a2;
    const attrs = {};
    this.attributes.forEach((value, key) => {
      attrs[key.name] = value;
    });
    return {
      schema: this.schema,
      content: this.content.toJSON(),
      attributes: attrs,
      formats: this.format.toJSON(),
      state: (_a2 = this.state) !== null && _a2 !== void 0 ? _a2 : null
    };
  }
  toString() {
    return this.content.toString();
  }
  toDelta() {
    const deltaList = new DeltaLite();
    if (this.length === 0) {
      return deltaList;
    }
    const formatGrid = this.format.toGrid();
    const contentGrid = this.content.toGrid();
    const gridSet = /* @__PURE__ */ new Set([...formatGrid, ...contentGrid]);
    const grid = [...gridSet].sort((a2, b2) => a2 - b2);
    this.attributes.forEach((value, key) => {
      deltaList.attributes.set(key, value);
    });
    let startIndex = grid.shift();
    while (grid.length) {
      const endIndex = grid.shift();
      deltaList.push({
        insert: this.content.slice(startIndex, endIndex)[0],
        formats: this.format.extract(startIndex, endIndex).toArray().map((i2) => {
          return [i2.formatter, i2.value];
        })
      });
      startIndex = endIndex;
    }
    return deltaList;
  }
  insertDelta(delta) {
    delta.attributes.forEach((value, key) => {
      this.setAttribute(key, value);
    });
    while (delta.length) {
      const first = delta[0];
      const is = this.insert(first.insert, first.formats);
      if (is) {
        delta.shift();
      } else {
        break;
      }
    }
    return delta;
  }
  cleanFormats(excludeFormats = [], startIndex = 0, endIndex = this.length) {
    const formats = this.getFormats();
    if (formats.length) {
      formats.forEach((item) => {
        if (typeof excludeFormats === "function" ? excludeFormats(item.formatter) : excludeFormats.includes(item.formatter)) {
          return;
        }
        this.retain(startIndex);
        this.retain(endIndex - startIndex, item.formatter, null);
      });
    } else {
      this.sliceContent(startIndex, endIndex).forEach((item) => {
        if (typeof item !== "string") {
          item.slots.toArray().forEach((slot) => {
            slot.cleanFormats(excludeFormats);
          });
        }
      });
    }
  }
  background(fn2) {
    this.applyFormatCoverChild = true;
    fn2();
    this.applyFormatCoverChild = false;
  }
  cleanAttributes(excludeAttributes = []) {
    Array.from(this.attributes.keys()).forEach((item) => {
      if (typeof excludeAttributes === "function" ? excludeAttributes(item) : excludeAttributes.includes(item)) {
        return;
      }
      this.removeAttribute(item);
    });
    this.sliceContent().forEach((item) => {
      if (typeof item !== "string") {
        item.slots.toArray().forEach((slot) => {
          slot.cleanAttributes(excludeAttributes);
        });
      }
    });
  }
  applyFormats(formats, startIndex, offset, background) {
    formats.forEach((keyValue) => {
      const key = keyValue[0];
      const value = keyValue[1];
      this.format.merge(key, {
        startIndex,
        endIndex: startIndex + offset,
        value
      }, background);
    });
  }
  static createActionByFormat(format2) {
    return format2.toArray().map((item) => {
      return [{
        type: "retain",
        offset: item.startIndex
      }, {
        type: "retain",
        offset: item.endIndex - item.startIndex,
        formats: {
          [item.formatter.name]: item.value
        }
      }];
    }).flat();
  }
};
Slot.placeholder = "\u200B";
var RenderMode;
(function(RenderMode2) {
  RenderMode2["Output"] = "Output";
  RenderMode2["Readonly"] = "Readonly";
  RenderMode2["Editing"] = "Editing";
})(RenderMode || (RenderMode = {}));
var Controller = class Controller2 {
  get readonly() {
    return this._readonly;
  }
  set readonly(b2) {
    this._readonly = b2;
    this.readonlyStateChangeEvent.next(b2);
  }
  constructor(readonly) {
    this._readonly = false;
    this.readonlyStateChangeEvent = new Subject();
    this.onReadonlyStateChange = this.readonlyStateChangeEvent.asObservable().pipe(distinctUntilChanged());
    this._readonly = readonly;
  }
};
Controller = __decorate([
  Injectable(),
  __param(0, Inject(READONLY)),
  __metadata("design:paramtypes", [Boolean])
], Controller);
var Selection_1;
var NativeSelectionBridge = class {
};
var Selection = Selection_1 = class Selection2 {
  get isSelected() {
    return ![this.startSlot, this.startOffset, this.endSlot, this.endOffset].includes(null);
  }
  get isCollapsed() {
    return this.isSelected && this.startSlot === this.endSlot && this.startOffset === this.endOffset;
  }
  get startSlot() {
    return this._startSlot;
  }
  get startOffset() {
    return this._startOffset;
  }
  get endSlot() {
    return this._endSlot;
  }
  get endOffset() {
    return this._endOffset;
  }
  get anchorSlot() {
    return this._anchorSlot;
  }
  get anchorOffset() {
    return this._anchorOffset;
  }
  get focusSlot() {
    return this._focusSlot;
  }
  get focusOffset() {
    return this._focusOffset;
  }
  get commonAncestorSlot() {
    return this._commonAncestorSlot;
  }
  get commonAncestorComponent() {
    return this._commonAncestorComponent;
  }
  get nativeSelectionDelegate() {
    return this._nativeSelectionDelegate;
  }
  set nativeSelectionDelegate(v2) {
    if (v2 === this._nativeSelectionDelegate) {
      return;
    }
    this._nativeSelectionDelegate = v2;
    if (this.controller.readonly) {
      return;
    }
    if (v2) {
      this.bridge.connect(this.connector);
    } else {
      this.bridge.disConnect();
    }
  }
  constructor(root, controller) {
    this.root = root;
    this.controller = controller;
    this.connector = {
      setSelection: (range) => {
        if (range === null) {
          if (null === this.startSlot && null === this.endSlot && null === this.startOffset && null === this.endOffset) {
            return;
          }
          this.unSelect();
          return;
        }
        const { focusOffset, focusSlot, anchorOffset, anchorSlot } = range;
        if (focusSlot === this.focusSlot && anchorSlot === this.anchorSlot && focusOffset === this.focusOffset && anchorOffset === this.anchorOffset) {
          return;
        }
        this.setBaseAndExtent(anchorSlot, anchorOffset, focusSlot, focusOffset);
      }
    };
    this._commonAncestorSlot = null;
    this._commonAncestorComponent = null;
    this._startSlot = null;
    this._endSlot = null;
    this._startOffset = null;
    this._endOffset = null;
    this._anchorSlot = null;
    this._anchorOffset = null;
    this._focusSlot = null;
    this._focusOffset = null;
    this.changeEvent = new Subject();
    this._nativeSelectionDelegate = false;
    this.subscriptions = [];
    this.customRanges = null;
    this.changeFromUpdateCustomRanges = false;
    let prevFocusComponent;
    this.onChange = this.changeEvent.asObservable().pipe(distinctUntilChanged((previous, current) => {
      if (previous && current) {
        return !(previous.focusOffset === current.focusOffset && previous.anchorOffset === current.anchorOffset && previous.focusSlot === current.focusSlot && previous.anchorSlot === current.anchorSlot);
      }
      return previous !== current;
    }), share());
    let selectedComponent = null;
    const focusInComponents = [];
    this.subscriptions.push(controller.onReadonlyStateChange.subscribe((b2) => {
      if (b2) {
        this.bridge.disConnect();
      } else {
        this.bridge.connect(this.connector);
      }
    }), this.onChange.pipe(map(() => {
      return this.commonAncestorComponent;
    }), distinctUntilChanged()).subscribe((component) => {
      while (focusInComponents.length) {
        const focusOutComponent = focusInComponents.shift();
        let parentComponent = focusOutComponent;
        while (parentComponent) {
          if (parentComponent === root.component) {
            invokeListener(focusOutComponent, "onFocusOut");
          }
          parentComponent = parentComponent.parentComponent;
        }
      }
      while (component) {
        focusInComponents.push(component);
        invokeListener(component, "onFocusIn");
        component = component.parentComponent;
      }
    }), this.onChange.pipe(map(() => {
      return this.commonAncestorComponent;
    })).subscribe((commonAncestorComponent) => {
      let ranges = null;
      if (commonAncestorComponent) {
        invokeListener(commonAncestorComponent, "onGetRanges", new GetRangesEvent(commonAncestorComponent, (rgs) => {
          ranges = rgs;
        }));
      }
      if (!this.changeFromUpdateCustomRanges) {
        this.customRanges = ranges;
      }
    }), this.onChange.pipe(map(() => {
      var _a2, _b2, _c;
      if (((_a2 = this.startSlot) === null || _a2 === void 0 ? void 0 : _a2.parent) === ((_b2 = this.endSlot) === null || _b2 === void 0 ? void 0 : _b2.parent)) {
        return ((_c = this.startSlot) === null || _c === void 0 ? void 0 : _c.parent) || null;
      }
      return null;
    }), distinctUntilChanged()).subscribe((component) => {
      if (prevFocusComponent) {
        let parentComponent = prevFocusComponent;
        while (parentComponent) {
          if (parentComponent === root.component) {
            invokeListener(prevFocusComponent, "onBlur");
          }
          parentComponent = parentComponent.parentComponent;
        }
      }
      if (component) {
        invokeListener(component, "onFocus");
      }
      prevFocusComponent = component;
    }), this.onChange.pipe(map(() => {
      if (selectedComponent) {
        let p2 = selectedComponent.parentComponent;
        while (p2) {
          if (p2 === root.component) {
            invokeListener(selectedComponent, "onUnselect");
          }
          p2 = p2.parentComponent;
        }
        selectedComponent = null;
      }
      if (!this.isSelected) {
        return null;
      }
      if (this.startSlot === this.endSlot && this.endOffset - this.startOffset === 1) {
        const content = this.startSlot.getContentAtIndex(this.startOffset);
        if (typeof content !== "string") {
          return content;
        }
      }
      return null;
    }), distinctUntilChanged()).subscribe((component) => {
      if (component) {
        invokeListener(component, "onSelected");
        selectedComponent = component;
      }
    }));
    Promise.resolve().then(() => this.nativeSelectionDelegate = true);
  }
  createSnapshot() {
    const { anchorSlot, anchorOffset, focusSlot, focusOffset } = this;
    return {
      restore: (syncNative) => {
        this._anchorSlot = anchorSlot;
        this._anchorOffset = anchorOffset;
        this._focusSlot = focusSlot;
        this._focusOffset = focusOffset;
        this.resetStartAndEndPosition();
        if (syncNative) {
          this.restore(true);
        }
      }
    };
  }
  destroy() {
    this.subscriptions.forEach((i2) => i2.unsubscribe());
    this.subscriptions = [];
  }
  setSelectedRanges(ranges) {
    this.changeFromUpdateCustomRanges = true;
    this.customRanges = ranges;
    this.broadcastChanged();
    this.changeFromUpdateCustomRanges = false;
  }
  setBaseAndExtent(anchorSlot, anchorOffset, focusSlot, focusOffset) {
    if (this.controller.readonly) {
      return;
    }
    this._anchorSlot = anchorSlot;
    anchorSlot.retain(anchorOffset);
    this._anchorOffset = anchorSlot.index;
    this._focusSlot = focusSlot;
    focusSlot.retain(focusOffset);
    this._focusOffset = focusSlot.index;
    this.resetStartAndEndPosition();
  }
  getRanges() {
    if (this.customRanges) {
      return this.customRanges.map((i2) => {
        return {
          startOffset: i2.startIndex,
          endOffset: i2.endIndex,
          startSlot: i2.slot,
          endSlot: i2.slot
        };
      });
    }
    return this.isSelected ? [{
      startSlot: this.startSlot,
      endSlot: this.endSlot,
      startOffset: this.startOffset,
      endOffset: this.endOffset
    }] : [];
  }
  setAnchor(slot, offset) {
    if (this.controller.readonly) {
      return;
    }
    this._anchorSlot = slot;
    slot.retain(offset);
    this._anchorOffset = slot.index;
    this.resetStartAndEndPosition();
  }
  setFocus(slot, offset) {
    if (this.controller.readonly) {
      return;
    }
    this._focusSlot = slot;
    slot.retain(offset);
    this._focusOffset = slot.index;
    this.resetStartAndEndPosition();
  }
  setPosition(slot, offset) {
    if (this.controller.readonly) {
      return;
    }
    this._focusSlot = this._anchorSlot = slot;
    slot.retain(offset);
    this._focusOffset = this._anchorOffset = slot.index;
    this.resetStartAndEndPosition();
  }
  selectSlot(slot) {
    this.setBaseAndExtent(slot, 0, slot, slot.length);
  }
  selectFirstPosition(componentInstance, isRestore = false) {
    const slots = componentInstance.slots;
    if (slots.length) {
      const first = slots.first;
      const { slot, offset } = this.findFirstPosition(first, false);
      this.setBaseAndExtent(slot, offset, slot, offset);
    } else {
      this.selectComponentFront(componentInstance);
    }
    if (isRestore) {
      this.restore();
    }
  }
  selectLastPosition(componentInstance, isRestore = false) {
    const slots = componentInstance.slots;
    if (slots.length) {
      const last = slots.last;
      const { slot, offset } = this.findLastPosition(last, false);
      this.setBaseAndExtent(slot, offset, slot, offset);
    } else {
      this.selectComponentEnd(componentInstance);
    }
    if (isRestore) {
      this.restore();
    }
  }
  selectComponentFront(componentInstance, isRestore = false) {
    const parent = componentInstance.parent;
    if (parent) {
      const index = parent.indexOf(componentInstance);
      this.setBaseAndExtent(parent, index, parent, index);
    } else {
      this.unSelect();
    }
    if (isRestore) {
      this.restore();
    }
  }
  selectComponentEnd(componentInstance, isRestore = false) {
    const parent = componentInstance.parent;
    if (parent) {
      const index = parent.indexOf(componentInstance);
      this.setBaseAndExtent(parent, index + 1, parent, index + 1);
    } else {
      this.unSelect();
    }
    if (isRestore) {
      this.restore();
    }
  }
  selectChildSlots(componentInstance, isRestore = false) {
    const slots = componentInstance.slots;
    if (slots.length) {
      const firstPosition = this.findFirstPosition(slots.first, false);
      const lastPosition = this.findLastPosition(slots.last, false);
      this.setBaseAndExtent(firstPosition.slot, firstPosition.offset, lastPosition.slot, lastPosition.offset);
    } else {
      this.selectComponent(componentInstance, false);
    }
    if (isRestore) {
      this.restore();
    }
  }
  selectComponent(componentInstance, isRestore = false) {
    const parent = componentInstance.parent;
    if (parent) {
      const index = parent.indexOf(componentInstance);
      this.setBaseAndExtent(parent, index, parent, index + 1);
      if (isRestore) {
        this.restore();
      }
    }
  }
  getSelectedScopes(decompose = false) {
    if (!this.isSelected) {
      return [];
    }
    if (this.isCollapsed) {
      return [{
        slot: this.startSlot,
        startIndex: this.startOffset,
        endIndex: this.startOffset
      }];
    }
    const scopes = this.getScopes(this.startSlot, this.startOffset, this.endSlot, this.endOffset, true);
    if (decompose) {
      const ranges = [];
      scopes.forEach((i2) => {
        ranges.push(...this.decomposeSlotRange(i2.slot, i2.startIndex, i2.endIndex));
      });
      return ranges;
    }
    return scopes;
  }
  toPrevious() {
    var _a2, _b2;
    if (!this.isCollapsed) {
      this.collapse(true);
      this.restore();
      return;
    }
    const { startSlot, startOffset } = this;
    const position = this.getPreviousPosition();
    if (position) {
      this.setPosition(position.slot, position.offset);
      let content = null;
      if (startSlot === this.startSlot) {
        if (startOffset === this.startOffset) {
          const first = this.root.component.slots.first;
          this.setPosition(first, 0);
        } else if (startOffset - this.startOffset === 1) {
          content = startSlot.getContentAtIndex(this.startOffset);
        }
      } else if ((startSlot === null || startSlot === void 0 ? void 0 : startSlot.parent) !== ((_a2 = this.startSlot) === null || _a2 === void 0 ? void 0 : _a2.parent)) {
        content = ((_b2 = this.endSlot) === null || _b2 === void 0 ? void 0 : _b2.parent) || null;
      }
      if (content && typeof content !== "string") {
        const event = new Event(content, null);
        invokeListener(content, "onSelectionFromEnd", event);
        if (!event.isPrevented) {
          if (content.slots.length === 0) {
            this.selectComponent(content);
          }
        } else {
          this.setPosition(startSlot, startOffset);
        }
      }
      this.restore();
    }
  }
  toNext() {
    var _a2, _b2;
    if (!this.isCollapsed) {
      this.collapse();
      this.restore();
      return;
    }
    const { endSlot, endOffset } = this;
    const position = this.getNextPosition();
    if (position) {
      let offset = position.offset;
      const slot = position.slot;
      while (offset <= slot.length) {
        this.setPosition(slot, offset);
        if (slot.index < offset) {
          offset++;
        } else {
          break;
        }
      }
      let content = null;
      if (endSlot === this.endSlot) {
        if (endOffset === this.endOffset) {
          const last = this.root.component.slots.last;
          this.setPosition(last, last.length);
        } else if (this.endOffset - endOffset === 1) {
          content = endSlot.getContentAtIndex(endOffset);
        }
      } else if ((endSlot === null || endSlot === void 0 ? void 0 : endSlot.parent) !== ((_a2 = this.endSlot) === null || _a2 === void 0 ? void 0 : _a2.parent)) {
        content = ((_b2 = this.endSlot) === null || _b2 === void 0 ? void 0 : _b2.parent) || null;
      }
      if (content && typeof content !== "string") {
        const event = new Event(content, null);
        invokeListener(content, "onSelectionFromFront", event);
        if (!event.isPrevented) {
          if (content.slots.length === 0) {
            this.selectComponent(content);
          }
        } else {
          this.setPosition(endSlot, endOffset);
        }
      }
      this.restore();
    }
  }
  toPreviousLine() {
    const previousLinePosition = this.bridge.getPreviousLinePositionByCurrent({
      slot: this.focusSlot,
      offset: this.focusOffset
    });
    if (previousLinePosition) {
      this.setPosition(previousLinePosition.slot, previousLinePosition.offset);
      this.restore();
    }
  }
  toNextLine() {
    const nextLinePosition = this.bridge.getNextLinePositionByCurrent({
      slot: this.focusSlot,
      offset: this.focusOffset
    });
    if (nextLinePosition) {
      this.setPosition(nextLinePosition.slot, nextLinePosition.offset);
      this.restore();
    }
  }
  wrapToAfter() {
    this.wrapTo(false);
  }
  wrapToBefore() {
    this.wrapTo(true);
  }
  wrapToPreviousLine() {
    const previousLinePosition = this.bridge.getPreviousLinePositionByCurrent({
      slot: this.focusSlot,
      offset: this.focusOffset
    });
    if (previousLinePosition) {
      this.setFocus(previousLinePosition.slot, previousLinePosition.offset);
      this.restore();
    }
  }
  wrapToNextLine() {
    const nextLinePosition = this.bridge.getNextLinePositionByCurrent({
      slot: this.focusSlot,
      offset: this.focusOffset
    });
    if (nextLinePosition) {
      this.setFocus(nextLinePosition.slot, nextLinePosition.offset);
      this.restore();
    }
  }
  collapse(toStart = false) {
    if (toStart) {
      this.setPosition(this.startSlot, this.startOffset);
    } else {
      this.setPosition(this.endSlot, this.endOffset);
    }
  }
  restore(fromLocal = true) {
    if (this.nativeSelectionDelegate) {
      const focusSlot = this.focusSlot;
      const focusOffset = this.focusOffset;
      const anchorSlot = this.anchorSlot;
      const anchorOffset = this.anchorOffset;
      if (focusSlot && anchorSlot) {
        focusSlot.retain(focusOffset);
        anchorSlot.retain(anchorOffset);
        this.bridge.restore({
          focusOffset,
          focusSlot,
          anchorOffset,
          anchorSlot
        }, fromLocal);
      } else {
        this.bridge.restore(null, fromLocal);
      }
    }
  }
  getPaths() {
    if (!this.isSelected) {
      return {
        anchor: [],
        focus: []
      };
    }
    const anchor = this.getPathsBySlot(this.anchorSlot) || [];
    anchor.push(this.anchorOffset);
    const focus = this.getPathsBySlot(this.focusSlot) || [];
    focus.push(this.focusOffset);
    return {
      anchor,
      focus
    };
  }
  usePaths(paths) {
    const anchorPosition = this.findPositionByPath(paths.anchor);
    const focusPosition = this.findPositionByPath(paths.focus);
    if (anchorPosition && focusPosition) {
      this.setBaseAndExtent(anchorPosition.slot, anchorPosition.offset, focusPosition.slot, focusPosition.offset);
    }
  }
  unSelect() {
    this._anchorSlot = this._focusSlot = this._anchorOffset = this._focusOffset = null;
    this.resetStartAndEndPosition();
    this.restore();
  }
  selectAll() {
    const slot = this.root.component.slots.get(0);
    this.setBaseAndExtent(slot, 0, slot, slot.length);
    this.restore();
  }
  getNextPosition() {
    if (!this.isSelected) {
      return null;
    }
    return this.getNextPositionByPosition(this.focusSlot, this.focusOffset);
  }
  getPreviousPosition() {
    if (!this.isSelected) {
      return null;
    }
    return this.getPreviousPositionByPosition(this.focusSlot, this.focusOffset);
  }
  findSlotByPaths(paths) {
    const result = Selection_1.findTreeNode(paths, this.root.component);
    if (result instanceof Slot) {
      return result;
    }
    return null;
  }
  findComponentByPaths(paths) {
    if (paths.length === 0) {
      return this.root.component;
    }
    const result = Selection_1.findTreeNode(paths, this.root.component);
    if (result instanceof Slot) {
      return null;
    }
    return result;
  }
  getBlocks() {
    const blocks = [];
    if (!this.isSelected) {
      return blocks;
    }
    const scopes = this.getGreedyRanges();
    scopes.forEach((i2) => {
      blocks.push(...this.decomposeSlotRange(i2.slot, i2.startIndex, i2.endIndex));
    });
    return blocks;
  }
  getSlotRangeInCommonAncestorComponent() {
    const ancestorComponent = this.commonAncestorComponent;
    if (!ancestorComponent) {
      return null;
    }
    let startSlot = this.startSlot;
    let endSlot = this.endSlot;
    let startOffset;
    let endOffset;
    while (true) {
      const parent = startSlot.parent;
      if (parent === ancestorComponent) {
        startOffset = parent.slots.indexOf(startSlot);
        break;
      }
      if (parent === null || parent === void 0 ? void 0 : parent.parent) {
        startSlot = parent.parent;
      } else {
        return null;
      }
    }
    while (true) {
      const parent = endSlot.parent;
      if (parent === ancestorComponent) {
        endOffset = parent.slots.indexOf(endSlot) + 1;
        break;
      }
      if (parent === null || parent === void 0 ? void 0 : parent.parent) {
        endSlot = parent.parent;
      } else {
        return null;
      }
    }
    if (startOffset >= 0 && endOffset >= 1) {
      return {
        startOffset,
        endOffset,
        component: ancestorComponent
      };
    }
    return null;
  }
  getGreedyRanges() {
    if (!this.isSelected) {
      return [];
    }
    return this.getScopes(this.startSlot, Selection_1.getInlineContentStartIndex(this.startSlot, this.startOffset), this.endSlot, Selection_1.getInlineContentEndIndex(this.endSlot, this.endOffset));
  }
  findFirstPosition(slot, toChild = true) {
    const first = slot.getContentAtIndex(0);
    if (toChild && first && typeof first !== "string") {
      const firstChildSlot = first.slots.first;
      if (firstChildSlot) {
        return this.findFirstPosition(firstChildSlot);
      }
    }
    return {
      offset: 0,
      slot
    };
  }
  findLastPosition(slot, toChild = true) {
    const last = slot.getContentAtIndex(slot.length - 1);
    if (toChild && last && typeof last !== "string") {
      const lastChildSlot = last.slots.last;
      if (lastChildSlot) {
        return this.findLastPosition(lastChildSlot);
      }
    }
    return {
      offset: last === "\n" ? slot.length - 1 : slot.length,
      slot
    };
  }
  getCommonAncestorSlotScope() {
    if (!this.isSelected) {
      return null;
    }
    let startSlot = this.startSlot;
    let endSlot = this.endSlot;
    let startChildSlot = this.startSlot;
    let endChildSlot = this.endSlot;
    let startOffset = this.startOffset;
    let endOffset = this.endOffset;
    const commonAncestorSlot = this.commonAncestorSlot;
    const commonAncestorComponent = this.commonAncestorComponent;
    let startChildComponent = null;
    let endChildComponent = null;
    while (startSlot !== commonAncestorSlot) {
      startChildComponent = startSlot.parent;
      if (startChildComponent === commonAncestorComponent) {
        startChildSlot = startSlot;
      }
      startSlot = startChildComponent.parent;
      startOffset = startSlot.indexOf(startChildComponent);
    }
    while (endSlot !== commonAncestorSlot) {
      endChildComponent = endSlot.parent;
      if (endChildComponent === commonAncestorComponent) {
        endChildSlot = endSlot;
      }
      endSlot = endChildComponent.parent;
      endOffset = endSlot.indexOf(endChildComponent);
    }
    return {
      startOffset,
      startSlot,
      startChildComponent,
      endOffset: endOffset + 1,
      endSlot,
      endChildComponent,
      startChildSlot,
      endChildSlot
    };
  }
  getPathsBySlot(slot) {
    const paths = [];
    while (true) {
      const parentComponent = slot.parent;
      if (!parentComponent) {
        return null;
      }
      const slotIndex = parentComponent.slots.indexOf(slot);
      paths.push(slotIndex);
      const parentSlot = parentComponent.parent;
      if (!parentSlot) {
        if (parentComponent !== this.root.component) {
          return null;
        }
        break;
      }
      const componentIndex = parentSlot.indexOf(parentComponent);
      paths.push(componentIndex);
      slot = parentSlot;
    }
    return paths.length ? paths.reverse() : null;
  }
  getNextPositionByPosition(slot, offset) {
    if (offset === slot.length - 1) {
      const current = slot.getContentAtIndex(offset);
      if (current === "\n") {
        offset++;
      }
    }
    if (offset < slot.length) {
      const current = slot.getContentAtIndex(offset);
      if (typeof current !== "string") {
        const firstChildSlot = current.slots.get(0);
        if (firstChildSlot) {
          return this.findFirstPosition(firstChildSlot);
        }
      }
      return {
        slot,
        offset: offset + current.length
      };
    }
    const cacheSlot = slot;
    while (slot) {
      const parentComponent = slot.parent;
      const slotIndex = parentComponent.slots.indexOf(slot);
      if (slotIndex < parentComponent.slots.length - 1) {
        return this.findFirstPosition(parentComponent.slots.get(slotIndex + 1));
      }
      const parentSlot = parentComponent.parent;
      if (!parentSlot) {
        const len = cacheSlot.length;
        const last = cacheSlot.getContentAtIndex(len - 1);
        return {
          slot: cacheSlot,
          offset: last === "\n" ? len - 1 : len
        };
      }
      const componentIndex = parentSlot.indexOf(parentComponent);
      if (componentIndex < parentSlot.length) {
        if (parentComponent.type !== ContentType.BlockComponent) {
          return {
            slot: parentSlot,
            offset: componentIndex + 1
          };
        }
        const nextContent = parentSlot.getContentAtIndex(componentIndex + 1);
        if (nextContent) {
          if (typeof nextContent !== "string") {
            const nextFirstSlot = nextContent.slots.first;
            if (nextFirstSlot) {
              return this.findFirstPosition(nextFirstSlot);
            }
          }
          return {
            slot: parentSlot,
            offset: componentIndex + 1
          };
        }
      }
      slot = parentSlot;
    }
    return {
      slot: cacheSlot,
      offset: this.endOffset
    };
  }
  getPreviousPositionByPosition(slot, offset) {
    if (offset > 0) {
      const prev = slot.getContentAtIndex(offset - 1);
      if (prev && typeof prev !== "string") {
        const lastChildSlot = prev.slots.last;
        if (lastChildSlot) {
          return this.findLastPosition(lastChildSlot);
        }
      }
      return {
        slot,
        offset: offset - prev.length
      };
    }
    let cacheSlot = slot;
    while (slot) {
      const parentComponent = slot.parent;
      const slots = parentComponent.slots;
      const slotIndex = slots.indexOf(slot);
      if (slotIndex > 0) {
        return this.findLastPosition(slots.get(slotIndex - 1));
      }
      const parentSlot = parentComponent.parent;
      if (!parentSlot) {
        return {
          slot: cacheSlot,
          offset: 0
        };
      }
      const componentIndex = parentSlot.indexOf(parentComponent);
      if (componentIndex > 0) {
        const prevContent = parentSlot.getContentAtIndex(componentIndex - 1);
        if (prevContent && typeof prevContent !== "string") {
          const lastChildSlot = prevContent.slots.last;
          if (lastChildSlot) {
            return this.findLastPosition(lastChildSlot);
          }
        }
        return {
          slot: parentSlot,
          offset: prevContent === "\n" ? componentIndex - 1 : componentIndex
        };
      }
      slot = parentSlot;
      cacheSlot = slot;
    }
    return {
      slot: cacheSlot,
      offset: 0
    };
  }
  getScopes(startSlot, startIndex, endSlot, endIndex, discardEmptyScope = false) {
    const commonAncestorSlot = Selection_1.getCommonAncestorSlot(startSlot, endSlot);
    const commonAncestorComponent = Selection_1.getCommonAncestorComponent(startSlot, endSlot);
    return this.getScopesByRange(startSlot, startIndex, endSlot, endIndex, commonAncestorSlot, commonAncestorComponent, discardEmptyScope);
  }
  static getCommonAncestorComponent(startSlot, endSlot) {
    let startComponent = startSlot === null || startSlot === void 0 ? void 0 : startSlot.parent;
    let endComponent = endSlot === null || endSlot === void 0 ? void 0 : endSlot.parent;
    if (startComponent === endComponent) {
      return startComponent || null;
    }
    const startPaths = [];
    const endPaths = [];
    while (startComponent) {
      startPaths.push(startComponent);
      const parentSlot = startComponent.parent;
      if (!parentSlot) {
        break;
      }
      startComponent = parentSlot.parent;
    }
    while (endComponent) {
      endPaths.push(endComponent);
      const parentSlot = endComponent.parent;
      if (!parentSlot) {
        break;
      }
      endComponent = parentSlot.parent;
    }
    let f2 = null;
    while (startPaths.length && endPaths.length) {
      const s2 = startPaths.pop();
      const e = endPaths.pop();
      if (s2 === e) {
        f2 = s2;
      } else {
        break;
      }
    }
    return f2;
  }
  static getCommonAncestorSlot(startSlot, endSlot) {
    if (startSlot === endSlot) {
      return startSlot;
    }
    const startPaths = [];
    const endPaths = [];
    while (startSlot) {
      startPaths.push(startSlot);
      const parentComponent = startSlot.parent;
      if (!parentComponent) {
        break;
      }
      startSlot = parentComponent.parent;
    }
    while (endSlot) {
      endPaths.push(endSlot);
      const parentComponent = endSlot.parent;
      if (!parentComponent) {
        break;
      }
      endSlot = parentComponent.parent;
    }
    let f2 = null;
    while (startPaths.length && endPaths.length) {
      const s2 = startPaths.pop();
      const e = endPaths.pop();
      if (s2 === e) {
        f2 = s2;
      } else {
        break;
      }
    }
    return f2;
  }
  static compareSelectionPaths(minPaths, maxPaths, canEqual = true) {
    let minIsStart = true;
    let i2 = 0;
    while (true) {
      if (i2 < maxPaths.length) {
        if (i2 < minPaths.length) {
          const min = minPaths[i2];
          const max = maxPaths[i2];
          if (min === max) {
            if (i2 === maxPaths.length - 1 && i2 === minPaths.length - 1) {
              return canEqual;
            }
            i2++;
            continue;
          }
          minIsStart = min < max;
          break;
        } else {
          minIsStart = true;
          break;
        }
      } else {
        minIsStart = false;
        break;
      }
    }
    return minIsStart;
  }
  static getInlineContentStartIndex(slot, index) {
    const contents = slot.sliceContent(0, index);
    const len = contents.length;
    for (let i2 = len - 1; i2 >= 0; i2--) {
      const item = contents[i2];
      if (typeof item !== "string" && item.type === ContentType.BlockComponent) {
        break;
      }
      index -= item.length;
    }
    return index;
  }
  static getInlineContentEndIndex(slot, index) {
    const contents = slot.sliceContent(index);
    for (let i2 = 0; i2 < contents.length; i2++) {
      const item = contents[i2];
      if (typeof item !== "string" && item.type === ContentType.BlockComponent) {
        break;
      }
      index += item.length;
    }
    return index;
  }
  decomposeSlotRange(slot, startIndex, endIndex) {
    const scopes = [];
    if (startIndex >= endIndex) {
      return scopes;
    }
    let newScope = null;
    let i2 = 0;
    const contents = slot.sliceContent(startIndex, endIndex);
    contents.forEach((c2) => {
      if (typeof c2 !== "string" && c2.type === ContentType.BlockComponent && c2.slots.length !== 0) {
        newScope = null;
        c2.slots.toArray().forEach((s2) => {
          scopes.push(...this.decomposeSlotRange(s2, 0, s2.length));
        });
      } else if (!newScope) {
        newScope = {
          startIndex: startIndex + i2,
          endIndex: startIndex + i2 + c2.length,
          slot
        };
        scopes.push(newScope);
      } else {
        newScope.endIndex = startIndex + i2 + c2.length;
      }
      i2 += c2.length;
    });
    return scopes;
  }
  resetStartAndEndPosition() {
    let focusPaths = [];
    let anchorPaths = [];
    if (this.focusSlot) {
      const _focusPaths = this.getPathsBySlot(this.focusSlot);
      if (_focusPaths) {
        focusPaths = _focusPaths;
        focusPaths.push(this.focusOffset);
      } else {
        this._focusSlot = this._focusOffset = null;
      }
    }
    if (this.anchorSlot) {
      const _anchorPaths = this.getPathsBySlot(this.anchorSlot);
      if (_anchorPaths) {
        anchorPaths = _anchorPaths;
        anchorPaths.push(this.anchorOffset);
      } else {
        this._anchorSlot = this._anchorOffset = null;
      }
    }
    const anchorSlotIsStart = Selection_1.compareSelectionPaths(anchorPaths, focusPaths);
    if (anchorSlotIsStart) {
      this._startSlot = this.anchorSlot;
      this._startOffset = this.anchorOffset;
      this._endSlot = this.focusSlot;
      this._endOffset = this.focusOffset;
    } else {
      this._endSlot = this.anchorSlot;
      this._endOffset = this.anchorOffset;
      this._startSlot = this.focusSlot;
      this._startOffset = this.focusOffset;
    }
    this._commonAncestorSlot = Selection_1.getCommonAncestorSlot(this.startSlot, this.endSlot);
    this._commonAncestorComponent = Selection_1.getCommonAncestorComponent(this.startSlot, this.endSlot);
    this.broadcastChanged();
  }
  wrapTo(toLeft) {
    if (!this.isSelected) {
      return;
    }
    const position = toLeft ? this.getPreviousPositionByPosition(this.focusSlot, this.focusOffset) : this.getNextPositionByPosition(this.focusSlot, this.focusOffset);
    this.setBaseAndExtent(this.anchorSlot, this.anchorOffset, position.slot, position.offset);
    this.restore();
  }
  findPositionByPath(paths) {
    const startPaths = [...paths];
    const offset = startPaths.pop();
    const slot = this.findSlotByPaths(startPaths);
    if (slot) {
      return {
        slot,
        offset
      };
    }
    return null;
  }
  broadcastChanged() {
    this.changeEvent.next(this.isSelected ? {
      focusSlot: this.focusSlot,
      anchorSlot: this.anchorSlot,
      focusOffset: this.focusOffset,
      anchorOffset: this.anchorOffset
    } : null);
  }
  getScopesByRange(startSlot, startIndex, endSlot, endIndex, commonAncestorSlot, commonAncestorComponent, discardEmptyScope = false) {
    const start = [];
    const end = [];
    let startParentComponent = null;
    let endParentComponent = null;
    let startSlotRefIndex = null;
    let endSlotRefIndex = null;
    if (this.customRanges) {
      return this.customRanges;
    }
    while (startSlot !== commonAncestorSlot) {
      start.push({
        startIndex,
        endIndex: startSlot.length,
        slot: startSlot
      });
      startParentComponent = startSlot.parent;
      const childSlots = startParentComponent.slots;
      const end2 = childSlots.indexOf(endSlot);
      startSlotRefIndex = childSlots.indexOf(startSlot);
      if (startParentComponent !== commonAncestorComponent && end2 === -1) {
        start.push(...childSlots.slice(startSlotRefIndex + 1, childSlots.length).map((slot) => {
          return {
            startIndex: 0,
            endIndex: slot.length,
            slot
          };
        }));
      }
      if (!startParentComponent.parent) {
        break;
      }
      startSlot = startParentComponent.parent;
      startIndex = startSlot.indexOf(startParentComponent) + 1;
    }
    while (endSlot !== commonAncestorSlot) {
      end.push({
        startIndex: 0,
        endIndex,
        slot: endSlot
      });
      endParentComponent = endSlot.parent;
      if (!endParentComponent) {
        break;
      }
      const childSlots = endParentComponent.slots;
      const index = childSlots.indexOf(startSlot);
      endSlotRefIndex = childSlots.indexOf(endSlot);
      if (endParentComponent !== commonAncestorComponent && index === -1) {
        end.push(...childSlots.slice(0, endSlotRefIndex).map((slot) => {
          return {
            startIndex: 0,
            endIndex: slot.length,
            slot
          };
        }).reverse());
      }
      if (!endParentComponent.parent) {
        break;
      }
      endSlot = endParentComponent.parent;
      endIndex = endSlot.indexOf(endParentComponent);
    }
    const result = [...start];
    if (startParentComponent && startParentComponent === endParentComponent) {
      const slots = startParentComponent.slots.slice(startSlotRefIndex + 1, endSlotRefIndex);
      result.push(...slots.map((slot) => {
        return {
          startIndex: 0,
          endIndex: slot.length,
          slot
        };
      }));
    } else {
      result.push({
        startIndex,
        endIndex,
        slot: commonAncestorSlot
      });
    }
    result.push(...end.reverse());
    if (discardEmptyScope) {
      return result.filter((item) => {
        return item.slot && item.startIndex < item.endIndex;
      });
    }
    return result;
  }
  static findTreeNode(paths, component) {
    if (typeof component !== "object") {
      return null;
    }
    const firstSlotRefIndex = paths.shift();
    const slot = component.slots.get(firstSlotRefIndex);
    if (paths.length === 0 || !slot) {
      return slot || null;
    }
    const position = paths.shift();
    component = slot.getContentAtIndex(position);
    if (paths.length === 0 || !component) {
      return component || null;
    }
    return Selection_1.findTreeNode(paths, component);
  }
};
__decorate([
  Prop(),
  __metadata(
    "design:type",
    NativeSelectionBridge
  )
], Selection.prototype, "bridge", void 0);
Selection = Selection_1 = __decorate([
  Injectable(),
  __metadata("design:paramtypes", [
    RootComponentRef,
    Controller
  ])
], Selection);
var Registry = class Registry2 {
  constructor(contextInjector, components, attributes, formatters) {
    this.contextInjector = contextInjector;
    this.components = components;
    this.attributes = attributes;
    this.formatters = formatters;
    this.componentMap = /* @__PURE__ */ new Map();
    this.formatMap = /* @__PURE__ */ new Map();
    this.attributeMap = /* @__PURE__ */ new Map();
    components.reverse().forEach((f2) => {
      this.componentMap.set(f2.name, f2);
    });
    attributes.reverse().forEach((f2) => {
      this.attributeMap.set(f2.name, f2);
    });
    formatters.reverse().forEach((f2) => {
      this.formatMap.set(f2.name, f2);
    });
  }
  getComponent(name) {
    return this.componentMap.get(name) || null;
  }
  getFormatter(name) {
    return this.formatMap.get(name) || null;
  }
  getAttribute(name) {
    return this.attributeMap.get(name) || null;
  }
  createComponentByData(name, data) {
    const factory = this.getComponent(name);
    if (factory) {
      return factory.createInstance(this.contextInjector, data);
    }
    return null;
  }
  createSlot(slotLiteral, customComponentCreator) {
    const slot = new Slot(slotLiteral.schema, slotLiteral.state);
    return this.loadSlot(slot, slotLiteral, customComponentCreator);
  }
  createComponent(componentLiteral, customSlotCreator) {
    const factory = this.getComponent(componentLiteral.name);
    if (factory) {
      return this.createComponentByFactory(componentLiteral, factory, customSlotCreator);
    }
    return null;
  }
  createComponentByFactory(componentLiteral, factory, customSlotCreator) {
    const slots = componentLiteral.slots.map(customSlotCreator || ((i2) => this.createSlot(i2)));
    return factory.createInstance(this.contextInjector, {
      state: componentLiteral.state,
      slots
    });
  }
  fillSlot(source, target) {
    return this.loadSlot(target, source);
  }
  loadSlot(slot, slotLiteral, customComponentCreator) {
    slotLiteral.content.forEach((item, index) => {
      if (typeof item !== "string") {
        const component = customComponentCreator ? customComponentCreator(item, index) : this.createComponent(item);
        if (component) {
          slot.insert(component);
        }
        return;
      }
      slot.insert(item);
    });
    Object.keys(slotLiteral.formats).forEach((key) => {
      const formatter = this.getFormatter(key);
      if (formatter) {
        slotLiteral.formats[key].forEach((i2) => {
          slot.retain(i2.startIndex);
          slot.retain(i2.endIndex - i2.startIndex, formatter, i2.value);
        });
      }
    });
    if (slotLiteral.attributes !== null && typeof slotLiteral.attributes === "object") {
      Object.keys(slotLiteral.attributes).forEach((key) => {
        const attribute = this.attributeMap.get(key);
        if (attribute) {
          slot.setAttribute(attribute, slotLiteral.attributes[key]);
        }
      });
    }
    return slot;
  }
};
Registry = __decorate([
  Injectable(),
  __param(1, Inject(COMPONENT_LIST)),
  __param(2, Inject(ATTRIBUTE_LIST)),
  __param(3, Inject(FORMATTER_LIST)),
  __metadata("design:paramtypes", [Injector, Array, Array, Array])
], Registry);
function getInsertPosition(slot, offset, content, excludeSlots = []) {
  if (canInsert(content, slot)) {
    return {
      slot,
      offset
    };
  }
  excludeSlots.push(slot);
  return getNextInsertPosition(slot, content, excludeSlots);
}
function canInsert(content, target) {
  const insertType = typeof content === "string" ? ContentType.Text : content.type;
  return target.schema.includes(insertType);
}
function getNextInsertPosition(currentSlot, content, excludeSlots) {
  const parentComponent = currentSlot.parent;
  const slotIndex = parentComponent.slots.indexOf(currentSlot);
  if (currentSlot !== parentComponent.slots.last) {
    return getInsertPosition(parentComponent.slots.get(slotIndex + 1), 0, content, excludeSlots);
  }
  const parentSlot = parentComponent.parent;
  if (!parentSlot) {
    return null;
  }
  if (excludeSlots.includes(parentSlot)) {
    return getNextInsertPosition(parentSlot, content, excludeSlots);
  }
  const index = parentSlot.indexOf(parentComponent);
  const position = getInsertPosition(parentSlot, index + 1, content, excludeSlots);
  if (position) {
    return position;
  }
  excludeSlots.push(parentSlot);
  const afterContent = parentSlot.sliceContent(index + 1);
  const firstComponent = afterContent.filter((i2) => {
    return typeof i2 !== "string";
  }).shift();
  if (firstComponent && firstComponent.slots.length) {
    return getInsertPosition(firstComponent.slots.get(0), 0, content, excludeSlots);
  }
  return getNextInsertPosition(parentSlot, content, excludeSlots);
}
function deleteUpBySlot(selection, slot, offset, rootComponent2, deleteBefore) {
  const parentComponent = slot.parent;
  if (!parentComponent) {
    return {
      slot,
      offset
    };
  }
  const parentSlot = parentComponent.parent;
  if (!parentSlot) {
    return {
      slot,
      offset
    };
  }
  const index = parentSlot.indexOf(parentComponent);
  if (parentComponent.slots.length === 1) {
    if (parentComponent === rootComponent2) {
      return {
        slot,
        offset
      };
    }
    const event2 = new Event(parentSlot, {
      index,
      count: 1,
      toEnd: !deleteBefore,
      actionType: "delete"
    });
    invokeListener(parentSlot.parent, "onContentDelete", event2);
    if (event2.isPrevented) {
      return {
        slot,
        offset
      };
    }
    parentSlot.retain(index);
    parentSlot.delete(1);
    invokeListener(parentSlot.parent, "onContentDeleted", new Event(parentSlot, null));
    if (parentSlot.isEmpty) {
      return deleteUpBySlot(selection, parentSlot, index, rootComponent2, deleteBefore);
    }
    return {
      slot: parentSlot,
      offset: parentSlot.index
    };
  }
  const slotIndex = parentComponent.slots.indexOf(slot);
  const position = slotIndex === 0 ? {
    slot: parentSlot,
    offset: index
  } : selection.findLastPosition(parentComponent.slots.get(slotIndex - 1), true);
  const event = new Event(parentComponent, {
    index: slotIndex,
    count: 1,
    toEnd: !deleteBefore,
    actionType: "delete"
  });
  invokeListener(parentComponent, "onSlotRemove", event);
  if (!event.isPrevented) {
    const isSuccess = parentComponent.slots.remove(slot);
    if (isSuccess) {
      invokeListener(parentComponent, "onSlotRemoved", new Event(parentComponent, null));
    }
    return position;
  }
  return {
    slot,
    offset
  };
}
function deltaToSlots(selection, source, delta, rule, abstractSelection, offset) {
  const parentComponent = source.parent;
  const context = {
    slotState: source.state,
    parentComponentName: parentComponent.name,
    parentComponentState: parentComponent.state
  };
  let newSlot = rule.slotFactory(context);
  delta.attributes.forEach((value, key) => {
    newSlot.setAttribute(key, value);
  });
  const newSlots = [newSlot];
  let index = 0;
  while (delta.length) {
    const { insert, formats } = delta.shift();
    const b2 = canInsert(insert, newSlot);
    const oldIndex = index;
    index += insert.length;
    if (b2) {
      newSlot.insert(insert, formats);
      if (source === abstractSelection.anchorSlot && abstractSelection.anchorOffset - offset >= oldIndex && abstractSelection.anchorOffset - offset <= index) {
        abstractSelection.anchorSlot = newSlot;
        abstractSelection.anchorOffset -= offset;
      }
      if (source === abstractSelection.focusSlot && abstractSelection.focusOffset - offset >= oldIndex && abstractSelection.focusOffset - offset <= index) {
        abstractSelection.focusSlot = newSlot;
        abstractSelection.focusOffset -= offset;
      }
      continue;
    }
    if (abstractSelection.anchorOffset > index) {
      abstractSelection.anchorOffset -= index;
    }
    if (abstractSelection.focusOffset > index) {
      abstractSelection.focusOffset -= index;
    }
    if (typeof insert !== "string") {
      const slots = insert.slots.toArray().map((childSlot) => {
        return deltaToSlots(selection, source, childSlot.toDelta(), rule, abstractSelection, offset);
      }).flat();
      newSlots.push(...slots);
    }
    newSlot = rule.slotFactory(context);
    delta.attributes.forEach((value, key) => {
      newSlot.setAttribute(key, value);
    });
  }
  return newSlots;
}
function slotsToComponents(injector, slots, rule) {
  var _a2;
  const componentInstances = [];
  if (!slots.length) {
    return componentInstances;
  }
  if (rule.multipleSlot) {
    componentInstances.push(rule.target.createInstance(injector, {
      state: (_a2 = rule.stateFactory) === null || _a2 === void 0 ? void 0 : _a2.call(rule),
      slots
    }));
  } else {
    slots.forEach((childSlot) => {
      var _a3;
      componentInstances.push(rule.target.createInstance(injector, {
        state: (_a3 = rule.stateFactory) === null || _a3 === void 0 ? void 0 : _a3.call(rule),
        slots: [childSlot]
      }));
    });
  }
  return componentInstances;
}
function getBlockRangeToBegin(selection, slot, offset) {
  let startIndex = offset;
  const content = slot.sliceContent(0, offset);
  while (content.length) {
    const item = content.pop();
    if (typeof item !== "string" && item.type === ContentType.BlockComponent) {
      break;
    }
    startIndex -= item.length;
  }
  return {
    slot,
    startIndex,
    endIndex: offset
  };
}
var Commander = class Commander2 {
  constructor(selection, injector, registry, rootComponentRef) {
    this.selection = selection;
    this.injector = injector;
    this.registry = registry;
    this.rootComponentRef = rootComponentRef;
  }
  transform(rule) {
    const selection = this.selection;
    if (!selection.isSelected) {
      return false;
    }
    const abstractSelection = {
      anchorSlot: selection.anchorSlot,
      anchorOffset: selection.anchorOffset,
      focusSlot: selection.focusSlot,
      focusOffset: selection.focusOffset
    };
    const ranges = selection.getRanges();
    for (let i2 = 0; i2 < ranges.length; i2++) {
      const range = ranges[i2];
      const isTransformed = this.transformByRange(rule, abstractSelection, range);
      if (!isTransformed) {
        break;
      }
    }
    selection.setBaseAndExtent(abstractSelection.anchorSlot, abstractSelection.anchorOffset, abstractSelection.focusSlot, abstractSelection.focusOffset);
    return true;
  }
  write(content, formatter, value) {
    const selection = this.selection;
    const canInsert2 = selection.isCollapsed ? true : this.delete();
    if (!canInsert2) {
      return false;
    }
    const position = getInsertPosition(selection.startSlot, selection.startOffset, content);
    if (!position) {
      return false;
    }
    let formats = position.slot.extractFormatsByIndex(position.offset);
    if (formatter) {
      if (Array.isArray(formatter)) {
        formats = [
          ...formats,
          ...formatter
        ];
      } else {
        formats.push([formatter, value]);
      }
    }
    return this.insert(content, formats);
  }
  insert(content, formatter, value) {
    const selection = this.selection;
    const canInsert2 = selection.isCollapsed ? true : this.delete();
    if (!canInsert2) {
      return false;
    }
    let formats = [];
    if (formatter) {
      if (Array.isArray(formatter)) {
        formats = formatter;
      } else {
        formats.push([formatter, value]);
      }
    }
    const position = getInsertPosition(selection.startSlot, selection.startOffset, content);
    if (!position) {
      return false;
    }
    const { slot, offset } = position;
    const event = new Event(slot, {
      index: offset,
      content,
      formats
    });
    invokeListener(slot.parent, "onContentInsert", event);
    if (!event.isPrevented) {
      slot.retain(offset);
      slot.insert(content, formats);
      const insertedEvent = new Event(slot, {
        index: offset,
        content,
        formats
      });
      invokeListener(slot.parent, "onContentInserted", insertedEvent);
      if (!insertedEvent.isPrevented) {
        selection.setBaseAndExtent(slot, slot.index, slot, slot.index);
      }
    }
    return !event.isPrevented;
  }
  delete(receiver, deleteBefore = true) {
    if (typeof receiver === "boolean") {
      deleteBefore = receiver;
      receiver = function() {
      };
    } else if (typeof receiver !== "function") {
      receiver = function() {
      };
    }
    const selection = this.selection;
    if (!selection.isSelected) {
      return false;
    }
    let endSlot = selection.endSlot;
    let endOffset = selection.endOffset;
    let startSlot = selection.startSlot;
    let startOffset = selection.startOffset;
    let isDeleteRanges = true;
    if (selection.isCollapsed) {
      if (deleteBefore) {
        if (startOffset === 0) {
          isDeleteRanges = false;
        }
        const prevPosition = selection.getPreviousPosition();
        startSlot = prevPosition.slot;
        startOffset = prevPosition.offset;
      } else {
        const nextPosition = selection.getNextPosition();
        endSlot = nextPosition.slot;
        endOffset = nextPosition.offset;
      }
    }
    if (startSlot === endSlot && startOffset === endOffset) {
      if (startSlot.isEmpty) {
        receiver(startSlot.cut());
        const position = deleteUpBySlot(selection, startSlot, startOffset, this.rootComponentRef.component, deleteBefore);
        selection.setBaseAndExtent(position.slot, position.offset, position.slot, position.offset);
        return position.slot !== startSlot || position.offset !== startOffset;
      }
      return false;
    }
    const scopes = selection.getScopes(startSlot, startOffset, endSlot, endOffset, true);
    let endCutIndex = endOffset;
    while (isDeleteRanges && scopes.length) {
      const lastScope = scopes.pop();
      const { slot, startIndex } = lastScope;
      const endIndex = lastScope.endIndex;
      const isFocusEnd = selection.focusSlot === slot && selection.focusOffset === endIndex;
      const event = new Event(slot, {
        index: startIndex,
        count: endIndex - startIndex,
        toEnd: !deleteBefore,
        actionType: "delete"
      });
      invokeListener(slot.parent, "onContentDelete", event);
      if (event.isPrevented) {
        return false;
      }
      const deletedSlot = slot.cut(startIndex, endIndex);
      receiver(deletedSlot);
      const deletedEvent = new Event(slot, null);
      invokeListener(slot.parent, "onContentDeleted", deletedEvent);
      if (deletedEvent.isPrevented) {
        if (isFocusEnd) {
          selection.setFocus(slot, endIndex);
        } else {
          selection.setAnchor(slot, endIndex);
        }
        return false;
      }
      if (slot === endSlot) {
        endCutIndex = startIndex;
      }
      if (slot !== startSlot && slot !== endSlot && slot.isEmpty) {
        const position = deleteUpBySlot(selection, slot, startIndex, this.rootComponentRef.component, deleteBefore);
        if (position.slot === endSlot) {
          endCutIndex = position.offset;
        }
      }
    }
    if (startSlot !== endSlot) {
      const event = new Event(endSlot, {
        index: endCutIndex,
        count: endSlot.length,
        toEnd: !deleteBefore,
        actionType: "move"
      });
      invokeListener(endSlot.parent, "onContentDelete", event);
      if (event.isPrevented) {
        return false;
      }
      const deletedSlot = endSlot.cut(endCutIndex);
      receiver(deletedSlot);
      const deletedEvent = new Event(endSlot, null);
      invokeListener(endSlot.parent, "onContentDeleted", deletedEvent);
      if (!deletedEvent.isPrevented) {
        if (endSlot.isEmpty) {
          deleteUpBySlot(selection, endSlot, 0, this.rootComponentRef.component, deleteBefore);
        }
      }
      if (!deletedSlot.isEmpty) {
        const deletedDelta = deletedSlot.toDelta();
        selection.setPosition(startSlot, startOffset);
        deletedDelta.forEach((item) => {
          this.insert(item.insert, item.formats);
        });
      }
      if (deletedEvent.isPrevented) {
        return false;
      }
    }
    selection.setBaseAndExtent(startSlot, startOffset, startSlot, startOffset);
    return true;
  }
  break() {
    const selection = this.selection;
    if (!selection.isSelected) {
      return false;
    }
    if (!selection.isCollapsed) {
      const isCollapsed = this.delete(false);
      if (!isCollapsed) {
        return false;
      }
    }
    const startSlot = this.selection.startSlot;
    const event = new Event(startSlot, {
      index: this.selection.startOffset
    });
    invokeListener(startSlot.parent, "onBreak", event);
    if (!event.isPrevented) {
      const startOffset = this.selection.startOffset;
      const isToEnd = startOffset === startSlot.length || startSlot.isEmpty;
      const content = isToEnd ? "\n\n" : "\n";
      const isInserted = this.write(content);
      if (isInserted && isToEnd) {
        this.selection.setPosition(startSlot, startOffset + 1);
      }
    }
    return !event.isPrevented;
  }
  insertBefore(newChild, ref) {
    const parentSlot = ref === null || ref === void 0 ? void 0 : ref.parent;
    if (parentSlot) {
      const index = parentSlot.indexOf(ref);
      this.selection.setBaseAndExtent(parentSlot, index, parentSlot, index);
      return this.insert(newChild);
    }
    return false;
  }
  insertAfter(newChild, ref) {
    const parentSlot = ref === null || ref === void 0 ? void 0 : ref.parent;
    if (parentSlot) {
      const index = parentSlot.indexOf(ref) + 1;
      this.selection.setBaseAndExtent(parentSlot, index, parentSlot, index);
      return this.insert(newChild);
    }
    return false;
  }
  replaceComponent(oldComponent, newComponent) {
    const b2 = this.removeComponent(oldComponent);
    if (b2) {
      return this.insert(newComponent);
    }
    return false;
  }
  copy() {
    this.injector.get(NativeRenderer).copy();
  }
  cut() {
    this.copy();
    if (this.selection.isCollapsed) {
      return false;
    }
    return this.delete();
  }
  paste(pasteSlot, text2) {
    if (pasteSlot.isEmpty) {
      return false;
    }
    const selection = this.selection;
    if (!selection.isSelected) {
      return false;
    }
    if (!selection.isCollapsed) {
      this.delete();
    }
    const component = selection.commonAncestorComponent;
    const slot = selection.commonAncestorSlot;
    const event = new Event(slot, {
      index: selection.startOffset,
      data: pasteSlot,
      text: text2
    });
    invokeListener(component, "onPaste", event);
    if (!event.isPrevented) {
      const delta = pasteSlot.toDelta();
      const afterDelta = new DeltaLite();
      while (delta.length) {
        const { insert, formats } = delta.shift();
        const commonAncestorSlot = selection.commonAncestorSlot;
        if (canInsert(insert, commonAncestorSlot)) {
          this.insert(insert, formats);
          continue;
        }
        afterDelta.push(...commonAncestorSlot.cut(selection.startOffset).toDelta());
        const parentComponent = commonAncestorSlot.parent;
        if (commonAncestorSlot === parentComponent.slots.last) {
          this.insert(insert, formats);
          continue;
        }
        if (parentComponent.separable) {
          const index = parentComponent.slots.indexOf(commonAncestorSlot);
          const nextSlots = parentComponent.slots.cut(index + 1);
          const nextComponent = this.registry.createComponentByData(parentComponent.name, {
            state: typeof parentComponent.state === "object" && parentComponent.state !== null ? JSON.parse(JSON.stringify(parentComponent.state)) : parentComponent.state,
            slots: nextSlots
          });
          afterDelta.push({
            insert: nextComponent,
            formats: []
          });
          this.insert(insert, formats);
          continue;
        }
        if (typeof insert === "string") {
          this.insert(insert, formats);
          continue;
        }
        for (const childSlot of insert.slots.toArray()) {
          delta.unshift(...childSlot.toDelta());
        }
      }
      const snapshot = this.selection.createSnapshot();
      while (afterDelta.length) {
        const { insert, formats } = afterDelta.shift();
        this.insert(insert, formats);
      }
      snapshot.restore();
      const currentContent = selection.startSlot.getContentAtIndex(selection.startOffset);
      if (currentContent && typeof currentContent !== "string" && currentContent.type === ContentType.BlockComponent && currentContent.slots.length > 0) {
        selection.toNext();
      }
    }
    return !event.isPrevented;
  }
  cleanFormats(excludeFormatters = []) {
    this.selection.getSelectedScopes().forEach((scope) => {
      const slot = scope.slot;
      if (scope.startIndex === 0) {
        if (scope.endIndex === slot.length - 1) {
          const lastContent = slot.getContentAtIndex(slot.length - 1);
          if (lastContent === "\n") {
            scope.endIndex++;
          }
        }
      }
      slot.cleanFormats(excludeFormatters, scope.startIndex, scope.endIndex);
    });
  }
  applyFormat(formatter, value) {
    if (this.selection.isCollapsed) {
      const slot = this.selection.commonAncestorSlot;
      if (slot.isEmpty) {
        slot.retain(0);
        slot.retain(slot.length, formatter, value);
      } else {
        this.write(Slot.placeholder);
        const startOffset = this.selection.startOffset;
        slot.retain(startOffset - 1);
        slot.retain(1, formatter, value);
      }
      return;
    }
    this.selection.getSelectedScopes().forEach((i2) => {
      i2.slot.retain(i2.startIndex);
      i2.slot.retain(i2.endIndex - i2.startIndex, formatter, value);
    });
  }
  unApplyFormat(formatter) {
    if (this.selection.isCollapsed) {
      const slot = this.selection.commonAncestorSlot;
      if (slot.isEmpty) {
        slot.retain(0);
        slot.retain(slot.length, formatter, null);
      } else {
        const startOffset = this.selection.startOffset;
        const prevContent = slot.getContentAtIndex(startOffset - 1);
        if (prevContent === Slot.placeholder) {
          slot.retain(startOffset - 1);
          slot.retain(1, formatter, null);
        } else {
          this.write(Slot.placeholder);
          slot.retain(startOffset);
          slot.retain(1, formatter, null);
        }
      }
      return;
    }
    this.selection.getSelectedScopes().forEach((i2) => {
      i2.slot.retain(i2.startIndex);
      i2.slot.retain(i2.endIndex - i2.startIndex, formatter, null);
    });
  }
  applyAttribute(attribute, value) {
    if (this.selection.isCollapsed) {
      const slot = this.selection.commonAncestorSlot;
      slot.setAttribute(attribute, value);
      return;
    }
    this.selection.getSelectedScopes().forEach((i2) => {
      const contents = i2.slot.sliceContent(i2.startIndex, i2.endIndex);
      const childComponents = [];
      let hasInlineContent = false;
      contents.forEach((item) => {
        if (typeof item === "string" || item.type === ContentType.InlineComponent) {
          hasInlineContent = true;
        } else {
          childComponents.push(item);
        }
      });
      if (hasInlineContent) {
        i2.slot.setAttribute(attribute, value);
      } else {
        childComponents.forEach((i3) => {
          i3.slots.toArray().forEach((slot) => {
            slot.setAttribute(attribute, value);
          });
        });
      }
    });
  }
  unApplyAttribute(attribute) {
    if (this.selection.isCollapsed) {
      const slot = this.selection.commonAncestorSlot;
      slot.removeAttribute(attribute);
      return;
    }
    this.selection.getSelectedScopes().forEach((i2) => {
      const contents = i2.slot.sliceContent(i2.startIndex, i2.endIndex);
      const childComponents = [];
      let hasString = false;
      contents.forEach((item) => {
        if (typeof item !== "string") {
          childComponents.push(item);
        } else {
          hasString = true;
        }
      });
      if (hasString) {
        i2.slot.removeAttribute(attribute);
      } else {
        childComponents.forEach((i3) => {
          i3.slots.toArray().forEach((slot) => {
            slot.removeAttribute(attribute);
          });
        });
      }
    });
  }
  cleanAttributes(excludeAttributes = []) {
    this.selection.getSelectedScopes().forEach((i2) => {
      const contents = i2.slot.sliceContent(i2.startIndex, i2.endIndex);
      const childComponents = [];
      let hasString = false;
      contents.forEach((item) => {
        if (typeof item !== "string") {
          childComponents.push(item);
        } else {
          hasString = true;
        }
      });
      if (hasString) {
        i2.slot.cleanAttributes(excludeAttributes);
      } else {
        childComponents.forEach((i3) => {
          i3.slots.toArray().forEach((slot) => {
            slot.cleanAttributes(excludeAttributes);
          });
        });
      }
    });
  }
  removeComponent(component) {
    const parentSlot = component === null || component === void 0 ? void 0 : component.parent;
    if (parentSlot) {
      const index = parentSlot.indexOf(component);
      this.selection.setBaseAndExtent(parentSlot, index, parentSlot, index + 1);
      return this.delete();
    }
    return false;
  }
  transformByRange(rule, abstractSelection, range) {
    const { startSlot, startOffset, endSlot, endOffset } = range;
    const selection = this.selection;
    const commonAncestorSlot = Selection.getCommonAncestorSlot(startSlot, endSlot);
    const commonAncestorComponent = Selection.getCommonAncestorComponent(startSlot, endSlot);
    if (!commonAncestorSlot || !commonAncestorComponent) {
      return false;
    }
    let stoppedComponent;
    if (commonAncestorSlot.parent !== commonAncestorComponent || abstractSelection.anchorSlot === commonAncestorSlot && abstractSelection.focusSlot === commonAncestorSlot) {
      stoppedComponent = commonAncestorComponent.parentComponent;
    } else {
      stoppedComponent = commonAncestorComponent;
    }
    const stoppedScope = {
      slot: startSlot,
      offset: Selection.getInlineContentStartIndex(startSlot, startOffset)
    };
    let startScope = {
      slot: endSlot,
      offset: Selection.getInlineContentEndIndex(endSlot, endOffset)
    };
    const parentComponent = startScope.slot.parent;
    if (parentComponent.separable) {
      if (startScope.slot !== parentComponent.slots.last) {
        const slotIndex = parentComponent.slots.indexOf(startScope.slot);
        const count = parentComponent.slots.length - slotIndex;
        const event = new Event(parentComponent, {
          index: slotIndex + 1,
          count: count - 1,
          toEnd: false
        });
        invokeListener(parentComponent, "onSlotRemove", event);
        if (!event.isPrevented) {
          const deletedSlots = parentComponent.slots.cut(slotIndex + 1, slotIndex + count);
          const newState = typeof parentComponent.state === "object" ? JSON.parse(JSON.stringify(parentComponent.state)) : parentComponent.state;
          let afterComponent = null;
          if (typeof rule.existingComponentTransformer === "function") {
            afterComponent = rule.existingComponentTransformer(parentComponent.name, deletedSlots, newState) || null;
          }
          if (!afterComponent) {
            afterComponent = this.registry.createComponentByData(parentComponent.name, {
              state: newState,
              slots: deletedSlots
            });
          }
          this.insertAfter(afterComponent, parentComponent);
        }
      }
    }
    let slots = [];
    let position = null;
    while (true) {
      const endPaths = selection.getPathsBySlot(startScope.slot);
      if (!endPaths) {
        break;
      }
      endPaths.push(startScope.offset);
      const startPaths = selection.getPathsBySlot(stoppedScope.slot);
      if (!startPaths) {
        break;
      }
      startPaths.push(stoppedScope.offset);
      if (!Selection.compareSelectionPaths(startPaths, endPaths)) {
        break;
      }
      const scope = startScope.slot.isEmpty ? {
        slot: startScope.slot,
        startIndex: 0,
        endIndex: 0
      } : getBlockRangeToBegin(selection, startScope.slot, startScope.offset);
      const { slot, startIndex, endIndex } = scope;
      const parentComponent2 = slot.parent;
      if (!parentComponent2.separable && parentComponent2.slots.length > 1 && !slot.schema.includes(rule.target.instanceType)) {
        const componentInstances2 = slotsToComponents(this.injector, slots, rule);
        componentInstances2.forEach((instance) => {
          this.insert(instance);
        });
        slots = [];
        startScope = selection.getPreviousPositionByPosition(slot, 0);
        position = null;
        continue;
      }
      selection.setBaseAndExtent(slot, startIndex, slot, endIndex);
      if (slot.isEmpty) {
        startScope = selection.getPreviousPositionByPosition(slot, 0);
        if (startScope.slot === slot && startScope.offset === startIndex) {
          if (position) {
            selection.setPosition(position.slot, position.offset);
          }
          break;
        }
        if (parentComponent2.separable || parentComponent2.slots.length === 1) {
          const delta = slot.toDelta();
          slots.unshift(...deltaToSlots(selection, slot, delta, rule, abstractSelection, 0));
          position = deleteUpBySlot(selection, slot, 0, stoppedComponent, false);
        } else {
          const componentInstances2 = slotsToComponents(this.injector, slots, rule);
          slots = [];
          selection.selectComponentEnd(parentComponent2);
          componentInstances2.forEach((instance) => {
            this.insert(instance);
          });
          position = null;
        }
      } else {
        startScope = selection.getPreviousPositionByPosition(slot, startIndex);
        if (startScope.slot === slot && startScope.offset === startIndex) {
          if (position) {
            selection.setPosition(position.slot, position.offset);
          }
          break;
        }
        if (startIndex === endIndex) {
          const componentInstances2 = slotsToComponents(this.injector, slots, rule);
          slots = [];
          componentInstances2.forEach((instance) => {
            this.insert(instance);
          });
          continue;
        }
        this.delete((deletedSlot) => {
          if (parentComponent2.separable || parentComponent2.slots.length === 1) {
            const delta2 = deletedSlot.toDelta();
            slots.unshift(...deltaToSlots(selection, slot, delta2, rule, abstractSelection, startIndex));
            if (startIndex > 0) {
              startScope = selection.getPreviousPositionByPosition(slot, startIndex);
              position = {
                slot,
                offset: startIndex
              };
              return;
            }
            position = deleteUpBySlot(selection, slot, 0, stoppedComponent, false);
            return;
          }
          position = null;
          let componentInstances2 = slotsToComponents(this.injector, slots, rule);
          slots = [];
          selection.selectComponentEnd(parentComponent2);
          componentInstances2.forEach((instance) => {
            this.insert(instance);
          });
          const delta = deletedSlot.toDelta();
          const dumpSlots = deltaToSlots(selection, slot, delta, rule, abstractSelection, startIndex);
          componentInstances2 = slotsToComponents(this.injector, dumpSlots, rule);
          componentInstances2.forEach((instance, index) => {
            selection.setPosition(slot, index + startIndex);
            this.insert(instance);
          });
          if (startIndex > 0) {
            startScope = selection.getPreviousPositionByPosition(slot, startIndex);
            position = {
              slot,
              offset: startIndex
            };
          }
        });
      }
      if (position) {
        selection.setPosition(position.slot, position.offset);
      }
      if (scope.slot === stoppedScope.slot && scope.endIndex === stoppedScope.offset) {
        break;
      }
    }
    const componentInstances = slotsToComponents(this.injector, slots, rule);
    componentInstances.forEach((instance) => {
      this.insert(instance);
    });
    return true;
  }
};
Commander = __decorate([
  Injectable(),
  __metadata("design:paramtypes", [
    Selection,
    Injector,
    Registry,
    RootComponentRef
  ])
], Commander);
var PureRenderer_1;
var pureRendererErrorFn = makeError("PureRenderer");
var PureRenderer = PureRenderer_1 = class PureRenderer2 {
  componentRender(component, renderMode) {
    return component.extends.render((slot, factory) => {
      return this.slotRender(slot, renderMode, factory);
    }, renderMode);
  }
  slotRender(slot, renderMode, slotRenderFactory) {
    const formatTree = slot.createFormatTree();
    const componentRender = (component, renderMode2) => {
      return this.componentRender(component, renderMode2);
    };
    let children = formatTree.children ? PureRenderer_1.createVDomByFormatTree(slot, formatTree.children, renderMode, componentRender) : PureRenderer_1.createVDomByContent(slot, formatTree.startIndex, formatTree.endIndex, renderMode, componentRender);
    if (formatTree.formats) {
      children = [PureRenderer_1.createVDomByOverlapFormats(formatTree.formats, children, slot, renderMode)];
    }
    const root = slotRenderFactory(children);
    for (const [attribute, value] of slot.getAttributes()) {
      attribute.render(root, value, renderMode);
    }
    return root;
  }
  static createVDomByFormatTree(slot, formats, renderMode, componentRender, setVNodeLocation) {
    var _a2;
    const nodes = [];
    for (const child of formats) {
      if ((_a2 = child.formats) === null || _a2 === void 0 ? void 0 : _a2.length) {
        const children = child.children ? PureRenderer_1.createVDomByFormatTree(slot, child.children, renderMode, componentRender, setVNodeLocation) : PureRenderer_1.createVDomByContent(slot, child.startIndex, child.endIndex, renderMode, componentRender, setVNodeLocation);
        const nextChildren = PureRenderer_1.createVDomByOverlapFormats(child.formats, children, slot, renderMode, setVNodeLocation);
        nodes.push(nextChildren);
      } else {
        nodes.push(...PureRenderer_1.createVDomByContent(slot, child.startIndex, child.endIndex, renderMode, componentRender, setVNodeLocation));
      }
    }
    return nodes;
  }
  static createVDomByOverlapFormats(formats, children, slot, renderMode, setVNodeLocation) {
    const hostBindings = [];
    let host = null;
    for (let i2 = formats.length - 1; i2 > -1; i2--) {
      const item = formats[i2];
      const next = item.formatter.render(children, item.value, renderMode);
      if (!next) {
        throw pureRendererErrorFn(`Formatter \`${item.formatter.name}\` must return an VElement!`);
      }
      if (!(next instanceof VElement)) {
        hostBindings.push({
          item,
          render: next
        });
        continue;
      }
      host = next;
      setVNodeLocation === null || setVNodeLocation === void 0 ? void 0 : setVNodeLocation(next, {
        slot,
        startIndex: item.startIndex,
        endIndex: item.endIndex
      });
      children = [next];
    }
    for (const binding of hostBindings) {
      const { render, item } = binding;
      if (!host) {
        host = jsx(render.fallbackTagName);
        host.appendChild(...children);
        setVNodeLocation === null || setVNodeLocation === void 0 ? void 0 : setVNodeLocation(host, {
          slot,
          startIndex: item.startIndex,
          endIndex: item.endIndex
        });
      }
      render.attach(host);
    }
    return host;
  }
  static createVDomByContent(slot, startIndex, endIndex, renderMode, componentRender, setVNodeLocation) {
    const elements = slot.sliceContent(startIndex, endIndex).map((i2) => {
      if (typeof i2 === "string") {
        return i2.match(/\n|[^\n]+/g);
      }
      return i2;
    }).flat();
    return elements.map((item) => {
      let vNode;
      let length;
      if (typeof item === "string") {
        if (item === "\n") {
          vNode = new VElement("br");
          length = 1;
        } else {
          vNode = new VTextNode(item);
          length = item.length;
        }
      } else {
        length = 1;
        vNode = componentRender(item, renderMode);
      }
      setVNodeLocation === null || setVNodeLocation === void 0 ? void 0 : setVNodeLocation(vNode, {
        slot,
        startIndex,
        endIndex: startIndex + length
      });
      startIndex += length;
      return vNode;
    });
  }
};
PureRenderer = PureRenderer_1 = __decorate([
  Injectable()
], PureRenderer);
var rendererErrorFn = makeError("Renderer");
function setEditable(vElement, isSlot) {
  vElement.attrs.set(isSlot ? "textbus-slot-root" : "textbus-component-root", "");
}
function getObjectChanges(target, source) {
  const changes = {
    remove: [],
    add: []
  };
  Object.keys(target).forEach((key) => {
    const leftValue = target[key];
    if (!Reflect.has(source, key)) {
      changes.add.push([key, leftValue]);
      return;
    }
    const rightValue = source[key];
    if (leftValue === rightValue) {
      return;
    }
    changes.add.push([key, leftValue]);
    changes.remove.push([key, rightValue]);
  });
  Object.keys(source).forEach((key) => {
    if (!Reflect.has(target, key)) {
      changes.remove.push([key, source[key]]);
    }
  });
  return changes;
}
function getMapChanges(target, source) {
  const changes = {
    remove: [],
    set: []
  };
  target.forEach((value, key) => {
    const rightValue = source.get(key);
    if (value === rightValue) {
      return;
    }
    changes.set.push([key, value]);
  });
  source.forEach((value, key) => {
    if (!target.has(key)) {
      changes.remove.push(key);
    }
  });
  return changes;
}
function getSetChanges(left, right) {
  const changes = {
    add: [],
    remove: []
  };
  left.forEach((i2) => {
    if (!right.has(i2)) {
      changes.add.push(i2);
    }
  });
  right.forEach((i2) => {
    if (!left.has(i2)) {
      changes.remove.push(i2);
    }
  });
  return changes;
}
function getNodeChanges(newVDom, oldVDom) {
  const styleChanges = getMapChanges(newVDom.styles, oldVDom.styles);
  const attrChanges = getMapChanges(newVDom.attrs, oldVDom.attrs);
  const classesChanges = getSetChanges(newVDom.classes, oldVDom.classes);
  const listenerChanges = getObjectChanges(newVDom.listeners, oldVDom.listeners);
  return {
    styleChanges,
    attrChanges,
    classesChanges,
    listenerChanges,
    isChanged: [
      attrChanges.set.length,
      attrChanges.remove.length,
      styleChanges.set.length,
      styleChanges.remove.length,
      classesChanges.add.length,
      classesChanges.remove.length,
      listenerChanges.add.length,
      listenerChanges.remove.length
    ].join("") !== "0".repeat(8)
  };
}
function createBidirectionalMapping(isA) {
  const a2b = /* @__PURE__ */ new WeakMap();
  const b2a = /* @__PURE__ */ new WeakMap();
  function set(key, value) {
    if (get(key)) {
      remove(key);
    }
    if (get(value)) {
      remove(value);
    }
    if (isA(key)) {
      a2b.set(key, value);
      b2a.set(value, key);
    } else {
      a2b.set(value, key);
      b2a.set(key, value);
    }
  }
  function get(key) {
    if (isA(key)) {
      return a2b.get(key);
    }
    return b2a.get(key);
  }
  function remove(key) {
    if (isA(key)) {
      const v2 = a2b.get(key);
      a2b.delete(key);
      b2a.delete(v2);
    } else {
      const v2 = b2a.get(key);
      b2a.delete(key);
      a2b.delete(v2);
    }
  }
  return {
    set,
    get,
    remove
  };
}
var Renderer = class Renderer2 {
  constructor(controller, rootComponentRef) {
    this.controller = controller;
    this.rootComponentRef = rootComponentRef;
    this.slotRootVNodeCaches = /* @__PURE__ */ new WeakMap();
    this.vNodeLocation = /* @__PURE__ */ new WeakMap();
    this.renderedVNode = /* @__PURE__ */ new WeakMap();
    this.slotVNodesCaches = /* @__PURE__ */ new WeakMap();
    this.slotRenderFactory = /* @__PURE__ */ new WeakMap();
    this.componentVNode = createBidirectionalMapping((v2) => {
      return v2 instanceof VElement;
    });
    this.nativeNodeCaches = createBidirectionalMapping((v2) => {
      return v2 instanceof VElement || v2 instanceof VTextNode;
    });
    this.viewUpdatedEvent = new Subject();
    this.viewUpdateBeforeEvent = new Subject();
    this.oldVDom = null;
    this.slotIdAttrKey = "__textbus-slot-id__";
    this.readonlyStateChanged = false;
    this.subscription = new Subscription();
    this.renderedComponents = [];
    this.firstRending = true;
    this.onViewUpdated = this.viewUpdatedEvent.asObservable();
    this.onViewUpdateBefore = this.viewUpdateBeforeEvent.asObservable();
    this.subscription = controller.onReadonlyStateChange.subscribe(() => {
      if (rootComponentRef.component) {
        this.readonlyStateChanged = true;
        this.render();
        this.readonlyStateChanged = false;
      }
    });
  }
  render() {
    const component = this.rootComponentRef.component;
    this.viewUpdateBeforeEvent.next();
    if (component.changeMarker.changed || this.readonlyStateChanged) {
      const dirty = component.changeMarker.dirty;
      const root = this.componentRender(component);
      new VElement("html", null, [root]);
      if (dirty || this.readonlyStateChanged) {
        if (this.oldVDom) {
          const oldNativeNode = this.nativeNodeCaches.get(this.oldVDom);
          const newNativeNode = this.diffAndUpdate(root, this.oldVDom, component);
          if (oldNativeNode !== newNativeNode) {
            this.nativeRenderer.replace(newNativeNode, oldNativeNode);
          }
        } else {
          const el = this.patch(root);
          this.nativeRenderer.appendChild(this.rootComponentRef.host, el);
        }
      }
      this.oldVDom = root;
    }
    this.firstRending = false;
    Promise.resolve().then(() => {
      for (const item of this.renderedComponents) {
        invokeListener(item, "onViewChecked");
      }
      this.renderedComponents = [];
      this.viewUpdatedEvent.next();
    });
  }
  getVNodeByComponent(component) {
    return this.componentVNode.get(component);
  }
  getComponentByVNode(vNode) {
    let n2 = vNode;
    while (n2) {
      const instance = this.componentVNode.get(vNode);
      if (instance) {
        return instance;
      }
      n2 = n2.parentNode;
    }
    return null;
  }
  getComponentByNativeNode(nativeNode) {
    let vNode = this.getVNodeByNativeNode(nativeNode);
    if (vNode instanceof VTextNode) {
      vNode = vNode.parentNode;
    }
    if (vNode instanceof VElement) {
      return this.getComponentByVNode(vNode);
    }
    return null;
  }
  getVNodeBySlot(slot) {
    return this.slotRootVNodeCaches.get(slot);
  }
  getNativeNodeByVNode(vNode) {
    return this.nativeNodeCaches.get(vNode);
  }
  getVNodeByNativeNode(nativeNode) {
    return this.nativeNodeCaches.get(nativeNode);
  }
  getLocationByVNode(node) {
    if (node instanceof Slot) {
      node = this.slotRootVNodeCaches.get(node);
    }
    return this.vNodeLocation.get(node);
  }
  getLocationByNativeNode(node) {
    const vNode = this.nativeNodeCaches.get(node);
    return this.vNodeLocation.get(vNode) || null;
  }
  getVNodesBySlot(slot) {
    return this.slotVNodesCaches.get(slot) || [];
  }
  destroy() {
    this.subscription.unsubscribe();
  }
  sortAndCleanNativeNode(parent, children, component) {
    let index = 0;
    while (true) {
      const node = children[index];
      if (!node) {
        break;
      }
      const current = this.nativeRenderer.getChildByIndex(parent, index);
      index++;
      if (!current) {
        this.nativeRenderer.appendChild(parent, node);
        continue;
      }
      if (current !== node) {
        this.nativeRenderer.insertBefore(node, current);
      }
    }
    while (true) {
      const current = this.nativeRenderer.getChildByIndex(parent, index);
      if (!current) {
        break;
      }
      const event = new Event(component, current);
      invokeListener(component, "onDirtyViewClean", event);
      if (event.isPrevented) {
        index++;
        continue;
      }
      this.nativeRenderer.remove(current);
    }
    return parent;
  }
  diffAndUpdate(newVDom, oldVDom, component) {
    const newNativeNode = this.diffNodeAndUpdate(newVDom, oldVDom);
    const children = this.diffChildrenAndUpdate(newVDom, oldVDom, component);
    return this.sortAndCleanNativeNode(newNativeNode, children, component);
  }
  diffChildrenAndUpdate(newVDom, oldVDom, component) {
    const newChildren = newVDom.children;
    const oldChildren = oldVDom.children;
    const beginIdenticalNodes = this.diffIdenticalChildrenToEnd(newChildren, oldChildren, component);
    const endIdenticalNodes = this.diffIdenticalChildrenToBegin(newChildren, oldChildren, component);
    const beginNodes = this.diffChildrenToEnd(newChildren, oldChildren, component);
    const endNodes = this.diffChildrenToBegin(newChildren, oldChildren, component);
    oldChildren.forEach((i2) => {
      const native = this.nativeNodeCaches.get(i2);
      if (native) {
        this.nativeRenderer.remove(native);
      }
    });
    return [
      ...beginIdenticalNodes,
      ...beginNodes,
      ...newChildren.map((i2) => {
        if (this.renderedVNode.has(i2)) {
          return this.nativeNodeCaches.get(i2);
        }
        return this.patch(i2);
      }),
      ...endNodes,
      ...endIdenticalNodes
    ];
  }
  diffIdenticalChildrenToEnd(newChildren, oldChildren, component) {
    const children = [];
    while (newChildren.length && oldChildren.length) {
      const newFirstVNode = newChildren[0];
      const oldFirstVNode = oldChildren[0];
      if (newFirstVNode instanceof VElement && oldFirstVNode instanceof VElement) {
        if (this.renderedVNode.has(newFirstVNode)) {
          newChildren.shift();
          children.push(this.nativeNodeCaches.get(newFirstVNode));
          continue;
        }
        if (newFirstVNode.tagName !== oldFirstVNode.tagName) {
          break;
        }
        const { isChanged } = getNodeChanges(newFirstVNode, oldFirstVNode);
        if (isChanged) {
          break;
        }
        newChildren.shift();
        oldChildren.shift();
        let nativeNode = this.nativeNodeCaches.get(oldFirstVNode);
        if (nativeNode) {
          this.nativeNodeCaches.set(newFirstVNode, nativeNode);
          this.renderedVNode.set(newFirstVNode, true);
        } else {
          nativeNode = this.createElement(newFirstVNode);
        }
        component = this.componentVNode.get(newFirstVNode) || component;
        const cc = this.diffChildrenAndUpdate(newFirstVNode, oldFirstVNode, component);
        children.push(this.sortAndCleanNativeNode(nativeNode, cc, component));
      } else {
        break;
      }
    }
    return children;
  }
  diffIdenticalChildrenToBegin(newChildren, oldChildren, component) {
    const children = [];
    while (newChildren.length && oldChildren.length) {
      const newLastVNode = newChildren[newChildren.length - 1];
      const oldLastVNode = oldChildren[oldChildren.length - 1];
      if (newLastVNode instanceof VElement && oldLastVNode instanceof VElement) {
        if (this.renderedVNode.has(newLastVNode)) {
          newChildren.pop();
          children.push(this.nativeNodeCaches.get(newLastVNode));
          continue;
        }
        if (newLastVNode.tagName !== oldLastVNode.tagName) {
          break;
        }
        const { isChanged } = getNodeChanges(newLastVNode, oldLastVNode);
        if (isChanged) {
          break;
        }
        newChildren.pop();
        oldChildren.pop();
        let nativeNode = this.nativeNodeCaches.get(oldLastVNode);
        if (nativeNode) {
          this.nativeNodeCaches.set(newLastVNode, nativeNode);
          this.renderedVNode.set(newLastVNode, true);
        } else {
          nativeNode = this.createElement(newLastVNode);
        }
        component = this.componentVNode.get(newLastVNode) || component;
        const cc = this.diffChildrenAndUpdate(newLastVNode, oldLastVNode, component);
        children.push(this.sortAndCleanNativeNode(nativeNode, cc, component));
      } else {
        break;
      }
    }
    return children.reverse();
  }
  diffChildrenToEnd(newChildren, oldChildren, component) {
    const children = [];
    while (newChildren.length && oldChildren.length) {
      const newFirstVNode = newChildren[0];
      const oldFirstVNode = oldChildren[0];
      if (newFirstVNode instanceof VElement) {
        if (this.renderedVNode.has(newFirstVNode)) {
          newChildren.shift();
          children.push(this.nativeNodeCaches.get(newFirstVNode));
          continue;
        }
        if (oldFirstVNode instanceof VElement && newFirstVNode.tagName === oldFirstVNode.tagName) {
          component = this.componentVNode.get(newFirstVNode) || component;
          const nativeNode = this.diffAndUpdate(newFirstVNode, oldFirstVNode, component);
          children.push(nativeNode);
          newChildren.shift();
          oldChildren.shift();
        } else {
          break;
        }
      } else {
        if (this.renderedVNode.has(newFirstVNode)) {
          newChildren.shift();
          children.push(this.nativeNodeCaches.get(newFirstVNode));
          continue;
        }
        if (oldFirstVNode instanceof VTextNode && newFirstVNode.textContent === oldFirstVNode.textContent) {
          const nativeNode = this.nativeNodeCaches.get(oldFirstVNode);
          this.nativeNodeCaches.set(newFirstVNode, nativeNode);
          children.push(nativeNode);
          this.nativeRenderer.syncTextContent(nativeNode, newFirstVNode.textContent);
          newChildren.shift();
          oldChildren.shift();
        } else {
          break;
        }
      }
    }
    return children;
  }
  diffChildrenToBegin(newChildren, oldChildren, component) {
    const children = [];
    while (newChildren.length && oldChildren.length) {
      const newLastVNode = newChildren[newChildren.length - 1];
      const oldLastVNode = oldChildren[oldChildren.length - 1];
      if (newLastVNode instanceof VElement) {
        if (this.renderedVNode.has(newLastVNode)) {
          newChildren.pop();
          children.push(this.nativeNodeCaches.get(newLastVNode));
          continue;
        }
        if (oldLastVNode instanceof VElement && newLastVNode.tagName === oldLastVNode.tagName) {
          component = this.componentVNode.get(newLastVNode) || component;
          const nativeNode = this.diffAndUpdate(newLastVNode, oldLastVNode, component);
          children.push(nativeNode);
          newChildren.pop();
          oldChildren.pop();
        } else {
          break;
        }
      } else {
        if (this.renderedVNode.has(newLastVNode)) {
          newChildren.pop();
          children.push(this.nativeNodeCaches.get(newLastVNode));
          continue;
        }
        if (oldLastVNode instanceof VTextNode && newLastVNode.textContent === oldLastVNode.textContent) {
          const nativeNode = this.nativeNodeCaches.get(oldLastVNode);
          this.nativeNodeCaches.set(newLastVNode, nativeNode);
          children.push(nativeNode);
          this.nativeRenderer.syncTextContent(nativeNode, newLastVNode.textContent);
          newChildren.pop();
          oldChildren.pop();
        } else {
          break;
        }
      }
    }
    return children.reverse();
  }
  diffNodeAndUpdate(newVDom, oldVDom) {
    let nativeNode = this.nativeNodeCaches.get(oldVDom);
    if (oldVDom.tagName !== newVDom.tagName) {
      nativeNode = this.createElement(newVDom);
    } else {
      const { styleChanges, attrChanges, classesChanges, listenerChanges } = getNodeChanges(newVDom, oldVDom);
      styleChanges.remove.forEach((i2) => this.nativeRenderer.removeStyle(nativeNode, i2));
      styleChanges.set.forEach((i2) => this.nativeRenderer.setStyle(nativeNode, i2[0], i2[1]));
      attrChanges.remove.forEach((i2) => this.nativeRenderer.removeAttribute(nativeNode, i2));
      attrChanges.set.forEach(([key, value]) => {
        if (key === this.slotIdAttrKey) {
          return;
        }
        if (key === "ref" && value instanceof Ref) {
          value.current = nativeNode;
          return;
        }
        this.nativeRenderer.setAttribute(nativeNode, key, value);
      });
      classesChanges.remove.forEach((i2) => this.nativeRenderer.removeClass(nativeNode, i2));
      classesChanges.add.forEach((i2) => this.nativeRenderer.addClass(nativeNode, i2));
      listenerChanges.remove.forEach((i2) => {
        this.nativeRenderer.unListen(nativeNode, i2[0], i2[1]);
      });
      listenerChanges.add.forEach((i2) => {
        this.nativeRenderer.listen(nativeNode, i2[0], i2[1]);
      });
      this.renderedVNode.set(newVDom, true);
      this.nativeNodeCaches.set(newVDom, nativeNode);
    }
    return nativeNode;
  }
  patch(vDom) {
    if (vDom instanceof VElement) {
      const el = this.createElement(vDom);
      vDom.children.forEach((child) => {
        if (this.renderedVNode.get(child)) {
          this.nativeRenderer.appendChild(el, this.nativeNodeCaches.get(child));
        } else {
          this.nativeRenderer.appendChild(el, this.patch(child));
        }
      });
      return el;
    }
    return this.createTextNode(vDom);
  }
  extractVNodesBySlot(slot, tree, vNodes) {
    for (const child of tree) {
      const position = this.getLocationByVNode(child);
      if (position) {
        if (position.slot === slot) {
          vNodes.push(child);
        } else {
          break;
        }
        if (child instanceof VElement) {
          this.extractVNodesBySlot(slot, child.children, vNodes);
        }
      }
    }
    return vNodes;
  }
  componentRender(component) {
    if (component.changeMarker.dirty || this.readonlyStateChanged) {
      const node = component.extends.render((slot, factory) => {
        return this.slotRender(component, slot, (children) => {
          const vNodes = this.extractVNodesBySlot(slot, children, []);
          this.slotVNodesCaches.set(slot, vNodes);
          return factory(children);
        });
      }, this.controller.readonly ? RenderMode.Readonly : RenderMode.Editing);
      if (!(node instanceof VElement)) {
        throw rendererErrorFn(`component \`${component.name}\` rendering does not return a VElement.`);
      }
      setEditable(node, false);
      this.componentVNode.set(component, node);
      component.changeMarker.rendered();
      this.renderedComponents.push(component);
      return node;
    }
    if (component.changeMarker.changed) {
      const oldComponentVNode = this.componentVNode.get(component);
      component.slots.toArray().forEach((slot) => {
        if (!slot.changeMarker.changed) {
          return;
        }
        const dirty = slot.changeMarker.dirty;
        const oldVNode = this.slotRootVNodeCaches.get(slot);
        const factory = this.slotRenderFactory.get(slot);
        const vNode = this.slotRender(component, slot, factory);
        if (!(vNode instanceof VElement)) {
          throw rendererErrorFn(`component \`${component.name}\` slot rendering does not return a VElement.`);
        }
        if (dirty) {
          if (oldComponentVNode === oldVNode) {
            this.componentVNode.set(component, vNode);
            setEditable(vNode, false);
          }
          oldVNode.parentNode.replaceChild(vNode, oldVNode);
          const oldNativeNode = this.nativeNodeCaches.get(oldVNode);
          const newNativeNode = this.diffAndUpdate(vNode, oldVNode, component);
          this.nativeNodeCaches.set(newNativeNode, vNode);
          this.slotRootVNodeCaches.set(slot, vNode);
          if (oldNativeNode !== newNativeNode) {
            this.nativeRenderer.replace(newNativeNode, oldNativeNode);
          }
        }
      });
      component.changeMarker.rendered();
    }
    this.renderedComponents.push(component);
    return this.componentVNode.get(component);
  }
  slotRender(component, slot, slotRenderFactory) {
    if (!(slot instanceof Slot)) {
      throw rendererErrorFn(`${slot} of the component \`${component.name}\` is not a Slot instance.`);
    }
    if (typeof slotRenderFactory !== "function") {
      throw rendererErrorFn(`component \`${component.name}\` slot render is not a function.`);
    }
    if (slot.changeMarker.dirty || this.readonlyStateChanged) {
      this.slotRenderFactory.set(slot, slotRenderFactory);
      const formatTree = slot.createFormatTree();
      const renderMode = this.controller.readonly ? RenderMode.Readonly : RenderMode.Editing;
      const componentRender = (component2) => {
        const componentVNode = this.componentRender(component2);
        if (!this.firstRending) {
          invokeListener(component2, "onParentSlotUpdated");
        }
        return componentVNode;
      };
      const setLocation = (vNode, location) => {
        this.vNodeLocation.set(vNode, location);
      };
      let children = formatTree.children ? PureRenderer.createVDomByFormatTree(slot, formatTree.children, renderMode, componentRender, setLocation) : PureRenderer.createVDomByContent(slot, formatTree.startIndex, formatTree.endIndex, renderMode, componentRender, setLocation);
      if (formatTree.formats) {
        children = [PureRenderer.createVDomByOverlapFormats(formatTree.formats, children, slot, renderMode, setLocation)];
      }
      const root = slotRenderFactory(children);
      if (!(root instanceof VElement)) {
        throw rendererErrorFn(`component \`${component.name}\` slot rendering does not return a VElement.`);
      }
      for (const [attribute, value] of slot.getAttributes()) {
        attribute.render(root, value, renderMode);
      }
      root.attrs.set(this.slotIdAttrKey, slot.id);
      setEditable(root, true);
      this.vNodeLocation.set(root, {
        slot,
        startIndex: 0,
        endIndex: slot.length
      });
      slot.changeMarker.rendered();
      this.slotRootVNodeCaches.set(slot, root);
      return root;
    }
    slot.sliceContent().filter((i2) => {
      return typeof i2 !== "string";
    }).forEach((component2) => {
      if (!component2.changeMarker.changed) {
        return;
      }
      const dirty = component2.changeMarker.dirty;
      const oldVNode = this.componentVNode.get(component2);
      const vNode = this.componentRender(component2);
      const startIndex = slot.indexOf(component2);
      this.vNodeLocation.set(vNode, {
        slot,
        startIndex,
        endIndex: startIndex + 1
      });
      if (dirty) {
        oldVNode.parentNode.replaceChild(vNode, oldVNode);
        const oldNativeNode = this.nativeNodeCaches.get(oldVNode);
        const newNativeNode = this.diffAndUpdate(vNode, oldVNode, component2);
        if (oldNativeNode !== newNativeNode) {
          this.nativeRenderer.replace(newNativeNode, oldNativeNode);
        }
      }
    });
    slot.changeMarker.rendered();
    return this.slotRootVNodeCaches.get(slot);
  }
  createElement(vDom) {
    this.renderedVNode.set(vDom, true);
    const el = this.nativeRenderer.createElement(vDom.tagName);
    vDom.attrs.forEach((value, key) => {
      if (key === this.slotIdAttrKey) {
        return;
      }
      if (key === "ref") {
        if (value instanceof Ref) {
          value.current = el;
        }
        return;
      }
      this.nativeRenderer.setAttribute(el, key, value);
    });
    vDom.styles.forEach((value, key) => {
      this.nativeRenderer.setStyle(el, key, value);
    });
    vDom.classes.forEach((k2) => this.nativeRenderer.addClass(el, k2));
    Object.keys(vDom.listeners).forEach((type) => {
      this.nativeRenderer.listen(el, type, vDom.listeners[type]);
    });
    this.nativeNodeCaches.set(el, vDom);
    return el;
  }
  createTextNode(vDom) {
    this.renderedVNode.set(vDom, true);
    const el = this.nativeRenderer.createTextNode(vDom.textContent);
    this.nativeNodeCaches.set(el, vDom);
    return el;
  }
};
__decorate([
  Prop(),
  __metadata("design:type", NativeRenderer)
], Renderer.prototype, "nativeRenderer", void 0);
Renderer = __decorate([
  Injectable(),
  __metadata("design:paramtypes", [
    Controller,
    RootComponentRef
  ])
], Renderer);
var Scheduler_1;
var ChangeOrigin;
(function(ChangeOrigin2) {
  ChangeOrigin2[ChangeOrigin2["History"] = 0] = "History";
  ChangeOrigin2[ChangeOrigin2["Local"] = 1] = "Local";
  ChangeOrigin2[ChangeOrigin2["Remote"] = 2] = "Remote";
})(ChangeOrigin || (ChangeOrigin = {}));
var Scheduler = Scheduler_1 = class Scheduler2 {
  get lastChangesHasLocalUpdate() {
    return this._lastChangesHasLocalUpdate;
  }
  get lastChangesHasRemoteUpdate() {
    return this._lastChangesHasRemoteUpdate;
  }
  constructor(rootComponentRef, selection, renderer) {
    this.rootComponentRef = rootComponentRef;
    this.selection = selection;
    this.renderer = renderer;
    this._lastChangesHasLocalUpdate = true;
    this._lastChangesHasRemoteUpdate = false;
    this.changeFromRemote = false;
    this.changeFromHistory = false;
    this.instanceList = /* @__PURE__ */ new Set();
    this.docChangedEvent = new Subject();
    this.docChangeEvent = new Subject();
    this.localChangeBeforeEvent = new Subject();
    this.subs = [];
    this.onDocChanged = this.docChangedEvent.asObservable();
    this.onDocChange = this.docChangeEvent.asObservable();
    this.onLocalChangeBefore = this.localChangeBeforeEvent.asObservable();
    this.onDocFirstChangeFromLocal = this.onLocalChangeBefore.pipe(take(1));
  }
  remoteUpdateTransact(task) {
    this.changeFromRemote = true;
    task();
    this.changeFromRemote = false;
  }
  historyApplyTransact(task) {
    this.changeFromHistory = true;
    task();
    this.changeFromHistory = false;
  }
  run() {
    const rootComponent2 = this.rootComponentRef.component;
    const changeMarker = rootComponent2.changeMarker;
    this.renderer.render();
    let isRendered = true;
    this.subs.push(changeMarker.onForceChange.pipe(microTask()).subscribe(() => {
      this.renderer.render();
    }), changeMarker.onChange.pipe(map((op) => {
      const from = this.changeFromRemote ? ChangeOrigin.Remote : this.changeFromHistory ? ChangeOrigin.History : ChangeOrigin.Local;
      if (isRendered) {
        isRendered = false;
        if (from === ChangeOrigin.Local) {
          this.localChangeBeforeEvent.next();
        }
        this.docChangeEvent.next();
      }
      return {
        from,
        operation: op
      };
    }), microTask()).subscribe((ops) => {
      isRendered = true;
      this.renderer.render();
      this._lastChangesHasRemoteUpdate = false;
      this._lastChangesHasLocalUpdate = false;
      ops.forEach((i2) => {
        if (i2.from === ChangeOrigin.Remote) {
          this._lastChangesHasRemoteUpdate = true;
        } else {
          this._lastChangesHasLocalUpdate = true;
        }
      });
      this.selection.restore(this._lastChangesHasLocalUpdate);
      this.docChangedEvent.next(ops);
    }), changeMarker.onChildComponentRemoved.subscribe((instance) => {
      this.instanceList.add(instance);
    }), this.renderer.onViewUpdated.subscribe(() => {
      this.instanceList.forEach((instance) => {
        let comp = instance;
        while (comp) {
          const parent = comp.parentComponent;
          if (parent) {
            comp = parent;
          } else {
            break;
          }
        }
        if (comp !== rootComponent2) {
          Scheduler_1.invokeChildComponentDestroyHook(comp);
        }
      });
      this.instanceList.clear();
    }));
  }
  destroy() {
    this.subs.forEach((i2) => i2.unsubscribe());
    const component = this.rootComponentRef.component;
    if (component) {
      Scheduler_1.invokeChildComponentDestroyHook(component);
    }
    this.subs = [];
  }
  static invokeChildComponentDestroyHook(parent) {
    parent.slots.toArray().forEach((slot) => {
      slot.sliceContent().forEach((i2) => {
        if (typeof i2 !== "string") {
          Scheduler_1.invokeChildComponentDestroyHook(i2);
        }
      });
    });
    invokeListener(parent, "onDestroy");
  }
};
Scheduler = Scheduler_1 = __decorate([
  Injectable(),
  __metadata("design:paramtypes", [
    RootComponentRef,
    Selection,
    Renderer
  ])
], Scheduler);
var History = class {
};
function objToFormats(formatsObj, registry) {
  const formats = [];
  Object.keys(formatsObj).forEach((i2) => {
    const formatter = registry.getFormatter(i2);
    if (formatter) {
      const value = formatsObj[i2];
      if (Array.isArray(value)) {
        value.forEach((item) => {
          formats.push([formatter, item]);
        });
      } else {
        formats.push([formatter, formatsObj[i2]]);
      }
    }
  });
  return formats;
}
var historyErrorFn = makeError("History");
var LocalHistory = class LocalHistory2 extends History {
  get canBack() {
    return this.historySequence.length > 0 && this.index > 0;
  }
  get canForward() {
    return this.historySequence.length > 0 && this.index < this.historySequence.length;
  }
  constructor(stackSize, root, scheduler, selection, registry) {
    super();
    this.stackSize = stackSize;
    this.root = root;
    this.scheduler = scheduler;
    this.selection = selection;
    this.registry = registry;
    this.index = 0;
    this.historySequence = [];
    this.changeEvent = new Subject();
    this.backEvent = new Subject();
    this.forwardEvent = new Subject();
    this.pushEvent = new Subject();
    this.subscription = null;
    this.forceChangeSubscription = null;
    this.onChange = this.changeEvent.asObservable();
    this.onBack = this.backEvent.asObservable();
    this.onForward = this.forwardEvent.asObservable();
    this.onPush = this.pushEvent.asObservable();
  }
  listen() {
    this.record();
  }
  forward() {
    if (this.canForward) {
      this.scheduler.historyApplyTransact(() => {
        const item = this.historySequence[this.index];
        this.apply(item, false);
        this.selection.usePaths(item.afterPaths);
      });
      this.index++;
      this.forwardEvent.next();
      this.changeEvent.next();
    }
  }
  back() {
    if (this.canBack) {
      this.scheduler.historyApplyTransact(() => {
        const item = this.historySequence[this.index - 1];
        this.apply(item, true);
        this.selection.usePaths(item.beforePaths);
      });
      this.index--;
      this.backEvent.next();
      this.changeEvent.next();
    }
  }
  clear() {
    this.historySequence = [];
    this.index = 0;
    this.changeEvent.next();
  }
  destroy() {
    var _a2;
    this.historySequence = [];
    (_a2 = this.forceChangeSubscription) === null || _a2 === void 0 ? void 0 : _a2.unsubscribe();
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  record() {
    let beforePaths = this.selection.getPaths();
    this.subscription = this.scheduler.onLocalChangeBefore.subscribe(() => {
      beforePaths = this.selection.getPaths();
    }).add(this.scheduler.onDocChanged.pipe(map((i2) => {
      const operations = [];
      for (const item of i2) {
        if (item.from !== ChangeOrigin.Local) {
          continue;
        }
        const operation = item.operation;
        const apply = operation.apply.filter((i3) => {
          return i3.type !== "apply" || i3.record;
        });
        const unApply = operation.unApply.filter((i3) => {
          return i3.type !== "apply" || i3.record;
        });
        if (apply.length && unApply.length) {
          operations.push({
            path: operation.path,
            apply,
            unApply
          });
        }
      }
      return operations;
    })).subscribe((operations) => {
      if (!operations.length) {
        return;
      }
      this.historySequence.length = this.index;
      this.index++;
      const afterPaths = this.selection.getPaths();
      this.historySequence.push({
        operations: operations.map((i2) => {
          return {
            path: [...i2.path],
            apply: i2.apply.map((j2) => {
              if (j2.type === "insert" || j2.type === "insertSlot") {
                return Object.assign(Object.assign({}, j2), { ref: null });
              }
              return j2;
            }),
            unApply: i2.unApply.map((j2) => {
              if (j2.type === "insert" || j2.type === "insertSlot") {
                return Object.assign(Object.assign({}, j2), { ref: null });
              }
              return j2;
            })
          };
        }),
        beforePaths,
        afterPaths
      });
      if (this.historySequence.length > this.stackSize) {
        this.historySequence.shift();
        this.index--;
      }
      beforePaths = afterPaths;
      this.pushEvent.next();
      this.changeEvent.next();
    }));
  }
  apply(historyItem, back) {
    let operations = historyItem.operations;
    if (back) {
      operations = [...operations].reverse();
    }
    operations.forEach((op) => {
      const path = [...op.path];
      const isFindSlot = path.length % 2 === 1;
      const actions = back ? op.unApply : op.apply;
      if (isFindSlot) {
        const slot = this.selection.findSlotByPaths(path);
        actions.forEach((action) => {
          if (action.type === "retain") {
            const formatsObj = action.formats;
            if (formatsObj) {
              const formats = objToFormats(formatsObj, this.registry);
              slot.retain(action.offset, formats);
            } else {
              slot.retain(action.offset);
            }
            return;
          }
          if (action.type === "delete") {
            slot.delete(action.count);
            return;
          }
          if (action.type === "apply") {
            slot.updateState((draft) => {
              pn(draft, action.patches);
            });
            return;
          }
          if (action.type === "attrSet") {
            const attribute = this.registry.getAttribute(action.name);
            if (attribute) {
              slot.setAttribute(attribute, action.value);
            }
            return;
          }
          if (action.type === "attrRemove") {
            const attribute = this.registry.getAttribute(action.name);
            if (attribute) {
              slot.removeAttribute(attribute);
            }
            return;
          }
          if (action.type === "insert") {
            const formatsObj = action.formats;
            let formats;
            if (formatsObj) {
              formats = objToFormats(formatsObj, this.registry);
            }
            if (typeof action.content === "string") {
              formats ? slot.insert(action.content, formats) : slot.insert(action.content);
            } else {
              const instance = this.registry.createComponent(action.content);
              if (!instance) {
                throw historyErrorFn(`component \`${action.content.name}\` not registered, please add \`${action.content.name}\` component to the components configuration item.`);
              }
              formats ? slot.insert(instance, formats) : slot.insert(instance);
            }
          }
        });
      } else {
        const component = this.selection.findComponentByPaths(path);
        actions.forEach((action) => {
          if (action.type === "retain") {
            component.slots.retain(action.offset);
            return;
          }
          if (action.type === "delete") {
            component.slots.delete(action.count);
            return;
          }
          if (action.type === "insertSlot") {
            const slot = this.registry.createSlot(action.slot);
            component.slots.insert(slot);
            return;
          }
          if (action.type === "apply") {
            component.updateState((draft) => {
              return pn(draft, action.patches);
            });
          }
        });
      }
    });
  }
};
LocalHistory = __decorate([
  Injectable(),
  __param(0, Inject(HISTORY_STACK_SIZE)),
  __metadata("design:paramtypes", [
    Number,
    RootComponentRef,
    Scheduler,
    Selection,
    Registry
  ])
], LocalHistory);
var Keyboard = class Keyboard2 {
  constructor(components, markdownDetect, commander, injector, selection) {
    this.components = components;
    this.markdownDetect = markdownDetect;
    this.commander = commander;
    this.injector = injector;
    this.selection = selection;
    this.shortcutList = [];
    this.zenCodingInterceptors = [];
    components.forEach((component) => {
      const config = component.zenCoding;
      if (Array.isArray(config)) {
        config.forEach((i2) => this.zenCodingInterceptors.push(this.createZenCodingEx(component, i2)));
      } else if (config) {
        this.zenCodingInterceptors.push(this.createZenCodingEx(component, config));
      }
    });
  }
  addZenCodingInterceptor(interceptor) {
    this.zenCodingInterceptors.push(interceptor);
    return {
      remove: () => {
        const index = this.zenCodingInterceptors.indexOf(interceptor);
        if (index > -1) {
          this.zenCodingInterceptors.splice(index, 1);
        }
      }
    };
  }
  execShortcut(keymapState) {
    if (!this.selection.isSelected) {
      return false;
    }
    const key = keymapState.key;
    const commonAncestorSlot = this.selection.commonAncestorSlot;
    if (this.markdownDetect && !keymapState.ctrlKey && !keymapState.shiftKey && !keymapState.altKey && commonAncestorSlot === this.selection.startSlot && commonAncestorSlot === this.selection.endSlot) {
      for (let i2 = this.zenCodingInterceptors.length - 1; i2 > -1; i2--) {
        const interceptor = this.zenCodingInterceptors[i2];
        const matchKey = interceptor.try(key);
        if (matchKey) {
          const activeSlotContents = commonAncestorSlot.sliceContent();
          let content = activeSlotContents[0];
          if (activeSlotContents.length > 1 || typeof content !== "string") {
            continue;
          }
          content = content.replace(/\n$/, "");
          const matchContent = interceptor.match(content);
          if (matchContent) {
            const r2 = interceptor.action(content);
            if (!r2) {
              break;
            }
            return true;
          }
        }
      }
    }
    const commonAncestorComponent = this.selection.commonAncestorComponent;
    if (commonAncestorComponent) {
      const is = this.handleShortcut(keymapState, commonAncestorComponent.shortcutList.map((s2) => this.createShortcutEx(s2)));
      if (is) {
        return true;
      }
    }
    return this.handleShortcut(keymapState, this.shortcutList);
  }
  addShortcut(shortcut) {
    const shortcutEx = this.createShortcutEx(shortcut);
    this.shortcutList.push(shortcutEx);
    return {
      remove: () => {
        const index = this.shortcutList.indexOf(shortcutEx);
        if (index > -1) {
          this.shortcutList.splice(index, 1);
        }
      }
    };
  }
  handleShortcut(keymap, shortcutList) {
    for (let i2 = shortcutList.length - 1; i2 > -1; i2--) {
      const ex = shortcutList[i2];
      const config = ex.config;
      if (ex.test(keymap.key) && !!config.keymap.altKey === keymap.altKey && !!config.keymap.shiftKey === keymap.shiftKey && !!config.keymap.ctrlKey === keymap.ctrlKey) {
        const b2 = config.action(keymap.key);
        if (b2 !== false) {
          return true;
        }
      }
    }
    return false;
  }
  createZenCodingEx(component, config) {
    const selection = this.selection;
    const commander = this.commander;
    return {
      match(content) {
        return typeof config.match === "function" ? config.match(content) : config.match.test(content);
      },
      try(key) {
        if (typeof config.key === "string") {
          return key.toLowerCase() === config.key.toLowerCase();
        }
        if (typeof config.key === "function") {
          return config.key(key);
        }
        if (Array.isArray(config.key)) {
          return config.key.some((item) => item.toLowerCase() === key.toLowerCase());
        }
        return config.key.test(key);
      },
      action: (content) => {
        const commonAncestorSlot = selection.commonAncestorSlot;
        const initData = config.generateInitData(content, this.injector);
        const newInstance = component.createInstance(this.injector, initData);
        if (commonAncestorSlot.schema.includes(newInstance.type)) {
          selection.selectSlot(commonAncestorSlot);
          commander.delete();
          commander.insert(newInstance);
        } else {
          const parentComponent = commonAncestorSlot.parent;
          if (parentComponent && parentComponent.slots.length > 1) {
            return false;
          }
          const parentSlot = parentComponent === null || parentComponent === void 0 ? void 0 : parentComponent.parent;
          if (!parentSlot) {
            return false;
          }
          selection.selectComponent(parentComponent);
          commander.delete();
          commander.insert(newInstance);
        }
        const newSlot = newInstance.slots.first;
        if (newSlot) {
          selection.setPosition(newSlot, 0);
        } else if (newInstance.parent) {
          const index = newInstance.parent.indexOf(newInstance);
          selection.setPosition(newInstance.parent, index + 1);
        }
        return true;
      }
    };
  }
  createShortcutEx(config) {
    const key = config.keymap.key;
    return {
      config,
      test(k2) {
        if (typeof key === "string") {
          return k2.toLowerCase() === key.toLowerCase();
        } else if (Array.isArray(key)) {
          return key.some((v2) => {
            return k2.toLowerCase() === v2.toLowerCase();
          });
        } else if (typeof key.match === "function") {
          return key.match(k2);
        }
        return key.match.test(k2);
      }
    };
  }
};
Keyboard = __decorate([
  Injectable(),
  __param(0, Inject(COMPONENT_LIST)),
  __param(1, Inject(ZEN_CODING_DETECT)),
  __metadata("design:paramtypes", [
    Array,
    Boolean,
    Commander,
    Injector,
    Selection
  ])
], Keyboard);
var OutputRenderer = class OutputRenderer2 {
  constructor(rootComponentRef) {
    this.rootComponentRef = rootComponentRef;
    this.componentVNode = /* @__PURE__ */ new WeakMap();
    this.slotVNodeCaches = /* @__PURE__ */ new WeakMap();
    this.slotRenderFactory = /* @__PURE__ */ new WeakMap();
  }
  render() {
    const root = this.componentRender(this.rootComponentRef.component);
    new VElement("body", null, [root]);
    return root;
  }
  componentRender(component) {
    if (component.changeMarker.outputDirty) {
      const node = component.extends.render((slot, factory) => {
        return this.slotRender(slot, factory);
      }, RenderMode.Output);
      component.changeMarker.outputRendered();
      this.componentVNode.set(component, node);
      return node;
    }
    const oldComponentVNode = this.componentVNode.get(component);
    component.slots.toArray().forEach((slot) => {
      if (!slot.changeMarker.outputChanged) {
        return;
      }
      const dirty = slot.changeMarker.outputDirty;
      const oldVNode = this.slotVNodeCaches.get(slot);
      const factory = this.slotRenderFactory.get(slot);
      const vNode = this.slotRender(slot, factory);
      if (dirty) {
        if (oldComponentVNode === oldVNode) {
          this.componentVNode.set(component, vNode);
        }
        oldVNode.parentNode.replaceChild(vNode, oldVNode);
        this.slotVNodeCaches.set(slot, vNode);
      }
    });
    component.changeMarker.outputRendered();
    return this.componentVNode.get(component);
  }
  slotRender(slot, slotRenderFactory) {
    if (slot.changeMarker.outputDirty) {
      this.slotRenderFactory.set(slot, slotRenderFactory);
      const formatTree = slot.createFormatTree();
      const componentRender = (component) => {
        return this.componentRender(component);
      };
      let children = formatTree.children ? PureRenderer.createVDomByFormatTree(slot, formatTree.children, RenderMode.Output, componentRender) : PureRenderer.createVDomByContent(slot, formatTree.startIndex, formatTree.endIndex, RenderMode.Output, componentRender);
      if (formatTree.formats) {
        children = [PureRenderer.createVDomByOverlapFormats(formatTree.formats, children, slot, RenderMode.Output)];
      }
      const root = slotRenderFactory(children);
      for (const [attribute, value] of slot.getAttributes()) {
        attribute.render(root, value, RenderMode.Output);
      }
      slot.changeMarker.outputRendered();
      this.slotVNodeCaches.set(slot, root);
      return root;
    }
    slot.sliceContent().filter((i2) => {
      return typeof i2 !== "string";
    }).forEach((component) => {
      if (!component.changeMarker.outputChanged) {
        return;
      }
      const dirty = component.changeMarker.outputDirty;
      const oldVNode = this.componentVNode.get(component);
      const vNode = this.componentRender(component);
      if (dirty) {
        oldVNode.parentNode.replaceChild(vNode, oldVNode);
      }
    });
    slot.changeMarker.outputRendered();
    return this.slotVNodeCaches.get(slot);
  }
};
OutputRenderer = __decorate([
  Injectable(),
  __metadata("design:paramtypes", [RootComponentRef])
], OutputRenderer);
var QueryStateType;
(function(QueryStateType2) {
  QueryStateType2["Normal"] = "Normal";
  QueryStateType2["Disabled"] = "Disabled";
  QueryStateType2["Enabled"] = "Enabled";
})(QueryStateType || (QueryStateType = {}));
var Query = class Query2 {
  constructor(selection) {
    this.selection = selection;
  }
  queryFormat(formatter) {
    if (!this.selection.isSelected) {
      return {
        state: QueryStateType.Normal,
        value: null
      };
    }
    const states = this.selection.getSelectedScopes().map((i2) => {
      return this.getStatesByRange(i2.slot, formatter, i2.startIndex, i2.endIndex);
    });
    return this.mergeState(states);
  }
  queryAttribute(attribute) {
    if (!this.selection.isSelected) {
      return {
        state: QueryStateType.Normal,
        value: null
      };
    }
    let ranges;
    if (this.selection.isCollapsed) {
      const c2 = this.selection.commonAncestorSlot;
      ranges = [{
        slot: c2,
        startIndex: 0,
        endIndex: c2.length
      }];
    } else {
      ranges = this.selection.getSelectedScopes();
    }
    const states = ranges.map((i2) => {
      const contents = i2.slot.sliceContent(i2.startIndex, i2.endIndex);
      const childComponents = [];
      let hasString = false;
      contents.forEach((item) => {
        if (typeof item !== "string") {
          childComponents.push(item);
        } else {
          hasString = true;
        }
      });
      if (hasString) {
        if (i2.slot.hasAttribute(attribute)) {
          return {
            state: QueryStateType.Enabled,
            value: i2.slot.getAttribute(attribute)
          };
        }
        return {
          state: QueryStateType.Normal,
          value: null
        };
      }
      const states2 = [];
      for (const component of childComponents) {
        const slots = component.slots;
        if (slots.length === 0) {
          if (i2.slot.hasAttribute(attribute)) {
            states2.push({
              state: QueryStateType.Enabled,
              value: i2.slot.getAttribute(attribute)
            });
          } else {
            return {
              state: QueryStateType.Normal,
              value: null
            };
          }
        }
        for (const slot of slots.toArray()) {
          if (slot.hasAttribute(attribute)) {
            states2.push({
              state: QueryStateType.Enabled,
              value: slot.getAttribute(attribute)
            });
          } else {
            return {
              state: QueryStateType.Normal,
              value: null
            };
          }
        }
      }
      return this.mergeState(states2);
    });
    return this.mergeState(states);
  }
  queryComponent(component, filter2) {
    if (!this.selection.isSelected) {
      return {
        state: QueryStateType.Normal,
        value: null
      };
    }
    const ranges = this.selection.getRanges();
    const states = ranges.map((item) => {
      var _a2;
      let parent = Selection.getCommonAncestorComponent(item.startSlot, item.endSlot);
      while (parent) {
        if (parent.name === component.name) {
          if (!filter2 || filter2(parent)) {
            return {
              state: QueryStateType.Enabled,
              value: parent
            };
          }
        }
        parent = ((_a2 = parent.parent) === null || _a2 === void 0 ? void 0 : _a2.parent) || null;
      }
      return {
        state: QueryStateType.Normal,
        value: null
      };
    });
    return this.mergeState(states);
  }
  queryWrappedComponent(component) {
    const selection = this.selection;
    if (!selection.isSelected || selection.isCollapsed) {
      return {
        state: QueryStateType.Normal,
        value: null
      };
    }
    const ranges = selection.getRanges();
    const instances = [];
    for (const range of ranges) {
      const { startSlot, endSlot, startOffset, endOffset } = range;
      if (startSlot !== endSlot || endOffset - startOffset > 1) {
        return {
          state: QueryStateType.Normal,
          value: null
        };
      }
      const instance = startSlot.getContentAtIndex(startOffset);
      if (typeof instance !== "string" && instance.name === component.name) {
        instances.push(instance);
      } else {
        return {
          state: QueryStateType.Normal,
          value: null
        };
      }
    }
    return {
      state: QueryStateType.Enabled,
      value: instances[0]
    };
  }
  getStatesByRange(slot, formatter, startIndex, endIndex) {
    if (startIndex === endIndex) {
      const format2 = startIndex === 0 ? slot.getFormatRangesByFormatter(formatter, 0, 1).shift() : slot.getFormatRangesByFormatter(formatter, startIndex - 1, endIndex).shift();
      if (format2) {
        return {
          state: QueryStateType.Enabled,
          value: format2.value
        };
      }
      return null;
    }
    const childContents = slot.sliceContent(startIndex, endIndex);
    const states = [];
    let index = startIndex;
    for (const child of childContents) {
      if (typeof child === "string" || child.slots.length === 0) {
        const formats = slot.getFormatRangesByFormatter(formatter, index, index + child.length);
        let s2 = index;
        for (const f2 of formats) {
          if (s2 !== f2.startIndex) {
            return {
              state: QueryStateType.Normal,
              value: null
            };
          }
          states.push({
            state: QueryStateType.Enabled,
            value: f2.value
          });
          s2 = f2.endIndex;
        }
        if (s2 !== index + child.length) {
          return {
            state: QueryStateType.Normal,
            value: null
          };
        }
      } else {
        child.slots.toArray().forEach((i2) => {
          states.push(this.getStatesByRange(i2, formatter, 0, i2.length));
        });
      }
      index += child.length;
    }
    return this.mergeState(states);
  }
  mergeState(states) {
    const states1 = states.filter((i2) => i2);
    const states2 = states1.filter((i2) => i2.state !== QueryStateType.Normal);
    if (states.length !== states2.length) {
      return {
        state: QueryStateType.Normal,
        value: null
      };
    }
    if (states2.length) {
      return {
        state: QueryStateType.Enabled,
        value: states2[0].value
      };
    }
    return {
      state: QueryStateType.Normal,
      value: null
    };
  }
};
Query = __decorate([
  Injectable(),
  __metadata("design:paramtypes", [Selection])
], Query);
var starterErrorFn = makeError("Starter");
var Starter = class extends ReflectiveInjector {
  constructor(config) {
    var _a2;
    super(new NullInjector(), [], Starter.diScope);
    this.config = config;
    this.beforeDestroyCallbacks = [];
    this.isDestroyed = false;
    const { plugins, providers } = this.mergeModules(config);
    this.plugins = plugins;
    this.staticProviders = providers;
    this.normalizedProviders = this.staticProviders.map((i2) => normalizeProvider(i2));
    (_a2 = config.imports) === null || _a2 === void 0 ? void 0 : _a2.forEach((module) => {
      if (typeof module.beforeEach === "function") {
        module.beforeEach(this);
      }
    });
  }
  mount(host, rootComponent2) {
    var _a2, _b2, _c;
    return __awaiter(this, void 0, void 0, function* () {
      const rootComponentRef = this.get(RootComponentRef);
      rootComponentRef.component = rootComponent2;
      rootComponentRef.host = host;
      const callbacks = [];
      (_a2 = this.config.imports) === null || _a2 === void 0 ? void 0 : _a2.forEach((i2) => {
        if (typeof i2.setup === "function") {
          const callback = i2.setup(this);
          callbacks.push(callback || null);
        }
      });
      callbacks.push(((_c = (_b2 = this.config).setup) === null || _c === void 0 ? void 0 : _c.call(_b2, this)) || null);
      const fns = yield Promise.all(callbacks);
      if (this.isDestroyed) {
        return this;
      }
      fns.forEach((i2) => {
        if (i2) {
          this.beforeDestroyCallbacks.push(i2);
        }
      });
      const scheduler = this.get(Scheduler);
      const history = this.get(History);
      history.listen();
      scheduler.run();
      this.plugins.forEach((i2) => i2.setup(this));
      return this;
    });
  }
  destroy() {
    this.isDestroyed = true;
    this.plugins.forEach((i2) => {
      var _a2;
      return (_a2 = i2.onDestroy) === null || _a2 === void 0 ? void 0 : _a2.call(i2);
    });
    this.beforeDestroyCallbacks.forEach((i2) => {
      i2();
    });
    [this.get(History), this.get(Selection), this.get(Scheduler), this.get(Renderer)].forEach((i2) => {
      i2.destroy();
    });
  }
  mergeModules(config) {
    var _a2;
    const customProviders = [
      ...config.providers || []
    ];
    const components = [
      ...config.components || []
    ];
    const attributes = this.bindContext(config.attributes);
    const formatters = this.bindContext(config.formatters);
    const plugins = [
      ...config.plugins || []
    ];
    (_a2 = config.imports) === null || _a2 === void 0 ? void 0 : _a2.forEach((module) => {
      customProviders.push(...module.providers || []);
      components.push(...module.components || []);
      attributes.push(...this.bindContext(module.attributes));
      formatters.push(...this.bindContext(module.formatters));
      plugins.push(...module.plugins || []);
    });
    const providers = [
      ...customProviders,
      {
        provide: READONLY,
        useValue: !!config.readonly
      },
      {
        provide: HISTORY_STACK_SIZE,
        useValue: typeof config.historyStackSize === "number" ? config.historyStackSize : 500
      },
      {
        provide: COMPONENT_LIST,
        useValue: components
      },
      {
        provide: ATTRIBUTE_LIST,
        useValue: attributes
      },
      {
        provide: FORMATTER_LIST,
        useValue: formatters
      },
      {
        provide: ZEN_CODING_DETECT,
        useValue: config.zenCoding
      },
      {
        provide: RootComponentRef,
        useValue: {}
      },
      {
        provide: History,
        useClass: LocalHistory
      },
      Controller,
      Scheduler,
      Commander,
      Keyboard,
      OutputRenderer,
      PureRenderer,
      Query,
      Renderer,
      Selection,
      Registry,
      {
        provide: Starter,
        useFactory: () => this
      },
      {
        provide: Injector,
        useFactory: () => {
          return this;
        }
      },
      {
        provide: NativeSelectionBridge,
        useFactory() {
          throw starterErrorFn("You must implement the `NativeSelectionBridge` interface to start Textbus!");
        }
      },
      {
        provide: NativeRenderer,
        useFactory() {
          throw starterErrorFn("You must implement the `NativeRenderer` interface to start Textbus!");
        }
      }
    ];
    return {
      providers,
      plugins: plugins.map((i2) => {
        if (typeof i2 === "function") {
          return i2();
        }
        return i2;
      })
    };
  }
  bindContext(list = []) {
    return list.map((item) => {
      if (typeof item === "function") {
        return item(this);
      }
      return item;
    });
  }
};
Starter.diScope = new Scope("Textbus");

// node_modules/@textbus/platform-browser/bundles/index.esm.js
function createElement(tagName, options = {}) {
  const el = document.createElement(tagName);
  if (options.classes) {
    el.classList.add(...options.classes);
  }
  if (options.attrs) {
    Object.keys(options.attrs).forEach((key) => {
      el.setAttribute(key, options.attrs[key]);
    });
  }
  if (options.props) {
    Object.keys(options.props).forEach((key) => {
      el[key] = options.props[key];
    });
  }
  if (options.styles) {
    Object.assign(el.style, options.styles);
  }
  if (options.children) {
    options.children.filter((i2) => i2).forEach((item) => {
      el.appendChild(item);
    });
  }
  if (options.on) {
    Object.keys(options.on).forEach((key) => {
      el.addEventListener(key, options.on[key]);
    });
  }
  return el;
}
function createTextNode(content) {
  return document.createTextNode(content);
}
function getLayoutRectByRange(range) {
  let { startContainer, startOffset } = range;
  if (startContainer.nodeType === Node.TEXT_NODE) {
    if (startOffset > 0) {
      return range.getBoundingClientRect();
    }
    const parentNode2 = startContainer.parentNode;
    startOffset = Array.from(parentNode2.childNodes).indexOf(startContainer);
    startContainer = parentNode2;
  }
  const beforeNode = startContainer.childNodes[startOffset - 1];
  if (beforeNode) {
    if (beforeNode.nodeType === Node.ELEMENT_NODE && beforeNode.nodeName.toLowerCase() !== "br") {
      const rect2 = beforeNode.getBoundingClientRect();
      return {
        left: rect2.right,
        top: rect2.top,
        width: rect2.width,
        height: rect2.height
      };
    } else if (beforeNode.nodeType === Node.TEXT_NODE) {
      const range2 = document.createRange();
      range2.setStart(beforeNode, beforeNode.textContent.length);
      range2.setEnd(beforeNode, beforeNode.textContent.length);
      return range2.getBoundingClientRect();
    }
  }
  const offsetNode = startContainer.childNodes[startOffset];
  let isInsertBefore = false;
  if (!offsetNode) {
    const lastChild = startContainer.lastChild;
    if (lastChild && lastChild.nodeType === Node.ELEMENT_NODE) {
      const rect2 = lastChild.getBoundingClientRect();
      return {
        left: rect2.right,
        top: rect2.top,
        width: rect2.width,
        height: rect2.height
      };
    }
  }
  if (offsetNode) {
    if (offsetNode.nodeType === Node.ELEMENT_NODE && offsetNode.nodeName.toLowerCase() !== "br") {
      return offsetNode.getBoundingClientRect();
    }
    isInsertBefore = true;
  }
  const span = startContainer.ownerDocument.createElement("span");
  span.innerText = "\u200B";
  span.style.display = "inline-block";
  if (isInsertBefore) {
    startContainer.insertBefore(span, offsetNode);
  } else {
    startContainer.appendChild(span);
  }
  const rect = span.getBoundingClientRect();
  startContainer.removeChild(span);
  return rect;
}
var isWindows = () => /win(dows|32|64)/i.test(navigator.userAgent);
var isMac = () => /mac os/i.test(navigator.userAgent);
var isSafari = () => /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
var isFirefox = () => /Firefox/.test(navigator.userAgent);
var isMobileBrowser = () => /Android|iPhone|iPad/.test(navigator.userAgent);
function __decorate2(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param2(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata2(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter2(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var EDITOR_OPTIONS = new InjectionToken("EDITOR_OPTIONS");
var VIEW_CONTAINER = new InjectionToken("VIEW_CONTAINER");
var VIEW_DOCUMENT = new InjectionToken("VIEW_DOCUMENT");
var VIEW_MASK = new InjectionToken("VIEW_MASK");
var Input = class {
};
var SelectionBridge = class SelectionBridge2 {
  constructor(config, injector, controller, selection, rootComponentRef, input, renderer) {
    this.config = config;
    this.injector = injector;
    this.controller = controller;
    this.selection = selection;
    this.rootComponentRef = rootComponentRef;
    this.input = input;
    this.renderer = renderer;
    this.nativeSelection = document.getSelection();
    this.selectionMaskElement = createElement("style");
    this.selectionChangeEvent = new Subject();
    this.subs = [];
    this.connector = null;
    this.ignoreSelectionChange = false;
    this.changeFromUser = false;
    this.docContainer = injector.get(VIEW_DOCUMENT);
    this.maskContainer = injector.get(VIEW_MASK);
    this.onSelectionChange = this.selectionChangeEvent.asObservable().pipe(filter(() => {
      return !controller.readonly;
    }));
    document.head.appendChild(this.selectionMaskElement);
    this.sub = this.onSelectionChange.subscribe((r2) => {
      if (r2) {
        input.focus(r2, this.changeFromUser);
      } else {
        input.blur();
      }
    });
    this.sub.add(fromEvent(document, "focusin").subscribe((ev) => {
      let target = ev.target;
      if (/^(input|textarea|select)$/i.test(target.nodeName)) {
        if (target.tagName.toLowerCase() === "input" && /^(range|date)$/.test(target.type)) {
          return;
        }
        this.ignoreSelectionChange = true;
        return;
      }
      if (!config.useContentEditable) {
        while (target) {
          if (target.contentEditable === "true") {
            this.ignoreSelectionChange = true;
            return;
          }
          target = target.parentNode;
        }
      }
    }));
    this.sub.add(fromEvent(document, "focusout").subscribe(() => {
      this.ignoreSelectionChange = false;
    }));
  }
  connect(connector) {
    this.disConnect();
    this.connector = connector;
    this.syncSelection(connector);
    this.listen(connector);
  }
  disConnect() {
    this.connector = null;
    this.unListen();
  }
  getRect(location) {
    const { focus, anchor } = this.getPositionByRange({
      focusOffset: location.offset,
      anchorOffset: location.offset,
      focusSlot: location.slot,
      anchorSlot: location.slot
    });
    if (!focus || !anchor) {
      return null;
    }
    const nativeRange = document.createRange();
    nativeRange.setStart(focus.node, focus.offset);
    nativeRange.collapse();
    return getLayoutRectByRange(nativeRange);
  }
  restore(abstractSelection, formLocal) {
    this.changeFromUser = formLocal;
    if (this.ignoreSelectionChange || !this.connector) {
      return;
    }
    this.unListen();
    if (!abstractSelection) {
      this.nativeSelection.removeAllRanges();
      this.selectionChangeEvent.next(null);
      this.listen(this.connector);
      return;
    }
    const { focus, anchor } = this.getPositionByRange(abstractSelection);
    if (!focus || !anchor) {
      this.nativeSelection.removeAllRanges();
      this.selectionChangeEvent.next(null);
      this.listen(this.connector);
      return;
    }
    this.nativeSelection.setBaseAndExtent(anchor.node, anchor.offset, focus.node, focus.offset);
    if (this.nativeSelection.rangeCount) {
      const nativeRange = this.nativeSelection.getRangeAt(0);
      this.selectionChangeEvent.next(nativeRange);
    } else {
      this.selectionChangeEvent.next(null);
    }
    const bind = () => {
      if (this.connector) {
        this.listen(this.connector);
      }
    };
    if (typeof requestIdleCallback === "function") {
      requestIdleCallback(bind);
    } else {
      setTimeout(bind, 30);
    }
  }
  destroy() {
    this.sub.unsubscribe();
  }
  getPositionByRange(abstractSelection) {
    let focus;
    let anchor;
    try {
      focus = this.findSelectedNodeAndOffset(abstractSelection.focusSlot, abstractSelection.focusOffset);
      anchor = focus;
      if (abstractSelection.anchorSlot !== abstractSelection.focusSlot || abstractSelection.anchorOffset !== abstractSelection.focusOffset) {
        anchor = this.findSelectedNodeAndOffset(abstractSelection.anchorSlot, abstractSelection.anchorOffset);
      }
      return {
        focus,
        anchor
      };
    } catch (e) {
      return {
        focus: null,
        anchor: null
      };
    }
  }
  getPreviousLinePositionByCurrent(position) {
    return this.getLinePosition(position, false);
  }
  getNextLinePositionByCurrent(position) {
    return this.getLinePosition(position, true);
  }
  getLinePosition(currentPosition, toNext) {
    clearTimeout(this.cacheCaretPositionTimer);
    let p2;
    if (this.oldCaretPosition) {
      p2 = toNext ? this.getNextLinePositionByOffset(currentPosition, this.oldCaretPosition.left) : this.getPreviousLinePositionByOffset(currentPosition, this.oldCaretPosition.left);
    } else {
      this.oldCaretPosition = this.getRect(currentPosition);
      p2 = toNext ? this.getNextLinePositionByOffset(currentPosition, this.oldCaretPosition.left) : this.getPreviousLinePositionByOffset(currentPosition, this.oldCaretPosition.left);
    }
    this.cacheCaretPositionTimer = setTimeout(() => {
      this.oldCaretPosition = null;
    }, 3e3);
    return p2;
  }
  getPreviousLinePositionByOffset(currentPosition, startLeft) {
    let isToPrevLine = false;
    let loopCount = 0;
    let minLeft = startLeft;
    let focusSlot = currentPosition.slot;
    let focusOffset = currentPosition.offset;
    let minTop = this.getRect({
      slot: focusSlot,
      offset: focusOffset
    }).top;
    let position;
    let oldPosition;
    let oldLeft = 0;
    while (true) {
      loopCount++;
      position = this.selection.getPreviousPositionByPosition(focusSlot, focusOffset);
      focusSlot = position.slot;
      focusOffset = position.offset;
      const rect2 = this.getRect(position);
      if (!isToPrevLine) {
        if (rect2.left > minLeft || rect2.top + rect2.height <= minTop) {
          isToPrevLine = true;
        } else if (rect2.left === minLeft && rect2.top === minTop) {
          return position;
        }
        minLeft = rect2.left;
        minTop = rect2.top;
      }
      if (isToPrevLine) {
        if (rect2.left < startLeft) {
          return position;
        }
        if (oldPosition) {
          if (rect2.left >= oldLeft) {
            return oldPosition;
          }
        }
        oldLeft = rect2.left;
        oldPosition = position;
      }
      if (loopCount > 1e4) {
        break;
      }
    }
    return position || {
      offset: 0,
      slot: focusSlot
    };
  }
  getNextLinePositionByOffset(currentPosition, startLeft) {
    let isToNextLine = false;
    let loopCount = 0;
    let maxRight = startLeft;
    let focusSlot = currentPosition.slot;
    let focusOffset = currentPosition.offset;
    const rect = this.getRect({
      slot: focusSlot,
      offset: focusOffset
    });
    let minTop = rect.top;
    let oldPosition;
    let oldLeft = 0;
    while (true) {
      loopCount++;
      const position = this.selection.getNextPositionByPosition(focusSlot, focusOffset);
      focusSlot = position.slot;
      focusOffset = position.offset;
      const rect2 = this.getRect(position);
      if (!isToNextLine) {
        if (rect2.left < maxRight || rect2.top >= minTop + rect.height) {
          isToNextLine = true;
        } else if (rect2.left === maxRight && rect2.top === minTop) {
          return position;
        }
        maxRight = rect2.left;
        minTop = rect2.top;
        oldPosition = position;
      }
      if (isToNextLine) {
        if (rect2.left > startLeft) {
          return oldPosition;
        }
        if (oldPosition) {
          if (rect2.left <= oldLeft) {
            return oldPosition;
          }
        }
        oldPosition = position;
        oldLeft = rect2.left;
      }
      if (loopCount > 1e4) {
        break;
      }
    }
    return oldPosition || {
      offset: focusSlot.length,
      slot: focusSlot
    };
  }
  unListen() {
    this.subs.forEach((i2) => i2.unsubscribe());
    this.subs = [];
  }
  listen(connector) {
    if (!this.config.useContentEditable) {
      const selection = this.nativeSelection;
      this.subs.push(fromEvent(this.docContainer, "mousedown").subscribe((ev) => {
        if (this.ignoreSelectionChange || ev.button === 2) {
          return;
        }
        if (!ev.shiftKey) {
          selection.removeAllRanges();
        }
      }));
    }
    this.subs.push(fromEvent(document, "selectionchange").pipe().subscribe(() => {
      this.syncSelection(connector);
    }));
  }
  syncSelection(connector) {
    var _a2;
    const selection = this.nativeSelection;
    this.changeFromUser = true;
    if (this.ignoreSelectionChange || this.input.composition || selection.rangeCount === 0 || !this.docContainer.contains(selection.anchorNode) || this.rootComponentRef.component.slots.length === 0) {
      return;
    }
    const rawRange = selection.getRangeAt(0);
    const nativeRange = rawRange.cloneRange();
    const isFocusEnd = selection.focusNode === nativeRange.endContainer && selection.focusOffset === nativeRange.endOffset;
    const isFocusStart = selection.focusNode === nativeRange.startContainer && selection.focusOffset === nativeRange.startOffset;
    if (!this.docContainer.contains(selection.focusNode)) {
      if (isFocusEnd) {
        const vEle = this.renderer.getVNodeBySlot(this.rootComponentRef.component.slots.first);
        if (!vEle) {
          return;
        }
        const nativeNode = this.renderer.getNativeNodeByVNode(vEle);
        if (!nativeNode) {
          return;
        }
        nativeRange.setEndAfter(nativeNode.lastChild);
      } else {
        const vEle = this.renderer.getVNodeBySlot(this.rootComponentRef.component.slots.last);
        if (!vEle) {
          return;
        }
        const nativeNode = this.renderer.getNativeNodeByVNode(vEle);
        if (!nativeNode) {
          return;
        }
        nativeRange.setStartBefore(nativeNode.firstChild);
      }
    }
    const startPosition = this.getCorrectedPosition(nativeRange.startContainer, nativeRange.startOffset, isFocusStart);
    const endPosition = nativeRange.collapsed ? startPosition : this.getCorrectedPosition(nativeRange.endContainer, nativeRange.endOffset, isFocusEnd);
    if ([Node.ELEMENT_NODE, Node.TEXT_NODE].includes((_a2 = nativeRange.commonAncestorContainer) === null || _a2 === void 0 ? void 0 : _a2.nodeType) && startPosition && endPosition) {
      const abstractSelection = isFocusEnd ? {
        anchorSlot: startPosition.slot,
        anchorOffset: startPosition.offset,
        focusSlot: endPosition.slot,
        focusOffset: endPosition.offset
      } : {
        focusSlot: startPosition.slot,
        focusOffset: startPosition.offset,
        anchorSlot: endPosition.slot,
        anchorOffset: endPosition.offset
      };
      const { focus, anchor } = this.getPositionByRange(abstractSelection);
      if (focus && anchor) {
        let start = anchor;
        let end = focus;
        if (isFocusStart) {
          start = focus;
          end = anchor;
        }
        if (nativeRange.startContainer !== start.node || nativeRange.startOffset !== start.offset) {
          nativeRange.setStart(start.node, start.offset);
        }
        if (nativeRange.endContainer !== end.node || nativeRange.endOffset !== end.offset) {
          nativeRange.setEnd(end.node, end.offset);
        }
        connector.setSelection(abstractSelection);
        if (selection.isCollapsed && (rawRange.startContainer !== start.node || rawRange.startOffset !== start.offset || rawRange.endContainer !== end.node || rawRange.endOffset !== end.offset)) {
          rawRange.setStart(start.node, start.offset);
          rawRange.setEnd(end.node, end.offset);
        }
        this.selectionChangeEvent.next(nativeRange);
      } else {
        connector.setSelection(null);
      }
      return;
    }
    connector.setSelection(null);
  }
  findSelectedNodeAndOffset(slot, offset) {
    const prev = slot.getContentAtIndex(offset - 1);
    const vNodes = this.renderer.getVNodesBySlot(slot);
    if (prev) {
      if (typeof prev !== "string") {
        const vNode = this.renderer.getVNodeByComponent(prev);
        const nativeNode = this.renderer.getNativeNodeByVNode(vNode);
        return {
          node: nativeNode.parentNode,
          offset: Array.from(nativeNode.parentNode.childNodes).indexOf(nativeNode) + 1
        };
      } else if (prev === "\n") {
        for (const vNode of vNodes) {
          if (vNode instanceof VTextNode) {
            continue;
          }
          if (vNode.tagName === "br") {
            const position = this.renderer.getLocationByVNode(vNode);
            if (position) {
              if (position.endIndex === offset) {
                const nativeNode = this.renderer.getNativeNodeByVNode(vNode);
                const parentNode2 = nativeNode.parentNode;
                return {
                  node: parentNode2,
                  offset: Array.from(parentNode2.childNodes).indexOf(nativeNode) + 1
                };
              }
            }
          }
        }
      }
    }
    const current = slot.getContentAtIndex(offset);
    if (current && typeof current !== "string") {
      const vNode = this.renderer.getVNodeByComponent(current);
      const nativeNode = this.renderer.getNativeNodeByVNode(vNode);
      return {
        node: nativeNode.parentNode,
        offset: Array.from(nativeNode.parentNode.childNodes).indexOf(nativeNode)
      };
    }
    for (const vNode of vNodes) {
      if (vNode instanceof VElement) {
        if (vNode.tagName === "br") {
          const position2 = this.renderer.getLocationByVNode(vNode);
          if (position2) {
            if (position2.startIndex === offset) {
              const nativeNode = this.renderer.getNativeNodeByVNode(vNode);
              const parentNode2 = nativeNode.parentNode;
              return {
                node: parentNode2,
                offset: Array.from(parentNode2.childNodes).indexOf(nativeNode)
              };
            }
          }
        }
        continue;
      }
      const position = this.renderer.getLocationByVNode(vNode);
      if (position) {
        if (offset >= position.startIndex && offset <= position.endIndex) {
          const nativeNode = this.renderer.getNativeNodeByVNode(vNode);
          return {
            node: nativeNode,
            offset: offset - position.startIndex
          };
        }
      }
    }
    return null;
  }
  getCorrectedPosition(node, offset, toAfter, excludeNodes = []) {
    excludeNodes.push(node);
    if (node.nodeType === Node.ELEMENT_NODE) {
      const containerPosition = this.renderer.getLocationByNativeNode(node);
      const childNode = node.childNodes[offset];
      if (childNode) {
        const childPosition = this.renderer.getLocationByNativeNode(childNode);
        if (childPosition) {
          if (containerPosition) {
            return {
              slot: childPosition.slot,
              offset: childPosition.startIndex
            };
          }
          return this.findFocusNode(childNode, toAfter, excludeNodes);
        }
        return this.findFocusNode(childNode, toAfter, excludeNodes);
      }
      const prevNode = node.childNodes[offset - 1];
      if (prevNode) {
        const prevPosition = this.renderer.getLocationByNativeNode(prevNode);
        if (prevPosition && containerPosition) {
          return {
            slot: prevPosition.slot,
            offset: prevPosition.endIndex
          };
        }
      }
      if (containerPosition) {
        return {
          slot: containerPosition.slot,
          offset: containerPosition.endIndex
        };
      }
      const nextNode = toAfter ? node.nextSibling : node.previousSibling;
      if (nextNode) {
        return this.findFocusNode(nextNode, toAfter, excludeNodes);
      }
      return this.findFocusNodeByParent(node, toAfter, excludeNodes);
    } else if (node.nodeType === Node.TEXT_NODE) {
      const containerPosition = this.renderer.getLocationByNativeNode(node);
      if (containerPosition) {
        return {
          slot: containerPosition.slot,
          offset: containerPosition.startIndex + offset
        };
      }
      const nextNode = toAfter ? node.nextSibling : node.previousSibling;
      if (nextNode) {
        return this.findFocusNode(nextNode, toAfter, excludeNodes);
      }
      return this.findFocusNodeByParent(node, toAfter, excludeNodes);
    }
    return null;
  }
  findFocusNode(node, toAfter = false, excludeNodes = []) {
    if (excludeNodes.includes(node)) {
      const next = toAfter ? node.nextSibling : node.previousSibling;
      if (next) {
        return this.findFocusNode(next, toAfter, excludeNodes);
      }
      return this.findFocusNodeByParent(node, toAfter, excludeNodes);
    }
    excludeNodes.push(node);
    const position = this.renderer.getLocationByNativeNode(node);
    if (position) {
      return {
        slot: position.slot,
        offset: toAfter ? position.startIndex : position.endIndex
      };
    }
    const firstChild = toAfter ? node.firstChild : node.lastChild;
    if (firstChild) {
      return this.findFocusNode(firstChild, toAfter, excludeNodes);
    }
    const nextSibling = toAfter ? node.nextSibling : node.previousSibling;
    if (nextSibling) {
      return this.findFocusNode(nextSibling, toAfter, excludeNodes);
    }
    return this.findFocusNodeByParent(node, toAfter, excludeNodes);
  }
  findFocusNodeByParent(node, toAfter, excludeNodes) {
    const parentNode2 = node.parentNode;
    if (parentNode2) {
      const parentPosition = this.renderer.getLocationByNativeNode(parentNode2);
      if (parentPosition) {
        return {
          slot: parentPosition.slot,
          offset: toAfter ? parentPosition.endIndex : parentPosition.startIndex
        };
      }
      excludeNodes.push(node);
      return this.findFocusNode(parentNode2, toAfter, excludeNodes);
    }
    return null;
  }
};
SelectionBridge = __decorate2([
  Injectable(),
  __param2(0, Inject(EDITOR_OPTIONS)),
  __metadata2("design:paramtypes", [
    Object,
    Injector,
    Controller,
    Selection,
    RootComponentRef,
    Input,
    Renderer
  ])
], SelectionBridge);
var CollaborateSelectionAwarenessDelegate = class {
};
var CollaborateCursor = class CollaborateCursor2 {
  constructor(injector, nativeSelection, scheduler, selection, awarenessDelegate) {
    this.injector = injector;
    this.nativeSelection = nativeSelection;
    this.scheduler = scheduler;
    this.selection = selection;
    this.awarenessDelegate = awarenessDelegate;
    this.host = createElement("div", {
      styles: {
        position: "absolute",
        left: 0,
        top: 0,
        width: "100%",
        height: "100%",
        pointerEvents: "none",
        zIndex: 1
      }
    });
    this.canvasContainer = createElement("div", {
      styles: {
        position: "absolute",
        left: 0,
        top: 0,
        width: "100%",
        height: "100%",
        overflow: "hidden"
      }
    });
    this.canvas = createElement("canvas", {
      styles: {
        position: "absolute",
        opacity: 0.5,
        left: 0,
        top: 0,
        width: "100%",
        height: document.documentElement.clientHeight + "px",
        pointerEvents: "none"
      }
    });
    this.context = this.canvas.getContext("2d");
    this.tooltips = createElement("div", {
      styles: {
        position: "absolute",
        left: 0,
        top: 0,
        width: "100%",
        height: "100%",
        pointerEvents: "none",
        fontSize: "12px",
        zIndex: 10
      }
    });
    this.onRectsChange = new Subject();
    this.subscription = new Subscription();
    this.currentSelection = [];
    this.container = injector.get(VIEW_CONTAINER);
    this.canvasContainer.append(this.canvas);
    this.host.append(this.canvasContainer, this.tooltips);
    this.container.prepend(this.host);
    this.subscription.add(this.onRectsChange.subscribe((rects) => {
      for (const rect of rects) {
        this.context.fillStyle = rect.color;
        this.context.beginPath();
        this.context.rect(rect.left, rect.top, rect.width, rect.height);
        this.context.fill();
        this.context.closePath();
      }
    }), fromEvent(window, "resize").subscribe(() => {
      this.canvas.style.height = document.documentElement.clientHeight + "px";
      this.refresh();
    }), this.scheduler.onDocChanged.subscribe(() => {
      this.refresh();
    }));
  }
  refresh() {
    this.draw(this.currentSelection);
  }
  destroy() {
    this.subscription.unsubscribe();
  }
  draw(paths) {
    this.currentSelection = paths;
    const containerRect = this.container.getBoundingClientRect();
    this.canvas.style.top = containerRect.top * -1 + "px";
    this.canvas.width = this.canvas.offsetWidth;
    this.canvas.height = this.canvas.offsetHeight;
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    const users = [];
    paths.filter((i2) => {
      return i2.paths.anchor.length && i2.paths.focus.length;
    }).forEach((item) => {
      const anchorPaths = [...item.paths.anchor];
      const focusPaths = [...item.paths.focus];
      const anchorOffset = anchorPaths.pop();
      const anchorSlot = this.selection.findSlotByPaths(anchorPaths);
      const focusOffset = focusPaths.pop();
      const focusSlot = this.selection.findSlotByPaths(focusPaths);
      if (!anchorSlot || !focusSlot) {
        return;
      }
      const { focus, anchor } = this.nativeSelection.getPositionByRange({
        focusOffset,
        anchorOffset,
        focusSlot,
        anchorSlot
      });
      if (!focus || !anchor) {
        return;
      }
      const nativeRange = document.createRange();
      nativeRange.setStart(anchor.node, anchor.offset);
      nativeRange.setEnd(focus.node, focus.offset);
      if ((anchor.node !== focus.node || anchor.offset !== focus.offset) && nativeRange.collapsed) {
        nativeRange.setStart(focus.node, focus.offset);
        nativeRange.setEnd(anchor.node, anchor.offset);
      }
      let rects = false;
      if (this.awarenessDelegate) {
        rects = this.awarenessDelegate.getRects({
          focusOffset,
          anchorOffset,
          focusSlot,
          anchorSlot
        }, nativeRange);
      }
      if (!rects) {
        rects = nativeRange.getClientRects();
      }
      const selectionRects = [];
      for (let i2 = rects.length - 1; i2 >= 0; i2--) {
        const rect2 = rects[i2];
        selectionRects.push({
          id: item.id,
          color: item.color,
          username: item.username,
          left: rect2.left - containerRect.left,
          top: rect2.top,
          width: rect2.width,
          height: rect2.height
        });
      }
      this.onRectsChange.next(selectionRects);
      const cursorRange = nativeRange.cloneRange();
      cursorRange.setStart(focus.node, focus.offset);
      cursorRange.collapse(true);
      const cursorRect = getLayoutRectByRange(cursorRange);
      const rect = {
        id: item.id,
        username: item.username,
        color: item.color,
        left: cursorRect.left - containerRect.left,
        top: cursorRect.top - containerRect.top,
        width: 1,
        height: cursorRect.height
      };
      if (rect.left < 0 || rect.top < 0 || rect.left > containerRect.width) {
        return;
      }
      users.push(rect);
    });
    this.drawUserCursor(users);
  }
  drawUserCursor(rects) {
    for (let i2 = 0; i2 < rects.length; i2++) {
      const rect = rects[i2];
      const { cursor, userTip, anchor } = this.getUserCursor(i2);
      Object.assign(cursor.style, {
        left: rect.left + "px",
        top: rect.top + "px",
        width: rect.width + "px",
        height: rect.height + "px",
        background: rect.color,
        display: "block"
      });
      anchor.style.background = rect.color;
      userTip.innerText = rect.username;
      userTip.style.background = rect.color;
    }
    for (let i2 = rects.length; i2 < this.tooltips.children.length; i2++) {
      this.tooltips.removeChild(this.tooltips.children[i2]);
    }
  }
  getUserCursor(index) {
    let child = this.tooltips.children[index];
    if (child) {
      const anchor2 = child.children[0];
      return {
        cursor: child,
        anchor: anchor2,
        userTip: anchor2.children[0]
      };
    }
    const userTip = createElement("span", {
      styles: {
        position: "absolute",
        left: "50%",
        transform: "translateX(-50%)",
        marginBottom: "2px",
        bottom: "100%",
        whiteSpace: "nowrap",
        color: "#fff",
        boxShadow: "0 1px 2px rgba(0,0,0,.1)",
        opacity: 0.8,
        borderRadius: "3px",
        padding: "3px 5px",
        pointerEvents: "none"
      }
    });
    const anchor = createElement("span", {
      styles: {
        position: "absolute",
        top: "-2px",
        left: "-2px",
        width: "5px",
        height: "5px",
        borderRadius: "50%",
        pointerEvents: "auto",
        pointer: "cursor"
      },
      children: [userTip]
    });
    child = createElement("span", {
      styles: {
        position: "absolute"
      },
      children: [
        anchor
      ]
    });
    this.tooltips.append(child);
    return {
      cursor: child,
      anchor,
      userTip
    };
  }
};
CollaborateCursor = __decorate2([
  Injectable(),
  __param2(4, Optional()),
  __metadata2("design:paramtypes", [
    Injector,
    SelectionBridge,
    Scheduler,
    Selection,
    CollaborateSelectionAwarenessDelegate
  ])
], CollaborateCursor);
var DomRenderer_1;
var DomRenderer = DomRenderer_1 = class DomRenderer2 {
  constructor() {
    this.isSVG = new RegExp(`^(${[
      "animate",
      "animateMotion",
      "animateTransform",
      "circle",
      "clipPath",
      "defs",
      "desc",
      "ellipse",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "filter",
      "foreignObject",
      "g",
      "image",
      "line",
      "linearGradient",
      "marker",
      "mask",
      "metadata",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "set",
      "stop",
      "svg",
      "switch",
      "symbol",
      "text",
      "textPath",
      "title",
      "tspan",
      "use",
      "view"
    ].join("|")})$`, "i");
    this.xlinkNameSpace = "http://www.w3.org/1999/xlink";
    this.possibleXlinkNames = {
      xlinkActuate: "xlink:actuate",
      xlinkactuate: "xlink:actuate",
      "xlink:actuate": "xlink:actuate",
      xlinkArcrole: "xlink:arcrole",
      xlinkarcrole: "xlink:arcrole",
      "xlink:arcrole": "xlink:arcrole",
      xlinkHref: "xlink:href",
      xlinkhref: "xlink:href",
      "xlink:href": "xlink:href",
      xlinkRole: "xlink:role",
      xlinkrole: "xlink:role",
      "xlink:role": "xlink:role",
      xlinkShow: "xlink:show",
      xlinkshow: "xlink:show",
      "xlink:show": "xlink:show",
      xlinkTitle: "xlink:title",
      xlinktitle: "xlink:title",
      "xlink:title": "xlink:title",
      xlinkType: "xlink:type",
      xlinktype: "xlink:type",
      "xlink:type": "xlink:type"
    };
    this.booleanProps = {
      input: ["disabled", "readonly"],
      select: ["disabled", "readonly"],
      option: ["disabled", "selected"],
      button: ["disabled"],
      video: ["controls", "autoplay", "loop", "muted"],
      audio: ["controls", "autoplay", "loop", "muted"]
    };
    this.valueProps = {
      input: ["value"],
      option: ["value"],
      video: ["src"],
      audio: ["src"]
    };
  }
  listen(node, type, callback) {
    node.addEventListener(type, callback);
  }
  unListen(node, type, callback) {
    node.removeEventListener(type, callback);
  }
  createTextNode(textContent) {
    return document.createTextNode(DomRenderer_1.replaceEmpty(textContent));
  }
  createElement(name) {
    if (this.isSVG.test(name)) {
      return document.createElementNS("http://www.w3.org/2000/svg", name);
    }
    return document.createElement(name);
  }
  appendChild(parent, newChild) {
    parent.appendChild(newChild);
  }
  remove(node) {
    var _a2;
    (_a2 = node.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(node);
  }
  insertBefore(newNode, ref) {
    ref.parentNode.insertBefore(newNode, ref);
  }
  getChildByIndex(parent, index) {
    return parent.childNodes[index] || null;
  }
  addClass(target, name) {
    target.classList.add(name);
  }
  removeClass(target, name) {
    target.classList.remove(name);
  }
  setStyle(target, key, value) {
    target.style[key] = value !== null && value !== void 0 ? value : "";
  }
  syncTextContent(target, content) {
    const c2 = DomRenderer_1.replaceEmpty(content);
    if (target.textContent !== c2) {
      target.textContent = c2;
    }
  }
  removeStyle(target, key) {
    target.style[key] = "";
  }
  setAttribute(target, key, value) {
    if (this.possibleXlinkNames[key]) {
      this.setXlinkAttribute(target, this.possibleXlinkNames[key], value);
      return;
    }
    target.setAttribute(key, value);
    const tag = target.tagName.toLowerCase();
    const booleanTagNames = this.booleanProps[tag];
    const valueTagNames = this.valueProps[tag];
    if (booleanTagNames && booleanTagNames.includes(key)) {
      target[key] = Boolean(value);
    }
    if (valueTagNames && valueTagNames.includes(key)) {
      target[key] = value;
    }
  }
  removeAttribute(target, key) {
    if (this.possibleXlinkNames[key]) {
      this.removeXlinkAttribute(target, this.possibleXlinkNames[key]);
    }
    target.removeAttribute(key);
    const tag = target.tagName.toLowerCase();
    const booleanTagNames = this.booleanProps[tag];
    const valueTagNames = this.valueProps[tag];
    if (booleanTagNames && booleanTagNames.includes(key)) {
      target[key] = false;
    }
    if (valueTagNames && valueTagNames.includes(key)) {
      target[key] = "";
    }
  }
  setXlinkAttribute(target, key, value) {
    target.setAttributeNS(this.xlinkNameSpace, key, value);
  }
  removeXlinkAttribute(target, key) {
    target.removeAttributeNS(this.xlinkNameSpace, key);
  }
  replace(newChild, oldChild) {
    oldChild.parentNode.replaceChild(newChild, oldChild);
  }
  copy() {
    document.execCommand("copy");
  }
  static replaceEmpty(s2) {
    const empty = "\xA0";
    return s2.replace(/\s\s+/g, (str) => {
      return " " + Array.from({
        length: str.length - 1
      }).fill(empty).join("");
    }).replace(/^\s|\s$/g, empty);
  }
};
DomRenderer = DomRenderer_1 = __decorate2([
  Injectable()
], DomRenderer);
var Parser_1;
var Parser = Parser_1 = class Parser2 {
  static parseHTML(html) {
    return new DOMParser().parseFromString(html, "text/html").body;
  }
  constructor(options, injector) {
    var _a2;
    this.options = options;
    this.injector = injector;
    const componentLoaders = [
      ...options.componentLoaders || []
    ];
    const formatLoaders = [
      ...options.formatLoaders || []
    ];
    const attributeLoaders = [
      ...options.attributeLoaders || []
    ];
    (_a2 = options.imports) === null || _a2 === void 0 ? void 0 : _a2.forEach((i2) => {
      componentLoaders.push(...i2.componentLoaders || []);
      formatLoaders.push(...i2.formatLoaders || []);
    });
    this.componentLoaders = componentLoaders;
    this.formatLoaders = formatLoaders;
    this.attributeLoaders = attributeLoaders;
  }
  parseDoc(html, rootComponentLoader2) {
    const element = typeof html === "string" ? Parser_1.parseHTML(html) : html;
    return rootComponentLoader2.read(element, this.injector, (childSlot, slotRootElement, slotContentHostElement = slotRootElement) => {
      return this.readSlot(childSlot, slotRootElement, slotContentHostElement);
    });
  }
  parse(html, rootSlot) {
    const element = typeof html === "string" ? Parser_1.parseHTML(html) : html;
    return this.readFormats(element, rootSlot);
  }
  readComponent(el, slot) {
    if (el.nodeType === Node.ELEMENT_NODE) {
      if (el.tagName === "BR") {
        slot.insert("\n");
        return;
      }
      for (const t2 of this.componentLoaders) {
        if (t2.match(el)) {
          const result = t2.read(el, this.injector, (childSlot, slotRootElement, slotContentHostElement = slotRootElement) => {
            return this.readSlot(childSlot, slotRootElement, slotContentHostElement);
          });
          if (!result) {
            return;
          }
          if (result instanceof Slot) {
            result.toDelta().forEach((i2) => slot.insert(i2.insert, i2.formats));
            return;
          }
          slot.insert(result);
          return;
        }
      }
      this.readFormats(el, slot);
    } else if (el.nodeType === Node.TEXT_NODE) {
      this.readText(slot, el);
    }
  }
  readText(slot, el) {
    const textContent = el.textContent;
    if (/^\s*[\r\n\u200b]+\s*$/.test(textContent)) {
      return;
    }
    slot.insert(textContent);
  }
  readFormats(el, slot) {
    const formats = this.formatLoaders.filter((f2) => {
      return f2.match(el);
    }).map((f2) => {
      return f2.read(el);
    });
    const startIndex = slot.index;
    let startNode = el.firstChild;
    while (startNode) {
      this.readComponent(startNode, slot);
      startNode = startNode.nextSibling;
    }
    const endIndex = slot.index;
    this.applyFormats(slot, formats.map((i2) => {
      return {
        formatter: i2.formatter,
        value: i2.value,
        startIndex,
        endIndex
      };
    }));
    slot.retain(endIndex);
    return slot;
  }
  readSlot(childSlot, slotRootElement, slotContentElement) {
    if (slotRootElement.nodeType === Node.ELEMENT_NODE) {
      this.attributeLoaders.filter((a2) => {
        return a2.match(slotRootElement);
      }).forEach((a2) => {
        const r2 = a2.read(slotRootElement);
        childSlot.setAttribute(r2.attribute, r2.value);
      });
    }
    if (slotContentElement.nodeType === Node.ELEMENT_NODE) {
      this.readFormats(slotContentElement, childSlot);
    } else {
      this.readText(childSlot, slotContentElement);
    }
    return childSlot;
  }
  applyFormats(slot, formatItems) {
    slot.background(() => {
      formatItems.forEach((i2) => {
        slot.retain(i2.startIndex);
        slot.retain(i2.endIndex - i2.startIndex, i2.formatter, i2.value);
      });
    });
  }
};
Parser = Parser_1 = __decorate2([
  Injectable(),
  __param2(0, Inject(EDITOR_OPTIONS)),
  __metadata2("design:paramtypes", [Object, Injector])
], Parser);
var iframeHTML = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Textbus</title>
  <style>
    html {position: fixed; left:0; overflow: hidden}
    html, body{height: 100%;width:100%}
    body{margin:0; overflow: hidden}
    textarea{width: 2000px;height: 100%;opacity: 0; padding: 0; outline: none; border: none; position: absolute; left:0; top:0;}
  </style>
</head>
<body>
</body>
</html>
`;
var ExperimentalCaret = class {
  get rect() {
    return this.caret.getBoundingClientRect();
  }
  set display(v2) {
    this._display = v2;
    this.caret.style.visibility = v2 ? "visible" : "hidden";
  }
  get display() {
    return this._display;
  }
  constructor(scheduler, editorMask) {
    this.scheduler = scheduler;
    this.editorMask = editorMask;
    this.compositionState = null;
    this.compositionElement = createElement("span", {
      styles: {
        textDecoration: "underline"
      }
    });
    this.timer = null;
    this.oldPosition = null;
    this._display = true;
    this.flashing = true;
    this.subs = [];
    this.subscription = new Subscription();
    this.positionChangeEvent = new Subject();
    this.styleChangeEvent = new Subject();
    this.oldRange = null;
    this.isFixed = false;
    this.onPositionChange = this.positionChangeEvent.pipe(distinctUntilChanged());
    this.onStyleChange = this.styleChangeEvent.asObservable();
    this.elementRef = createElement("div", {
      styles: {
        position: "absolute",
        width: "2px",
        pointerEvents: "none"
      },
      children: [
        this.caret = createElement("span", {
          styles: {
            width: "100%",
            height: "100%",
            position: "absolute",
            left: 0,
            top: 0
          }
        })
      ]
    });
    this.subscription.add(fromEvent(document, "mousedown").subscribe(() => {
      this.flashing = false;
    }), fromEvent(document, "mouseup").subscribe(() => {
      this.flashing = true;
    }));
    this.editorMask.appendChild(this.elementRef);
  }
  refresh(isFixedCaret = false) {
    this.isFixed = isFixedCaret;
    if (this.oldRange) {
      this.show(this.oldRange, false);
    }
    this.isFixed = false;
  }
  show(range, restart) {
    const oldRect = this.elementRef.getBoundingClientRect();
    this.oldPosition = {
      top: oldRect.top,
      left: oldRect.left,
      height: oldRect.height
    };
    this.oldRange = range;
    if (restart || this.scheduler.lastChangesHasLocalUpdate) {
      clearTimeout(this.timer);
    }
    this.updateCursorPosition(range);
    if (range.collapsed) {
      if (restart || this.scheduler.lastChangesHasLocalUpdate) {
        this.display = true;
        const toggleShowHide = () => {
          this.display = !this.display || !this.flashing;
          this.timer = setTimeout(toggleShowHide, 400);
        };
        clearTimeout(this.timer);
        this.timer = setTimeout(toggleShowHide, 400);
      }
    } else {
      this.display = false;
      clearTimeout(this.timer);
    }
  }
  hide() {
    this.display = false;
    clearTimeout(this.timer);
    this.positionChangeEvent.next(null);
  }
  destroy() {
    clearTimeout(this.timer);
    this.subscription.unsubscribe();
    this.subs.forEach((i2) => i2.unsubscribe());
  }
  correctScrollTop(scroller) {
    this.subs.forEach((i2) => i2.unsubscribe());
    this.subs = [];
    const scheduler = this.scheduler;
    let docIsChanged = true;
    function limitPosition(position) {
      const { top, bottom } = scroller.getLimit();
      const caretTop = position.top;
      if (caretTop + position.height > bottom) {
        const offset = caretTop - bottom + position.height;
        scroller.setOffset(offset);
      } else if (position.top < top) {
        scroller.setOffset(-(top - position.top));
      }
    }
    let isPressed = false;
    this.subs.push(scroller.onScroll.subscribe(() => {
      if (this.oldPosition) {
        const rect = this.rect;
        this.oldPosition.top = rect.top;
        this.oldPosition.left = rect.left;
        this.oldPosition.height = rect.height;
      }
    }), fromEvent(document, "mousedown", true).subscribe(() => {
      isPressed = true;
    }), fromEvent(document, "mouseup", true).subscribe(() => {
      isPressed = false;
    }), scheduler.onDocChange.subscribe(() => {
      docIsChanged = true;
    }), this.onPositionChange.subscribe((position) => {
      if (position) {
        if (docIsChanged) {
          if (scheduler.lastChangesHasLocalUpdate) {
            limitPosition(position);
          } else if (this.oldPosition) {
            const offset = Math.floor(position.top - this.oldPosition.top);
            scroller.setOffset(offset);
          }
        } else if (!isPressed) {
          if (this.isFixed && this.oldPosition) {
            const offset = Math.floor(position.top - this.oldPosition.top);
            scroller.setOffset(offset);
          } else {
            limitPosition(position);
          }
        }
      }
      docIsChanged = false;
    }));
  }
  updateCursorPosition(nativeRange) {
    const startContainer = nativeRange.startContainer;
    const node = startContainer.nodeType === Node.ELEMENT_NODE ? startContainer : startContainer.parentNode;
    if ((node === null || node === void 0 ? void 0 : node.nodeType) !== Node.ELEMENT_NODE) {
      this.positionChangeEvent.next(null);
      return;
    }
    if (this.compositionState) {
      const compositionElement = this.compositionElement;
      compositionElement.innerText = this.compositionState.data;
      nativeRange = nativeRange.cloneRange();
      nativeRange.insertNode(compositionElement);
      nativeRange.selectNodeContents(compositionElement);
      nativeRange.collapse();
    }
    const rect = getLayoutRectByRange(nativeRange);
    const { fontSize, lineHeight, color } = getComputedStyle(node);
    let height;
    if (isNaN(+lineHeight)) {
      const f2 = parseFloat(lineHeight);
      if (isNaN(f2)) {
        height = parseFloat(fontSize);
      } else {
        height = f2;
      }
    } else {
      height = parseFloat(fontSize) * parseFloat(lineHeight);
    }
    const boxHeight = Math.max(Math.floor(Math.max(height, rect.height)), 12);
    let rectTop = rect.top;
    if (rect.height < height) {
      rectTop -= (height - rect.height) / 2;
    }
    rectTop = Math.floor(rectTop);
    const containerRect = this.editorMask.getBoundingClientRect();
    const top = Math.floor(rectTop - containerRect.top);
    const left = Math.floor(rect.left - containerRect.left);
    Object.assign(this.elementRef.style, {
      left: left + "px",
      top: top + "px",
      height: boxHeight + "px",
      lineHeight: boxHeight + "px",
      fontSize
    });
    this.caret.style.backgroundColor = color;
    this.styleChangeEvent.next({
      height: boxHeight + "px",
      lineHeight: boxHeight + "px",
      fontSize
    });
    this.positionChangeEvent.next({
      left,
      top: rectTop,
      height: boxHeight
    });
  }
};
var MagicInput = class MagicInput2 extends Input {
  set disabled(b2) {
    this._disabled = b2;
    if (b2 && this.textarea) {
      this.textarea.disabled = b2;
    }
  }
  get disabled() {
    return this._disabled;
  }
  constructor(parser, keyboard, commander, selection, controller, scheduler, injector) {
    super();
    this.parser = parser;
    this.keyboard = keyboard;
    this.commander = commander;
    this.selection = selection;
    this.controller = controller;
    this.scheduler = scheduler;
    this.injector = injector;
    this.composition = false;
    this.compositionState = null;
    this.caret = new ExperimentalCaret(this.scheduler, this.injector.get(VIEW_MASK));
    this.isSafari = isSafari();
    this.isFirefox = isFirefox();
    this.isMac = isMac();
    this.isWindows = isWindows();
    this._disabled = false;
    this.container = this.createEditableFrame();
    this.subscription = new Subscription();
    this.textarea = null;
    this.isFocus = false;
    this.nativeFocus = false;
    this.ignoreComposition = false;
    this.onReady = new Promise((resolve) => {
      this.subscription.add(fromEvent(this.container, "load").subscribe(() => {
        const doc = this.container.contentDocument;
        doc.open();
        doc.write(iframeHTML);
        doc.close();
        this.doc = doc;
        this.init();
        resolve();
      }), controller.onReadonlyStateChange.subscribe(() => {
        if (controller.readonly) {
          this.blur();
        }
      }));
    });
    this.caret.elementRef.append(this.container);
  }
  focus(range, restart) {
    var _a2;
    if (!this.disabled) {
      this.caret.show(range, restart);
    }
    if (this.controller.readonly) {
      return;
    }
    if (!this.isFocus) {
      (_a2 = this.textarea) === null || _a2 === void 0 ? void 0 : _a2.focus();
      setTimeout(() => {
        var _a3, _b2, _c;
        if (!this.nativeFocus && this.isFocus) {
          this.subscription.unsubscribe();
          (_b2 = (_a3 = this.textarea) === null || _a3 === void 0 ? void 0 : _a3.parentNode) === null || _b2 === void 0 ? void 0 : _b2.removeChild(this.textarea);
          this.subscription = new Subscription();
          this.init();
          (_c = this.textarea) === null || _c === void 0 ? void 0 : _c.focus();
        }
      });
    }
    this.isFocus = true;
  }
  blur() {
    var _a2;
    this.caret.hide();
    (_a2 = this.textarea) === null || _a2 === void 0 ? void 0 : _a2.blur();
    this.isFocus = false;
  }
  destroy() {
    this.caret.destroy();
    this.subscription.unsubscribe();
  }
  init() {
    const doc = this.doc;
    const contentBody = doc.body;
    const textarea = doc.createElement("textarea");
    textarea.disabled = this.disabled;
    contentBody.appendChild(textarea);
    this.textarea = textarea;
    this.subscription.add(fromEvent(textarea, "blur").subscribe(() => {
      this.isFocus = false;
      this.nativeFocus = false;
      this.caret.hide();
    }), fromEvent(textarea, "focus").subscribe(() => {
      this.nativeFocus = true;
    }), this.caret.onStyleChange.subscribe((style) => {
      Object.assign(textarea.style, style);
    }));
    this.handleInput(textarea);
    this.handleShortcut(textarea);
    this.handleDefaultActions(textarea);
  }
  handleDefaultActions(textarea) {
    this.subscription.add(fromEvent(document, "copy").subscribe((ev) => {
      const selection = this.selection;
      if (!selection.isSelected) {
        return;
      }
      if (selection.startSlot === selection.endSlot && selection.endOffset - selection.startOffset === 1) {
        const content = selection.startSlot.getContentAtIndex(selection.startOffset);
        if (typeof content === "object") {
          const clipboardData = ev.clipboardData;
          const nativeSelection = document.getSelection();
          const range = nativeSelection.getRangeAt(0);
          const div = document.createElement("div");
          const fragment = range.cloneContents();
          div.append(fragment);
          clipboardData.setData("text/html", div.innerHTML);
          clipboardData.setData("text", div.innerText);
          ev.preventDefault();
        }
      }
    }), fromEvent(textarea, "paste").subscribe((ev) => {
      const text2 = ev.clipboardData.getData("Text");
      const files = Array.from(ev.clipboardData.files);
      if (files.length) {
        Promise.all(files.filter((i2) => {
          return /image/i.test(i2.type);
        }).map((item) => {
          const reader = new FileReader();
          return new Promise((resolve) => {
            reader.onload = (event) => {
              resolve(event.target.result);
            };
            reader.readAsDataURL(item);
          });
        })).then((urls) => {
          const html = urls.map((i2) => {
            return `<img src=${i2}>`;
          }).join("");
          this.handlePaste(html, text2);
        });
        ev.preventDefault();
        return;
      }
      const div = this.doc.createElement("div");
      div.style.cssText = "width:1px; height:10px; overflow: hidden; position: fixed; left: 50%; top: 50%; opacity:0";
      div.contentEditable = "true";
      this.doc.body.appendChild(div);
      div.focus();
      setTimeout(() => {
        this.doc.body.removeChild(div);
        div.style.cssText = "";
        this.handlePaste(div, text2);
      });
    }));
  }
  handlePaste(dom, text2) {
    const slot = this.parser.parse(dom, new Slot([
      ContentType.BlockComponent,
      ContentType.InlineComponent,
      ContentType.Text
    ]));
    this.commander.paste(slot, text2);
  }
  handleShortcut(textarea) {
    let isWriting = false;
    let isIgnore = false;
    this.subscription.add(fromEvent(textarea, "compositionstart").subscribe(() => {
      isWriting = true;
    }), fromEvent(textarea, "compositionend").subscribe(() => {
      isWriting = false;
    }), fromEvent(textarea, "beforeinput").subscribe((ev) => {
      if (this.isSafari) {
        if (ev.inputType === "insertFromComposition") {
          isIgnore = true;
        }
      }
    }), fromEvent(textarea, "keydown").pipe(filter(() => {
      if (this.isSafari && isIgnore) {
        isIgnore = false;
        return false;
      }
      return !isWriting;
    })).subscribe((ev) => {
      this.ignoreComposition = false;
      let key = ev.key;
      const keys = ")!@#$%^Z&*(";
      const b2 = key === "Process" && /Digit\d/.test(ev.code) && ev.shiftKey;
      if (b2) {
        key = keys.charAt(+ev.code.substring(5));
        ev.preventDefault();
      }
      const is = this.keyboard.execShortcut({
        key,
        altKey: ev.altKey,
        shiftKey: ev.shiftKey,
        ctrlKey: this.isMac ? ev.metaKey : ev.ctrlKey
      });
      if (is) {
        this.ignoreComposition = true;
        ev.preventDefault();
      }
    }));
  }
  handleInput(textarea) {
    let startIndex = 0;
    this.subscription.add(fromEvent(textarea, "compositionstart").pipe(filter(() => {
      return !this.ignoreComposition;
    })).subscribe(() => {
      if (!this.selection.isCollapsed) {
        this.commander.delete();
      }
      this.composition = true;
      this.caret.compositionState = this.compositionState = null;
      startIndex = this.selection.startOffset;
      const startSlot = this.selection.startSlot;
      const event = new Event(startSlot, {
        index: startIndex
      });
      invokeListener(startSlot.parent, "onCompositionStart", event);
    }), fromEvent(textarea, "compositionupdate").pipe(filter(() => {
      return !this.ignoreComposition;
    })).pipe(distinctUntilChanged((prev, next) => {
      return prev.data !== next.data;
    })).subscribe((ev) => {
      if (ev.data === " ") {
        return;
      }
      const startSlot = this.selection.startSlot;
      this.caret.compositionState = this.compositionState = {
        slot: startSlot,
        index: startIndex,
        data: ev.data
      };
      this.caret.refresh(true);
      const event = new Event(startSlot, {
        index: startIndex,
        data: ev.data
      });
      invokeListener(startSlot.parent, "onCompositionUpdate", event);
    }));
    let isCompositionEnd = false;
    this.subscription.add(merge(fromEvent(textarea, "beforeinput").pipe(filter((ev) => {
      ev.preventDefault();
      if (this.isFirefox && ev.inputType === "insertFromPaste") {
        return false;
      }
      if (this.isSafari) {
        isCompositionEnd = ev.inputType === "insertFromComposition";
        return ev.inputType === "insertText" || ev.inputType === "insertFromComposition";
      }
      return !ev.isComposing && !!ev.data;
    }), map((ev) => {
      return ev.data;
    })), this.isSafari ? new Observable() : fromEvent(textarea, "compositionend").pipe(filter(() => {
      return !this.ignoreComposition;
    })).pipe(map((ev) => {
      isCompositionEnd = true;
      ev.preventDefault();
      textarea.value = "";
      return ev.data;
    }))).subscribe((text2) => {
      var _a2;
      this.composition = false;
      this.caret.compositionState = this.compositionState = null;
      (_a2 = this.caret.compositionElement.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.caret.compositionElement);
      if (text2) {
        this.commander.write(text2);
      }
      if (isCompositionEnd) {
        const startSlot = this.selection.startSlot;
        if (startSlot) {
          const event = new Event(startSlot, null);
          invokeListener(startSlot.parent, "onCompositionEnd", event);
        }
      }
      isCompositionEnd = false;
    }));
  }
  createEditableFrame() {
    return createElement("iframe", {
      attrs: {
        scrolling: "no"
      },
      styles: {
        border: "none",
        width: "100%",
        display: "block",
        height: "100%",
        position: "relative",
        top: this.isWindows ? "3px" : "0"
      }
    });
  }
};
MagicInput = __decorate2([
  Injectable(),
  __metadata2("design:paramtypes", [
    Parser,
    Keyboard,
    Commander,
    Selection,
    Controller,
    Scheduler,
    Injector
  ])
], MagicInput);
var NativeCaret = class {
  set nativeRange(range) {
    this._nativeRange = range;
    if (range) {
      const r2 = range.cloneRange();
      r2.collapse(true);
      const rect = getLayoutRectByRange(r2);
      this.positionChangeEvent.next({
        left: rect.left,
        top: rect.top,
        height: rect.height
      });
    } else {
      this.positionChangeEvent.next(null);
    }
  }
  get nativeRange() {
    return this._nativeRange;
  }
  get rect() {
    if (this.nativeRange) {
      const range = this.nativeRange.cloneRange();
      range.collapse(true);
      return getLayoutRectByRange(range);
    }
    return {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
  }
  constructor(scheduler) {
    this.scheduler = scheduler;
    this.oldPosition = null;
    this._nativeRange = null;
    this.subs = [];
    this.positionChangeEvent = new Subject();
    this.onPositionChange = this.positionChangeEvent.pipe(distinctUntilChanged());
  }
  refresh() {
  }
  correctScrollTop(scroller) {
    this.destroy();
    const scheduler = this.scheduler;
    let docIsChanged = true;
    function limitPosition(position) {
      const { top, bottom } = scroller.getLimit();
      const caretTop = position.top;
      if (caretTop + position.height > bottom) {
        const offset = caretTop - bottom + position.height;
        scroller.setOffset(offset);
      } else if (position.top < top) {
        scroller.setOffset(-(top - position.top));
      }
    }
    let isPressed = false;
    this.subs.push(scroller.onScroll.subscribe(() => {
      if (this.oldPosition) {
        const rect = this.rect;
        this.oldPosition.top = rect.top;
        this.oldPosition.left = rect.left;
        this.oldPosition.height = rect.height;
      }
    }), fromEvent(document, "mousedown", true).subscribe(() => {
      isPressed = true;
    }), fromEvent(document, "mouseup", true).subscribe(() => {
      isPressed = false;
    }), scheduler.onDocChange.subscribe(() => {
      docIsChanged = true;
    }), this.onPositionChange.subscribe((position) => {
      if (position) {
        if (docIsChanged) {
          if (scheduler.lastChangesHasLocalUpdate) {
            limitPosition(position);
          } else if (this.oldPosition) {
            const offset = Math.floor(position.top - this.oldPosition.top);
            scroller.setOffset(offset);
          }
        } else if (!isPressed) {
          if (this.oldPosition) {
            const offset = Math.floor(position.top - this.oldPosition.top);
            scroller.setOffset(offset);
          } else {
            limitPosition(position);
          }
        }
      }
      docIsChanged = false;
    }));
  }
  destroy() {
    this.subs.forEach((i2) => i2.unsubscribe());
    this.subs = [];
  }
};
var NativeInput = class NativeInput2 extends Input {
  set disabled(b2) {
    this._disabled = b2;
    if (this.controller.readonly) {
      this.documentView.contentEditable = "false";
      return;
    }
    this.documentView.contentEditable = b2 ? "false" : "true";
  }
  get disabled() {
    return this._disabled;
  }
  constructor(injector, parser, scheduler, selection, keyboard, renderer, commander, controller) {
    super();
    this.injector = injector;
    this.parser = parser;
    this.scheduler = scheduler;
    this.selection = selection;
    this.keyboard = keyboard;
    this.renderer = renderer;
    this.commander = commander;
    this.controller = controller;
    this.caret = new NativeCaret(this.scheduler);
    this.composition = false;
    this.compositionState = null;
    this.onReady = Promise.resolve();
    this._disabled = false;
    this.nativeSelection = document.getSelection();
    this.subscription = new Subscription();
    this.nativeRange = null;
    this.isSafari = isSafari();
    this.isMac = isMac();
    this.isMobileBrowser = isMobileBrowser();
    this.ignoreComposition = false;
    this.documentView = injector.get(VIEW_DOCUMENT);
    if (!controller.readonly) {
      this.documentView.contentEditable = "true";
    }
    this.subscription.add(controller.onReadonlyStateChange.subscribe(() => {
      this.documentView.contentEditable = controller.readonly ? "false" : "true";
    }));
    this.handleShortcut(this.documentView);
    this.handleInput(this.documentView);
    this.handleDefaultActions(this.documentView);
  }
  focus(nativeRange) {
    if (this.controller.readonly) {
      return;
    }
    this.caret.nativeRange = nativeRange;
    this.nativeRange = nativeRange;
  }
  blur() {
    if (this.nativeRange && this.nativeSelection.rangeCount > 0) {
      const current = this.nativeSelection.getRangeAt(0);
      if (current === this.nativeRange) {
        this.nativeSelection.removeAllRanges();
        this.nativeRange = null;
        return;
      }
    }
  }
  destroy() {
    this.caret.destroy();
    this.subscription.unsubscribe();
  }
  handleDefaultActions(textarea) {
    this.subscription.add(fromEvent(document, "copy").subscribe((ev) => {
      const selection = this.selection;
      if (!selection.isSelected) {
        return;
      }
      if (selection.startSlot === selection.endSlot && selection.endOffset - selection.startOffset === 1) {
        const content = selection.startSlot.getContentAtIndex(selection.startOffset);
        if (typeof content === "object") {
          const clipboardData = ev.clipboardData;
          const nativeSelection = document.getSelection();
          const range = nativeSelection.getRangeAt(0);
          const div = document.createElement("div");
          const fragment = range.cloneContents();
          div.append(fragment);
          clipboardData.setData("text/html", div.innerHTML);
          clipboardData.setData("text", div.innerText);
          ev.preventDefault();
        }
      }
    }), fromEvent(textarea, "paste").subscribe((ev) => {
      const text2 = ev.clipboardData.getData("Text");
      const files = Array.from(ev.clipboardData.files);
      if (files.length) {
        Promise.all(files.filter((i2) => {
          return /image/i.test(i2.type);
        }).map((item) => {
          const reader = new FileReader();
          return new Promise((resolve) => {
            reader.onload = (event) => {
              resolve(event.target.result);
            };
            reader.readAsDataURL(item);
          });
        })).then((urls) => {
          const html = urls.map((i2) => {
            return `<img src=${i2}>`;
          }).join("");
          this.handlePaste(html, text2);
        });
        ev.preventDefault();
        return;
      }
      const div = document.createElement("div");
      div.style.cssText = "width:1px; height:10px; overflow: hidden; position: fixed; left: 50%; top: 50%; opacity:0";
      div.contentEditable = "true";
      document.body.appendChild(div);
      div.focus();
      setTimeout(() => {
        document.body.removeChild(div);
        div.style.cssText = "";
        this.handlePaste(div, text2);
      });
    }));
  }
  handlePaste(dom, text2) {
    const slot = this.parser.parse(dom, new Slot([
      ContentType.BlockComponent,
      ContentType.InlineComponent,
      ContentType.Text
    ]));
    this.commander.paste(slot, text2);
  }
  handleShortcut(input) {
    let isWriting = false;
    let isIgnore = false;
    this.subscription.add(fromEvent(input, "compositionstart").subscribe(() => {
      isWriting = true;
    }), fromEvent(input, "compositionend").subscribe(() => {
      isWriting = false;
    }), fromEvent(input, "beforeinput").subscribe((ev) => {
      if (this.isSafari) {
        if (ev.inputType === "insertFromComposition") {
          isIgnore = true;
        }
      }
    }), fromEvent(input, "keydown").pipe(filter(() => {
      if (this.isSafari && isIgnore) {
        isIgnore = false;
        return false;
      }
      return !isWriting;
    })).subscribe((ev) => {
      this.ignoreComposition = false;
      let key = ev.key;
      const keys = ")!@#$%^Z&*(";
      const b2 = key === "Process" && /Digit\d/.test(ev.code) && ev.shiftKey;
      if (b2) {
        key = keys.charAt(+ev.code.substring(5));
        ev.preventDefault();
      }
      const is = this.keyboard.execShortcut({
        key,
        altKey: ev.altKey,
        shiftKey: ev.shiftKey,
        ctrlKey: this.isMac ? ev.metaKey : ev.ctrlKey
      });
      if (is) {
        this.ignoreComposition = true;
        ev.preventDefault();
      }
    }));
  }
  handleInput(input) {
    if (this.isMobileBrowser) {
      this.handleMobileInput(input);
    } else {
      this.handlePCInput(input);
    }
  }
  handleMobileInput(input) {
    let isCompositionStart = true;
    let startIndex;
    const compositionStart = () => {
      this.composition = true;
      this.compositionState = null;
      startIndex = this.selection.startOffset;
      const startSlot = this.selection.startSlot;
      const event = new Event(startSlot, {
        index: startIndex
      });
      invokeListener(startSlot.parent, "onCompositionStart", event);
    };
    const compositionUpdate = (data) => {
      const startSlot = this.selection.startSlot;
      this.compositionState = {
        slot: startSlot,
        index: startIndex,
        data
      };
      const event = new Event(startSlot, {
        index: startIndex,
        data
      });
      invokeListener(startSlot.parent, "onCompositionUpdate", event);
    };
    const compositionEnd = (data) => {
      this.composition = false;
      if (data) {
        this.commander.write(data);
      }
      const startSlot = this.selection.startSlot;
      if (startSlot) {
        const event = new Event(startSlot, null);
        invokeListener(startSlot.parent, "onCompositionEnd", event);
      }
    };
    this.subscription.add(fromEvent(input, "compositionstart").subscribe(() => {
      compositionStart();
    }), fromEvent(input, "compositionupdate").subscribe((ev) => {
      compositionUpdate(ev.data);
    }), fromEvent(input, "compositionend").subscribe((ev) => {
      compositionEnd(ev.data);
    }), fromEvent(input, "beforeinput").subscribe((ev) => {
      var _a2;
      switch (ev.inputType) {
        case "insertText":
          if (ev.data) {
            this.commander.write(ev.data);
            ev.preventDefault();
          }
          break;
        case "insertCompositionText":
          if (isCompositionStart) {
            isCompositionStart = false;
            compositionStart();
          } else {
            compositionUpdate(ev.data || "");
          }
          break;
        case "deleteCompositionText":
          this.composition = false;
          break;
        case "deleteContentBackward": {
          this.composition = false;
          const range = ev.getTargetRanges()[0];
          if (!range) {
            break;
          }
          const location = this.renderer.getLocationByNativeNode(range.startContainer);
          const startSlot = this.selection.startSlot;
          if (startSlot) {
            this.selection.setBaseAndExtent(startSlot, location.startIndex + range.startOffset, startSlot, location.startIndex + range.endOffset);
            this.commander.delete();
          }
          break;
        }
        case "insertReplacementText": {
          this.composition = false;
          const range = ev.getTargetRanges()[0];
          const location = this.renderer.getLocationByNativeNode(range.startContainer);
          const startSlot = this.selection.startSlot;
          this.selection.setBaseAndExtent(startSlot, location.startIndex + range.startOffset, startSlot, location.startIndex + range.endOffset);
          this.commander.delete();
          const text2 = ((_a2 = ev.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.getData("text")) || ev.data || null;
          if (text2) {
            this.commander.write(text2);
          }
          break;
        }
      }
    }));
  }
  handlePCInput(input) {
    let startIndex = 0;
    let isCompositionEnd = false;
    this.subscription.add(fromEvent(input, "compositionstart").pipe(filter(() => {
      return !this.ignoreComposition;
    })).subscribe(() => {
      this.composition = true;
      this.compositionState = null;
      startIndex = this.selection.startOffset;
      const startSlot = this.selection.startSlot;
      const event = new Event(startSlot, {
        index: startIndex
      });
      invokeListener(startSlot.parent, "onCompositionStart", event);
    }), fromEvent(input, "compositionupdate").pipe(filter(() => {
      return !this.ignoreComposition;
    })).subscribe((ev) => {
      const startSlot = this.selection.startSlot;
      this.compositionState = {
        slot: startSlot,
        index: startIndex,
        data: ev.data
      };
      const event = new Event(startSlot, {
        index: startIndex,
        data: ev.data
      });
      invokeListener(startSlot.parent, "onCompositionUpdate", event);
    }), merge(fromEvent(input, "beforeinput").pipe(map((ev) => {
      var _a2;
      ev.preventDefault();
      if (ev.inputType === "insertCompositionText") {
        return null;
      }
      if (ev.inputType === "insertReplacementText") {
        const range = ev.getTargetRanges()[0];
        const location = this.renderer.getLocationByNativeNode(range.startContainer);
        const startSlot = this.selection.startSlot;
        this.selection.setBaseAndExtent(startSlot, location.startIndex + range.startOffset, startSlot, location.startIndex + range.endOffset);
        this.commander.delete();
        return ((_a2 = ev.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.getData("text")) || ev.data || null;
      }
      isCompositionEnd = ev.inputType === "insertFromComposition";
      if (isCompositionEnd && this.composition) {
        return null;
      }
      if (this.isSafari) {
        if (ev.inputType === "insertText" || isCompositionEnd) {
          return ev.data;
        }
      }
      if (!ev.isComposing && !!ev.data) {
        return ev.data;
      }
      return null;
    }), filter((text2) => {
      return text2;
    })), this.isSafari ? new Observable() : fromEvent(input, "compositionend").pipe(filter(() => {
      return !this.ignoreComposition;
    })).pipe(filter(() => {
      return this.composition;
    }), map((ev) => {
      isCompositionEnd = true;
      ev.preventDefault();
      return ev.data;
    }), filter(() => {
      const b2 = this.ignoreComposition;
      this.ignoreComposition = false;
      return !b2;
    }))).subscribe((text2) => {
      this.composition = false;
      this.compositionState = null;
      if (text2) {
        this.commander.write(text2);
      }
      if (isCompositionEnd) {
        const startSlot = this.selection.startSlot;
        if (startSlot) {
          const event = new Event(startSlot, null);
          invokeListener(startSlot.parent, "onCompositionEnd", event);
        }
      }
      isCompositionEnd = false;
    }));
  }
};
NativeInput = __decorate2([
  Injectable(),
  __metadata2("design:paramtypes", [
    Injector,
    Parser,
    Scheduler,
    Selection,
    Keyboard,
    Renderer,
    Commander,
    Controller
  ])
], NativeInput);
var OutputTranslator_1;
var OutputTranslator = OutputTranslator_1 = class OutputTranslator2 {
  constructor() {
    this.singleTagTest = new RegExp(`^(${OutputTranslator_1.singleTags.join("|")})$`, "i");
  }
  transform(vDom) {
    return vDom.children.map((child) => {
      return this.vDomToHTMLString(child);
    }).join("");
  }
  vDomToHTMLString(vDom) {
    const xssFilter = OutputTranslator_1.simpleXSSFilter;
    if (vDom instanceof VTextNode) {
      return this.replaceEmpty(xssFilter.text(vDom.textContent), "&nbsp;");
    }
    const styles = Array.from(vDom.styles.keys()).filter((key) => {
      const v2 = vDom.styles.get(key);
      return !(v2 === void 0 || v2 === null || v2 === "");
    }).map((key) => {
      const k2 = key.replace(/(?=[A-Z])/g, "-").toLowerCase();
      return xssFilter.attrValue(`${k2}:${vDom.styles.get(key)}`);
    }).join(";");
    const attrs = Array.from(vDom.attrs.keys()).filter((key) => key !== "ref" && vDom.attrs.get(key) !== false).map((k2) => {
      const key = xssFilter.attrName(k2);
      const value = vDom.attrs.get(k2);
      return value === true ? `${key}` : `${key}="${xssFilter.attrValue(`${value}`)}"`;
    });
    if (styles) {
      attrs.push(`style="${styles}"`);
    }
    if (vDom.classes && vDom.classes.size) {
      attrs.push(`class="${xssFilter.attrValue(Array.from(vDom.classes).join(" "))}"`);
    }
    let attrStr = attrs.join(" ");
    attrStr = attrStr ? " " + attrStr : "";
    if (this.singleTagTest.test(vDom.tagName)) {
      return `<${vDom.tagName}${attrStr}>`;
    }
    const childHTML = vDom.children.map((child) => {
      return this.vDomToHTMLString(child);
    }).join("");
    return [
      `<${vDom.tagName}${attrStr}>`,
      childHTML,
      `</${vDom.tagName}>`
    ].join("");
  }
  replaceEmpty(s2, target) {
    return s2.replace(/\s\s+/g, (str) => {
      return " " + Array.from({
        length: str.length - 1
      }).fill(target).join("");
    }).replace(/^\s|\s$/g, target);
  }
};
OutputTranslator.singleTags = "br,img,hr".split(",");
OutputTranslator.simpleXSSFilter = {
  text(text2) {
    return text2.replace(/[><&]/g, (str) => {
      return {
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;"
      }[str];
    });
  },
  attrName(text2) {
    return text2.replace(/[><"'&]/g, (str) => {
      return {
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "&": "&amp;"
      }[str];
    });
  },
  attrValue(text2) {
    return text2.replace(/["']/g, (str) => {
      return {
        '"': "&quot;",
        "'": "&#x27;"
      }[str];
    });
  }
};
OutputTranslator = OutputTranslator_1 = __decorate2([
  Injectable()
], OutputTranslator);
var editorError = makeError("CoreEditor");
var Viewer = class extends Starter {
  get readonly() {
    return this.controller.readonly;
  }
  set readonly(b2) {
    this.controller.readonly = b2;
  }
  isFocus() {
    return this._isFocus;
  }
  constructor(rootComponent2, rootComponentLoader2, options = {}) {
    const id = "textbus-" + Number((Math.random() + "").substring(2)).toString(16);
    const { doc, mask: mask2, wrapper } = Viewer.createLayout(id, options.minHeight);
    const staticProviders = [
      {
        provide: EDITOR_OPTIONS,
        useValue: options
      },
      {
        provide: VIEW_CONTAINER,
        useValue: wrapper
      },
      {
        provide: VIEW_DOCUMENT,
        useValue: doc
      },
      {
        provide: VIEW_MASK,
        useValue: mask2
      },
      {
        provide: NativeRenderer,
        useExisting: DomRenderer
      },
      {
        provide: NativeSelectionBridge,
        useExisting: SelectionBridge
      },
      {
        provide: Input,
        useClass: options.useContentEditable ? NativeInput : MagicInput
      },
      {
        provide: Viewer,
        useFactory: () => this
      },
      DomRenderer,
      Parser,
      SelectionBridge,
      OutputTranslator,
      CollaborateCursor
    ];
    options.imports = options.imports || [];
    options.imports.push({
      providers: staticProviders
    });
    super(Object.assign(Object.assign({}, options), { plugins: options.plugins || [], providers: options.providers, setup: options.setup }));
    this.rootComponent = rootComponent2;
    this.rootComponentLoader = rootComponentLoader2;
    this.options = options;
    this.destroyed = false;
    this.isReady = false;
    this.changeEvent = new Subject();
    this.subs = [];
    this._isFocus = false;
    this.resourceNodes = [];
    this.focusEvent = new Subject();
    this.blurEvent = new Subject();
    this.saveEvent = new Subject();
    this.styleSheet = "";
    this.scripts = [];
    this.links = [];
    this.id = id;
    this.workbench = wrapper;
    this.onChange = this.changeEvent.asObservable();
    this.onFocus = this.focusEvent.asObservable();
    this.onBlur = this.blurEvent.asObservable();
    this.onSave = this.saveEvent.asObservable();
    this.controller = this.get(Controller);
  }
  mount(host) {
    const _super = Object.create(null, {
      mount: { get: () => super.mount }
    });
    return __awaiter2(this, void 0, void 0, function* () {
      if (this.destroyed) {
        throw editorError("the editor instance is destroyed!");
      }
      if (this.destroyed) {
        return this;
      }
      const parser = this.get(Parser);
      const registry = this.get(Registry);
      const doc = this.get(VIEW_DOCUMENT);
      this.initDefaultShortcut();
      let component;
      const content = this.options.content;
      if (content) {
        if (typeof content === "string") {
          component = parser.parseDoc(content, this.rootComponentLoader);
        } else {
          component = registry.createComponentByFactory(content, this.rootComponent);
        }
      } else {
        component = this.rootComponent.createInstance(this);
      }
      this.initDocStyleSheetsAndScripts(this.options);
      host.appendChild(this.workbench);
      yield _super.mount.call(this, doc, component);
      const renderer = this.get(Renderer);
      const input = this.get(Input);
      this.subs.push(renderer.onViewUpdated.subscribe(() => {
        this.changeEvent.next();
      }), input.caret.onPositionChange.pipe(map((p2) => !!p2), distinctUntilChanged()).subscribe((b2) => {
        if (b2) {
          this._isFocus = true;
          this.focusEvent.next();
        } else {
          this._isFocus = false;
          this.blurEvent.next();
        }
      }));
      this.isReady = true;
      if (this.options.autoFocus) {
        input.onReady.then(() => {
          if (this.destroyed) {
            return;
          }
          this.focus();
        });
      }
      return this;
    });
  }
  focus() {
    this.guardReady();
    const selection = this.get(Selection);
    const rootComponentRef = this.get(RootComponentRef);
    if (selection.commonAncestorSlot) {
      selection.restore();
      return;
    }
    const location = selection.findFirstPosition(rootComponentRef.component.slots.get(0));
    selection.setPosition(location.slot, location.offset);
    selection.restore();
  }
  blur() {
    if (this.isReady && !this.destroyed) {
      const selection = this.get(Selection);
      selection.unSelect();
      selection.restore();
    }
  }
  getResources() {
    var _a2;
    return {
      styleSheets: ((_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.styleSheets) || [],
      styleSheet: this.styleSheet,
      links: this.links,
      scripts: this.scripts
    };
  }
  getHTML() {
    this.guardReady();
    const outputRenderer = this.get(OutputRenderer);
    const outputTranslator = this.get(OutputTranslator);
    const vDom = outputRenderer.render();
    return outputTranslator.transform(vDom);
  }
  getJSON() {
    this.guardReady();
    const rootComponentRef = this.get(RootComponentRef);
    return rootComponentRef.component.toJSON();
  }
  clear() {
    this.replaceContent("");
    const history = this.get(History);
    history.clear();
  }
  destroy() {
    var _a2;
    if (this.destroyed) {
      return;
    }
    this.destroyed = true;
    this.subs.forEach((i2) => i2.unsubscribe());
    const types = [
      Input
    ];
    types.forEach((i2) => {
      this.get(i2).destroy();
    });
    super.destroy();
    (_a2 = this.workbench.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.workbench);
    this.resourceNodes.forEach((node) => {
      var _a3;
      (_a3 = node.parentNode) === null || _a3 === void 0 ? void 0 : _a3.removeChild(node);
    });
  }
  replaceContent(content) {
    this.guardReady();
    const parser = this.get(Parser);
    const registry = this.get(Registry);
    const rootComponentRef = this.get(RootComponentRef);
    const selection = this.get(Selection);
    const rootComponentLoader2 = this.rootComponentLoader;
    let component;
    if (typeof content === "string") {
      component = parser.parseDoc(content, rootComponentLoader2);
    } else {
      component = registry.createComponentByFactory(content, this.rootComponent);
    }
    selection.unSelect();
    rootComponentRef.component.slots.clean();
    rootComponentRef.component.slots.push(...component.slots.toArray());
    invokeListener(component, "onDestroy");
  }
  guardReady() {
    if (this.destroyed) {
      throw editorError("the editor instance is destroyed!");
    }
    if (!this.isReady) {
      throw editorError("please wait for the editor to initialize before getting the content!");
    }
  }
  initDefaultShortcut() {
    const selection = this.get(Selection);
    const keyboard = this.get(Keyboard);
    const history = this.get(History);
    const commander = this.get(Commander);
    keyboard.addShortcut({
      keymap: {
        key: "s",
        ctrlKey: true
      },
      action: () => {
        this.saveEvent.next();
      }
    });
    keyboard.addShortcut({
      keymap: {
        key: "Enter"
      },
      action: () => {
        commander.break();
      }
    });
    keyboard.addShortcut({
      keymap: {
        key: "Enter",
        shiftKey: true
      },
      action: () => {
        const startOffset = selection.startOffset;
        const startSlot = selection.startSlot;
        const isToEnd = startOffset === startSlot.length || startSlot.isEmpty;
        const content = isToEnd ? "\n\n" : "\n";
        const isInserted = commander.insert(content);
        if (isInserted && isToEnd) {
          selection.setPosition(startSlot, startOffset + 1);
        }
      }
    });
    keyboard.addShortcut({
      keymap: {
        key: ["Delete", "Backspace"]
      },
      action: (key) => {
        commander.delete(key === "Backspace");
      }
    });
    keyboard.addShortcut({
      keymap: {
        key: ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"]
      },
      action: (key) => {
        switch (key) {
          case "ArrowLeft":
            selection.toPrevious();
            break;
          case "ArrowRight":
            selection.toNext();
            break;
          case "ArrowUp":
            selection.toPreviousLine();
            break;
          case "ArrowDown":
            selection.toNextLine();
            break;
        }
      }
    });
    keyboard.addShortcut({
      keymap: {
        key: ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"],
        shiftKey: true
      },
      action: (key) => {
        switch (key) {
          case "ArrowLeft":
            selection.wrapToBefore();
            break;
          case "ArrowRight":
            selection.wrapToAfter();
            break;
          case "ArrowUp":
            selection.wrapToPreviousLine();
            break;
          case "ArrowDown":
            selection.wrapToNextLine();
            break;
        }
      }
    });
    keyboard.addShortcut({
      keymap: {
        key: "Tab"
      },
      action: () => {
        commander.insert("    ");
      }
    });
    keyboard.addShortcut({
      keymap: {
        key: "a",
        ctrlKey: true
      },
      action: () => {
        selection.selectAll();
      }
    });
    keyboard.addShortcut({
      keymap: {
        key: "c",
        ctrlKey: true
      },
      action: () => {
        commander.copy();
      }
    });
    keyboard.addShortcut({
      keymap: {
        key: "x",
        ctrlKey: true
      },
      action: () => {
        commander.cut();
      }
    });
    keyboard.addShortcut({
      keymap: {
        key: "z",
        ctrlKey: true
      },
      action: () => {
        history.back();
      }
    });
    keyboard.addShortcut({
      keymap: {
        key: "z",
        ctrlKey: true,
        shiftKey: true
      },
      action: () => {
        history.forward();
      }
    });
  }
  initDocStyleSheetsAndScripts(options) {
    var _a2;
    const loaders = [];
    (_a2 = options.imports) === null || _a2 === void 0 ? void 0 : _a2.forEach((module) => {
      loaders.push(...module.componentLoaders || []);
    });
    loaders.push(...options.componentLoaders || []);
    const resources = loaders.filter((i2) => i2.resources).map((i2) => i2.resources);
    const docStyles = [];
    const editModeStyles = [];
    resources.forEach((metadata) => {
      var _a3, _b2;
      if (Array.isArray(metadata.links)) {
        this.links.push(...metadata.links);
      }
      docStyles.push(((_a3 = metadata.styles) === null || _a3 === void 0 ? void 0 : _a3.join("")) || "");
      editModeStyles.push(((_b2 = metadata.editModeStyles) === null || _b2 === void 0 ? void 0 : _b2.join("")) || "");
    });
    this.links.forEach((link) => {
      const linkEle = document.createElement("link");
      Object.assign(linkEle, link);
      this.resourceNodes.push(linkEle);
      document.head.appendChild(linkEle);
    });
    const styleEl = document.createElement("style");
    docStyles.push(...options.styleSheets || []);
    editModeStyles.push(`#${this.id} *::selection{background-color: rgba(18, 150, 219, .2); color:inherit}`, ...options.editingStyleSheets || []);
    this.styleSheet = Viewer.cssMin(docStyles.join(""));
    styleEl.innerHTML = this.styleSheet + Viewer.cssMin(editModeStyles.join(""));
    this.resourceNodes.push(styleEl);
    document.head.append(styleEl);
    resources.filter((i2) => {
      var _a3;
      return (_a3 = i2.scripts) === null || _a3 === void 0 ? void 0 : _a3.length;
    }).map((i2) => i2.scripts).flat().forEach((src) => {
      if (src) {
        const script = document.createElement("script");
        script.src = src;
        this.scripts.push(src);
        document.head.appendChild(script);
        this.resourceNodes.push(script);
      }
    });
  }
  static createLayout(id, minHeight = "100%") {
    const doc = createElement("div", {
      styles: {
        cursor: "text",
        wordBreak: "break-all",
        boxSizing: "border-box",
        minHeight,
        flex: 1,
        outline: "none"
      },
      attrs: {
        "data-textbus-view": VIEW_DOCUMENT
      },
      props: {
        id
      }
    });
    const mask2 = createElement("div", {
      attrs: {
        "data-textbus-view": VIEW_MASK
      },
      styles: {
        position: "absolute",
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        zIndex: 1,
        pointerEvents: "none",
        overflow: "hidden"
      }
    });
    const wrapper = createElement("div", {
      attrs: {
        "data-textbus-view": VIEW_CONTAINER
      },
      styles: {
        display: "flex",
        minHeight: "100%",
        position: "relative",
        flexDirection: "column"
      },
      children: [doc, mask2]
    });
    return {
      wrapper,
      doc,
      mask: mask2
    };
  }
  static cssMin(str) {
    return str.replace(/\s*(?=[>{}:;,[])/g, "").replace(/([>{}:;,])\s*/g, "$1").replace(/;}/g, "}").replace(/\s+/, " ").trim();
  }
};

// node_modules/@tanbo/bezier/bundles/esm/bezier.js
var Bezier = function() {
  function Bezier2(args) {
    this.anchors = [];
    if (args.length < 4) {
      throw new Error("[Bezier]: the parameters should not be less than 4.");
    }
    if (args.length % 2 !== 0) {
      throw new Error("[Bezier]: the parameter should be an even number.");
    }
    var point = {
      x: null,
      y: null
    };
    for (var i2 = 0; i2 < args.length; i2++) {
      if (i2 % 2) {
        point.y = args[i2];
        this.anchors.push(point);
        point = {
          x: null,
          y: null
        };
      } else {
        point.x = args[i2];
      }
    }
  }
  Bezier2.prototype.update = function(t2, fn2) {
    var points = this.anchors;
    while (points.length > 1) {
      if (typeof fn2 === "function") {
        fn2(points);
      }
      points = Bezier2.next(points, t2);
    }
    return points[0];
  };
  Bezier2.next = function(points, t2) {
    var nextPoints = [];
    for (var i2 = 0; i2 < points.length - 1; i2++) {
      var startPoint = points[i2];
      var endPoint = points[i2 + 1];
      nextPoints.push({
        x: (endPoint.x - startPoint.x) * t2 + startPoint.x,
        y: (endPoint.y - startPoint.y) * t2 + startPoint.y
      });
    }
    return nextPoints;
  };
  return Bezier2;
}();

// node_modules/@tanbo/bezier/bundles/esm/cubic-bezier.js
var __extends2 = function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CubicBezier = function(_super) {
  __extends2(CubicBezier2, _super);
  function CubicBezier2(x1, y1, x2, y2) {
    var _this = _super.call(this, [
      0,
      0,
      CubicBezier2.guard0To1(x1),
      y1,
      CubicBezier2.guard0To1(x2),
      y2,
      1,
      1
    ]) || this;
    _this.precision = 1e-6;
    return _this;
  }
  CubicBezier2.prototype.update = function(t2, fn2) {
    var offset = this.newton(t2);
    return _super.prototype.update.call(this, offset, fn2);
  };
  CubicBezier2.prototype.newton = function(s2) {
    var t2 = s2;
    var max = 1;
    while (true) {
      var point = _super.prototype.update.call(this, s2);
      var xDistance = point.x - t2;
      if (Math.abs(xDistance) < this.precision) {
        return s2;
      }
      var next = void 0;
      if (xDistance < 0) {
        next = (s2 + max) / 2;
      } else {
        next = s2 / 2;
        max = s2;
      }
      s2 = next;
    }
  };
  CubicBezier2.guard0To1 = function(n2) {
    if (n2 < 0) {
      return 0;
    } else if (n2 > 1) {
      return 1;
    }
    return n2;
  };
  return CubicBezier2;
}(Bezier);

// node_modules/@textbus/editor/bundles/index.esm.js
var import_prismjs = __toESM(require_prism());
var import_classnames = __toESM(require_classnames());

// node_modules/@tanbo/color/bundles/esm/utils.js
function normalizeAngle(degrees) {
  return (degrees % 360 + 360) % 360;
}
function normalizeHex(hex) {
  if (/^#/.test(hex)) {
    hex = hex.substring(1);
  }
  if (hex.length === 3) {
    return "#" + hex.split("").map(function(ch) {
      return ch + ch;
    }).join("");
  }
  return "#" + hex;
}

// node_modules/@tanbo/color/bundles/esm/color.js
var RGB_MAX = 255;
var HUE_MAX = 360;
var SV_MAX = 100;
function rgb2Hsl(color) {
  var r2 = color.r, g2 = color.g, b2 = color.b;
  r2 = r2 === RGB_MAX ? 1 : r2 % RGB_MAX / RGB_MAX;
  g2 = g2 === RGB_MAX ? 1 : g2 % RGB_MAX / RGB_MAX;
  b2 = b2 === RGB_MAX ? 1 : b2 % RGB_MAX / RGB_MAX;
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2, s2, l2 = (max + min) / 2;
  if (max === min) {
    h2 = s2 = 0;
  } else {
    var d2 = max - min;
    s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return {
    h: Math.round(h2 * HUE_MAX),
    s: Math.round(s2 * SV_MAX),
    l: Math.round(l2 * SV_MAX)
  };
}
function rgb2Hsv(color) {
  var r2 = color.r, g2 = color.g, b2 = color.b;
  r2 = r2 === RGB_MAX ? 1 : r2 % RGB_MAX / RGB_MAX;
  g2 = g2 === RGB_MAX ? 1 : g2 % RGB_MAX / RGB_MAX;
  b2 = b2 === RGB_MAX ? 1 : b2 % RGB_MAX / RGB_MAX;
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2, s2, v2 = max;
  var d2 = max - min;
  s2 = max === 0 ? 0 : d2 / max;
  if (max === min) {
    h2 = 0;
  } else {
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return {
    h: Math.round(h2 * HUE_MAX),
    s: Math.round(s2 * SV_MAX),
    v: Math.round(v2 * SV_MAX)
  };
}
function hsl2Rgb(color) {
  var h2 = color.h, s2 = color.s, l2 = color.l;
  function _hue2Rgb(p3, q3, t2) {
    if (t2 < 0)
      t2 += 1;
    if (t2 > 1)
      t2 -= 1;
    if (t2 < 1 / 6) {
      return p3 + (q3 - p3) * 6 * t2;
    }
    if (t2 < 1 / 2) {
      return q3;
    }
    if (t2 < 2 / 3) {
      return p3 + (q3 - p3) * (2 / 3 - t2) * 6;
    }
    return p3;
  }
  var r2, g2, b2;
  h2 = normalizeAngle(h2);
  h2 = h2 === HUE_MAX ? 1 : h2 % HUE_MAX / HUE_MAX;
  s2 = s2 === SV_MAX ? 1 : s2 % SV_MAX / SV_MAX;
  l2 = l2 === SV_MAX ? 1 : l2 % SV_MAX / SV_MAX;
  if (s2 === 0) {
    r2 = g2 = b2 = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q2;
    r2 = _hue2Rgb(p2, q2, h2 + 1 / 3);
    g2 = _hue2Rgb(p2, q2, h2);
    b2 = _hue2Rgb(p2, q2, h2 - 1 / 3);
  }
  return {
    r: Math.round(r2 * RGB_MAX),
    g: Math.round(g2 * RGB_MAX),
    b: Math.round(b2 * RGB_MAX)
  };
}
function hsv2Rgb(color) {
  var h2 = color.h, s2 = color.s, v2 = color.v;
  h2 = normalizeAngle(h2);
  h2 = h2 === HUE_MAX ? 1 : h2 % HUE_MAX / HUE_MAX * 6;
  s2 = s2 === SV_MAX ? 1 : s2 % SV_MAX / SV_MAX;
  v2 = v2 === SV_MAX ? 1 : v2 % SV_MAX / SV_MAX;
  var i2 = Math.floor(h2);
  var f2 = h2 - i2;
  var p2 = v2 * (1 - s2);
  var q2 = v2 * (1 - f2 * s2);
  var t2 = v2 * (1 - (1 - f2) * s2);
  var mod = i2 % 6;
  var r2 = [v2, q2, p2, p2, t2, v2][mod];
  var g2 = [t2, v2, v2, q2, p2, p2][mod];
  var b2 = [p2, p2, t2, v2, v2, q2][mod];
  return {
    r: Math.floor(r2 * RGB_MAX),
    g: Math.floor(g2 * RGB_MAX),
    b: Math.floor(b2 * RGB_MAX)
  };
}
function rgb2Hex(color) {
  var r2 = color.r, g2 = color.g, b2 = color.b;
  var rr = Math.round(r2).toString(16);
  var gg = Math.round(g2).toString(16);
  var bb = Math.round(b2).toString(16);
  rr = rr.length === 1 ? "0" + rr : rr;
  gg = gg.length === 1 ? "0" + gg : gg;
  bb = bb.length === 1 ? "0" + bb : bb;
  return "#" + rr + gg + bb;
}
function hex2Rgb(color) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(normalizeHex(color));
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}
function hsv2Hex(color) {
  var rgb = hsv2Rgb(color);
  return rgb2Hex(rgb);
}
function hex2Hsv(color) {
  var rgb = hex2Rgb(normalizeHex(color));
  return rgb2Hsv(rgb);
}
function hsl2Hex(color) {
  var rgb = hsl2Rgb(color);
  return rgb2Hex(rgb);
}
function hex2Hsl(color) {
  var rgb = hex2Rgb(normalizeHex(color));
  return rgb2Hsl(rgb);
}
function cmyk2Rgb(_a2) {
  var c2 = _a2.c, m2 = _a2.m, y2 = _a2.y, k2 = _a2.k;
  var r2 = 255 * (1 - c2) * (1 - k2);
  var g2 = 255 * (1 - m2) * (1 - k2);
  var b2 = 255 * (1 - y2) * (1 - k2);
  return {
    r: Math.floor(r2),
    g: Math.floor(g2),
    b: Math.floor(b2)
  };
}
function hsv2Hsl(color) {
  return rgb2Hsl(hsv2Rgb(color));
}
function hsl2Hsv(color) {
  var rgb = hsl2Rgb(color);
  return rgb2Hsv(rgb);
}

// node_modules/@tanbo/color/bundles/esm/tools.js
function parseCss(css) {
  if (css.indexOf("#") > -1) {
    return hex2Rgb(css);
  }
  var prefix = css.split("(")[0];
  var args = css.split("(")[1].split(")")[0].split(",");
  return prefix.split("").reduce(function(color, param, idx) {
    var nextColor = color;
    nextColor[param] = parseFloat(args[idx]);
    return nextColor;
  }, {});
}
function getColorEncoding(color) {
  if (typeof color === "string") {
    try {
      hex2Rgb(color);
      return "hex";
    } catch (err) {
    }
  }
  if (typeof color !== "object") {
    return "unknown";
  }
  var c2 = color;
  if (c2.r + c2.g + c2.b && typeof (c2.r + c2.g + c2.b) === "number") {
    return "rgb";
  }
  if (c2.h + c2.s + c2.v && typeof (c2.h + c2.s + c2.v) === "number") {
    return "hsv";
  }
  if (c2.h + c2.s + c2.l && typeof (c2.h + c2.s + c2.l) === "number") {
    return "hsl";
  }
  if (c2.c + c2.m + c2.y + c2.k && typeof (c2.c + c2.m + c2.y + c2.k) === "number") {
    return "cmyk";
  }
  return "unknown";
}
function any2Hsl(color) {
  var colorEncoding = getColorEncoding(color);
  switch (colorEncoding) {
    case "hsl":
      return color;
    case "rgb":
      return rgb2Hsl(color);
    case "hex":
      return hex2Hsl(color);
    case "hsv":
      return hsv2Hsl(color);
    case "cmyk":
      return rgb2Hsl(cmyk2Rgb(color));
    default:
      return "unknown";
  }
}

// node_modules/@tanbo/color-picker/bundles/index.esm.js
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign2.apply(this, arguments);
};
function template(btnText, paletteText, recentText, backText) {
  return '\n<div class="tanbo-color-picker-preset">\n  <div class="tanbo-color-picker-swatches" style="height: 50px"></div>\n  <div class="tanbo-color-picker-swatches" style="height: 118px;"></div>\n  <div class="tanbo-color-picker-recent-text">'.concat(recentText, '</div>\n  <div class="tanbo-color-picker-swatches" style="height: 25px;">\n    <div></div>\n    <div></div>\n    <div></div>\n    <div></div>\n    <div></div>\n    <div></div>\n    <div></div>\n  </div>\n  <div class="tanbo-color-picker-flex">\n    <div class="tanbo-color-picker-swatches">\n      <div data-color=""></div>\n    </div>\n    <button type="button" class="tanbo-color-picker-to-palette">').concat(paletteText, '<svg style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path transform="rotate(180, 512, 512)" d="M497.92 165.12L422.4 89.6 0 512l422.4 422.4 75.52-75.52L151.04 512z"></path></svg>\n    </button>\n  </div>\n</div>\n<div class="tanbo-color-picker-menu">\n  <div class="tanbo-color-picker-back-btn-wrap">\n    <button type="button" class="tanbo-color-picker-back-btn">\n      <svg style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M497.92 165.12L422.4 89.6 0 512l422.4 422.4 75.52-75.52L151.04 512z"></path></svg>').concat(backText, '\n    </button>\n  </div>\n  <div class="tanbo-color-picker-viewer">\n    <div class="tanbo-color-picker-viewer-left">\n      <div class="tanbo-color-picker-palette">\n        <div class="tanbo-color-picker-palette-point"></div>\n      </div>\n      <div class="tanbo-color-picker-viewer-alpha">\n        <div class="tanbo-color-picker-viewer-alpha-pointer"></div>\n        <div class="tanbo-color-picker-viewer-alpha-bar"></div>\n      </div>\n    </div>\n    <div class="tanbo-color-picker-viewer-right">\n      <div class="tanbo-color-picker-tools">\n        <div class="tanbo-color-picker-value">\n          <div class="tanbo-color-picker-value-color"></div>\n        </div>\n        <div class="tanbo-color-picker-hue-bar">\n          <div class="tanbo-color-picker-hue-pointer"></div>\n        </div>\n      </div>\n      <div class="tanbo-color-picker-viewer-alpha-value">\n        1\n      </div>\n    </div>\n  </div>\n  <div class="tanbo-color-picker-inputs">\n    <div class="tanbo-color-picker-hsl">\n      <div>H <input data-model="H" min="0" max="360" type="number"></div>\n      <div>S <input data-model="S" min="0" max="100" type="number"></div>\n      <div>L <input data-model="L" min="0" max="100" type="number"></div>\n    </div>\n    <div class="tanbo-color-picker-rgb">\n      <div>R <input data-model="R" min="0" max="255" type="number"></div>\n      <div>G <input data-model="G" min="0" max="255" type="number"></div>\n      <div>B <input data-model="B" min="0" max="255" type="number"></div>\n    </div>\n    <div class="tanbo-color-picker-hex">\n      <div>HEX <input data-model="HEX" type="text"></div>\n    </div>\n  </div>\n  <div class="tanbo-color-picker-btn-wrap">\n    <button type="button" class="tanbo-color-picker-btn">').concat(btnText, "</button>\n  </div>\n</div>\n");
}
var Picker = function() {
  function Picker2(selector, options) {
    if (options === void 0) {
      options = {};
    }
    var _this = this;
    this.onChange = new Subject();
    this.onSelected = new Subject();
    this.host = document.createElement("div");
    this.empty = false;
    this.resetAlpha = true;
    this.recentColorOptions = [];
    this.writing = false;
    this.colorElements = [];
    if (typeof selector === "string") {
      this.container = document.querySelector(selector);
    } else {
      this.container = selector;
    }
    this.host.classList.add("tanbo-color-picker");
    this.host.innerHTML = template(options.btnText || "\u786E\u5B9A", options.paletteText || "\u8C03\u8272\u76D8", options.recentText || "\u6700\u8FD1\u4F7F\u7528", options.backText || "\u8FD4\u56DE");
    this.container.appendChild(this.host);
    this.valueViewer = this.host.querySelector(".tanbo-color-picker-value-color");
    this.palette = this.host.querySelector(".tanbo-color-picker-palette");
    this.palettePoint = this.host.querySelector(".tanbo-color-picker-palette-point");
    this.hueBar = this.host.querySelector(".tanbo-color-picker-hue-bar");
    this.huePoint = this.host.querySelector(".tanbo-color-picker-hue-pointer");
    this.checkBtn = this.host.querySelector(".tanbo-color-picker-btn");
    this.alphaBar = this.host.querySelector(".tanbo-color-picker-viewer-alpha-bar");
    this.alphaValue = this.host.querySelector(".tanbo-color-picker-viewer-alpha-value");
    this.alphaPoint = this.host.querySelector(".tanbo-color-picker-viewer-alpha-pointer");
    this.inputsWrap = this.host.querySelector(".tanbo-color-picker-inputs");
    this.hslInputs = Array.from(this.host.querySelectorAll(".tanbo-color-picker-hsl input"));
    this.rgbInputs = Array.from(this.host.querySelectorAll(".tanbo-color-picker-rgb input"));
    this.hexInput = this.host.querySelector(".tanbo-color-picker-hex input");
    this.colorWrapper = this.host.querySelector(".tanbo-color-picker-preset");
    this.switchBtn = this.host.querySelector(".tanbo-color-picker-to-palette");
    this.menu = this.host.querySelector(".tanbo-color-picker-menu");
    this.backBtn = this.host.querySelector(".tanbo-color-picker-back-btn");
    this.mainColors = this.colorWrapper.children[0];
    this.colors = this.colorWrapper.children[1];
    this.recentElement = this.colorWrapper.children[3];
    if (Array.isArray(options.mainColors)) {
      this.addColor(options.mainColors, this.mainColors);
    }
    if (Array.isArray(options.colors)) {
      this.addColor(options.colors, this.colors);
    }
    this.hex = options.value || "#f00";
    this.bindingEvents();
    this.onSelected.subscribe(function() {
      _this.addRecentColor(_this.hex);
    });
  }
  Object.defineProperty(Picker2.prototype, "hex", {
    get: function() {
      return this.empty ? null : this._hex;
    },
    set: function(color) {
      var c2 = color ? normalizeHex(color) : null;
      if (c2) {
        this.empty = false;
        this._hex = c2;
        this._hsl = hex2Hsl(c2);
        this._rgb = hex2Rgb(c2);
        this._hsv = hex2Hsv(c2);
        this._rgba = __assign2(__assign2({}, this._rgb), { a: this.resetAlpha ? 1 : this._rgba.a });
      } else {
        this.empty = true;
      }
      this.resetAlpha = true;
      this.render();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Picker2.prototype, "hsl", {
    get: function() {
      return this.empty ? null : this._hsl;
    },
    set: function(color) {
      if (!color || typeof color.h !== "number" || typeof color.s !== "number" || typeof color.l !== "number") {
        this.empty = true;
      } else {
        this.empty = false;
        this._hsl = color;
        this._hex = hsl2Hex(color);
        this._hsv = hsl2Hsv(color);
        this._rgb = hsl2Rgb(color);
        this._rgba = __assign2(__assign2({}, this._rgb), { a: this.resetAlpha ? 1 : this._rgba.a });
      }
      this.resetAlpha = true;
      this.render();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Picker2.prototype, "rgb", {
    get: function() {
      return this.empty ? null : this._rgb;
    },
    set: function(color) {
      if (!color || typeof color.r !== "number" || typeof color.g !== "number" || typeof color.b !== "number") {
        this.empty = true;
      } else {
        this.empty = false;
        this._rgb = color;
        this._rgba = __assign2(__assign2({}, color), { a: this.resetAlpha ? 1 : this._rgba.a });
        this._hsl = rgb2Hsl(color);
        this._hex = rgb2Hex(color);
        this._hsv = rgb2Hsv(color);
      }
      this.resetAlpha = true;
      this.render();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Picker2.prototype, "rgba", {
    get: function() {
      return this.empty ? null : this._rgba;
    },
    set: function(color) {
      if (!color || typeof color.r !== "number" || typeof color.g !== "number" || typeof color.b !== "number" || typeof color.a !== "number") {
        this.empty = true;
      } else {
        this.empty = false;
        this._rgba = color;
        this._hsl = rgb2Hsl(color);
        this._hex = rgb2Hex(color);
        this._hsv = rgb2Hsv(color);
      }
      this.render();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Picker2.prototype, "hsv", {
    get: function() {
      return this.empty ? null : this._hsv;
    },
    set: function(color) {
      if (!color || typeof color.h !== "number" || typeof color.s !== "number" || typeof color.v !== "number") {
        this.empty = true;
      } else {
        this.empty = false;
        this._hsv = color;
        this._hex = hsv2Hex(color);
        this._hsl = hsv2Hsl(color);
        this._rgb = hsv2Rgb(color);
        this._rgba = __assign2(__assign2({}, this._rgb), { a: this.resetAlpha ? 1 : this._rgba.a });
      }
      this.resetAlpha = true;
      this.render();
    },
    enumerable: false,
    configurable: true
  });
  Picker2.prototype.addRecentColor = function(color) {
    if (!color) {
      return;
    }
    this.recentColorOptions = this.recentColorOptions.filter(function(item) {
      return item !== color;
    });
    this.recentColorOptions.unshift(color);
    if (this.recentColorOptions.length >= 7) {
      this.recentColorOptions.length = 7;
    }
    this.renderRecentColors();
  };
  Picker2.prototype.renderRecentColors = function() {
    var i2 = 0;
    while (i2 < 7) {
      var color = this.recentColorOptions[i2];
      var el = this.recentElement.children[i2];
      i2++;
      if (color) {
        el.style.background = color;
        el.setAttribute("data-color", color);
      } else {
        el.style.background = "";
        el.removeAttribute("data-color");
      }
    }
  };
  Picker2.prototype.addColor = function(colors, host) {
    var _this = this;
    colors.forEach(function(color) {
      var el = document.createElement("div");
      el.style.background = color;
      el.setAttribute("data-color", color);
      _this.colorElements.push(el);
      host.append(el);
    });
  };
  Picker2.prototype.render = function() {
    var _this = this;
    if (!this.writing) {
      if (this.empty) {
        this.hslInputs[0].value = "";
        this.hslInputs[1].value = "";
        this.hslInputs[2].value = "";
        this.rgbInputs[0].value = "";
        this.rgbInputs[1].value = "";
        this.rgbInputs[2].value = "";
        this.hexInput.value = "";
        this.alphaValue.innerText = "1";
      } else {
        this.hslInputs[0].value = this.hsl.h + "";
        this.hslInputs[1].value = this.hsl.s + "";
        this.hslInputs[2].value = this.hsl.l + "";
        this.rgbInputs[0].value = this.rgb.r + "";
        this.rgbInputs[1].value = this.rgb.g + "";
        this.rgbInputs[2].value = this.rgb.b + "";
        this.hexInput.value = this.hex;
        this.alphaValue.innerText = Number(this.rgba.a.toFixed(2)) + "";
      }
    }
    this.palette.classList.remove("tanbo-color-picker-palette-empty");
    this.palette.style.background = "linear-gradient(to right, #fff, hsl(".concat(this._hsv.h, ", 100%, 50%))");
    this.palettePoint.style.left = "calc(".concat(this._hsv.s, "% - 6px)");
    this.palettePoint.style.top = "calc(".concat(100 - this._hsv.v, "% - 6px)");
    this.huePoint.style.top = "calc(".concat(this._hsv.h / 360 * 100, "% - 4px)");
    if (this.empty) {
      this.palette.classList.add("tanbo-color-picker-palette-empty");
      this.palette.style.background = "";
      this.valueViewer.style.background = "";
      this.alphaBar.style.background = "";
      this.alphaPoint.style.left = "100%";
    } else {
      this.valueViewer.style.background = "rgba(".concat(this.rgba.r, ", ").concat(this.rgba.g, ", ").concat(this.rgba.b, ", ").concat(this.rgba.a, ")");
      this.palette.classList.remove("tanbo-color-picker-palette-empty");
      this.palette.style.background = "linear-gradient(to right, #fff, hsl(".concat(this._hsv.h, ", 100%, 50%))");
      this.alphaBar.style.background = "linear-gradient(to right, transparent, ".concat(this.hex, ")");
      this.alphaPoint.style.left = (this.rgba.a || 0) * 100 + "%";
    }
    this.colorElements.forEach(function(el) {
      var v2 = el.getAttribute("data-color") || "";
      var hsl = any2Hsl(v2);
      if (hsl === "unknown" || !_this.hsl) {
        el.classList.remove("tanbo-color-picker-current");
        return;
      }
      if (hsl.l === _this.hsl.l && hsl.s === _this.hsl.s && hsl.h === _this.hsl.h) {
        el.classList.add("tanbo-color-picker-current");
      } else {
        el.classList.remove("tanbo-color-picker-current");
      }
    });
  };
  Picker2.prototype.bindingEvents = function() {
    this.bindPaletteEvent();
    this.bindHueBarEvent();
    this.bindAlphaEvent();
    this.bindInputsEvent();
    this.bindSelectedEvent();
    this.bindColorOptionsEvent();
    this.bindSwitchEvent();
  };
  Picker2.prototype.bindSwitchEvent = function() {
    var _this = this;
    this.switchBtn.addEventListener("click", function() {
      _this.host.classList.add("tanbo-color-picker-show-palette");
    });
    this.backBtn.addEventListener("click", function() {
      _this.host.classList.remove("tanbo-color-picker-show-palette");
    });
  };
  Picker2.prototype.bindAlphaEvent = function() {
    var _this = this;
    var update = function(ev) {
      var position = _this.alphaBar.getBoundingClientRect();
      var offsetX = ev.clientX - position.left;
      offsetX = Math.max(0, offsetX);
      offsetX = Math.min(position.width, offsetX);
      _this.rgba = __assign2(__assign2({}, _this._rgba), { a: offsetX / position.width });
      _this.onChange.next(_this);
    };
    var mouseDownFn = function(ev) {
      update(ev);
      document.addEventListener("mousemove", mouseMoveFn);
      document.addEventListener("mouseup", mouseUpFn);
    };
    var mouseMoveFn = function(ev) {
      update(ev);
    };
    var mouseUpFn = function() {
      document.removeEventListener("mousemove", mouseMoveFn);
      document.removeEventListener("mouseup", mouseUpFn);
    };
    this.alphaBar.addEventListener("mousedown", mouseDownFn);
  };
  Picker2.prototype.bindPaletteEvent = function() {
    var _this = this;
    var update = function(ev) {
      var position = _this.palette.getBoundingClientRect();
      var offsetX = ev.clientX - position.left;
      var offsetY = ev.clientY - position.top;
      var s2 = offsetX / 130 * 100;
      var v2 = 100 - offsetY / 130 * 100;
      s2 = Math.max(0, s2);
      s2 = Math.min(100, s2);
      v2 = Math.max(0, v2);
      v2 = Math.min(100, v2);
      _this.resetAlpha = false;
      _this.hsv = {
        h: _this._hsv.h,
        s: s2,
        v: v2
      };
      _this.onChange.next(_this);
    };
    var mouseDownFn = function(ev) {
      update(ev);
      document.addEventListener("mousemove", mouseMoveFn);
      document.addEventListener("mouseup", mouseUpFn);
    };
    var mouseMoveFn = function(ev) {
      update(ev);
    };
    var mouseUpFn = function() {
      document.removeEventListener("mousemove", mouseMoveFn);
      document.removeEventListener("mouseup", mouseUpFn);
    };
    this.palette.addEventListener("mousedown", mouseDownFn);
  };
  Picker2.prototype.bindHueBarEvent = function() {
    var _this = this;
    var update = function(ev) {
      var position = _this.hueBar.getBoundingClientRect();
      var offsetY = ev.clientY - position.top;
      offsetY = Math.max(0, offsetY);
      offsetY = Math.min(100, offsetY);
      var h2 = 360 / 100 * offsetY;
      _this.resetAlpha = false;
      _this.hsv = {
        h: h2,
        s: _this._hsv.s,
        v: _this._hsv.v
      };
      _this.onChange.next(_this);
    };
    var mouseDownFn = function(ev) {
      update(ev);
      document.addEventListener("mousemove", mouseMoveFn);
      document.addEventListener("mouseup", mouseUpFn);
    };
    var mouseMoveFn = function(ev) {
      update(ev);
    };
    var mouseUpFn = function() {
      document.removeEventListener("mousemove", mouseMoveFn);
      document.removeEventListener("mouseup", mouseUpFn);
    };
    this.hueBar.addEventListener("mousedown", mouseDownFn);
  };
  Picker2.prototype.bindInputsEvent = function() {
    var _this = this;
    var updateByHSL = function(h2, s2, l2) {
      _this.hex = hsl2Hex({ h: h2, s: s2, l: l2 });
      _this.onChange.next(_this);
    };
    var updateByRGB = function(r2, g2, b2) {
      _this.hex = rgb2Hex({ r: r2, g: g2, b: b2 });
      _this.onChange.next(_this);
    };
    this.inputsWrap.addEventListener("input", function(ev) {
      _this.writing = true;
      var el = ev.target;
      var model = el.getAttribute("data-model");
      if (el.type === "number") {
        var min = +el.min;
        var max = +el.max;
        el.value = Math.max(el.value, min);
        el.value = Math.min(el.value, max);
      }
      var _a2 = _this.hsl, h2 = _a2.h, s2 = _a2.s, l2 = _a2.l;
      var _b2 = _this.rgb, r2 = _b2.r, g2 = _b2.g, b2 = _b2.b;
      switch (model) {
        case "H":
          updateByHSL(el.value, s2, l2);
          break;
        case "S":
          updateByHSL(h2, el.value, l2);
          break;
        case "L":
          updateByHSL(h2, s2, el.value);
          break;
        case "R":
          updateByRGB(el.value, g2, b2);
          break;
        case "G":
          updateByRGB(r2, el.value, b2);
          break;
        case "B":
          updateByRGB(r2, g2, el.value);
          break;
        case "HEX":
          if (/^#(([0-9a-f]){3}){1,2}$/i.test(el.value)) {
            _this.hex = el.value;
            _this.onChange.next(_this);
          }
          break;
      }
      _this.writing = false;
    });
  };
  Picker2.prototype.bindSelectedEvent = function() {
    var _this = this;
    this.checkBtn.addEventListener("click", function() {
      _this.host.classList.remove("tanbo-color-picker-show-palette");
      _this.onSelected.next(_this);
    });
  };
  Picker2.prototype.bindColorOptionsEvent = function() {
    var _this = this;
    this.colorWrapper.addEventListener("click", function(ev) {
      var target = ev.target;
      if (!target.hasAttribute("data-color")) {
        return;
      }
      var c2 = target.getAttribute("data-color");
      if (/^rgba/.test(c2)) {
        _this.rgba = parseCss(c2);
      } else {
        _this.hex = c2;
      }
      _this.onSelected.next(_this);
    });
  };
  return Picker2;
}();
function createPicker(selector, options) {
  if (options === void 0) {
    options = {};
  }
  return new Picker(selector, __assign2({ mainColors: [
    "#000",
    "#333",
    "#444",
    "#555",
    "#666",
    "#777",
    "#888",
    "#999",
    "#aaa",
    "#bbb",
    "#ccc",
    "#ddd",
    "#eee",
    "#fff"
  ], colors: [
    "#fec6c2",
    "#fee5c3",
    "#fefcc3",
    "#baf6c4",
    "#c3ebfe",
    "#c3cbfe",
    "#e1caff",
    "#fc8e88",
    "#fccc88",
    "#fcf888",
    "#76ec8a",
    "#88d8fc",
    "#97a4fb",
    "#c098f4",
    "#ff6666",
    "#ffb151",
    "#fada3a",
    "#18c937",
    "#3aaafa",
    "#6373e2",
    "#a669f7",
    "#f63030",
    "#f88933",
    "#deb12a",
    "#038e23",
    "#1276cc",
    "#3f52ce",
    "#8838ed",
    "#c60000",
    "#d86912",
    "#b88811",
    "#086508",
    "#144c93",
    "#1b2eaa",
    "#6117bf"
  ] }, options));
}

// node_modules/@textbus/editor/bundles/index.esm.js
var text = document.createElement("div");
var handlers = [];
for (let i2 = 0; i2 < 8; i2++) {
  const button = document.createElement("button");
  button.type = "button";
  handlers.push(button);
}
var mask = createElement("div", {
  classes: ["textbus-image-video-resize"],
  children: [
    ...handlers,
    text
  ]
});
var currentRef = null;
function useDragResize(ref, callback) {
  const context = useContext();
  const componentInstance = useSelf();
  const selection = context.get(Selection);
  const docContainer = context.get(VIEW_CONTAINER);
  const renderer = context.get(Renderer);
  const self2 = useSelf();
  let isFocus = false;
  const subs = [];
  subs.push(renderer.onViewUpdated.subscribe(() => {
    if (isFocus && currentRef) {
      updateStyle(currentRef.current, docContainer.getBoundingClientRect());
    }
  }), selection.onChange.subscribe(() => {
    var _a2, _b2;
    const index = (_a2 = self2.parent) === null || _a2 === void 0 ? void 0 : _a2.indexOf(self2);
    if (selection.startSlot !== self2.parent || selection.endSlot !== self2.parent || selection.startOffset !== index || selection.endOffset !== index + 1) {
      isFocus = false;
      (_b2 = mask.parentNode) === null || _b2 === void 0 ? void 0 : _b2.removeChild(mask);
    }
  }), fromEvent(mask, "mousedown").subscribe((ev) => {
    if (currentRef !== ref || !(currentRef === null || currentRef === void 0 ? void 0 : currentRef.current)) {
      return;
    }
    docContainer.style.pointerEvents = "none";
    const startRect = ref.current.getBoundingClientRect();
    const startX = ev.clientX;
    const startY = ev.clientY;
    const startWidth = startRect.width;
    const startHeight = startRect.height;
    const startHypotenuse = Math.sqrt(startWidth * startWidth + startHeight * startHeight);
    let endWidth = startWidth;
    let endHeight = startHeight;
    const index = handlers.indexOf(ev.target);
    const unMove = fromEvent(document, "mousemove").subscribe((ev2) => {
      const moveX = ev2.clientX;
      const moveY = ev2.clientY;
      const offsetX = moveX - startX;
      const offsetY = moveY - startY;
      let gainHypotenuse;
      let proportion;
      let sideX;
      let sideY;
      switch (index) {
        case 0:
        case 4:
          sideX = startWidth + offsetX;
          sideY = startHeight + offsetY;
          gainHypotenuse = Math.sqrt(sideX * sideX + sideY * sideY);
          proportion = gainHypotenuse / startHypotenuse;
          if (index === 0) {
            proportion = 1 - (proportion - 1);
          }
          endWidth = startWidth * proportion;
          endHeight = startHeight * proportion;
          break;
        case 2:
          sideX = startWidth + offsetX;
          sideY = startHeight - offsetY;
          gainHypotenuse = Math.sqrt(sideX * sideX + sideY * sideY);
          proportion = gainHypotenuse / startHypotenuse;
          endWidth = startWidth * proportion;
          endHeight = startHeight * proportion;
          break;
        case 6:
          sideX = startWidth - offsetX;
          sideY = startHeight + offsetY;
          gainHypotenuse = Math.sqrt(sideX * sideX + sideY * sideY);
          gainHypotenuse = Math.sqrt(sideX * sideX + sideY * sideY);
          proportion = gainHypotenuse / startHypotenuse;
          endWidth = startWidth * proportion;
          endHeight = startHeight * proportion;
          break;
        case 1:
          endHeight = startHeight - offsetY;
          break;
        case 5:
          endHeight = startHeight + offsetY;
          break;
        case 3:
          endWidth = startWidth + offsetX;
          break;
        case 7:
          endWidth = startWidth - offsetX;
          break;
      }
      currentRef.current.style.width = endWidth + "px";
      currentRef.current.style.height = endHeight + "px";
      updateStyle(currentRef.current, docContainer.getBoundingClientRect());
    });
    const unUp = fromEvent(document, "mouseup").subscribe(() => {
      callback({
        width: endWidth + "px",
        height: endHeight + "px"
      });
      docContainer.style.pointerEvents = "";
      unMove.unsubscribe();
      unUp.unsubscribe();
    });
  }));
  onViewInit(() => {
    subs.push(fromEvent(ref.current, "click").subscribe((ev) => {
      currentRef = ref;
      isFocus = true;
      selection.selectComponent(componentInstance, true);
      updateStyle(ref.current, docContainer.getBoundingClientRect());
      docContainer.appendChild(mask);
      ev.stopPropagation();
    }));
  });
  onDestroy(() => {
    var _a2;
    isFocus = false;
    (_a2 = mask.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(mask);
    subs.forEach((i2) => i2.unsubscribe());
  });
}
function updateStyle(nativeElement, offsetRect) {
  const rect = nativeElement.getBoundingClientRect();
  mask.style.cssText = `left: ${rect.left - offsetRect.left}px; top: ${rect.top - offsetRect.top}px; width: ${rect.width}px; height: ${rect.height}px;`;
  text.innerText = `${Math.round(rect.width)}px * ${Math.round(rect.height)}px`;
}
var paragraphComponent = defineComponent({
  type: ContentType.BlockComponent,
  name: "ParagraphComponent",
  setup(data) {
    const injector = useContext();
    const slots = useSlots((data === null || data === void 0 ? void 0 : data.slots) || [new Slot([
      ContentType.Text,
      ContentType.InlineComponent
    ])]);
    if (!slots.length) {
      slots.push(new Slot([
        ContentType.Text,
        ContentType.InlineComponent
      ]));
    }
    useEnterBreaking(injector, slots);
    return {
      render(slotRender) {
        return slotRender(slots.get(0), (children) => {
          return VElement.createElement("p", null, children);
        });
      }
    };
  }
});
var paragraphComponentLoader = {
  match(element) {
    return element.tagName === "P";
  },
  read(element, injector, slotParser) {
    const slot = slotParser(new Slot([
      ContentType.Text,
      ContentType.InlineComponent
    ]), element);
    return paragraphComponent.createInstance(injector, {
      slots: [slot]
    });
  }
};
var Matcher = class {
  constructor(target, rule) {
    this.target = target;
    this.rule = rule;
    this.validators = [];
    this.excludeValidators = [];
    if (rule.tags) {
      this.validators.push(this.makeTagsMatcher(rule.tags));
    }
    if (rule.styles) {
      this.validators.push(this.makeStyleMatcher(rule.styles));
    }
    if (rule.attrs) {
      this.validators.push(this.makeAttrsMatcher(rule.attrs));
    }
    if (rule.excludeStyles) {
      this.excludeValidators.push(this.makeStyleMatcher(rule.excludeStyles));
    }
    if (rule.excludeAttrs) {
      this.excludeValidators.push(this.makeAttrsMatcher(rule.excludeAttrs));
    }
  }
  match(element) {
    if (this.rule.filter) {
      const b2 = this.rule.filter(element);
      if (!b2) {
        return false;
      }
    }
    const exclude = this.excludeValidators.map((fn2) => fn2(element)).includes(true);
    if (exclude) {
      return false;
    }
    return this.validators.map((fn2) => fn2(element)).includes(true);
  }
  extractFormatData(node, config) {
    const attrs = {};
    if (config.attrs) {
      config.attrs.forEach((key) => {
        attrs[key] = node.getAttribute(key);
      });
    }
    const style = {};
    if (config.styleName) {
      (Array.isArray(config.styleName) ? config.styleName : [config.styleName]).forEach((name) => {
        const v2 = node.style[name];
        if (v2) {
          style[name] = v2;
        }
      });
    }
    return {
      tag: config.tag ? node.nodeName.toLowerCase() : null,
      attrs: Object.keys(attrs).length ? attrs : null,
      styles: style
    };
  }
  makeTagsMatcher(tags) {
    return (node) => {
      const tagName = node.nodeName.toLowerCase();
      return Array.isArray(tags) ? tags.includes(tagName) : tags.test(tagName);
    };
  }
  makeAttrsMatcher(attrs) {
    return (node) => {
      return attrs.map((attr) => {
        if (attr.value) {
          return node.getAttribute(attr.key) === attr.value;
        }
        return node.hasAttribute(attr.key);
      }).includes(true);
    };
  }
  makeStyleMatcher(styles) {
    return (node) => {
      return !Object.keys(styles).map((key) => {
        const optionValue = Array.isArray(styles[key]) ? styles[key] : [styles[key]];
        let styleValue = node.style[key];
        if (key === "fontFamily" && typeof styleValue === "string") {
          styleValue = styleValue.replace(/['"]/g, "");
        }
        if (styleValue) {
          return optionValue.map((v2) => {
            if (v2 instanceof RegExp) {
              return v2.test(styleValue);
            }
            return v2 === styleValue;
          }).includes(true);
        }
        return false;
      }).includes(false);
    };
  }
};
var LinkFormatLoader = class extends Matcher {
  constructor(formatter) {
    super(formatter, {
      tags: ["a"]
    });
  }
  read(element) {
    return {
      formatter: this.target,
      value: this.extractFormatData(element, {
        attrs: ["target", "href", "data-href"]
      }).attrs
    };
  }
};
var LinkFormatter = class {
  constructor() {
    this.priority = -1;
    this.name = "link";
    this.columned = false;
  }
  render(children, formatValue, renderMode) {
    if (renderMode !== RenderMode.Editing) {
      return new VElement("a", {
        target: formatValue.target,
        href: formatValue.href || formatValue["data-href"]
      }, children);
    }
    return new VElement("a", {
      target: formatValue.target,
      "data-href": formatValue.href || formatValue["data-href"]
    }, children);
  }
};
var linkFormatter = new LinkFormatter();
var linkFormatLoader = new LinkFormatLoader(linkFormatter);
function useEnterBreaking(injector, slots) {
  const selection = injector.get(Selection);
  const commander = injector.get(Commander);
  const self2 = useSelf();
  onBreak((ev) => {
    var _a2;
    const parentSlot = self2.parent;
    const index = parentSlot.indexOf(self2);
    parentSlot.retain(index + 1);
    const currentSlot = slots.get(0);
    const delta = currentSlot.cut(ev.data.index).toDelta();
    const nextSlot = new Slot([
      ContentType.Text,
      ContentType.InlineComponent
    ]);
    let i2 = 0;
    while (i2 < delta.length) {
      const item = delta[i2];
      if (nextSlot.insert(item.insert, item.formats)) {
        i2++;
        continue;
      }
      break;
    }
    if (nextSlot.isEmpty) {
      nextSlot.applyFormat(linkFormatter, {
        startIndex: 0,
        endIndex: 1,
        value: null
      });
    }
    const component = paragraphComponent.createInstance(injector, {
      slots: [nextSlot]
    });
    const beforeComponent = parentSlot.getContentAtIndex(index - 1);
    if (index === parentSlot.length - 1 && beforeComponent && typeof beforeComponent !== "string" && ["BlockComponent", "ParagraphComponent", "HeadingComponent"].includes(beforeComponent.name) && ((_a2 = beforeComponent.slots.get(0)) === null || _a2 === void 0 ? void 0 : _a2.isEmpty) && currentSlot.isEmpty && nextSlot.isEmpty) {
      const host = parentSlot.parentSlot;
      if (host) {
        const index2 = host.indexOf(self2.parentComponent);
        parentSlot.retain(parentSlot.index - 2);
        parentSlot.delete(2);
        host.retain(index2 + 1);
        host.insert(component);
      }
    }
    if (!component.parent) {
      parentSlot.insert(component);
    }
    selection.selectLastPosition(component);
    while (i2 < delta.length) {
      const item = delta[i2];
      i2++;
      commander.insert(item.insert, item.formats);
    }
    selection.setPosition(component.slots.get(0), 0);
    ev.preventDefault();
  });
}
function createCell(colspan = 1, rowspan = 1) {
  return new Slot([
    ContentType.InlineComponent,
    ContentType.BlockComponent,
    ContentType.Text
  ], {
    rowspan,
    colspan
  });
}
function findCellPosition(cell, cellMatrix) {
  let minRow, maxRow, minColumn, maxColumn;
  forA:
    for (let rowIndex = 0; rowIndex < cellMatrix.length; rowIndex++) {
      const cells = cellMatrix[rowIndex].cellsPosition;
      for (let colIndex = 0; colIndex < cells.length; colIndex++) {
        if (cells[colIndex].cell === cell) {
          minRow = rowIndex;
          minColumn = colIndex;
          break forA;
        }
      }
    }
  forB:
    for (let rowIndex = cellMatrix.length - 1; rowIndex > -1; rowIndex--) {
      const cells = cellMatrix[rowIndex].cellsPosition;
      for (let colIndex = cells.length - 1; colIndex > -1; colIndex--) {
        if (cells[colIndex].cell === cell) {
          maxRow = rowIndex;
          maxColumn = colIndex;
          break forB;
        }
      }
    }
  return {
    minRow,
    maxRow,
    minColumn,
    maxColumn
  };
}
function selectCellsByRange(minRow, minColumn, maxRow, maxColumn, cellMatrix) {
  const x1 = -Math.max(...cellMatrix.slice(minRow, maxRow + 1).map((row) => row.cellsPosition[minColumn].offsetColumn));
  const x2 = Math.max(...cellMatrix.slice(minRow, maxRow + 1).map((row) => {
    return row.cellsPosition[maxColumn].cell.state.colspan - (row.cellsPosition[maxColumn].offsetColumn + 1);
  }));
  const y1 = -Math.max(...cellMatrix[minRow].cellsPosition.slice(minColumn, maxColumn + 1).map((cell) => cell.offsetRow));
  const y2 = Math.max(...cellMatrix[maxRow].cellsPosition.slice(minColumn, maxColumn + 1).map((cell) => {
    return cell.cell.state.rowspan - (cell.offsetRow + 1);
  }));
  if (x1 || y1 || x2 || y2) {
    return selectCellsByRange(minRow + y1, minColumn + x1, maxRow + y2, maxColumn + x2, cellMatrix);
  }
  const startCellPosition = cellMatrix[minRow].cellsPosition[minColumn];
  const endCellPosition = cellMatrix[maxRow].cellsPosition[maxColumn];
  const selectedCells = cellMatrix.slice(startCellPosition.rowIndex, endCellPosition.rowIndex + 1).map((row) => {
    return row.cellsPosition.slice(startCellPosition.columnIndex, endCellPosition.columnIndex + 1);
  }).reduce((a2, b2) => {
    return a2.concat(b2);
  }).map((item) => item.cell);
  return {
    selectedCells: Array.from(new Set(selectedCells)),
    startPosition: startCellPosition,
    endPosition: endCellPosition
  };
}
function autoComplete(table) {
  const newTable = [];
  table.forEach((tr, rowIndex) => {
    if (!newTable[rowIndex]) {
      newTable[rowIndex] = [];
    }
    const row = newTable[rowIndex];
    let startColumnIndex = 0;
    tr.forEach((td) => {
      while (row[startColumnIndex]) {
        startColumnIndex++;
      }
      let maxColspan = 1;
      while (maxColspan < td.state.colspan) {
        if (!row[startColumnIndex + maxColspan]) {
          maxColspan++;
        } else {
          break;
        }
      }
      td.updateState((draft) => {
        draft.rowspan = td.state.rowspan;
        draft.colspan = maxColspan;
      });
      for (let i2 = rowIndex, len = td.state.rowspan + rowIndex; i2 < len; i2++) {
        if (!newTable[i2]) {
          newTable[i2] = [];
        }
        const row2 = newTable[i2];
        for (let j2 = startColumnIndex, max = startColumnIndex + maxColspan; j2 < max; j2++) {
          row2[j2] = td;
        }
      }
      startColumnIndex += maxColspan;
    });
  });
  const maxColumns = Math.max(...newTable.map((i2) => i2.length));
  newTable.forEach((tr) => {
    for (let i2 = 0; i2 < maxColumns; i2++) {
      if (!tr[i2]) {
        tr[i2] = createCell();
      }
    }
  });
  const recordCells = [];
  return newTable.map((tr) => {
    return tr.filter((td) => {
      const is = recordCells.includes(td);
      if (is) {
        return false;
      }
      recordCells.push(td);
      return true;
    });
  });
}
function slotsToTable(slots, columnSize) {
  const table = [];
  let rowIndex = 0;
  let columnIndex = 0;
  for (let index = 0; index < slots.length; index++) {
    const slot = slots[index];
    const state = slot.state;
    const row = table[rowIndex];
    if (row) {
      let isFull = true;
      for (let i2 = 0; i2 < columnSize; i2++) {
        if (!row[i2]) {
          columnIndex = i2;
          isFull = false;
          break;
        }
      }
      if (isFull) {
        columnIndex = 0;
        rowIndex++;
        index--;
        continue;
      }
    }
    for (let j2 = rowIndex; j2 < state.rowspan + rowIndex; j2++) {
      if (!table[j2]) {
        table[j2] = [];
      }
      const row2 = table[j2];
      for (let i2 = columnIndex; i2 < state.colspan + columnIndex; i2++) {
        row2[i2] = slot;
      }
    }
    columnIndex = state.colspan + columnIndex - 1;
    if (columnIndex === columnSize - 1) {
      columnIndex = 0;
      rowIndex++;
    }
  }
  const recordCells = [];
  return table.map((tr) => {
    return tr.filter((td) => {
      const is = recordCells.includes(td);
      if (is) {
        return false;
      }
      recordCells.push(td);
      return true;
    });
  });
}
function serialize(bodies) {
  const rows = [];
  for (let i2 = 0; i2 < bodies.length; i2++) {
    const cells = [];
    bodies[i2].forEach((cell, index) => {
      cells.push({
        row: bodies[i2],
        beforeCell: bodies[i2][index - 1],
        afterCell: bodies[i2][index + 1],
        offsetColumn: 0,
        offsetRow: 0,
        columnIndex: index,
        rowIndex: i2,
        cell
      });
    });
    rows.push({
      beforeRow: bodies[i2 - 1] || null,
      afterRow: bodies[i2 + 1] || null,
      cellsPosition: cells,
      cells: bodies[i2]
    });
  }
  let stop = false;
  let columnIndex = 0;
  const marks = [];
  do {
    let rowIndex = 0;
    stop = false;
    while (rowIndex < rows.length) {
      const row = rows[rowIndex];
      const cellPosition = row.cellsPosition[columnIndex];
      if (cellPosition) {
        let mark;
        cellPosition.rowIndex = rowIndex;
        cellPosition.columnIndex = columnIndex;
        if (cellPosition.offsetColumn + 1 < cellPosition.cell.state.colspan) {
          mark = `${rowIndex}*${columnIndex + 1}`;
          if (marks.indexOf(mark) === -1) {
            row.cellsPosition.splice(columnIndex + 1, 0, {
              beforeCell: cellPosition.beforeCell,
              afterCell: cellPosition.afterCell,
              cell: cellPosition.cell,
              row: row.cells,
              rowIndex,
              columnIndex,
              offsetColumn: cellPosition.offsetColumn + 1,
              offsetRow: cellPosition.offsetRow
            });
            marks.push(mark);
          }
        }
        if (cellPosition.offsetRow + 1 < cellPosition.cell.state.rowspan) {
          mark = `${rowIndex + 1}*${columnIndex}`;
          if (marks.indexOf(mark) === -1) {
            let nextRow = rows[rowIndex + 1];
            if (!nextRow) {
              nextRow = Object.assign(Object.assign({}, row), { cells: [], cellsPosition: [] });
              rows.push(nextRow);
            }
            const newRowBeforeColumn = nextRow.cellsPosition[columnIndex - 1];
            const newRowAfterColumn = nextRow.cellsPosition[columnIndex];
            nextRow.cellsPosition.splice(columnIndex, 0, {
              beforeCell: newRowBeforeColumn ? newRowBeforeColumn.cell : null,
              afterCell: newRowAfterColumn ? newRowAfterColumn.cell : null,
              row: nextRow.cells,
              cell: cellPosition.cell,
              offsetColumn: cellPosition.offsetColumn,
              offsetRow: cellPosition.offsetRow + 1,
              rowIndex,
              columnIndex
            });
            marks.push(mark);
          }
        }
        stop = true;
      }
      rowIndex++;
    }
    columnIndex++;
  } while (stop);
  return rows;
}
function findFocusCell(componentInstance, slot) {
  var _a2;
  while (slot) {
    if (componentInstance.slots.has(slot)) {
      return slot;
    }
    slot = (_a2 = slot.parent) === null || _a2 === void 0 ? void 0 : _a2.parent;
  }
  return null;
}
function selectCells(startCell, endCell, componentInstance, columnCount) {
  const serializedCells = serialize(slotsToTable(componentInstance.slots.toArray(), columnCount));
  const slots = componentInstance.slots;
  if (startCell === slots.first && endCell === slots.last) {
    const last = serializedCells[serializedCells.length - 1].cellsPosition;
    const cells = serializedCells.map((i2) => i2.cellsPosition).flat().map((i2) => i2.cell);
    return {
      startPosition: serializedCells[0].cellsPosition[0],
      endPosition: last[last.length - 1],
      selectedCells: Array.from(new Set(cells))
    };
  }
  const p1 = findCellPosition(startCell, serializedCells);
  const p2 = findCellPosition(endCell, serializedCells);
  const minRow = Math.min(p1.minRow, p2.minRow);
  const minColumn = Math.min(p1.minColumn, p2.minColumn);
  const maxRow = Math.max(p1.maxRow, p2.maxRow);
  const maxColumn = Math.max(p1.maxColumn, p2.maxColumn);
  return selectCellsByRange(minRow, minColumn, maxRow, maxColumn, serializedCells);
}
function useTableMultipleRange(slots, stateController, config, callback) {
  const injector = useContext();
  const renderer = injector.get(Renderer);
  const selection = injector.get(Selection);
  const editorContainer = injector.get(VIEW_CONTAINER);
  const animateBezier = new CubicBezier(0.25, 0.1, 0.25, 0.1);
  const self2 = useSelf();
  const subs = [
    stateController.onChange.subscribe((s2) => {
      config = s2;
    })
  ];
  const mask2 = createElement("div", {
    classes: ["textbus-table-editor-mask"]
  });
  let insertMask = false;
  let animateId;
  function addMask() {
    editorContainer.appendChild(mask2);
    insertMask = true;
  }
  function removeMask() {
    var _a2;
    insertMask = false;
    (_a2 = mask2.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(mask2);
  }
  function animate(start, target) {
    cancelAnimationFrame(animateId);
    function toInt(n2) {
      return n2 < 0 ? Math.ceil(n2) : Math.floor(n2);
    }
    let step = 0;
    const maxStep = 6;
    const animateFn = () => {
      step++;
      const ratio = animateBezier.update(step / maxStep).y;
      const left = start.left + toInt((target.left - start.left) * ratio);
      const top = start.top + toInt((target.top - start.top) * ratio);
      const width = start.width + toInt((target.width - start.width) * ratio);
      const height = start.height + toInt((target.height - start.height) * ratio);
      mask2.style.left = left + "px";
      mask2.style.top = top + "px";
      mask2.style.width = width + "px";
      mask2.style.height = height + "px";
      if (step < maxStep) {
        animateId = requestAnimationFrame(animateFn);
      }
    };
    animateId = requestAnimationFrame(animateFn);
  }
  function setSelectedCellsAndUpdateMaskStyle(startSlot, endSlot, offsetRect) {
    const tableRange = selectCells(startSlot, endSlot, self2, config.columnCount);
    callback(tableRange);
    const startPosition = tableRange.startPosition;
    const endPosition = tableRange.endPosition;
    const startCell = renderer.getNativeNodeByVNode(renderer.getVNodeBySlot(startPosition.cell));
    const endCell = renderer.getNativeNodeByVNode(renderer.getVNodeBySlot(endPosition.cell));
    if (!startCell || !endCell) {
      return tableRange;
    }
    const startRect = startCell.getBoundingClientRect();
    const endRect = endCell.getBoundingClientRect();
    const maskRect = mask2.getBoundingClientRect();
    if (startSlot === endSlot) {
      mask2.style.background = "none";
    } else {
      mask2.style.background = "";
    }
    if (insertMask) {
      animate({
        left: maskRect.left - offsetRect.left,
        top: maskRect.top - offsetRect.top,
        width: maskRect.width,
        height: maskRect.height
      }, {
        left: startRect.left - offsetRect.left,
        top: startRect.top - offsetRect.top,
        width: endRect.left + endRect.width - startRect.left,
        height: endRect.top + endRect.height - startRect.top
      });
    } else {
      addMask();
      mask2.style.left = startRect.left - offsetRect.left + "px";
      mask2.style.top = startRect.top - offsetRect.top + "px";
      mask2.style.width = endRect.left + endRect.width - startRect.left + "px";
      mask2.style.height = endRect.top + endRect.height - startRect.top + "px";
    }
    return tableRange;
  }
  function updateMaskEffect(event) {
    const commonAncestorComponent = selection.commonAncestorComponent;
    if (commonAncestorComponent === self2) {
      const containerRect = editorContainer.getBoundingClientRect();
      const startCell = findFocusCell(self2, selection.startSlot);
      const endCell = findFocusCell(self2, selection.endSlot);
      if (startCell && endCell) {
        const range = setSelectedCellsAndUpdateMaskStyle(startCell, endCell, containerRect);
        if (startCell !== endCell) {
          event === null || event === void 0 ? void 0 : event.useRanges(range.selectedCells.map((i2) => {
            return {
              slot: i2,
              startIndex: 0,
              endIndex: i2.length
            };
          }));
        }
      }
    } else {
      removeMask();
    }
  }
  onGetRanges((event) => {
    updateMaskEffect(event);
  });
  subs.push(merge(selection.onChange, renderer.onViewUpdated).pipe(debounceTime(1)).subscribe(() => {
    updateMaskEffect();
  }));
  onDestroy(() => {
    subs.forEach((i2) => i2.unsubscribe());
    removeMask();
  });
}
function __decorate3(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __metadata3(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
var I18n_1;
var I18n = I18n_1 = class I18n2 {
  constructor(defaultConfig, customConfig) {
    this.defaultConfig = defaultConfig;
    this.customConfig = customConfig;
  }
  get(path) {
    const tokens = this.parse(path);
    const customValue = this.getLabelByTokens(this.customConfig, tokens);
    if (typeof customValue === "string") {
      return customValue;
    }
    const value = this.getLabelByTokens(this.defaultConfig, tokens);
    return typeof value === "string" ? value : "";
  }
  getContext(path) {
    const tokens = this.parse(path);
    const customConfig = this.getLabelByTokens(this.customConfig, tokens) || {};
    const defaultConfig = this.getLabelByTokens(this.defaultConfig, tokens) || {};
    return new I18n_1(defaultConfig, customConfig);
  }
  joinTemplate(template2, ...values) {
    return template2.replace(/{\d+}/g, (str) => {
      return values[str.replace(/{\s*|\s*}/g, "")] || str;
    });
  }
  parse(path) {
    return path.split(/[.\[\]'"]+/g).map((i2) => i2.trim()).filter((i2) => i2);
  }
  getLabelByTokens(config, tokens) {
    if (!config || tokens.length === 0) {
      return null;
    }
    let value = config;
    for (let i2 = 0; i2 < tokens.length; i2++) {
      value = value[tokens[i2]];
      if (typeof value === "undefined") {
        return null;
      }
    }
    return value;
  }
};
I18n = I18n_1 = __decorate3([
  Injectable(),
  __metadata3("design:paramtypes", [Object, Object])
], I18n);
var alertComponent = defineComponent({
  type: ContentType.BlockComponent,
  name: "AlertComponent",
  setup(initData) {
    const slots = useSlots((initData === null || initData === void 0 ? void 0 : initData.slots) || []);
    let state = (initData === null || initData === void 0 ? void 0 : initData.state) || {
      type: "primary",
      fill: false
    };
    const stateController = useState(state);
    const injector = useContext();
    const i18n = injector.get(I18n);
    const sub = stateController.onChange.subscribe((newState) => {
      state = newState;
    });
    onDestroy(() => {
      sub.unsubscribe();
    });
    if (slots.length === 0) {
      slots.push(new Slot([
        ContentType.InlineComponent,
        ContentType.Text
      ]));
    }
    const childI18n = i18n.getContext("components.alertComponent.contextMenu");
    onContextMenu((ev) => {
      ev.useMenus([{
        label: state.fill ? childI18n.get("noFill") : childI18n.get("fill"),
        onClick() {
          stateController.update((draft) => {
            draft.fill = !state.fill;
          });
        }
      }, {
        label: childI18n.get("type"),
        submenu: "default,primary,info,success,warning,danger,dark,gray".split(",").map((i2) => {
          return {
            label: i2,
            onClick() {
              stateController.update((draft) => {
                draft.type = i2;
              });
            }
          };
        })
      }]);
    });
    return {
      render(slotRender) {
        const classes = ["tb-alert"];
        if (state.fill) {
          classes.push("tb-alert-fill");
        }
        if (state.type) {
          classes.push("tb-alert-" + state.type);
        }
        return VElement.createElement("tb-alert", { "data-type": state.type, class: classes.join(" ") }, slotRender(slots.get(0), (children) => {
          return VElement.createElement("div", null, children);
        }));
      }
    };
  }
});
var alertComponentLoader = {
  match(element) {
    return element.tagName.toLowerCase() === "tb-alert";
  },
  read(element, context, slotParser) {
    return alertComponent.createInstance(context, {
      state: {
        fill: element.classList.contains("tb-alert-fill"),
        type: element.dataset.type || ""
      },
      slots: [
        slotParser(new Slot([
          ContentType.InlineComponent,
          ContentType.Text
        ]), element.children[0] || document.createElement("div"))
      ]
    });
  }
};
var audioComponent = defineComponent({
  name: "AudioComponent",
  type: ContentType.InlineComponent,
  setup(data) {
    let state = (data === null || data === void 0 ? void 0 : data.state) || {
      src: "",
      autoplay: false,
      controls: true
    };
    const controller = useState(state);
    controller.onChange.subscribe((s2) => {
      state = s2;
    });
    return {
      render() {
        return VElement.createElement("audio", { src: state.src, autoplay: state.autoplay, controls: state.controls });
      },
      toJSON() {
        return Object.assign({}, state);
      },
      mergeProps(props) {
        state = controller.update((draft) => {
          Object.assign(draft, props);
        });
      }
    };
  }
});
var audioComponentLoader = {
  match(element) {
    return element.nodeName.toLowerCase() === "audio";
  },
  read(element, context) {
    return audioComponent.createInstance(context, {
      state: {
        src: element.src,
        autoplay: element.autoplay,
        controls: element.controls
      }
    });
  }
};
var blockComponent = defineComponent({
  type: ContentType.BlockComponent,
  name: "BlockComponent",
  setup(data) {
    const injector = useContext();
    const slots = useSlots((data === null || data === void 0 ? void 0 : data.slots) || [new Slot([
      ContentType.Text,
      ContentType.InlineComponent,
      ContentType.BlockComponent
    ])]);
    if (!slots.length) {
      slots.push(new Slot([
        ContentType.Text,
        ContentType.InlineComponent,
        ContentType.BlockComponent
      ]));
    }
    useEnterBreaking(injector, slots);
    return {
      render(slotRender) {
        return slotRender(slots.get(0), (children) => {
          return VElement.createElement("div", null, children);
        });
      }
    };
  }
});
var blockComponentLoader = {
  match(element) {
    return element.tagName === "DIV";
  },
  read(element, injector, slotParser) {
    const slot = slotParser(new Slot([
      ContentType.Text,
      ContentType.BlockComponent,
      ContentType.InlineComponent
    ]), element);
    const content = slot.sliceContent();
    const isAllContent = content.some((i2) => {
      return typeof i2 === "string" || i2.type === ContentType.InlineComponent;
    });
    if (isAllContent) {
      return blockComponent.createInstance(injector, {
        slots: [slot]
      });
    }
    return slot;
  }
};
var blockquoteComponent = defineComponent({
  type: ContentType.BlockComponent,
  name: "BlockquoteComponent",
  zenCoding: {
    key: " ",
    match: /^>$/,
    generateInitData() {
      return {
        slots: [new Slot([
          ContentType.Text,
          ContentType.InlineComponent,
          ContentType.BlockComponent
        ])]
      };
    }
  },
  setup(data) {
    const slots = useSlots((data === null || data === void 0 ? void 0 : data.slots) || [new Slot([
      ContentType.Text,
      ContentType.InlineComponent,
      ContentType.BlockComponent
    ])]);
    if (!slots.length) {
      slots.push(new Slot([
        ContentType.Text,
        ContentType.InlineComponent,
        ContentType.BlockComponent
      ]));
    }
    return {
      render(slotRender) {
        return slotRender(slots.get(0), (children) => {
          return VElement.createElement("blockquote", { class: "tb-blockquote" }, children);
        });
      }
    };
  }
});
var blockquoteComponentLoader = {
  match(element) {
    return element.tagName === "BLOCKQUOTE" || element.tagName === "DIV" && element.className === "tb-blockquote";
  },
  read(element, injector, slotParser) {
    const slot = slotParser(new Slot([
      ContentType.Text,
      ContentType.BlockComponent,
      ContentType.InlineComponent
    ]), element);
    return blockquoteComponent.createInstance(injector, {
      slots: [slot]
    });
  }
};
var headingComponent = defineComponent({
  type: ContentType.BlockComponent,
  name: "HeadingComponent",
  zenCoding: {
    key: " ",
    match(content) {
      return /^#{1,6}$/.test(content);
    },
    generateInitData(content) {
      return {
        state: "h" + content.length
      };
    }
  },
  setup(data) {
    const injector = useContext();
    const slots = useSlots((data === null || data === void 0 ? void 0 : data.slots) || [new Slot([
      ContentType.Text,
      ContentType.InlineComponent
    ])]);
    if (!slots.length) {
      slots.push(new Slot([
        ContentType.Text,
        ContentType.InlineComponent
      ]));
    }
    useEnterBreaking(injector, slots);
    return {
      type: (data === null || data === void 0 ? void 0 : data.state) || "h1",
      render(slotRender) {
        return slotRender(slots.get(0), (children) => {
          const Tag = (data === null || data === void 0 ? void 0 : data.state) || "h1";
          return VElement.createElement(Tag, null, children);
        });
      }
    };
  }
});
var headingComponentLoader = {
  match(element) {
    return /^h[1-6]$/i.test(element.tagName);
  },
  read(element, injector, slotParser) {
    const slot = slotParser(new Slot([
      ContentType.Text,
      ContentType.InlineComponent
    ]), element);
    return headingComponent.createInstance(injector, {
      slots: [slot],
      state: element.tagName.toLowerCase()
    });
  }
};
var Form = class {
  constructor(config) {
    this.config = config;
    this.completeEvent = new Subject();
    this.cancelEvent = new Subject();
    this.onComplete = this.completeEvent.asObservable();
    this.onCancel = this.cancelEvent.asObservable();
    this.elementRef = createElement("form", {
      classes: [config.mini ? "textbus-form-mini" : "textbus-form"],
      attrs: {
        novalidate: true,
        autocomplete: "off"
      }
    });
    if (config.title) {
      this.elementRef.appendChild(createElement("h3", {
        classes: ["textbus-form-title"],
        children: [createTextNode(config.title)]
      }));
    }
    this.elementRef.appendChild(this.body = createElement("div", {
      attrs: {
        novalidate: "novalidate"
      },
      classes: config.mini ? [] : ["textbus-form-body"],
      children: config.items.map((item) => {
        return item.elementRef;
      })
    }));
    const btns = config.mini ? [
      createElement("button", {
        attrs: {
          type: "submit"
        },
        classes: ["textbus-btn", "textbus-btn-block", "textbus-btn-primary"],
        children: [createTextNode(this.config.confirmBtnText || "\u786E\u5B9A")]
      })
    ] : [
      createElement("button", {
        attrs: {
          type: "submit"
        },
        classes: ["textbus-btn", "textbus-btn-primary"],
        children: [createTextNode(this.config.confirmBtnText || "\u786E\u5B9A")]
      }),
      (() => {
        const cancelBtn = createElement("button", {
          classes: ["textbus-btn", "textbus-btn-default"],
          attrs: {
            type: "button"
          },
          children: [createTextNode(this.config.cancelBtnText || "\u53D6\u6D88")]
        });
        cancelBtn.addEventListener("click", () => {
          this.cancelEvent.next();
        });
        return cancelBtn;
      })()
    ];
    this.elementRef.appendChild(this.footer = createElement("div", {
      classes: ["textbus-form-footer"],
      children: btns
    }));
    this.elementRef.addEventListener("submit", (ev) => {
      ev.preventDefault();
      const values = {};
      for (const item of config.items) {
        if (!item.validate()) {
          return;
        }
        const i2 = item.getAttr();
        if (i2) {
          values[i2.name] = i2.value;
        }
      }
      this.completeEvent.next(values);
    });
  }
  addItem(item, index) {
    if (typeof index === "number") {
      const next = this.config.items[index];
      if (next) {
        this.config.items.splice(index, 0, item);
        this.elementRef.insertBefore(item.elementRef, next.elementRef);
        return;
      }
    }
    this.config.items.push(item);
    this.body.appendChild(item.elementRef);
  }
  removeItem(item) {
    var _a2;
    const index = this.config.items.indexOf(item);
    if (index > -1) {
      this.config.items.splice(index, 1);
      (_a2 = item.elementRef.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(item.elementRef);
    }
  }
  reset() {
    this.config.items.forEach((item) => {
      item.reset();
    });
  }
  update(value) {
    Object.keys(value).forEach((key) => {
      this.config.items.forEach((item) => {
        if (item.name === key) {
          item.update(value[key]);
        }
      });
    });
  }
};
var FormButton = class {
  constructor(config) {
    this.config = config;
    this.elementRef = createElement("div", {
      classes: ["textbus-form-group"],
      children: [
        createElement("div", {
          classes: ["textbus-control-label"],
          children: [createTextNode(this.config.label)]
        }),
        createElement("div", {
          classes: ["textbus-control-value"],
          children: [
            createElement("button", {
              classes: ["textbus-btn", "textbus-btn-dark"],
              attrs: {
                type: "button"
              },
              on: {
                click: () => {
                  this.config.onClick();
                }
              },
              children: [
                createElement("span", {
                  classes: this.config.iconClasses
                }),
                createTextNode(" " + this.config.btnText)
              ]
            })
          ]
        })
      ]
    });
    this.name = this.config.name;
  }
  reset() {
  }
  update() {
  }
  getAttr() {
    return {
      name: this.name,
      value: this.config.value
    };
  }
  validate() {
    return true;
  }
};
var FormHidden = class {
  constructor(config) {
    this.config = config;
    this.elementRef = document.createElement("input");
    this.name = config.name;
    this.value = config.value;
    this.elementRef.type = "hidden";
    this.elementRef.value = config.value + "";
  }
  reset() {
  }
  update() {
  }
  getAttr() {
    return {
      name: this.name,
      value: this.value
    };
  }
  validate() {
    return true;
  }
};
var FormNumber = class {
  constructor(config) {
    this.config = config;
    this.elementRef = document.createElement("div");
    this.name = config.name;
    this.elementRef.classList.add("textbus-form-group");
    this.elementRef.innerHTML = `
    <div class="textbus-control-label">${config.label}</div>
    <div class="textbus-control-value">
      <div class="textbus-input-group textbus-input-block">
        <input name="${config.name}" class="textbus-form-control textbus-input-block" placeholder="${config.placeholder || ""}" type="number" value="${config.value || ""}">
     </div>
     <div class="textbus-control-feedback-invalid"></div>
   </div>`;
    this.input = this.elementRef.querySelector("input");
    this.feedbackEle = this.elementRef.querySelector(".textbus-control-feedback-invalid");
  }
  reset() {
    this.input.value = this.config.value || null;
  }
  update(value) {
    this.input.value = (value !== null && value !== void 0 ? value : this.config.value) || "";
  }
  getAttr() {
    return {
      name: this.config.name,
      value: Number(this.input.value)
    };
  }
  validate() {
    var _a2, _b2;
    const feedback = (_b2 = (_a2 = this.config).validateFn) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, this.getAttr().value);
    this.feedbackEle.innerText = feedback || "";
    return !feedback;
  }
};
var FormRadio = class {
  constructor(config) {
    this.config = config;
    this.elementRef = document.createElement("div");
    this.name = config.name;
    this.elementRef.classList.add("textbus-form-group");
    this.elementRef.innerHTML = `
    <div class="textbus-control-label">${config.label}</div>
    <div class="textbus-control-static">
    <div>${config.values.map((c2) => {
      return `<label>
                  <input type="radio" ${c2.default ? 'checked="checked"' : ""} name="${config.name}" value="${c2.value}">
                  ${c2.label}
                 </label>`;
    }).join("")}</div>
    <div class="textbus-control-feedback-invalid"></div>
    </div>
    `;
    this.inputs = Array.from(this.elementRef.querySelectorAll("input"));
    this.feedbackEle = this.elementRef.querySelector(".textbus-control-feedback-invalid");
  }
  reset() {
    const values = this.config.values;
    for (let i2 = 0; i2 < values.length; i2++) {
      this.inputs[i2].checked = !!values[i2].default;
    }
  }
  update(value) {
    const values = this.config.values;
    let isMatch = false;
    for (let i2 = 0; i2 < values.length; i2++) {
      if (values[i2].value === value) {
        this.inputs[i2].checked = true;
        isMatch = true;
        break;
      } else {
        this.inputs[i2].checked = true;
      }
    }
    if (!isMatch) {
      this.config.values.forEach((item, i2) => {
        if (item.default) {
          this.inputs[i2].checked = true;
        }
      });
    }
  }
  getAttr() {
    const inputs = this.inputs;
    let value;
    for (let i2 = 0; i2 < inputs.length; i2++) {
      if (inputs[i2].checked) {
        value = this.config.values[i2].value;
        break;
      }
    }
    return {
      name: this.config.name,
      value
    };
  }
  validate() {
    var _a2, _b2;
    const feedback = (_b2 = (_a2 = this.config).validateFn) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, this.getAttr().value);
    this.feedbackEle.innerText = feedback || "";
    return !feedback;
  }
};
var FormSelect = class {
  constructor(config) {
    this.config = config;
    this.elementRef = document.createElement("div");
    this.name = config.name;
    this.elementRef.classList.add("textbus-form-group");
    this.elementRef.innerHTML = `
    <div class="textbus-control-label">${config.label}</div>
    <div class="textbus-control-value">
       <select class="textbus-form-control" name="${config.name}">${config.options.map((option) => {
      return `<option ${option.selected ? "selected" : ""} value="${option.value}">${option.label}</option>`;
    }).join("")}</select>
    </div>
    <div class="textbus-control-feedback-invalid"></div>`;
    this.select = this.elementRef.querySelector("select");
    this.feedbackEle = this.elementRef.querySelector(".textbus-control-feedback-invalid");
  }
  reset() {
    let value = void 0;
    this.config.options.forEach((option) => {
      if (option.selected) {
        value = option.value;
      }
    });
    this.update(value);
  }
  update(value) {
    this.config.options.forEach((option, index) => {
      this.select.options.item(index).selected = option.value === value;
    });
  }
  getAttr() {
    return {
      name: this.config.name,
      value: this.select.value
    };
  }
  validate() {
    var _a2, _b2;
    const feedback = (_b2 = (_a2 = this.config).validateFn) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, this.getAttr().value);
    this.feedbackEle.innerText = feedback || "";
    return !feedback;
  }
};
var FormStatic = class {
  constructor(config) {
    this.config = config;
    this.elementRef = createElement("div", {
      classes: ["textbus-form-group"],
      children: [
        config.label ? createElement("div", {
          classes: ["textbus-control-label"],
          children: [createTextNode(config.label)]
        }) : null,
        createElement("div", {
          classes: ["textbus-control-value"],
          children: [
            typeof config.content === "string" ? createTextNode(config.content) : config.content
          ]
        })
      ]
    });
  }
  reset() {
  }
  update() {
  }
  getAttr() {
    return null;
  }
  validate() {
    return true;
  }
};
var FormSwitch = class {
  constructor(config) {
    this.config = config;
    this.elementRef = document.createElement("div");
    this.name = config.name;
    this.elementRef.classList.add("textbus-form-group");
    this.elementRef.innerHTML = `
    <div class="textbus-control-label"></div>
    <div class="textbus-control-static">
      <label><input name="${config.name}" type="checkbox" ${config.checked ? 'checked="checked"' : ""}> ${config.label}</label>
      <div class="textbus-control-feedback-invalid"></div>
    </div>
    `;
    this.input = this.elementRef.querySelector("input");
    this.feedbackEle = this.elementRef.querySelector(".textbus-control-feedback-invalid");
  }
  reset() {
    this.input.checked = this.config.checked;
  }
  update(value) {
    this.input.checked = typeof value === "boolean" ? value : this.config.checked;
  }
  getAttr() {
    return {
      name: this.name,
      value: this.input.checked
    };
  }
  validate() {
    var _a2, _b2;
    const feedback = (_b2 = (_a2 = this.config).validateFn) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, this.getAttr().value);
    this.feedbackEle.innerText = feedback || "";
    return !feedback;
  }
};
var FormTextField = class {
  constructor(config) {
    this.config = config;
    this.elementRef = document.createElement("div");
    this.name = config.name;
    this.elementRef.classList.add("textbus-form-group");
    this.elementRef.innerHTML = `
    <div class="textbus-control-label">${config.label}</div>
    <div class="textbus-control-value">
      <div class="textbus-input-group textbus-input-block">
        <input name="${config.name}" class="textbus-form-control textbus-input-block" placeholder="${config.placeholder || ""}" type="text" value="${config.value || ""}">${config.canUpload ? `<button type="button" class="textbus-btn textbus-btn-dark" title="${config.uploadBtnText || ""}">
        <span class="textbus-icon-upload"></span>
       </button>` : ""}
     </div>
     <div class="textbus-control-feedback-invalid"></div>
   </div>`;
    this.input = this.elementRef.querySelector("input");
    this.feedbackEle = this.elementRef.querySelector(".textbus-control-feedback-invalid");
    if (config.canUpload) {
      this.btn = this.elementRef.querySelector("button");
      this.btn.addEventListener("click", () => {
        var _a2;
        this.btn.classList.add("textbus-btn-loading");
        this.input.disabled = true;
        this.btn.children[0].className = "textbus-icon-loading";
        if (this.sub) {
          this.sub.unsubscribe();
        }
        this.sub = (_a2 = this.config.fileUploader) === null || _a2 === void 0 ? void 0 : _a2.upload({
          uploadType: this.config.uploadType,
          currentValue: this.input.value,
          multiple: false
        }).subscribe({
          next: (url) => {
            this.update(url);
          },
          error: () => {
            this.uploaded();
          },
          complete: () => {
            this.uploaded();
          }
        });
      });
    }
  }
  reset() {
    this.input.value = this.config.value || "";
  }
  update(value) {
    this.uploaded();
    this.input.value = (value !== null && value !== void 0 ? value : this.config.value) || "";
  }
  getAttr() {
    return {
      name: this.config.name,
      value: this.input.value
    };
  }
  validate() {
    var _a2, _b2;
    const feedback = (_b2 = (_a2 = this.config).validateFn) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, this.getAttr().value);
    this.feedbackEle.innerText = feedback || "";
    return !feedback;
  }
  uploaded() {
    if (this.sub) {
      this.sub.unsubscribe();
    }
    this.input.disabled = false;
    if (this.btn) {
      this.btn.classList.remove("textbus-btn-loading");
      this.btn.children[0].className = "textbus-icon-upload";
    }
  }
};
var FormTextarea = class {
  constructor(config) {
    this.config = config;
    this.elementRef = document.createElement("div");
    this.name = config.name;
    this.elementRef.classList.add("textbus-form-group");
    this.elementRef.innerHTML = `
    <div class="textbus-control-label">${config.label}</div>
    <div class="textbus-control-value">
      <div class="textbus-input-group textbus-input-block">
        <textarea name="${config.name}" style="width: ${config.width || "auto"}; height: ${config.height || "auto"}" class="textbus-form-control textbus-input-block" placeholder="${config.placeholder || ""}">${config.value || ""}</textarea>
     </div>
     <div class="textbus-control-feedback-invalid"></div>
   </div>`;
    this.input = this.elementRef.querySelector("textarea");
    this.feedbackEle = this.elementRef.querySelector(".textbus-control-feedback-invalid");
  }
  reset() {
    this.input.value = this.config.value;
  }
  update(value) {
    this.uploaded();
    this.input.value = (value !== null && value !== void 0 ? value : this.config.value) || "";
  }
  getAttr() {
    return {
      name: this.config.name,
      value: this.input.value
    };
  }
  validate() {
    var _a2, _b2;
    const feedback = (_b2 = (_a2 = this.config).validateFn) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, this.getAttr().value);
    this.feedbackEle.innerText = feedback || "";
    return !feedback;
  }
  uploaded() {
    if (this.sub) {
      this.sub.unsubscribe();
    }
    this.input.disabled = false;
    if (this.btn) {
      this.btn.classList.remove("textbus-btn-loading");
      this.btn.children[0].className = "textbus-icon-upload";
    }
  }
};
var FileUploader = class {
};
var Dialog = class Dialog2 {
  constructor(controller) {
    this.controller = controller;
    this.timer = null;
    this.subs = [];
    this.elementRef = createElement("div", {
      classes: ["textbus-dialog"],
      children: [
        this.dialogWrapper = createElement("div", {
          classes: ["textbus-dialog-wrapper"]
        })
      ]
    });
    document.body.appendChild(this.elementRef);
    this.subs.push(this.controller.onReadonlyStateChange.subscribe(() => {
      if (this.controller.readonly) {
        this.hide();
      }
    }));
  }
  show(element) {
    this.dialogWrapper.innerHTML = "";
    this.dialogWrapper.appendChild(element);
    this.elementRef.classList.add("textbus-dialog-active");
    this.timer = setTimeout(() => {
      this.dialogWrapper.classList.add("textbus-dialog-wrapper-active");
    }, 200);
  }
  hide() {
    this.dialogWrapper.classList.remove("textbus-dialog-wrapper-active");
    this.timer = setTimeout(() => {
      this.elementRef.classList.remove("textbus-dialog-active");
      this.dialogWrapper.innerHTML = "";
    }, 200);
  }
  destroy() {
    var _a2;
    clearTimeout(this.timer);
    this.subs.forEach((i2) => i2.unsubscribe());
    (_a2 = this.elementRef.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.elementRef);
  }
};
Dialog = __decorate3([
  Injectable(),
  __metadata3("design:paramtypes", [Controller])
], Dialog);
var MarginSetter = class {
  constructor(label) {
    this.name = "margin";
    this.inputs = [];
    this.elementRef = createElement("div", {
      classes: ["textbus-form-group"],
      children: [
        createElement("label", {
          classes: ["textbus-control-label"],
          children: [
            createTextNode(label)
          ]
        }),
        createElement("div", {
          classes: ["textbus-control-static"],
          children: [
            createElement("div", {
              classes: ["textbus-toolbar-image-margin-setter"],
              children: Array.from({ length: 4 }).fill(null).map(() => createElement("input", {
                attrs: {
                  type: "text",
                  value: "0"
                },
                classes: ["textbus-form-control"]
              }))
            })
          ]
        })
      ]
    });
    this.inputs = Array.from(this.elementRef.querySelectorAll("input"));
  }
  reset() {
    this.inputs.forEach((input) => input.value = "");
  }
  update(value) {
    this.reset();
    if (value) {
      const vars = (value + "").split(/\s+/g);
      vars.forEach((v2, index) => {
        this.inputs[index].value = v2;
      });
    }
  }
  getAttr() {
    return {
      name: this.name,
      value: this.inputs.map((input) => {
        if (Number(input.value)) {
          return input.value + "px";
        }
        return input.value || "0";
      }).join(" ")
    };
  }
  validate() {
    return true;
  }
};
var SizeSetter = class {
  constructor(name, i18n) {
    this.name = name;
    this.i18n = i18n;
    this.inputs = [];
    this.elementRef = createElement("div", {
      classes: ["textbus-form-group"],
      children: [
        createElement("label", {
          classes: ["textbus-control-label"],
          children: [
            createTextNode(i18n.get("label"))
          ]
        }),
        createElement("div", {
          classes: ["textbus-control-value"],
          children: [
            createElement("div", {
              classes: ["textbus-toolbar-image-size-setter"],
              children: [
                createElement("input", {
                  attrs: { type: "text", placeholder: i18n.get("widthPlaceholder") },
                  classes: ["textbus-form-control"]
                }),
                createTextNode(" * "),
                createElement("input", {
                  attrs: { type: "text", placeholder: i18n.get("heightPlaceholder") },
                  classes: ["textbus-form-control"]
                })
              ]
            })
          ]
        })
      ]
    });
    this.inputs = Array.from(this.elementRef.querySelectorAll("input"));
  }
  reset() {
    this.inputs.forEach((input) => input.value = "");
  }
  update(value) {
    this.inputs[0].value = (value === null || value === void 0 ? void 0 : value.width) || "";
    this.inputs[1].value = (value === null || value === void 0 ? void 0 : value.height) || "";
  }
  getAttr() {
    return {
      name: this.name,
      value: {
        width: this.inputs[0].value,
        height: this.inputs[1].value
      }
    };
  }
  validate() {
    return true;
  }
};
var imageComponent = defineComponent({
  type: ContentType.InlineComponent,
  name: "ImgComponent",
  setup(data) {
    let state = (data === null || data === void 0 ? void 0 : data.state) || {
      src: ""
    };
    const stateController = useState(state);
    stateController.onChange.subscribe((v2) => {
      state = v2;
    });
    const ref = useRef();
    useDragResize(ref, (rect) => {
      stateController.update((draft) => {
        Object.assign(draft, rect);
      });
    });
    const injector = useContext();
    const fileUploader = injector.get(FileUploader);
    const i18n = injector.get(I18n);
    const dialog = injector.get(Dialog);
    const childI18n = i18n.getContext("components.imageComponent.contextMenu");
    onContextMenu((event) => {
      event.useMenus([{
        label: childI18n.get("title"),
        iconClasses: ["textbus-icon-image"],
        onClick() {
          const form = new Form({
            title: childI18n.get("title"),
            cancelBtnText: childI18n.get("cancelBtnText"),
            confirmBtnText: childI18n.get("confirmBtnText"),
            items: [
              new FormTextField({
                label: childI18n.get("linkLabel"),
                name: "src",
                placeholder: childI18n.get("linkInputPlaceholder"),
                canUpload: true,
                uploadType: "image",
                uploadBtnText: childI18n.get("uploadBtnText"),
                fileUploader,
                validateFn(value) {
                  if (!value) {
                    return childI18n.get("validateErrorMessage");
                  }
                  return false;
                }
              }),
              new SizeSetter("size", childI18n.getContext("sizeSetter")),
              new SizeSetter("maxSize", childI18n.getContext("maxSizeSetter")),
              new FormRadio({
                label: childI18n.get("float.label"),
                name: "float",
                values: [{
                  label: childI18n.get("float.noFloatLabel"),
                  value: "none",
                  default: true
                }, {
                  label: childI18n.get("float.floatToLeftLabel"),
                  value: "left"
                }, {
                  label: childI18n.get("float.floatToRightLabel"),
                  value: "right"
                }]
              }),
              new MarginSetter(childI18n.get("marginLabel"))
            ]
          });
          form.update({
            src: state.src,
            margin: state.margin,
            float: state.float,
            size: {
              width: state.width,
              height: state.height
            },
            maxSize: {
              width: state.maxWidth,
              height: state.maxHeight
            }
          });
          dialog.show(form.elementRef);
          const sub = new Subscription();
          sub.add(form.onComplete.subscribe((value) => {
            const config = {
              src: value.src,
              margin: value.margin,
              float: value.float,
              maxWidth: value.maxSize.width,
              maxHeight: value.maxSize.height,
              width: value.size.width,
              height: value.size.height
            };
            stateController.update((draft) => {
              Object.assign(draft, config);
            });
            dialog.hide();
            sub.unsubscribe();
          }));
          sub.add(form.onCancel.subscribe(() => {
            dialog.hide();
            sub.unsubscribe();
          }));
        }
      }]);
    });
    return {
      render() {
        return VElement.createElement("img", { src: state.src, ref, class: "tb-img", style: {
          width: state.width,
          height: state.height,
          maxWidth: state.maxWidth,
          maxHeight: state.maxHeight,
          margin: state.margin,
          float: state.float
        } });
      }
    };
  }
});
var imageComponentLoader = {
  match(element) {
    return element.tagName === "IMG";
  },
  read(element, injector) {
    const style = element.style;
    return imageComponent.createInstance(injector, {
      state: {
        src: element.getAttribute("src") || "",
        width: style.width,
        height: style.height,
        margin: style.margin,
        float: style.float,
        maxWidth: style.maxWidth,
        maxHeight: style.maxHeight
      }
    });
  }
};
var svg = '<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><g><rect fill="#555" height="100%" width="100%"/></g><g><text font-family="Helvetica, Arial, sans-serif" font-size="24" y="50%" x="50%" text-anchor="middle" dominant-baseline="middle" stroke-width="0" stroke="#000" fill="#000000">Image</text></g></svg>';
var defaultImageSrc = "data:image/svg+xml;charset=UTF-8," + encodeURIComponent(svg);
var imageCardComponent = defineComponent({
  type: ContentType.BlockComponent,
  separable: false,
  name: "ImageCardComponent",
  setup(initData) {
    let state = (initData === null || initData === void 0 ? void 0 : initData.state) || {
      src: defaultImageSrc,
      height: "200px"
    };
    const stateController = useState(state);
    const injector = useContext();
    const dialog = injector.get(Dialog);
    const commander = injector.get(Commander);
    const selection = injector.get(Selection);
    const i18n = injector.get(I18n);
    const fileUploader = injector.get(FileUploader);
    const slots = useSlots((initData === null || initData === void 0 ? void 0 : initData.slots) || []);
    if (slots.length === 0) {
      const slot = new Slot([
        ContentType.Text
      ]);
      slot.insert("\u56FE\u7247\u540D\u79F0");
      slots.push(slot);
    }
    const sub = stateController.onChange.subscribe((newState) => {
      state = newState;
    });
    onDestroy(() => {
      sub.unsubscribe();
    });
    const self2 = useSelf();
    onBreak((ev) => {
      const slot = ev.target.cutTo(new Slot([
        ContentType.InlineComponent,
        ContentType.Text
      ]), ev.data.index);
      const component = paragraphComponent.createInstance(injector, {
        slots: [slot]
      });
      commander.insertAfter(component, self2);
      ev.preventDefault();
      selection.selectFirstPosition(component);
    });
    const childI18n = i18n.getContext("components.imageCardComponent.setting");
    function showForm() {
      const form = new Form({
        title: childI18n.get("title"),
        confirmBtnText: childI18n.get("confirmBtnText"),
        cancelBtnText: childI18n.get("cancelBtnText"),
        items: [
          new FormTextField({
            label: childI18n.get("srcLabel"),
            uploadType: "image",
            canUpload: true,
            value: state.src,
            name: "src",
            placeholder: childI18n.get("srcPlaceholder"),
            fileUploader
          }),
          new FormTextField({
            label: childI18n.get("heightLabel"),
            name: "height",
            value: state.height,
            placeholder: childI18n.get("heightPlaceholder")
          })
        ]
      });
      dialog.show(form.elementRef);
      form.onComplete.subscribe((values) => {
        stateController.update((draft) => {
          Object.assign(draft, values);
        });
        dialog.hide();
      });
      form.onCancel.subscribe(() => {
        dialog.hide();
      });
    }
    return {
      render(slotRender) {
        return VElement.createElement(
          "tb-image-card",
          { "data-src": state.src, "data-height": state.height },
          VElement.createElement(
            "div",
            { onClick: showForm },
            VElement.createElement("img", { src: state.src, style: {
              height: state.height
            } })
          ),
          slotRender(slots.get(0), (children) => {
            return VElement.createElement("p", null, children);
          })
        );
      }
    };
  }
});
var imageCardComponentLoader = {
  match(element) {
    return element.nodeName.toLowerCase() === "tb-image-card";
  },
  read(element, context, slotParser) {
    const p2 = element.querySelector("p");
    const slot = new Slot([ContentType.Text]);
    return imageCardComponent.createInstance(context, {
      state: {
        height: element.dataset.height,
        src: element.dataset.src
      },
      slots: [
        p2 ? slotParser(slot, p2) : slot
      ]
    });
  }
};
function createJumbotronSlot(injector) {
  const slot = new Slot([
    ContentType.Text,
    ContentType.InlineComponent,
    ContentType.BlockComponent
  ]);
  const h1 = headingComponent.createInstance(injector);
  h1.slots.first.insert("Hello, world!");
  const p1 = paragraphComponent.createInstance(injector);
  p1.slots.first.insert("\u4F60\u597D\uFF0C\u6211\u662F Textbus\uFF0C\u4E00\u4E2A\u7ED9\u4F60\u5E26\u6765\u5168\u65B0\u4F53\u9A8C\u7684\u5BCC\u6587\u672C\u5F00\u53D1\u6846\u67B6\u3002");
  const p2 = paragraphComponent.createInstance(injector);
  p2.slots.first.insert("\u73B0\u5728\u6211\u4EEC\u5F00\u59CB\u5427\uFF01");
  slot.insert(h1);
  slot.insert(p1);
  slot.insert(p2);
  return slot;
}
var jumbotronComponent = defineComponent({
  type: ContentType.BlockComponent,
  name: "JumbotronComponent",
  setup(initData) {
    const slots = useSlots((initData === null || initData === void 0 ? void 0 : initData.slots) || []);
    const injector = useContext();
    const dialog = injector.get(Dialog);
    const i18n = injector.get(I18n);
    const fileUploader = injector.get(FileUploader);
    if (slots.length === 0) {
      slots.push(createJumbotronSlot(injector));
    }
    let state = (initData === null || initData === void 0 ? void 0 : initData.state) || {
      minHeight: "200px",
      backgroundImage: "",
      backgroundPosition: "center",
      backgroundSize: "cover"
    };
    const stateController = useState(state);
    const sub = stateController.onChange.subscribe((newState) => {
      state = newState;
    });
    onDestroy(() => {
      sub.unsubscribe();
    });
    const componentI18n = i18n.getContext("components.jumbotronComponent");
    const childI18n = componentI18n.getContext("setting.form");
    function setting() {
      const form = new Form({
        title: childI18n.get("title"),
        confirmBtnText: childI18n.get("confirmBtnText"),
        cancelBtnText: childI18n.get("cancelBtnText"),
        items: [
          new FormTextField({
            name: "minHeight",
            value: "200px",
            placeholder: childI18n.get("minHeightInputPlaceholder"),
            label: childI18n.get("minHeightLabel")
          }),
          new FormTextField({
            label: childI18n.get("backgroundImageLabel"),
            name: "backgroundImage",
            value: state.backgroundImage,
            placeholder: childI18n.get("backgroundImageInputPlaceholder"),
            canUpload: true,
            uploadType: "image",
            fileUploader,
            uploadBtnText: childI18n.get("uploadBtnText"),
            validateFn(value) {
              if (!value) {
                return childI18n.get("validateErrorMessage");
              }
              return false;
            }
          })
        ]
      });
      dialog.show(form.elementRef);
      const sub1 = form.onComplete.subscribe((data) => {
        stateController.update((draft) => {
          Object.assign(draft, data);
        });
        dialog.hide();
        sub1.unsubscribe();
        sub2.unsubscribe();
      });
      const sub2 = form.onCancel.subscribe(() => {
        dialog.hide();
        sub1.unsubscribe();
        sub2.unsubscribe();
      });
    }
    return {
      render(slotRender, renderMode) {
        return VElement.createElement(
          "tb-jumbotron",
          { style: {
            backgroundImage: state.backgroundImage ? `url("${state.backgroundImage}")` : null,
            backgroundSize: state.backgroundSize || "cover",
            backgroundPosition: state.backgroundPosition || "center",
            minHeight: state.minHeight
          } },
          renderMode === RenderMode.Editing && VElement.createElement(
            "button",
            { type: "button", class: "tb-jumbotron-setting", onClick: setting },
            VElement.createElement("span", { class: "textbus-icon-setting" })
          ),
          slotRender(slots.get(0), (children) => {
            return VElement.createElement("div", null, children);
          })
        );
      }
    };
  }
});
var jumbotronComponentLoader = {
  match(element) {
    return element.nodeName.toLowerCase() === "tb-jumbotron";
  },
  read(element, context, slotParser) {
    const style = element.style;
    return jumbotronComponent.createInstance(context, {
      state: {
        backgroundImage: (style.backgroundImage || "").replace(/^url\(['"]?|['"]?\)$/g, ""),
        backgroundSize: style.backgroundSize,
        backgroundPosition: style.backgroundPosition,
        minHeight: style.minHeight
      },
      slots: [
        slotParser(new Slot([
          ContentType.BlockComponent,
          ContentType.InlineComponent,
          ContentType.Text
        ]), element.children[0] || document.createElement("div"))
      ]
    });
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var katex = { exports: {} };
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory();
  })(typeof self !== "undefined" ? self : commonjsGlobal, function() {
    return function() {
      var __webpack_require__ = {};
      !function() {
        __webpack_require__.d = function(exports2, definition) {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      }();
      !function() {
        __webpack_require__.o = function(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        };
      }();
      var __webpack_exports__ = {};
      __webpack_require__.d(__webpack_exports__, {
        "default": function() {
          return katex_webpack;
        }
      });
      var ParseError = function ParseError2(message, token) {
        this.position = void 0;
        var error = "KaTeX parse error: " + message;
        var start;
        var loc = token && token.loc;
        if (loc && loc.start <= loc.end) {
          var input = loc.lexer.input;
          start = loc.start;
          var end = loc.end;
          if (start === input.length) {
            error += " at end of input: ";
          } else {
            error += " at position " + (start + 1) + ": ";
          }
          var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");
          var left;
          if (start > 15) {
            left = "\u2026" + input.slice(start - 15, start);
          } else {
            left = input.slice(0, start);
          }
          var right;
          if (end + 15 < input.length) {
            right = input.slice(end, end + 15) + "\u2026";
          } else {
            right = input.slice(end);
          }
          error += left + underlined + right;
        }
        var self2 = new Error(error);
        self2.name = "ParseError";
        self2.__proto__ = ParseError2.prototype;
        self2.position = start;
        return self2;
      };
      ParseError.prototype.__proto__ = Error.prototype;
      var src_ParseError = ParseError;
      var contains = function contains2(list, elem) {
        return list.indexOf(elem) !== -1;
      };
      var deflt = function deflt2(setting, defaultIfUndefined) {
        return setting === void 0 ? defaultIfUndefined : setting;
      };
      var uppercase = /([A-Z])/g;
      var hyphenate = function hyphenate2(str) {
        return str.replace(uppercase, "-$1").toLowerCase();
      };
      var ESCAPE_LOOKUP = {
        "&": "&amp;",
        ">": "&gt;",
        "<": "&lt;",
        '"': "&quot;",
        "'": "&#x27;"
      };
      var ESCAPE_REGEX = /[&><"']/g;
      function utils_escape(text2) {
        return String(text2).replace(ESCAPE_REGEX, function(match) {
          return ESCAPE_LOOKUP[match];
        });
      }
      var getBaseElem = function getBaseElem2(group) {
        if (group.type === "ordgroup") {
          if (group.body.length === 1) {
            return getBaseElem2(group.body[0]);
          } else {
            return group;
          }
        } else if (group.type === "color") {
          if (group.body.length === 1) {
            return getBaseElem2(group.body[0]);
          } else {
            return group;
          }
        } else if (group.type === "font") {
          return getBaseElem2(group.body);
        } else {
          return group;
        }
      };
      var isCharacterBox = function isCharacterBox2(group) {
        var baseElem = getBaseElem(group);
        return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
      };
      var assert = function assert2(value) {
        if (!value) {
          throw new Error("Expected non-null, but got " + String(value));
        }
        return value;
      };
      var protocolFromUrl = function protocolFromUrl2(url) {
        var protocol = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);
        return protocol != null ? protocol[1] : "_relative";
      };
      var utils = {
        contains,
        deflt,
        escape: utils_escape,
        hyphenate,
        getBaseElem,
        isCharacterBox,
        protocolFromUrl
      };
      var SETTINGS_SCHEMA = {
        displayMode: {
          type: "boolean",
          description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
          cli: "-d, --display-mode"
        },
        output: {
          type: {
            enum: ["htmlAndMathml", "html", "mathml"]
          },
          description: "Determines the markup language of the output.",
          cli: "-F, --format <type>"
        },
        leqno: {
          type: "boolean",
          description: "Render display math in leqno style (left-justified tags)."
        },
        fleqn: {
          type: "boolean",
          description: "Render display math flush left."
        },
        throwOnError: {
          type: "boolean",
          default: true,
          cli: "-t, --no-throw-on-error",
          cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
        },
        errorColor: {
          type: "string",
          default: "#cc0000",
          cli: "-c, --error-color <color>",
          cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
          cliProcessor: function cliProcessor(color) {
            return "#" + color;
          }
        },
        macros: {
          type: "object",
          cli: "-m, --macro <def>",
          cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
          cliDefault: [],
          cliProcessor: function cliProcessor(def, defs) {
            defs.push(def);
            return defs;
          }
        },
        minRuleThickness: {
          type: "number",
          description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
          processor: function processor(t2) {
            return Math.max(0, t2);
          },
          cli: "--min-rule-thickness <size>",
          cliProcessor: parseFloat
        },
        colorIsTextColor: {
          type: "boolean",
          description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
          cli: "-b, --color-is-text-color"
        },
        strict: {
          type: [{
            enum: ["warn", "ignore", "error"]
          }, "boolean", "function"],
          description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
          cli: "-S, --strict",
          cliDefault: false
        },
        trust: {
          type: ["boolean", "function"],
          description: "Trust the input, enabling all HTML features such as \\url.",
          cli: "-T, --trust"
        },
        maxSize: {
          type: "number",
          default: Infinity,
          description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
          processor: function processor(s2) {
            return Math.max(0, s2);
          },
          cli: "-s, --max-size <n>",
          cliProcessor: parseInt
        },
        maxExpand: {
          type: "number",
          default: 1e3,
          description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
          processor: function processor(n2) {
            return Math.max(0, n2);
          },
          cli: "-e, --max-expand <n>",
          cliProcessor: function cliProcessor(n2) {
            return n2 === "Infinity" ? Infinity : parseInt(n2);
          }
        },
        globalGroup: {
          type: "boolean",
          cli: false
        }
      };
      function getDefaultValue(schema) {
        if (schema.default) {
          return schema.default;
        }
        var type = schema.type;
        var defaultType = Array.isArray(type) ? type[0] : type;
        if (typeof defaultType !== "string") {
          return defaultType.enum[0];
        }
        switch (defaultType) {
          case "boolean":
            return false;
          case "string":
            return "";
          case "number":
            return 0;
          case "object":
            return {};
        }
      }
      var Settings = function() {
        function Settings2(options) {
          this.displayMode = void 0;
          this.output = void 0;
          this.leqno = void 0;
          this.fleqn = void 0;
          this.throwOnError = void 0;
          this.errorColor = void 0;
          this.macros = void 0;
          this.minRuleThickness = void 0;
          this.colorIsTextColor = void 0;
          this.strict = void 0;
          this.trust = void 0;
          this.maxSize = void 0;
          this.maxExpand = void 0;
          this.globalGroup = void 0;
          options = options || {};
          for (var prop in SETTINGS_SCHEMA) {
            if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
              var schema = SETTINGS_SCHEMA[prop];
              this[prop] = options[prop] !== void 0 ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
            }
          }
        }
        var _proto = Settings2.prototype;
        _proto.reportNonstrict = function reportNonstrict(errorCode, errorMsg, token) {
          var strict = this.strict;
          if (typeof strict === "function") {
            strict = strict(errorCode, errorMsg, token);
          }
          if (!strict || strict === "ignore") {
            return;
          } else if (strict === true || strict === "error") {
            throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
          } else if (strict === "warn") {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
          } else {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
          }
        };
        _proto.useStrictBehavior = function useStrictBehavior(errorCode, errorMsg, token) {
          var strict = this.strict;
          if (typeof strict === "function") {
            try {
              strict = strict(errorCode, errorMsg, token);
            } catch (error) {
              strict = "error";
            }
          }
          if (!strict || strict === "ignore") {
            return false;
          } else if (strict === true || strict === "error") {
            return true;
          } else if (strict === "warn") {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
            return false;
          } else {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
            return false;
          }
        };
        _proto.isTrusted = function isTrusted(context) {
          if (context.url && !context.protocol) {
            context.protocol = utils.protocolFromUrl(context.url);
          }
          var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
          return Boolean(trust);
        };
        return Settings2;
      }();
      var Style = function() {
        function Style2(id, size, cramped) {
          this.id = void 0;
          this.size = void 0;
          this.cramped = void 0;
          this.id = id;
          this.size = size;
          this.cramped = cramped;
        }
        var _proto = Style2.prototype;
        _proto.sup = function sup() {
          return styles[_sup[this.id]];
        };
        _proto.sub = function sub() {
          return styles[_sub[this.id]];
        };
        _proto.fracNum = function fracNum() {
          return styles[_fracNum[this.id]];
        };
        _proto.fracDen = function fracDen() {
          return styles[_fracDen[this.id]];
        };
        _proto.cramp = function cramp() {
          return styles[_cramp[this.id]];
        };
        _proto.text = function text2() {
          return styles[_text[this.id]];
        };
        _proto.isTight = function isTight() {
          return this.size >= 2;
        };
        return Style2;
      }();
      var D2 = 0;
      var Dc = 1;
      var T2 = 2;
      var Tc = 3;
      var S2 = 4;
      var Sc = 5;
      var SS = 6;
      var SSc = 7;
      var styles = [new Style(D2, 0, false), new Style(Dc, 0, true), new Style(T2, 1, false), new Style(Tc, 1, true), new Style(S2, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
      var _sup = [S2, Sc, S2, Sc, SS, SSc, SS, SSc];
      var _sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
      var _fracNum = [T2, Tc, S2, Sc, SS, SSc, SS, SSc];
      var _fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
      var _cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
      var _text = [D2, Dc, T2, Tc, T2, Tc, T2, Tc];
      var src_Style = {
        DISPLAY: styles[D2],
        TEXT: styles[T2],
        SCRIPT: styles[S2],
        SCRIPTSCRIPT: styles[SS]
      };
      var scriptData = [{
        name: "latin",
        blocks: [
          [256, 591],
          [768, 879]
        ]
      }, {
        name: "cyrillic",
        blocks: [[1024, 1279]]
      }, {
        name: "armenian",
        blocks: [[1328, 1423]]
      }, {
        name: "brahmic",
        blocks: [[2304, 4255]]
      }, {
        name: "georgian",
        blocks: [[4256, 4351]]
      }, {
        name: "cjk",
        blocks: [
          [12288, 12543],
          [19968, 40879],
          [65280, 65376]
        ]
      }, {
        name: "hangul",
        blocks: [[44032, 55215]]
      }];
      function scriptFromCodepoint(codepoint) {
        for (var i3 = 0; i3 < scriptData.length; i3++) {
          var script = scriptData[i3];
          for (var _i6 = 0; _i6 < script.blocks.length; _i6++) {
            var block = script.blocks[_i6];
            if (codepoint >= block[0] && codepoint <= block[1]) {
              return script.name;
            }
          }
        }
        return null;
      }
      var allBlocks = [];
      scriptData.forEach(function(s2) {
        return s2.blocks.forEach(function(b2) {
          return allBlocks.push.apply(allBlocks, b2);
        });
      });
      function supportedCodepoint(codepoint) {
        for (var i3 = 0; i3 < allBlocks.length; i3 += 2) {
          if (codepoint >= allBlocks[i3] && codepoint <= allBlocks[i3 + 1]) {
            return true;
          }
        }
        return false;
      }
      var hLinePad = 80;
      var sqrtMain = function sqrtMain2(extraViniculum, hLinePad2) {
        return "M95," + (622 + extraViniculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraViniculum / 2.075 + " -" + extraViniculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraViniculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
      };
      var sqrtSize1 = function sqrtSize12(extraViniculum, hLinePad2) {
        return "M263," + (601 + extraViniculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraViniculum / 2.084 + " -" + extraViniculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraViniculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
      };
      var sqrtSize2 = function sqrtSize22(extraViniculum, hLinePad2) {
        return "M983 " + (10 + extraViniculum + hLinePad2) + "\nl" + extraViniculum / 3.13 + " -" + extraViniculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraViniculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
      };
      var sqrtSize3 = function sqrtSize32(extraViniculum, hLinePad2) {
        return "M424," + (2398 + extraViniculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraViniculum / 4.223 + " -" + extraViniculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraViniculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraViniculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraViniculum) + "h-400000z";
      };
      var sqrtSize4 = function sqrtSize42(extraViniculum, hLinePad2) {
        return "M473," + (2713 + extraViniculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraViniculum / 5.298 + " -" + extraViniculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraViniculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "H1017.7z";
      };
      var phasePath = function phasePath2(y2) {
        var x2 = y2 / 2;
        return "M400000 " + y2 + " H0 L" + x2 + " 0 l65 45 L145 " + (y2 - 80) + " H400000z";
      };
      var sqrtTall = function sqrtTall2(extraViniculum, hLinePad2, viewBoxHeight) {
        var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraViniculum;
        return "M702 " + (extraViniculum + hLinePad2) + "H400000" + (40 + extraViniculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraViniculum) + "H742z";
      };
      var sqrtPath = function sqrtPath2(size, extraViniculum, viewBoxHeight) {
        extraViniculum = 1e3 * extraViniculum;
        var path2 = "";
        switch (size) {
          case "sqrtMain":
            path2 = sqrtMain(extraViniculum, hLinePad);
            break;
          case "sqrtSize1":
            path2 = sqrtSize1(extraViniculum, hLinePad);
            break;
          case "sqrtSize2":
            path2 = sqrtSize2(extraViniculum, hLinePad);
            break;
          case "sqrtSize3":
            path2 = sqrtSize3(extraViniculum, hLinePad);
            break;
          case "sqrtSize4":
            path2 = sqrtSize4(extraViniculum, hLinePad);
            break;
          case "sqrtTall":
            path2 = sqrtTall(extraViniculum, hLinePad, viewBoxHeight);
        }
        return path2;
      };
      var innerPath = function innerPath2(name, height) {
        switch (name) {
          case "\u239C":
            return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
          case "\u2223":
            return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
          case "\u2225":
            return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
          case "\u239F":
            return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
          case "\u23A2":
            return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
          case "\u23A5":
            return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
          case "\u23AA":
            return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
          case "\u23D0":
            return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
          case "\u2016":
            return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
          default:
            return "";
        }
      };
      var path = {
        doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
        doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
        leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
        leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
        leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
        leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
        leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
        leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
        leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
        leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
        leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
        lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
        leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
        leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
        leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
        longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
        midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
        midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
        oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
        oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
        oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
        oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
        rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
        rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
        rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
        rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
        rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
        rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
        rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
        rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
        rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
        righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
        rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
        rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
        twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
        twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
        tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
        tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
        tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
        tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
        vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
        widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
        widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
        widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
        rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
        baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
        rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
        shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
        shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
      };
      var tallDelim = function tallDelim2(label, midHeight) {
        switch (label) {
          case "lbrack":
            return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
          case "rbrack":
            return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
          case "vert":
            return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
          case "doublevert":
            return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
          case "lfloor":
            return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
          case "rfloor":
            return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
          case "lceil":
            return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
          case "rceil":
            return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
          case "lparen":
            return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
          case "rparen":
            return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
          default:
            throw new Error("Unknown stretchy delimiter.");
        }
      };
      var DocumentFragment = function() {
        function DocumentFragment2(children) {
          this.children = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          this.children = children;
          this.classes = [];
          this.height = 0;
          this.depth = 0;
          this.maxFontSize = 0;
          this.style = {};
        }
        var _proto = DocumentFragment2.prototype;
        _proto.hasClass = function hasClass(className) {
          return utils.contains(this.classes, className);
        };
        _proto.toNode = function toNode() {
          var frag = document.createDocumentFragment();
          for (var i3 = 0; i3 < this.children.length; i3++) {
            frag.appendChild(this.children[i3].toNode());
          }
          return frag;
        };
        _proto.toMarkup = function toMarkup() {
          var markup = "";
          for (var i3 = 0; i3 < this.children.length; i3++) {
            markup += this.children[i3].toMarkup();
          }
          return markup;
        };
        _proto.toText = function toText() {
          var toText2 = function toText3(child) {
            return child.toText();
          };
          return this.children.map(toText2).join("");
        };
        return DocumentFragment2;
      }();
      var fontMetricsData = {
        "AMS-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.68889, 0, 0, 0.72222],
          "66": [0, 0.68889, 0, 0, 0.66667],
          "67": [0, 0.68889, 0, 0, 0.72222],
          "68": [0, 0.68889, 0, 0, 0.72222],
          "69": [0, 0.68889, 0, 0, 0.66667],
          "70": [0, 0.68889, 0, 0, 0.61111],
          "71": [0, 0.68889, 0, 0, 0.77778],
          "72": [0, 0.68889, 0, 0, 0.77778],
          "73": [0, 0.68889, 0, 0, 0.38889],
          "74": [0.16667, 0.68889, 0, 0, 0.5],
          "75": [0, 0.68889, 0, 0, 0.77778],
          "76": [0, 0.68889, 0, 0, 0.66667],
          "77": [0, 0.68889, 0, 0, 0.94445],
          "78": [0, 0.68889, 0, 0, 0.72222],
          "79": [0.16667, 0.68889, 0, 0, 0.77778],
          "80": [0, 0.68889, 0, 0, 0.61111],
          "81": [0.16667, 0.68889, 0, 0, 0.77778],
          "82": [0, 0.68889, 0, 0, 0.72222],
          "83": [0, 0.68889, 0, 0, 0.55556],
          "84": [0, 0.68889, 0, 0, 0.66667],
          "85": [0, 0.68889, 0, 0, 0.72222],
          "86": [0, 0.68889, 0, 0, 0.72222],
          "87": [0, 0.68889, 0, 0, 1],
          "88": [0, 0.68889, 0, 0, 0.72222],
          "89": [0, 0.68889, 0, 0, 0.72222],
          "90": [0, 0.68889, 0, 0, 0.66667],
          "107": [0, 0.68889, 0, 0, 0.55556],
          "160": [0, 0, 0, 0, 0.25],
          "165": [0, 0.675, 0.025, 0, 0.75],
          "174": [0.15559, 0.69224, 0, 0, 0.94666],
          "240": [0, 0.68889, 0, 0, 0.55556],
          "295": [0, 0.68889, 0, 0, 0.54028],
          "710": [0, 0.825, 0, 0, 2.33334],
          "732": [0, 0.9, 0, 0, 2.33334],
          "770": [0, 0.825, 0, 0, 2.33334],
          "771": [0, 0.9, 0, 0, 2.33334],
          "989": [0.08167, 0.58167, 0, 0, 0.77778],
          "1008": [0, 0.43056, 0.04028, 0, 0.66667],
          "8245": [0, 0.54986, 0, 0, 0.275],
          "8463": [0, 0.68889, 0, 0, 0.54028],
          "8487": [0, 0.68889, 0, 0, 0.72222],
          "8498": [0, 0.68889, 0, 0, 0.55556],
          "8502": [0, 0.68889, 0, 0, 0.66667],
          "8503": [0, 0.68889, 0, 0, 0.44445],
          "8504": [0, 0.68889, 0, 0, 0.66667],
          "8513": [0, 0.68889, 0, 0, 0.63889],
          "8592": [-0.03598, 0.46402, 0, 0, 0.5],
          "8594": [-0.03598, 0.46402, 0, 0, 0.5],
          "8602": [-0.13313, 0.36687, 0, 0, 1],
          "8603": [-0.13313, 0.36687, 0, 0, 1],
          "8606": [0.01354, 0.52239, 0, 0, 1],
          "8608": [0.01354, 0.52239, 0, 0, 1],
          "8610": [0.01354, 0.52239, 0, 0, 1.11111],
          "8611": [0.01354, 0.52239, 0, 0, 1.11111],
          "8619": [0, 0.54986, 0, 0, 1],
          "8620": [0, 0.54986, 0, 0, 1],
          "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
          "8622": [-0.13313, 0.36687, 0, 0, 1],
          "8624": [0, 0.69224, 0, 0, 0.5],
          "8625": [0, 0.69224, 0, 0, 0.5],
          "8630": [0, 0.43056, 0, 0, 1],
          "8631": [0, 0.43056, 0, 0, 1],
          "8634": [0.08198, 0.58198, 0, 0, 0.77778],
          "8635": [0.08198, 0.58198, 0, 0, 0.77778],
          "8638": [0.19444, 0.69224, 0, 0, 0.41667],
          "8639": [0.19444, 0.69224, 0, 0, 0.41667],
          "8642": [0.19444, 0.69224, 0, 0, 0.41667],
          "8643": [0.19444, 0.69224, 0, 0, 0.41667],
          "8644": [0.1808, 0.675, 0, 0, 1],
          "8646": [0.1808, 0.675, 0, 0, 1],
          "8647": [0.1808, 0.675, 0, 0, 1],
          "8648": [0.19444, 0.69224, 0, 0, 0.83334],
          "8649": [0.1808, 0.675, 0, 0, 1],
          "8650": [0.19444, 0.69224, 0, 0, 0.83334],
          "8651": [0.01354, 0.52239, 0, 0, 1],
          "8652": [0.01354, 0.52239, 0, 0, 1],
          "8653": [-0.13313, 0.36687, 0, 0, 1],
          "8654": [-0.13313, 0.36687, 0, 0, 1],
          "8655": [-0.13313, 0.36687, 0, 0, 1],
          "8666": [0.13667, 0.63667, 0, 0, 1],
          "8667": [0.13667, 0.63667, 0, 0, 1],
          "8669": [-0.13313, 0.37788, 0, 0, 1],
          "8672": [-0.064, 0.437, 0, 0, 1.334],
          "8674": [-0.064, 0.437, 0, 0, 1.334],
          "8705": [0, 0.825, 0, 0, 0.5],
          "8708": [0, 0.68889, 0, 0, 0.55556],
          "8709": [0.08167, 0.58167, 0, 0, 0.77778],
          "8717": [0, 0.43056, 0, 0, 0.42917],
          "8722": [-0.03598, 0.46402, 0, 0, 0.5],
          "8724": [0.08198, 0.69224, 0, 0, 0.77778],
          "8726": [0.08167, 0.58167, 0, 0, 0.77778],
          "8733": [0, 0.69224, 0, 0, 0.77778],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8737": [0, 0.69224, 0, 0, 0.72222],
          "8738": [0.03517, 0.52239, 0, 0, 0.72222],
          "8739": [0.08167, 0.58167, 0, 0, 0.22222],
          "8740": [0.25142, 0.74111, 0, 0, 0.27778],
          "8741": [0.08167, 0.58167, 0, 0, 0.38889],
          "8742": [0.25142, 0.74111, 0, 0, 0.5],
          "8756": [0, 0.69224, 0, 0, 0.66667],
          "8757": [0, 0.69224, 0, 0, 0.66667],
          "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
          "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8774": [0.30274, 0.79383, 0, 0, 0.77778],
          "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
          "8778": [0.08167, 0.58167, 0, 0, 0.77778],
          "8782": [0.06062, 0.54986, 0, 0, 0.77778],
          "8783": [0.06062, 0.54986, 0, 0, 0.77778],
          "8785": [0.08198, 0.58198, 0, 0, 0.77778],
          "8786": [0.08198, 0.58198, 0, 0, 0.77778],
          "8787": [0.08198, 0.58198, 0, 0, 0.77778],
          "8790": [0, 0.69224, 0, 0, 0.77778],
          "8791": [0.22958, 0.72958, 0, 0, 0.77778],
          "8796": [0.08198, 0.91667, 0, 0, 0.77778],
          "8806": [0.25583, 0.75583, 0, 0, 0.77778],
          "8807": [0.25583, 0.75583, 0, 0, 0.77778],
          "8808": [0.25142, 0.75726, 0, 0, 0.77778],
          "8809": [0.25142, 0.75726, 0, 0, 0.77778],
          "8812": [0.25583, 0.75583, 0, 0, 0.5],
          "8814": [0.20576, 0.70576, 0, 0, 0.77778],
          "8815": [0.20576, 0.70576, 0, 0, 0.77778],
          "8816": [0.30274, 0.79383, 0, 0, 0.77778],
          "8817": [0.30274, 0.79383, 0, 0, 0.77778],
          "8818": [0.22958, 0.72958, 0, 0, 0.77778],
          "8819": [0.22958, 0.72958, 0, 0, 0.77778],
          "8822": [0.1808, 0.675, 0, 0, 0.77778],
          "8823": [0.1808, 0.675, 0, 0, 0.77778],
          "8828": [0.13667, 0.63667, 0, 0, 0.77778],
          "8829": [0.13667, 0.63667, 0, 0, 0.77778],
          "8830": [0.22958, 0.72958, 0, 0, 0.77778],
          "8831": [0.22958, 0.72958, 0, 0, 0.77778],
          "8832": [0.20576, 0.70576, 0, 0, 0.77778],
          "8833": [0.20576, 0.70576, 0, 0, 0.77778],
          "8840": [0.30274, 0.79383, 0, 0, 0.77778],
          "8841": [0.30274, 0.79383, 0, 0, 0.77778],
          "8842": [0.13597, 0.63597, 0, 0, 0.77778],
          "8843": [0.13597, 0.63597, 0, 0, 0.77778],
          "8847": [0.03517, 0.54986, 0, 0, 0.77778],
          "8848": [0.03517, 0.54986, 0, 0, 0.77778],
          "8858": [0.08198, 0.58198, 0, 0, 0.77778],
          "8859": [0.08198, 0.58198, 0, 0, 0.77778],
          "8861": [0.08198, 0.58198, 0, 0, 0.77778],
          "8862": [0, 0.675, 0, 0, 0.77778],
          "8863": [0, 0.675, 0, 0, 0.77778],
          "8864": [0, 0.675, 0, 0, 0.77778],
          "8865": [0, 0.675, 0, 0, 0.77778],
          "8872": [0, 0.69224, 0, 0, 0.61111],
          "8873": [0, 0.69224, 0, 0, 0.72222],
          "8874": [0, 0.69224, 0, 0, 0.88889],
          "8876": [0, 0.68889, 0, 0, 0.61111],
          "8877": [0, 0.68889, 0, 0, 0.61111],
          "8878": [0, 0.68889, 0, 0, 0.72222],
          "8879": [0, 0.68889, 0, 0, 0.72222],
          "8882": [0.03517, 0.54986, 0, 0, 0.77778],
          "8883": [0.03517, 0.54986, 0, 0, 0.77778],
          "8884": [0.13667, 0.63667, 0, 0, 0.77778],
          "8885": [0.13667, 0.63667, 0, 0, 0.77778],
          "8888": [0, 0.54986, 0, 0, 1.11111],
          "8890": [0.19444, 0.43056, 0, 0, 0.55556],
          "8891": [0.19444, 0.69224, 0, 0, 0.61111],
          "8892": [0.19444, 0.69224, 0, 0, 0.61111],
          "8901": [0, 0.54986, 0, 0, 0.27778],
          "8903": [0.08167, 0.58167, 0, 0, 0.77778],
          "8905": [0.08167, 0.58167, 0, 0, 0.77778],
          "8906": [0.08167, 0.58167, 0, 0, 0.77778],
          "8907": [0, 0.69224, 0, 0, 0.77778],
          "8908": [0, 0.69224, 0, 0, 0.77778],
          "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
          "8910": [0, 0.54986, 0, 0, 0.76042],
          "8911": [0, 0.54986, 0, 0, 0.76042],
          "8912": [0.03517, 0.54986, 0, 0, 0.77778],
          "8913": [0.03517, 0.54986, 0, 0, 0.77778],
          "8914": [0, 0.54986, 0, 0, 0.66667],
          "8915": [0, 0.54986, 0, 0, 0.66667],
          "8916": [0, 0.69224, 0, 0, 0.66667],
          "8918": [0.0391, 0.5391, 0, 0, 0.77778],
          "8919": [0.0391, 0.5391, 0, 0, 0.77778],
          "8920": [0.03517, 0.54986, 0, 0, 1.33334],
          "8921": [0.03517, 0.54986, 0, 0, 1.33334],
          "8922": [0.38569, 0.88569, 0, 0, 0.77778],
          "8923": [0.38569, 0.88569, 0, 0, 0.77778],
          "8926": [0.13667, 0.63667, 0, 0, 0.77778],
          "8927": [0.13667, 0.63667, 0, 0, 0.77778],
          "8928": [0.30274, 0.79383, 0, 0, 0.77778],
          "8929": [0.30274, 0.79383, 0, 0, 0.77778],
          "8934": [0.23222, 0.74111, 0, 0, 0.77778],
          "8935": [0.23222, 0.74111, 0, 0, 0.77778],
          "8936": [0.23222, 0.74111, 0, 0, 0.77778],
          "8937": [0.23222, 0.74111, 0, 0, 0.77778],
          "8938": [0.20576, 0.70576, 0, 0, 0.77778],
          "8939": [0.20576, 0.70576, 0, 0, 0.77778],
          "8940": [0.30274, 0.79383, 0, 0, 0.77778],
          "8941": [0.30274, 0.79383, 0, 0, 0.77778],
          "8994": [0.19444, 0.69224, 0, 0, 0.77778],
          "8995": [0.19444, 0.69224, 0, 0, 0.77778],
          "9416": [0.15559, 0.69224, 0, 0, 0.90222],
          "9484": [0, 0.69224, 0, 0, 0.5],
          "9488": [0, 0.69224, 0, 0, 0.5],
          "9492": [0, 0.37788, 0, 0, 0.5],
          "9496": [0, 0.37788, 0, 0, 0.5],
          "9585": [0.19444, 0.68889, 0, 0, 0.88889],
          "9586": [0.19444, 0.74111, 0, 0, 0.88889],
          "9632": [0, 0.675, 0, 0, 0.77778],
          "9633": [0, 0.675, 0, 0, 0.77778],
          "9650": [0, 0.54986, 0, 0, 0.72222],
          "9651": [0, 0.54986, 0, 0, 0.72222],
          "9654": [0.03517, 0.54986, 0, 0, 0.77778],
          "9660": [0, 0.54986, 0, 0, 0.72222],
          "9661": [0, 0.54986, 0, 0, 0.72222],
          "9664": [0.03517, 0.54986, 0, 0, 0.77778],
          "9674": [0.11111, 0.69224, 0, 0, 0.66667],
          "9733": [0.19444, 0.69224, 0, 0, 0.94445],
          "10003": [0, 0.69224, 0, 0, 0.83334],
          "10016": [0, 0.69224, 0, 0, 0.83334],
          "10731": [0.11111, 0.69224, 0, 0, 0.66667],
          "10846": [0.19444, 0.75583, 0, 0, 0.61111],
          "10877": [0.13667, 0.63667, 0, 0, 0.77778],
          "10878": [0.13667, 0.63667, 0, 0, 0.77778],
          "10885": [0.25583, 0.75583, 0, 0, 0.77778],
          "10886": [0.25583, 0.75583, 0, 0, 0.77778],
          "10887": [0.13597, 0.63597, 0, 0, 0.77778],
          "10888": [0.13597, 0.63597, 0, 0, 0.77778],
          "10889": [0.26167, 0.75726, 0, 0, 0.77778],
          "10890": [0.26167, 0.75726, 0, 0, 0.77778],
          "10891": [0.48256, 0.98256, 0, 0, 0.77778],
          "10892": [0.48256, 0.98256, 0, 0, 0.77778],
          "10901": [0.13667, 0.63667, 0, 0, 0.77778],
          "10902": [0.13667, 0.63667, 0, 0, 0.77778],
          "10933": [0.25142, 0.75726, 0, 0, 0.77778],
          "10934": [0.25142, 0.75726, 0, 0, 0.77778],
          "10935": [0.26167, 0.75726, 0, 0, 0.77778],
          "10936": [0.26167, 0.75726, 0, 0, 0.77778],
          "10937": [0.26167, 0.75726, 0, 0, 0.77778],
          "10938": [0.26167, 0.75726, 0, 0, 0.77778],
          "10949": [0.25583, 0.75583, 0, 0, 0.77778],
          "10950": [0.25583, 0.75583, 0, 0, 0.77778],
          "10955": [0.28481, 0.79383, 0, 0, 0.77778],
          "10956": [0.28481, 0.79383, 0, 0, 0.77778],
          "57350": [0.08167, 0.58167, 0, 0, 0.22222],
          "57351": [0.08167, 0.58167, 0, 0, 0.38889],
          "57352": [0.08167, 0.58167, 0, 0, 0.77778],
          "57353": [0, 0.43056, 0.04028, 0, 0.66667],
          "57356": [0.25142, 0.75726, 0, 0, 0.77778],
          "57357": [0.25142, 0.75726, 0, 0, 0.77778],
          "57358": [0.41951, 0.91951, 0, 0, 0.77778],
          "57359": [0.30274, 0.79383, 0, 0, 0.77778],
          "57360": [0.30274, 0.79383, 0, 0, 0.77778],
          "57361": [0.41951, 0.91951, 0, 0, 0.77778],
          "57366": [0.25142, 0.75726, 0, 0, 0.77778],
          "57367": [0.25142, 0.75726, 0, 0, 0.77778],
          "57368": [0.25142, 0.75726, 0, 0, 0.77778],
          "57369": [0.25142, 0.75726, 0, 0, 0.77778],
          "57370": [0.13597, 0.63597, 0, 0, 0.77778],
          "57371": [0.13597, 0.63597, 0, 0, 0.77778]
        },
        "Caligraphic-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.68333, 0, 0.19445, 0.79847],
          "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
          "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
          "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
          "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
          "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
          "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
          "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
          "73": [0, 0.68333, 0.07382, 0, 0.54452],
          "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
          "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
          "76": [0, 0.68333, 0, 0.13889, 0.68972],
          "77": [0, 0.68333, 0, 0.13889, 1.2009],
          "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
          "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
          "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
          "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
          "82": [0, 0.68333, 0, 0.08334, 0.8475],
          "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
          "84": [0, 0.68333, 0.25417, 0, 0.54464],
          "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
          "86": [0, 0.68333, 0.08222, 0, 0.61278],
          "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
          "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
          "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
          "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
          "160": [0, 0, 0, 0, 0.25]
        },
        "Fraktur-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69141, 0, 0, 0.29574],
          "34": [0, 0.69141, 0, 0, 0.21471],
          "38": [0, 0.69141, 0, 0, 0.73786],
          "39": [0, 0.69141, 0, 0, 0.21201],
          "40": [0.24982, 0.74947, 0, 0, 0.38865],
          "41": [0.24982, 0.74947, 0, 0, 0.38865],
          "42": [0, 0.62119, 0, 0, 0.27764],
          "43": [0.08319, 0.58283, 0, 0, 0.75623],
          "44": [0, 0.10803, 0, 0, 0.27764],
          "45": [0.08319, 0.58283, 0, 0, 0.75623],
          "46": [0, 0.10803, 0, 0, 0.27764],
          "47": [0.24982, 0.74947, 0, 0, 0.50181],
          "48": [0, 0.47534, 0, 0, 0.50181],
          "49": [0, 0.47534, 0, 0, 0.50181],
          "50": [0, 0.47534, 0, 0, 0.50181],
          "51": [0.18906, 0.47534, 0, 0, 0.50181],
          "52": [0.18906, 0.47534, 0, 0, 0.50181],
          "53": [0.18906, 0.47534, 0, 0, 0.50181],
          "54": [0, 0.69141, 0, 0, 0.50181],
          "55": [0.18906, 0.47534, 0, 0, 0.50181],
          "56": [0, 0.69141, 0, 0, 0.50181],
          "57": [0.18906, 0.47534, 0, 0, 0.50181],
          "58": [0, 0.47534, 0, 0, 0.21606],
          "59": [0.12604, 0.47534, 0, 0, 0.21606],
          "61": [-0.13099, 0.36866, 0, 0, 0.75623],
          "63": [0, 0.69141, 0, 0, 0.36245],
          "65": [0, 0.69141, 0, 0, 0.7176],
          "66": [0, 0.69141, 0, 0, 0.88397],
          "67": [0, 0.69141, 0, 0, 0.61254],
          "68": [0, 0.69141, 0, 0, 0.83158],
          "69": [0, 0.69141, 0, 0, 0.66278],
          "70": [0.12604, 0.69141, 0, 0, 0.61119],
          "71": [0, 0.69141, 0, 0, 0.78539],
          "72": [0.06302, 0.69141, 0, 0, 0.7203],
          "73": [0, 0.69141, 0, 0, 0.55448],
          "74": [0.12604, 0.69141, 0, 0, 0.55231],
          "75": [0, 0.69141, 0, 0, 0.66845],
          "76": [0, 0.69141, 0, 0, 0.66602],
          "77": [0, 0.69141, 0, 0, 1.04953],
          "78": [0, 0.69141, 0, 0, 0.83212],
          "79": [0, 0.69141, 0, 0, 0.82699],
          "80": [0.18906, 0.69141, 0, 0, 0.82753],
          "81": [0.03781, 0.69141, 0, 0, 0.82699],
          "82": [0, 0.69141, 0, 0, 0.82807],
          "83": [0, 0.69141, 0, 0, 0.82861],
          "84": [0, 0.69141, 0, 0, 0.66899],
          "85": [0, 0.69141, 0, 0, 0.64576],
          "86": [0, 0.69141, 0, 0, 0.83131],
          "87": [0, 0.69141, 0, 0, 1.04602],
          "88": [0, 0.69141, 0, 0, 0.71922],
          "89": [0.18906, 0.69141, 0, 0, 0.83293],
          "90": [0.12604, 0.69141, 0, 0, 0.60201],
          "91": [0.24982, 0.74947, 0, 0, 0.27764],
          "93": [0.24982, 0.74947, 0, 0, 0.27764],
          "94": [0, 0.69141, 0, 0, 0.49965],
          "97": [0, 0.47534, 0, 0, 0.50046],
          "98": [0, 0.69141, 0, 0, 0.51315],
          "99": [0, 0.47534, 0, 0, 0.38946],
          "100": [0, 0.62119, 0, 0, 0.49857],
          "101": [0, 0.47534, 0, 0, 0.40053],
          "102": [0.18906, 0.69141, 0, 0, 0.32626],
          "103": [0.18906, 0.47534, 0, 0, 0.5037],
          "104": [0.18906, 0.69141, 0, 0, 0.52126],
          "105": [0, 0.69141, 0, 0, 0.27899],
          "106": [0, 0.69141, 0, 0, 0.28088],
          "107": [0, 0.69141, 0, 0, 0.38946],
          "108": [0, 0.69141, 0, 0, 0.27953],
          "109": [0, 0.47534, 0, 0, 0.76676],
          "110": [0, 0.47534, 0, 0, 0.52666],
          "111": [0, 0.47534, 0, 0, 0.48885],
          "112": [0.18906, 0.52396, 0, 0, 0.50046],
          "113": [0.18906, 0.47534, 0, 0, 0.48912],
          "114": [0, 0.47534, 0, 0, 0.38919],
          "115": [0, 0.47534, 0, 0, 0.44266],
          "116": [0, 0.62119, 0, 0, 0.33301],
          "117": [0, 0.47534, 0, 0, 0.5172],
          "118": [0, 0.52396, 0, 0, 0.5118],
          "119": [0, 0.52396, 0, 0, 0.77351],
          "120": [0.18906, 0.47534, 0, 0, 0.38865],
          "121": [0.18906, 0.47534, 0, 0, 0.49884],
          "122": [0.18906, 0.47534, 0, 0, 0.39054],
          "160": [0, 0, 0, 0, 0.25],
          "8216": [0, 0.69141, 0, 0, 0.21471],
          "8217": [0, 0.69141, 0, 0, 0.21471],
          "58112": [0, 0.62119, 0, 0, 0.49749],
          "58113": [0, 0.62119, 0, 0, 0.4983],
          "58114": [0.18906, 0.69141, 0, 0, 0.33328],
          "58115": [0.18906, 0.69141, 0, 0, 0.32923],
          "58116": [0.18906, 0.47534, 0, 0, 0.50343],
          "58117": [0, 0.69141, 0, 0, 0.33301],
          "58118": [0, 0.62119, 0, 0, 0.33409],
          "58119": [0, 0.47534, 0, 0, 0.50073]
        },
        "Main-Bold": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.35],
          "34": [0, 0.69444, 0, 0, 0.60278],
          "35": [0.19444, 0.69444, 0, 0, 0.95833],
          "36": [0.05556, 0.75, 0, 0, 0.575],
          "37": [0.05556, 0.75, 0, 0, 0.95833],
          "38": [0, 0.69444, 0, 0, 0.89444],
          "39": [0, 0.69444, 0, 0, 0.31944],
          "40": [0.25, 0.75, 0, 0, 0.44722],
          "41": [0.25, 0.75, 0, 0, 0.44722],
          "42": [0, 0.75, 0, 0, 0.575],
          "43": [0.13333, 0.63333, 0, 0, 0.89444],
          "44": [0.19444, 0.15556, 0, 0, 0.31944],
          "45": [0, 0.44444, 0, 0, 0.38333],
          "46": [0, 0.15556, 0, 0, 0.31944],
          "47": [0.25, 0.75, 0, 0, 0.575],
          "48": [0, 0.64444, 0, 0, 0.575],
          "49": [0, 0.64444, 0, 0, 0.575],
          "50": [0, 0.64444, 0, 0, 0.575],
          "51": [0, 0.64444, 0, 0, 0.575],
          "52": [0, 0.64444, 0, 0, 0.575],
          "53": [0, 0.64444, 0, 0, 0.575],
          "54": [0, 0.64444, 0, 0, 0.575],
          "55": [0, 0.64444, 0, 0, 0.575],
          "56": [0, 0.64444, 0, 0, 0.575],
          "57": [0, 0.64444, 0, 0, 0.575],
          "58": [0, 0.44444, 0, 0, 0.31944],
          "59": [0.19444, 0.44444, 0, 0, 0.31944],
          "60": [0.08556, 0.58556, 0, 0, 0.89444],
          "61": [-0.10889, 0.39111, 0, 0, 0.89444],
          "62": [0.08556, 0.58556, 0, 0, 0.89444],
          "63": [0, 0.69444, 0, 0, 0.54305],
          "64": [0, 0.69444, 0, 0, 0.89444],
          "65": [0, 0.68611, 0, 0, 0.86944],
          "66": [0, 0.68611, 0, 0, 0.81805],
          "67": [0, 0.68611, 0, 0, 0.83055],
          "68": [0, 0.68611, 0, 0, 0.88194],
          "69": [0, 0.68611, 0, 0, 0.75555],
          "70": [0, 0.68611, 0, 0, 0.72361],
          "71": [0, 0.68611, 0, 0, 0.90416],
          "72": [0, 0.68611, 0, 0, 0.9],
          "73": [0, 0.68611, 0, 0, 0.43611],
          "74": [0, 0.68611, 0, 0, 0.59444],
          "75": [0, 0.68611, 0, 0, 0.90138],
          "76": [0, 0.68611, 0, 0, 0.69166],
          "77": [0, 0.68611, 0, 0, 1.09166],
          "78": [0, 0.68611, 0, 0, 0.9],
          "79": [0, 0.68611, 0, 0, 0.86388],
          "80": [0, 0.68611, 0, 0, 0.78611],
          "81": [0.19444, 0.68611, 0, 0, 0.86388],
          "82": [0, 0.68611, 0, 0, 0.8625],
          "83": [0, 0.68611, 0, 0, 0.63889],
          "84": [0, 0.68611, 0, 0, 0.8],
          "85": [0, 0.68611, 0, 0, 0.88472],
          "86": [0, 0.68611, 0.01597, 0, 0.86944],
          "87": [0, 0.68611, 0.01597, 0, 1.18888],
          "88": [0, 0.68611, 0, 0, 0.86944],
          "89": [0, 0.68611, 0.02875, 0, 0.86944],
          "90": [0, 0.68611, 0, 0, 0.70277],
          "91": [0.25, 0.75, 0, 0, 0.31944],
          "92": [0.25, 0.75, 0, 0, 0.575],
          "93": [0.25, 0.75, 0, 0, 0.31944],
          "94": [0, 0.69444, 0, 0, 0.575],
          "95": [0.31, 0.13444, 0.03194, 0, 0.575],
          "97": [0, 0.44444, 0, 0, 0.55902],
          "98": [0, 0.69444, 0, 0, 0.63889],
          "99": [0, 0.44444, 0, 0, 0.51111],
          "100": [0, 0.69444, 0, 0, 0.63889],
          "101": [0, 0.44444, 0, 0, 0.52708],
          "102": [0, 0.69444, 0.10903, 0, 0.35139],
          "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
          "104": [0, 0.69444, 0, 0, 0.63889],
          "105": [0, 0.69444, 0, 0, 0.31944],
          "106": [0.19444, 0.69444, 0, 0, 0.35139],
          "107": [0, 0.69444, 0, 0, 0.60694],
          "108": [0, 0.69444, 0, 0, 0.31944],
          "109": [0, 0.44444, 0, 0, 0.95833],
          "110": [0, 0.44444, 0, 0, 0.63889],
          "111": [0, 0.44444, 0, 0, 0.575],
          "112": [0.19444, 0.44444, 0, 0, 0.63889],
          "113": [0.19444, 0.44444, 0, 0, 0.60694],
          "114": [0, 0.44444, 0, 0, 0.47361],
          "115": [0, 0.44444, 0, 0, 0.45361],
          "116": [0, 0.63492, 0, 0, 0.44722],
          "117": [0, 0.44444, 0, 0, 0.63889],
          "118": [0, 0.44444, 0.01597, 0, 0.60694],
          "119": [0, 0.44444, 0.01597, 0, 0.83055],
          "120": [0, 0.44444, 0, 0, 0.60694],
          "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
          "122": [0, 0.44444, 0, 0, 0.51111],
          "123": [0.25, 0.75, 0, 0, 0.575],
          "124": [0.25, 0.75, 0, 0, 0.31944],
          "125": [0.25, 0.75, 0, 0, 0.575],
          "126": [0.35, 0.34444, 0, 0, 0.575],
          "160": [0, 0, 0, 0, 0.25],
          "163": [0, 0.69444, 0, 0, 0.86853],
          "168": [0, 0.69444, 0, 0, 0.575],
          "172": [0, 0.44444, 0, 0, 0.76666],
          "176": [0, 0.69444, 0, 0, 0.86944],
          "177": [0.13333, 0.63333, 0, 0, 0.89444],
          "184": [0.17014, 0, 0, 0, 0.51111],
          "198": [0, 0.68611, 0, 0, 1.04166],
          "215": [0.13333, 0.63333, 0, 0, 0.89444],
          "216": [0.04861, 0.73472, 0, 0, 0.89444],
          "223": [0, 0.69444, 0, 0, 0.59722],
          "230": [0, 0.44444, 0, 0, 0.83055],
          "247": [0.13333, 0.63333, 0, 0, 0.89444],
          "248": [0.09722, 0.54167, 0, 0, 0.575],
          "305": [0, 0.44444, 0, 0, 0.31944],
          "338": [0, 0.68611, 0, 0, 1.16944],
          "339": [0, 0.44444, 0, 0, 0.89444],
          "567": [0.19444, 0.44444, 0, 0, 0.35139],
          "710": [0, 0.69444, 0, 0, 0.575],
          "711": [0, 0.63194, 0, 0, 0.575],
          "713": [0, 0.59611, 0, 0, 0.575],
          "714": [0, 0.69444, 0, 0, 0.575],
          "715": [0, 0.69444, 0, 0, 0.575],
          "728": [0, 0.69444, 0, 0, 0.575],
          "729": [0, 0.69444, 0, 0, 0.31944],
          "730": [0, 0.69444, 0, 0, 0.86944],
          "732": [0, 0.69444, 0, 0, 0.575],
          "733": [0, 0.69444, 0, 0, 0.575],
          "915": [0, 0.68611, 0, 0, 0.69166],
          "916": [0, 0.68611, 0, 0, 0.95833],
          "920": [0, 0.68611, 0, 0, 0.89444],
          "923": [0, 0.68611, 0, 0, 0.80555],
          "926": [0, 0.68611, 0, 0, 0.76666],
          "928": [0, 0.68611, 0, 0, 0.9],
          "931": [0, 0.68611, 0, 0, 0.83055],
          "933": [0, 0.68611, 0, 0, 0.89444],
          "934": [0, 0.68611, 0, 0, 0.83055],
          "936": [0, 0.68611, 0, 0, 0.89444],
          "937": [0, 0.68611, 0, 0, 0.83055],
          "8211": [0, 0.44444, 0.03194, 0, 0.575],
          "8212": [0, 0.44444, 0.03194, 0, 1.14999],
          "8216": [0, 0.69444, 0, 0, 0.31944],
          "8217": [0, 0.69444, 0, 0, 0.31944],
          "8220": [0, 0.69444, 0, 0, 0.60278],
          "8221": [0, 0.69444, 0, 0, 0.60278],
          "8224": [0.19444, 0.69444, 0, 0, 0.51111],
          "8225": [0.19444, 0.69444, 0, 0, 0.51111],
          "8242": [0, 0.55556, 0, 0, 0.34444],
          "8407": [0, 0.72444, 0.15486, 0, 0.575],
          "8463": [0, 0.69444, 0, 0, 0.66759],
          "8465": [0, 0.69444, 0, 0, 0.83055],
          "8467": [0, 0.69444, 0, 0, 0.47361],
          "8472": [0.19444, 0.44444, 0, 0, 0.74027],
          "8476": [0, 0.69444, 0, 0, 0.83055],
          "8501": [0, 0.69444, 0, 0, 0.70277],
          "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8593": [0.19444, 0.69444, 0, 0, 0.575],
          "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8595": [0.19444, 0.69444, 0, 0, 0.575],
          "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8597": [0.25, 0.75, 0, 0, 0.575],
          "8598": [0.19444, 0.69444, 0, 0, 1.14999],
          "8599": [0.19444, 0.69444, 0, 0, 1.14999],
          "8600": [0.19444, 0.69444, 0, 0, 1.14999],
          "8601": [0.19444, 0.69444, 0, 0, 1.14999],
          "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8657": [0.19444, 0.69444, 0, 0, 0.70277],
          "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8659": [0.19444, 0.69444, 0, 0, 0.70277],
          "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8661": [0.25, 0.75, 0, 0, 0.70277],
          "8704": [0, 0.69444, 0, 0, 0.63889],
          "8706": [0, 0.69444, 0.06389, 0, 0.62847],
          "8707": [0, 0.69444, 0, 0, 0.63889],
          "8709": [0.05556, 0.75, 0, 0, 0.575],
          "8711": [0, 0.68611, 0, 0, 0.95833],
          "8712": [0.08556, 0.58556, 0, 0, 0.76666],
          "8715": [0.08556, 0.58556, 0, 0, 0.76666],
          "8722": [0.13333, 0.63333, 0, 0, 0.89444],
          "8723": [0.13333, 0.63333, 0, 0, 0.89444],
          "8725": [0.25, 0.75, 0, 0, 0.575],
          "8726": [0.25, 0.75, 0, 0, 0.575],
          "8727": [-0.02778, 0.47222, 0, 0, 0.575],
          "8728": [-0.02639, 0.47361, 0, 0, 0.575],
          "8729": [-0.02639, 0.47361, 0, 0, 0.575],
          "8730": [0.18, 0.82, 0, 0, 0.95833],
          "8733": [0, 0.44444, 0, 0, 0.89444],
          "8734": [0, 0.44444, 0, 0, 1.14999],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8739": [0.25, 0.75, 0, 0, 0.31944],
          "8741": [0.25, 0.75, 0, 0, 0.575],
          "8743": [0, 0.55556, 0, 0, 0.76666],
          "8744": [0, 0.55556, 0, 0, 0.76666],
          "8745": [0, 0.55556, 0, 0, 0.76666],
          "8746": [0, 0.55556, 0, 0, 0.76666],
          "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
          "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
          "8768": [0.19444, 0.69444, 0, 0, 0.31944],
          "8771": [222e-5, 0.50222, 0, 0, 0.89444],
          "8773": [0.027, 0.638, 0, 0, 0.894],
          "8776": [0.02444, 0.52444, 0, 0, 0.89444],
          "8781": [222e-5, 0.50222, 0, 0, 0.89444],
          "8801": [222e-5, 0.50222, 0, 0, 0.89444],
          "8804": [0.19667, 0.69667, 0, 0, 0.89444],
          "8805": [0.19667, 0.69667, 0, 0, 0.89444],
          "8810": [0.08556, 0.58556, 0, 0, 1.14999],
          "8811": [0.08556, 0.58556, 0, 0, 1.14999],
          "8826": [0.08556, 0.58556, 0, 0, 0.89444],
          "8827": [0.08556, 0.58556, 0, 0, 0.89444],
          "8834": [0.08556, 0.58556, 0, 0, 0.89444],
          "8835": [0.08556, 0.58556, 0, 0, 0.89444],
          "8838": [0.19667, 0.69667, 0, 0, 0.89444],
          "8839": [0.19667, 0.69667, 0, 0, 0.89444],
          "8846": [0, 0.55556, 0, 0, 0.76666],
          "8849": [0.19667, 0.69667, 0, 0, 0.89444],
          "8850": [0.19667, 0.69667, 0, 0, 0.89444],
          "8851": [0, 0.55556, 0, 0, 0.76666],
          "8852": [0, 0.55556, 0, 0, 0.76666],
          "8853": [0.13333, 0.63333, 0, 0, 0.89444],
          "8854": [0.13333, 0.63333, 0, 0, 0.89444],
          "8855": [0.13333, 0.63333, 0, 0, 0.89444],
          "8856": [0.13333, 0.63333, 0, 0, 0.89444],
          "8857": [0.13333, 0.63333, 0, 0, 0.89444],
          "8866": [0, 0.69444, 0, 0, 0.70277],
          "8867": [0, 0.69444, 0, 0, 0.70277],
          "8868": [0, 0.69444, 0, 0, 0.89444],
          "8869": [0, 0.69444, 0, 0, 0.89444],
          "8900": [-0.02639, 0.47361, 0, 0, 0.575],
          "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
          "8902": [-0.02778, 0.47222, 0, 0, 0.575],
          "8968": [0.25, 0.75, 0, 0, 0.51111],
          "8969": [0.25, 0.75, 0, 0, 0.51111],
          "8970": [0.25, 0.75, 0, 0, 0.51111],
          "8971": [0.25, 0.75, 0, 0, 0.51111],
          "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
          "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
          "9651": [0.19444, 0.69444, 0, 0, 1.02222],
          "9657": [-0.02778, 0.47222, 0, 0, 0.575],
          "9661": [0.19444, 0.69444, 0, 0, 1.02222],
          "9667": [-0.02778, 0.47222, 0, 0, 0.575],
          "9711": [0.19444, 0.69444, 0, 0, 1.14999],
          "9824": [0.12963, 0.69444, 0, 0, 0.89444],
          "9825": [0.12963, 0.69444, 0, 0, 0.89444],
          "9826": [0.12963, 0.69444, 0, 0, 0.89444],
          "9827": [0.12963, 0.69444, 0, 0, 0.89444],
          "9837": [0, 0.75, 0, 0, 0.44722],
          "9838": [0.19444, 0.69444, 0, 0, 0.44722],
          "9839": [0.19444, 0.69444, 0, 0, 0.44722],
          "10216": [0.25, 0.75, 0, 0, 0.44722],
          "10217": [0.25, 0.75, 0, 0, 0.44722],
          "10815": [0, 0.68611, 0, 0, 0.9],
          "10927": [0.19667, 0.69667, 0, 0, 0.89444],
          "10928": [0.19667, 0.69667, 0, 0, 0.89444],
          "57376": [0.19444, 0.69444, 0, 0, 0]
        },
        "Main-BoldItalic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.11417, 0, 0.38611],
          "34": [0, 0.69444, 0.07939, 0, 0.62055],
          "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
          "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
          "38": [0, 0.69444, 0.08528, 0, 0.88555],
          "39": [0, 0.69444, 0.12945, 0, 0.35555],
          "40": [0.25, 0.75, 0.15806, 0, 0.47333],
          "41": [0.25, 0.75, 0.03306, 0, 0.47333],
          "42": [0, 0.75, 0.14333, 0, 0.59111],
          "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
          "44": [0.19444, 0.14722, 0, 0, 0.35555],
          "45": [0, 0.44444, 0.02611, 0, 0.41444],
          "46": [0, 0.14722, 0, 0, 0.35555],
          "47": [0.25, 0.75, 0.15806, 0, 0.59111],
          "48": [0, 0.64444, 0.13167, 0, 0.59111],
          "49": [0, 0.64444, 0.13167, 0, 0.59111],
          "50": [0, 0.64444, 0.13167, 0, 0.59111],
          "51": [0, 0.64444, 0.13167, 0, 0.59111],
          "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
          "53": [0, 0.64444, 0.13167, 0, 0.59111],
          "54": [0, 0.64444, 0.13167, 0, 0.59111],
          "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
          "56": [0, 0.64444, 0.13167, 0, 0.59111],
          "57": [0, 0.64444, 0.13167, 0, 0.59111],
          "58": [0, 0.44444, 0.06695, 0, 0.35555],
          "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
          "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
          "63": [0, 0.69444, 0.11472, 0, 0.59111],
          "64": [0, 0.69444, 0.09208, 0, 0.88555],
          "65": [0, 0.68611, 0, 0, 0.86555],
          "66": [0, 0.68611, 0.0992, 0, 0.81666],
          "67": [0, 0.68611, 0.14208, 0, 0.82666],
          "68": [0, 0.68611, 0.09062, 0, 0.87555],
          "69": [0, 0.68611, 0.11431, 0, 0.75666],
          "70": [0, 0.68611, 0.12903, 0, 0.72722],
          "71": [0, 0.68611, 0.07347, 0, 0.89527],
          "72": [0, 0.68611, 0.17208, 0, 0.8961],
          "73": [0, 0.68611, 0.15681, 0, 0.47166],
          "74": [0, 0.68611, 0.145, 0, 0.61055],
          "75": [0, 0.68611, 0.14208, 0, 0.89499],
          "76": [0, 0.68611, 0, 0, 0.69777],
          "77": [0, 0.68611, 0.17208, 0, 1.07277],
          "78": [0, 0.68611, 0.17208, 0, 0.8961],
          "79": [0, 0.68611, 0.09062, 0, 0.85499],
          "80": [0, 0.68611, 0.0992, 0, 0.78721],
          "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
          "82": [0, 0.68611, 0.02559, 0, 0.85944],
          "83": [0, 0.68611, 0.11264, 0, 0.64999],
          "84": [0, 0.68611, 0.12903, 0, 0.7961],
          "85": [0, 0.68611, 0.17208, 0, 0.88083],
          "86": [0, 0.68611, 0.18625, 0, 0.86555],
          "87": [0, 0.68611, 0.18625, 0, 1.15999],
          "88": [0, 0.68611, 0.15681, 0, 0.86555],
          "89": [0, 0.68611, 0.19803, 0, 0.86555],
          "90": [0, 0.68611, 0.14208, 0, 0.70888],
          "91": [0.25, 0.75, 0.1875, 0, 0.35611],
          "93": [0.25, 0.75, 0.09972, 0, 0.35611],
          "94": [0, 0.69444, 0.06709, 0, 0.59111],
          "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
          "97": [0, 0.44444, 0.09426, 0, 0.59111],
          "98": [0, 0.69444, 0.07861, 0, 0.53222],
          "99": [0, 0.44444, 0.05222, 0, 0.53222],
          "100": [0, 0.69444, 0.10861, 0, 0.59111],
          "101": [0, 0.44444, 0.085, 0, 0.53222],
          "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
          "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
          "104": [0, 0.69444, 0.09426, 0, 0.59111],
          "105": [0, 0.69326, 0.11387, 0, 0.35555],
          "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
          "107": [0, 0.69444, 0.11111, 0, 0.53222],
          "108": [0, 0.69444, 0.10861, 0, 0.29666],
          "109": [0, 0.44444, 0.09426, 0, 0.94444],
          "110": [0, 0.44444, 0.09426, 0, 0.64999],
          "111": [0, 0.44444, 0.07861, 0, 0.59111],
          "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
          "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
          "114": [0, 0.44444, 0.11111, 0, 0.50167],
          "115": [0, 0.44444, 0.08167, 0, 0.48694],
          "116": [0, 0.63492, 0.09639, 0, 0.385],
          "117": [0, 0.44444, 0.09426, 0, 0.62055],
          "118": [0, 0.44444, 0.11111, 0, 0.53222],
          "119": [0, 0.44444, 0.11111, 0, 0.76777],
          "120": [0, 0.44444, 0.12583, 0, 0.56055],
          "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
          "122": [0, 0.44444, 0.13889, 0, 0.49055],
          "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.69444, 0.11473, 0, 0.59111],
          "176": [0, 0.69444, 0, 0, 0.94888],
          "184": [0.17014, 0, 0, 0, 0.53222],
          "198": [0, 0.68611, 0.11431, 0, 1.02277],
          "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
          "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
          "230": [0, 0.44444, 0.085, 0, 0.82666],
          "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
          "305": [0, 0.44444, 0.09426, 0, 0.35555],
          "338": [0, 0.68611, 0.11431, 0, 1.14054],
          "339": [0, 0.44444, 0.085, 0, 0.82666],
          "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
          "710": [0, 0.69444, 0.06709, 0, 0.59111],
          "711": [0, 0.63194, 0.08271, 0, 0.59111],
          "713": [0, 0.59444, 0.10444, 0, 0.59111],
          "714": [0, 0.69444, 0.08528, 0, 0.59111],
          "715": [0, 0.69444, 0, 0, 0.59111],
          "728": [0, 0.69444, 0.10333, 0, 0.59111],
          "729": [0, 0.69444, 0.12945, 0, 0.35555],
          "730": [0, 0.69444, 0, 0, 0.94888],
          "732": [0, 0.69444, 0.11472, 0, 0.59111],
          "733": [0, 0.69444, 0.11472, 0, 0.59111],
          "915": [0, 0.68611, 0.12903, 0, 0.69777],
          "916": [0, 0.68611, 0, 0, 0.94444],
          "920": [0, 0.68611, 0.09062, 0, 0.88555],
          "923": [0, 0.68611, 0, 0, 0.80666],
          "926": [0, 0.68611, 0.15092, 0, 0.76777],
          "928": [0, 0.68611, 0.17208, 0, 0.8961],
          "931": [0, 0.68611, 0.11431, 0, 0.82666],
          "933": [0, 0.68611, 0.10778, 0, 0.88555],
          "934": [0, 0.68611, 0.05632, 0, 0.82666],
          "936": [0, 0.68611, 0.10778, 0, 0.88555],
          "937": [0, 0.68611, 0.0992, 0, 0.82666],
          "8211": [0, 0.44444, 0.09811, 0, 0.59111],
          "8212": [0, 0.44444, 0.09811, 0, 1.18221],
          "8216": [0, 0.69444, 0.12945, 0, 0.35555],
          "8217": [0, 0.69444, 0.12945, 0, 0.35555],
          "8220": [0, 0.69444, 0.16772, 0, 0.62055],
          "8221": [0, 0.69444, 0.07939, 0, 0.62055]
        },
        "Main-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.12417, 0, 0.30667],
          "34": [0, 0.69444, 0.06961, 0, 0.51444],
          "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
          "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
          "38": [0, 0.69444, 0.09694, 0, 0.76666],
          "39": [0, 0.69444, 0.12417, 0, 0.30667],
          "40": [0.25, 0.75, 0.16194, 0, 0.40889],
          "41": [0.25, 0.75, 0.03694, 0, 0.40889],
          "42": [0, 0.75, 0.14917, 0, 0.51111],
          "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
          "44": [0.19444, 0.10556, 0, 0, 0.30667],
          "45": [0, 0.43056, 0.02826, 0, 0.35778],
          "46": [0, 0.10556, 0, 0, 0.30667],
          "47": [0.25, 0.75, 0.16194, 0, 0.51111],
          "48": [0, 0.64444, 0.13556, 0, 0.51111],
          "49": [0, 0.64444, 0.13556, 0, 0.51111],
          "50": [0, 0.64444, 0.13556, 0, 0.51111],
          "51": [0, 0.64444, 0.13556, 0, 0.51111],
          "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
          "53": [0, 0.64444, 0.13556, 0, 0.51111],
          "54": [0, 0.64444, 0.13556, 0, 0.51111],
          "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
          "56": [0, 0.64444, 0.13556, 0, 0.51111],
          "57": [0, 0.64444, 0.13556, 0, 0.51111],
          "58": [0, 0.43056, 0.0582, 0, 0.30667],
          "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
          "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
          "63": [0, 0.69444, 0.1225, 0, 0.51111],
          "64": [0, 0.69444, 0.09597, 0, 0.76666],
          "65": [0, 0.68333, 0, 0, 0.74333],
          "66": [0, 0.68333, 0.10257, 0, 0.70389],
          "67": [0, 0.68333, 0.14528, 0, 0.71555],
          "68": [0, 0.68333, 0.09403, 0, 0.755],
          "69": [0, 0.68333, 0.12028, 0, 0.67833],
          "70": [0, 0.68333, 0.13305, 0, 0.65277],
          "71": [0, 0.68333, 0.08722, 0, 0.77361],
          "72": [0, 0.68333, 0.16389, 0, 0.74333],
          "73": [0, 0.68333, 0.15806, 0, 0.38555],
          "74": [0, 0.68333, 0.14028, 0, 0.525],
          "75": [0, 0.68333, 0.14528, 0, 0.76888],
          "76": [0, 0.68333, 0, 0, 0.62722],
          "77": [0, 0.68333, 0.16389, 0, 0.89666],
          "78": [0, 0.68333, 0.16389, 0, 0.74333],
          "79": [0, 0.68333, 0.09403, 0, 0.76666],
          "80": [0, 0.68333, 0.10257, 0, 0.67833],
          "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
          "82": [0, 0.68333, 0.03868, 0, 0.72944],
          "83": [0, 0.68333, 0.11972, 0, 0.56222],
          "84": [0, 0.68333, 0.13305, 0, 0.71555],
          "85": [0, 0.68333, 0.16389, 0, 0.74333],
          "86": [0, 0.68333, 0.18361, 0, 0.74333],
          "87": [0, 0.68333, 0.18361, 0, 0.99888],
          "88": [0, 0.68333, 0.15806, 0, 0.74333],
          "89": [0, 0.68333, 0.19383, 0, 0.74333],
          "90": [0, 0.68333, 0.14528, 0, 0.61333],
          "91": [0.25, 0.75, 0.1875, 0, 0.30667],
          "93": [0.25, 0.75, 0.10528, 0, 0.30667],
          "94": [0, 0.69444, 0.06646, 0, 0.51111],
          "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
          "97": [0, 0.43056, 0.07671, 0, 0.51111],
          "98": [0, 0.69444, 0.06312, 0, 0.46],
          "99": [0, 0.43056, 0.05653, 0, 0.46],
          "100": [0, 0.69444, 0.10333, 0, 0.51111],
          "101": [0, 0.43056, 0.07514, 0, 0.46],
          "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
          "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
          "104": [0, 0.69444, 0.07671, 0, 0.51111],
          "105": [0, 0.65536, 0.1019, 0, 0.30667],
          "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
          "107": [0, 0.69444, 0.10764, 0, 0.46],
          "108": [0, 0.69444, 0.10333, 0, 0.25555],
          "109": [0, 0.43056, 0.07671, 0, 0.81777],
          "110": [0, 0.43056, 0.07671, 0, 0.56222],
          "111": [0, 0.43056, 0.06312, 0, 0.51111],
          "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
          "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
          "114": [0, 0.43056, 0.10764, 0, 0.42166],
          "115": [0, 0.43056, 0.08208, 0, 0.40889],
          "116": [0, 0.61508, 0.09486, 0, 0.33222],
          "117": [0, 0.43056, 0.07671, 0, 0.53666],
          "118": [0, 0.43056, 0.10764, 0, 0.46],
          "119": [0, 0.43056, 0.10764, 0, 0.66444],
          "120": [0, 0.43056, 0.12042, 0, 0.46389],
          "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
          "122": [0, 0.43056, 0.12292, 0, 0.40889],
          "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.66786, 0.10474, 0, 0.51111],
          "176": [0, 0.69444, 0, 0, 0.83129],
          "184": [0.17014, 0, 0, 0, 0.46],
          "198": [0, 0.68333, 0.12028, 0, 0.88277],
          "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
          "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
          "230": [0, 0.43056, 0.07514, 0, 0.71555],
          "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
          "338": [0, 0.68333, 0.12028, 0, 0.98499],
          "339": [0, 0.43056, 0.07514, 0, 0.71555],
          "710": [0, 0.69444, 0.06646, 0, 0.51111],
          "711": [0, 0.62847, 0.08295, 0, 0.51111],
          "713": [0, 0.56167, 0.10333, 0, 0.51111],
          "714": [0, 0.69444, 0.09694, 0, 0.51111],
          "715": [0, 0.69444, 0, 0, 0.51111],
          "728": [0, 0.69444, 0.10806, 0, 0.51111],
          "729": [0, 0.66786, 0.11752, 0, 0.30667],
          "730": [0, 0.69444, 0, 0, 0.83129],
          "732": [0, 0.66786, 0.11585, 0, 0.51111],
          "733": [0, 0.69444, 0.1225, 0, 0.51111],
          "915": [0, 0.68333, 0.13305, 0, 0.62722],
          "916": [0, 0.68333, 0, 0, 0.81777],
          "920": [0, 0.68333, 0.09403, 0, 0.76666],
          "923": [0, 0.68333, 0, 0, 0.69222],
          "926": [0, 0.68333, 0.15294, 0, 0.66444],
          "928": [0, 0.68333, 0.16389, 0, 0.74333],
          "931": [0, 0.68333, 0.12028, 0, 0.71555],
          "933": [0, 0.68333, 0.11111, 0, 0.76666],
          "934": [0, 0.68333, 0.05986, 0, 0.71555],
          "936": [0, 0.68333, 0.11111, 0, 0.76666],
          "937": [0, 0.68333, 0.10257, 0, 0.71555],
          "8211": [0, 0.43056, 0.09208, 0, 0.51111],
          "8212": [0, 0.43056, 0.09208, 0, 1.02222],
          "8216": [0, 0.69444, 0.12417, 0, 0.30667],
          "8217": [0, 0.69444, 0.12417, 0, 0.30667],
          "8220": [0, 0.69444, 0.1685, 0, 0.51444],
          "8221": [0, 0.69444, 0.06961, 0, 0.51444],
          "8463": [0, 0.68889, 0, 0, 0.54028]
        },
        "Main-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.27778],
          "34": [0, 0.69444, 0, 0, 0.5],
          "35": [0.19444, 0.69444, 0, 0, 0.83334],
          "36": [0.05556, 0.75, 0, 0, 0.5],
          "37": [0.05556, 0.75, 0, 0, 0.83334],
          "38": [0, 0.69444, 0, 0, 0.77778],
          "39": [0, 0.69444, 0, 0, 0.27778],
          "40": [0.25, 0.75, 0, 0, 0.38889],
          "41": [0.25, 0.75, 0, 0, 0.38889],
          "42": [0, 0.75, 0, 0, 0.5],
          "43": [0.08333, 0.58333, 0, 0, 0.77778],
          "44": [0.19444, 0.10556, 0, 0, 0.27778],
          "45": [0, 0.43056, 0, 0, 0.33333],
          "46": [0, 0.10556, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0, 0, 0.5],
          "48": [0, 0.64444, 0, 0, 0.5],
          "49": [0, 0.64444, 0, 0, 0.5],
          "50": [0, 0.64444, 0, 0, 0.5],
          "51": [0, 0.64444, 0, 0, 0.5],
          "52": [0, 0.64444, 0, 0, 0.5],
          "53": [0, 0.64444, 0, 0, 0.5],
          "54": [0, 0.64444, 0, 0, 0.5],
          "55": [0, 0.64444, 0, 0, 0.5],
          "56": [0, 0.64444, 0, 0, 0.5],
          "57": [0, 0.64444, 0, 0, 0.5],
          "58": [0, 0.43056, 0, 0, 0.27778],
          "59": [0.19444, 0.43056, 0, 0, 0.27778],
          "60": [0.0391, 0.5391, 0, 0, 0.77778],
          "61": [-0.13313, 0.36687, 0, 0, 0.77778],
          "62": [0.0391, 0.5391, 0, 0, 0.77778],
          "63": [0, 0.69444, 0, 0, 0.47222],
          "64": [0, 0.69444, 0, 0, 0.77778],
          "65": [0, 0.68333, 0, 0, 0.75],
          "66": [0, 0.68333, 0, 0, 0.70834],
          "67": [0, 0.68333, 0, 0, 0.72222],
          "68": [0, 0.68333, 0, 0, 0.76389],
          "69": [0, 0.68333, 0, 0, 0.68056],
          "70": [0, 0.68333, 0, 0, 0.65278],
          "71": [0, 0.68333, 0, 0, 0.78472],
          "72": [0, 0.68333, 0, 0, 0.75],
          "73": [0, 0.68333, 0, 0, 0.36111],
          "74": [0, 0.68333, 0, 0, 0.51389],
          "75": [0, 0.68333, 0, 0, 0.77778],
          "76": [0, 0.68333, 0, 0, 0.625],
          "77": [0, 0.68333, 0, 0, 0.91667],
          "78": [0, 0.68333, 0, 0, 0.75],
          "79": [0, 0.68333, 0, 0, 0.77778],
          "80": [0, 0.68333, 0, 0, 0.68056],
          "81": [0.19444, 0.68333, 0, 0, 0.77778],
          "82": [0, 0.68333, 0, 0, 0.73611],
          "83": [0, 0.68333, 0, 0, 0.55556],
          "84": [0, 0.68333, 0, 0, 0.72222],
          "85": [0, 0.68333, 0, 0, 0.75],
          "86": [0, 0.68333, 0.01389, 0, 0.75],
          "87": [0, 0.68333, 0.01389, 0, 1.02778],
          "88": [0, 0.68333, 0, 0, 0.75],
          "89": [0, 0.68333, 0.025, 0, 0.75],
          "90": [0, 0.68333, 0, 0, 0.61111],
          "91": [0.25, 0.75, 0, 0, 0.27778],
          "92": [0.25, 0.75, 0, 0, 0.5],
          "93": [0.25, 0.75, 0, 0, 0.27778],
          "94": [0, 0.69444, 0, 0, 0.5],
          "95": [0.31, 0.12056, 0.02778, 0, 0.5],
          "97": [0, 0.43056, 0, 0, 0.5],
          "98": [0, 0.69444, 0, 0, 0.55556],
          "99": [0, 0.43056, 0, 0, 0.44445],
          "100": [0, 0.69444, 0, 0, 0.55556],
          "101": [0, 0.43056, 0, 0, 0.44445],
          "102": [0, 0.69444, 0.07778, 0, 0.30556],
          "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
          "104": [0, 0.69444, 0, 0, 0.55556],
          "105": [0, 0.66786, 0, 0, 0.27778],
          "106": [0.19444, 0.66786, 0, 0, 0.30556],
          "107": [0, 0.69444, 0, 0, 0.52778],
          "108": [0, 0.69444, 0, 0, 0.27778],
          "109": [0, 0.43056, 0, 0, 0.83334],
          "110": [0, 0.43056, 0, 0, 0.55556],
          "111": [0, 0.43056, 0, 0, 0.5],
          "112": [0.19444, 0.43056, 0, 0, 0.55556],
          "113": [0.19444, 0.43056, 0, 0, 0.52778],
          "114": [0, 0.43056, 0, 0, 0.39167],
          "115": [0, 0.43056, 0, 0, 0.39445],
          "116": [0, 0.61508, 0, 0, 0.38889],
          "117": [0, 0.43056, 0, 0, 0.55556],
          "118": [0, 0.43056, 0.01389, 0, 0.52778],
          "119": [0, 0.43056, 0.01389, 0, 0.72222],
          "120": [0, 0.43056, 0, 0, 0.52778],
          "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
          "122": [0, 0.43056, 0, 0, 0.44445],
          "123": [0.25, 0.75, 0, 0, 0.5],
          "124": [0.25, 0.75, 0, 0, 0.27778],
          "125": [0.25, 0.75, 0, 0, 0.5],
          "126": [0.35, 0.31786, 0, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "163": [0, 0.69444, 0, 0, 0.76909],
          "167": [0.19444, 0.69444, 0, 0, 0.44445],
          "168": [0, 0.66786, 0, 0, 0.5],
          "172": [0, 0.43056, 0, 0, 0.66667],
          "176": [0, 0.69444, 0, 0, 0.75],
          "177": [0.08333, 0.58333, 0, 0, 0.77778],
          "182": [0.19444, 0.69444, 0, 0, 0.61111],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "198": [0, 0.68333, 0, 0, 0.90278],
          "215": [0.08333, 0.58333, 0, 0, 0.77778],
          "216": [0.04861, 0.73194, 0, 0, 0.77778],
          "223": [0, 0.69444, 0, 0, 0.5],
          "230": [0, 0.43056, 0, 0, 0.72222],
          "247": [0.08333, 0.58333, 0, 0, 0.77778],
          "248": [0.09722, 0.52778, 0, 0, 0.5],
          "305": [0, 0.43056, 0, 0, 0.27778],
          "338": [0, 0.68333, 0, 0, 1.01389],
          "339": [0, 0.43056, 0, 0, 0.77778],
          "567": [0.19444, 0.43056, 0, 0, 0.30556],
          "710": [0, 0.69444, 0, 0, 0.5],
          "711": [0, 0.62847, 0, 0, 0.5],
          "713": [0, 0.56778, 0, 0, 0.5],
          "714": [0, 0.69444, 0, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0, 0, 0.5],
          "729": [0, 0.66786, 0, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.75],
          "732": [0, 0.66786, 0, 0, 0.5],
          "733": [0, 0.69444, 0, 0, 0.5],
          "915": [0, 0.68333, 0, 0, 0.625],
          "916": [0, 0.68333, 0, 0, 0.83334],
          "920": [0, 0.68333, 0, 0, 0.77778],
          "923": [0, 0.68333, 0, 0, 0.69445],
          "926": [0, 0.68333, 0, 0, 0.66667],
          "928": [0, 0.68333, 0, 0, 0.75],
          "931": [0, 0.68333, 0, 0, 0.72222],
          "933": [0, 0.68333, 0, 0, 0.77778],
          "934": [0, 0.68333, 0, 0, 0.72222],
          "936": [0, 0.68333, 0, 0, 0.77778],
          "937": [0, 0.68333, 0, 0, 0.72222],
          "8211": [0, 0.43056, 0.02778, 0, 0.5],
          "8212": [0, 0.43056, 0.02778, 0, 1],
          "8216": [0, 0.69444, 0, 0, 0.27778],
          "8217": [0, 0.69444, 0, 0, 0.27778],
          "8220": [0, 0.69444, 0, 0, 0.5],
          "8221": [0, 0.69444, 0, 0, 0.5],
          "8224": [0.19444, 0.69444, 0, 0, 0.44445],
          "8225": [0.19444, 0.69444, 0, 0, 0.44445],
          "8230": [0, 0.123, 0, 0, 1.172],
          "8242": [0, 0.55556, 0, 0, 0.275],
          "8407": [0, 0.71444, 0.15382, 0, 0.5],
          "8463": [0, 0.68889, 0, 0, 0.54028],
          "8465": [0, 0.69444, 0, 0, 0.72222],
          "8467": [0, 0.69444, 0, 0.11111, 0.41667],
          "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
          "8476": [0, 0.69444, 0, 0, 0.72222],
          "8501": [0, 0.69444, 0, 0, 0.61111],
          "8592": [-0.13313, 0.36687, 0, 0, 1],
          "8593": [0.19444, 0.69444, 0, 0, 0.5],
          "8594": [-0.13313, 0.36687, 0, 0, 1],
          "8595": [0.19444, 0.69444, 0, 0, 0.5],
          "8596": [-0.13313, 0.36687, 0, 0, 1],
          "8597": [0.25, 0.75, 0, 0, 0.5],
          "8598": [0.19444, 0.69444, 0, 0, 1],
          "8599": [0.19444, 0.69444, 0, 0, 1],
          "8600": [0.19444, 0.69444, 0, 0, 1],
          "8601": [0.19444, 0.69444, 0, 0, 1],
          "8614": [0.011, 0.511, 0, 0, 1],
          "8617": [0.011, 0.511, 0, 0, 1.126],
          "8618": [0.011, 0.511, 0, 0, 1.126],
          "8636": [-0.13313, 0.36687, 0, 0, 1],
          "8637": [-0.13313, 0.36687, 0, 0, 1],
          "8640": [-0.13313, 0.36687, 0, 0, 1],
          "8641": [-0.13313, 0.36687, 0, 0, 1],
          "8652": [0.011, 0.671, 0, 0, 1],
          "8656": [-0.13313, 0.36687, 0, 0, 1],
          "8657": [0.19444, 0.69444, 0, 0, 0.61111],
          "8658": [-0.13313, 0.36687, 0, 0, 1],
          "8659": [0.19444, 0.69444, 0, 0, 0.61111],
          "8660": [-0.13313, 0.36687, 0, 0, 1],
          "8661": [0.25, 0.75, 0, 0, 0.61111],
          "8704": [0, 0.69444, 0, 0, 0.55556],
          "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
          "8707": [0, 0.69444, 0, 0, 0.55556],
          "8709": [0.05556, 0.75, 0, 0, 0.5],
          "8711": [0, 0.68333, 0, 0, 0.83334],
          "8712": [0.0391, 0.5391, 0, 0, 0.66667],
          "8715": [0.0391, 0.5391, 0, 0, 0.66667],
          "8722": [0.08333, 0.58333, 0, 0, 0.77778],
          "8723": [0.08333, 0.58333, 0, 0, 0.77778],
          "8725": [0.25, 0.75, 0, 0, 0.5],
          "8726": [0.25, 0.75, 0, 0, 0.5],
          "8727": [-0.03472, 0.46528, 0, 0, 0.5],
          "8728": [-0.05555, 0.44445, 0, 0, 0.5],
          "8729": [-0.05555, 0.44445, 0, 0, 0.5],
          "8730": [0.2, 0.8, 0, 0, 0.83334],
          "8733": [0, 0.43056, 0, 0, 0.77778],
          "8734": [0, 0.43056, 0, 0, 1],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8739": [0.25, 0.75, 0, 0, 0.27778],
          "8741": [0.25, 0.75, 0, 0, 0.5],
          "8743": [0, 0.55556, 0, 0, 0.66667],
          "8744": [0, 0.55556, 0, 0, 0.66667],
          "8745": [0, 0.55556, 0, 0, 0.66667],
          "8746": [0, 0.55556, 0, 0, 0.66667],
          "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
          "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8768": [0.19444, 0.69444, 0, 0, 0.27778],
          "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8773": [-0.022, 0.589, 0, 0, 0.778],
          "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
          "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8784": [-0.133, 0.673, 0, 0, 0.778],
          "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8804": [0.13597, 0.63597, 0, 0, 0.77778],
          "8805": [0.13597, 0.63597, 0, 0, 0.77778],
          "8810": [0.0391, 0.5391, 0, 0, 1],
          "8811": [0.0391, 0.5391, 0, 0, 1],
          "8826": [0.0391, 0.5391, 0, 0, 0.77778],
          "8827": [0.0391, 0.5391, 0, 0, 0.77778],
          "8834": [0.0391, 0.5391, 0, 0, 0.77778],
          "8835": [0.0391, 0.5391, 0, 0, 0.77778],
          "8838": [0.13597, 0.63597, 0, 0, 0.77778],
          "8839": [0.13597, 0.63597, 0, 0, 0.77778],
          "8846": [0, 0.55556, 0, 0, 0.66667],
          "8849": [0.13597, 0.63597, 0, 0, 0.77778],
          "8850": [0.13597, 0.63597, 0, 0, 0.77778],
          "8851": [0, 0.55556, 0, 0, 0.66667],
          "8852": [0, 0.55556, 0, 0, 0.66667],
          "8853": [0.08333, 0.58333, 0, 0, 0.77778],
          "8854": [0.08333, 0.58333, 0, 0, 0.77778],
          "8855": [0.08333, 0.58333, 0, 0, 0.77778],
          "8856": [0.08333, 0.58333, 0, 0, 0.77778],
          "8857": [0.08333, 0.58333, 0, 0, 0.77778],
          "8866": [0, 0.69444, 0, 0, 0.61111],
          "8867": [0, 0.69444, 0, 0, 0.61111],
          "8868": [0, 0.69444, 0, 0, 0.77778],
          "8869": [0, 0.69444, 0, 0, 0.77778],
          "8872": [0.249, 0.75, 0, 0, 0.867],
          "8900": [-0.05555, 0.44445, 0, 0, 0.5],
          "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
          "8902": [-0.03472, 0.46528, 0, 0, 0.5],
          "8904": [5e-3, 0.505, 0, 0, 0.9],
          "8942": [0.03, 0.903, 0, 0, 0.278],
          "8943": [-0.19, 0.313, 0, 0, 1.172],
          "8945": [-0.1, 0.823, 0, 0, 1.282],
          "8968": [0.25, 0.75, 0, 0, 0.44445],
          "8969": [0.25, 0.75, 0, 0, 0.44445],
          "8970": [0.25, 0.75, 0, 0, 0.44445],
          "8971": [0.25, 0.75, 0, 0, 0.44445],
          "8994": [-0.14236, 0.35764, 0, 0, 1],
          "8995": [-0.14236, 0.35764, 0, 0, 1],
          "9136": [0.244, 0.744, 0, 0, 0.412],
          "9137": [0.244, 0.745, 0, 0, 0.412],
          "9651": [0.19444, 0.69444, 0, 0, 0.88889],
          "9657": [-0.03472, 0.46528, 0, 0, 0.5],
          "9661": [0.19444, 0.69444, 0, 0, 0.88889],
          "9667": [-0.03472, 0.46528, 0, 0, 0.5],
          "9711": [0.19444, 0.69444, 0, 0, 1],
          "9824": [0.12963, 0.69444, 0, 0, 0.77778],
          "9825": [0.12963, 0.69444, 0, 0, 0.77778],
          "9826": [0.12963, 0.69444, 0, 0, 0.77778],
          "9827": [0.12963, 0.69444, 0, 0, 0.77778],
          "9837": [0, 0.75, 0, 0, 0.38889],
          "9838": [0.19444, 0.69444, 0, 0, 0.38889],
          "9839": [0.19444, 0.69444, 0, 0, 0.38889],
          "10216": [0.25, 0.75, 0, 0, 0.38889],
          "10217": [0.25, 0.75, 0, 0, 0.38889],
          "10222": [0.244, 0.744, 0, 0, 0.412],
          "10223": [0.244, 0.745, 0, 0, 0.412],
          "10229": [0.011, 0.511, 0, 0, 1.609],
          "10230": [0.011, 0.511, 0, 0, 1.638],
          "10231": [0.011, 0.511, 0, 0, 1.859],
          "10232": [0.024, 0.525, 0, 0, 1.609],
          "10233": [0.024, 0.525, 0, 0, 1.638],
          "10234": [0.024, 0.525, 0, 0, 1.858],
          "10236": [0.011, 0.511, 0, 0, 1.638],
          "10815": [0, 0.68333, 0, 0, 0.75],
          "10927": [0.13597, 0.63597, 0, 0, 0.77778],
          "10928": [0.13597, 0.63597, 0, 0, 0.77778],
          "57376": [0.19444, 0.69444, 0, 0, 0]
        },
        "Math-BoldItalic": {
          "32": [0, 0, 0, 0, 0.25],
          "48": [0, 0.44444, 0, 0, 0.575],
          "49": [0, 0.44444, 0, 0, 0.575],
          "50": [0, 0.44444, 0, 0, 0.575],
          "51": [0.19444, 0.44444, 0, 0, 0.575],
          "52": [0.19444, 0.44444, 0, 0, 0.575],
          "53": [0.19444, 0.44444, 0, 0, 0.575],
          "54": [0, 0.64444, 0, 0, 0.575],
          "55": [0.19444, 0.44444, 0, 0, 0.575],
          "56": [0, 0.64444, 0, 0, 0.575],
          "57": [0.19444, 0.44444, 0, 0, 0.575],
          "65": [0, 0.68611, 0, 0, 0.86944],
          "66": [0, 0.68611, 0.04835, 0, 0.8664],
          "67": [0, 0.68611, 0.06979, 0, 0.81694],
          "68": [0, 0.68611, 0.03194, 0, 0.93812],
          "69": [0, 0.68611, 0.05451, 0, 0.81007],
          "70": [0, 0.68611, 0.15972, 0, 0.68889],
          "71": [0, 0.68611, 0, 0, 0.88673],
          "72": [0, 0.68611, 0.08229, 0, 0.98229],
          "73": [0, 0.68611, 0.07778, 0, 0.51111],
          "74": [0, 0.68611, 0.10069, 0, 0.63125],
          "75": [0, 0.68611, 0.06979, 0, 0.97118],
          "76": [0, 0.68611, 0, 0, 0.75555],
          "77": [0, 0.68611, 0.11424, 0, 1.14201],
          "78": [0, 0.68611, 0.11424, 0, 0.95034],
          "79": [0, 0.68611, 0.03194, 0, 0.83666],
          "80": [0, 0.68611, 0.15972, 0, 0.72309],
          "81": [0.19444, 0.68611, 0, 0, 0.86861],
          "82": [0, 0.68611, 421e-5, 0, 0.87235],
          "83": [0, 0.68611, 0.05382, 0, 0.69271],
          "84": [0, 0.68611, 0.15972, 0, 0.63663],
          "85": [0, 0.68611, 0.11424, 0, 0.80027],
          "86": [0, 0.68611, 0.25555, 0, 0.67778],
          "87": [0, 0.68611, 0.15972, 0, 1.09305],
          "88": [0, 0.68611, 0.07778, 0, 0.94722],
          "89": [0, 0.68611, 0.25555, 0, 0.67458],
          "90": [0, 0.68611, 0.06979, 0, 0.77257],
          "97": [0, 0.44444, 0, 0, 0.63287],
          "98": [0, 0.69444, 0, 0, 0.52083],
          "99": [0, 0.44444, 0, 0, 0.51342],
          "100": [0, 0.69444, 0, 0, 0.60972],
          "101": [0, 0.44444, 0, 0, 0.55361],
          "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
          "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
          "104": [0, 0.69444, 0, 0, 0.66759],
          "105": [0, 0.69326, 0, 0, 0.4048],
          "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
          "107": [0, 0.69444, 0.01852, 0, 0.6037],
          "108": [0, 0.69444, 88e-4, 0, 0.34815],
          "109": [0, 0.44444, 0, 0, 1.0324],
          "110": [0, 0.44444, 0, 0, 0.71296],
          "111": [0, 0.44444, 0, 0, 0.58472],
          "112": [0.19444, 0.44444, 0, 0, 0.60092],
          "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
          "114": [0, 0.44444, 0.03194, 0, 0.5287],
          "115": [0, 0.44444, 0, 0, 0.53125],
          "116": [0, 0.63492, 0, 0, 0.41528],
          "117": [0, 0.44444, 0, 0, 0.68102],
          "118": [0, 0.44444, 0.03704, 0, 0.56666],
          "119": [0, 0.44444, 0.02778, 0, 0.83148],
          "120": [0, 0.44444, 0, 0, 0.65903],
          "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
          "122": [0, 0.44444, 0.04213, 0, 0.55509],
          "160": [0, 0, 0, 0, 0.25],
          "915": [0, 0.68611, 0.15972, 0, 0.65694],
          "916": [0, 0.68611, 0, 0, 0.95833],
          "920": [0, 0.68611, 0.03194, 0, 0.86722],
          "923": [0, 0.68611, 0, 0, 0.80555],
          "926": [0, 0.68611, 0.07458, 0, 0.84125],
          "928": [0, 0.68611, 0.08229, 0, 0.98229],
          "931": [0, 0.68611, 0.05451, 0, 0.88507],
          "933": [0, 0.68611, 0.15972, 0, 0.67083],
          "934": [0, 0.68611, 0, 0, 0.76666],
          "936": [0, 0.68611, 0.11653, 0, 0.71402],
          "937": [0, 0.68611, 0.04835, 0, 0.8789],
          "945": [0, 0.44444, 0, 0, 0.76064],
          "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
          "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
          "948": [0, 0.69444, 0.03819, 0, 0.52222],
          "949": [0, 0.44444, 0, 0, 0.52882],
          "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
          "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
          "952": [0, 0.69444, 0.03194, 0, 0.5618],
          "953": [0, 0.44444, 0, 0, 0.41204],
          "954": [0, 0.44444, 0, 0, 0.66759],
          "955": [0, 0.69444, 0, 0, 0.67083],
          "956": [0.19444, 0.44444, 0, 0, 0.70787],
          "957": [0, 0.44444, 0.06898, 0, 0.57685],
          "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
          "959": [0, 0.44444, 0, 0, 0.58472],
          "960": [0, 0.44444, 0.03704, 0, 0.68241],
          "961": [0.19444, 0.44444, 0, 0, 0.6118],
          "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
          "963": [0, 0.44444, 0.03704, 0, 0.68588],
          "964": [0, 0.44444, 0.13472, 0, 0.52083],
          "965": [0, 0.44444, 0.03704, 0, 0.63055],
          "966": [0.19444, 0.44444, 0, 0, 0.74722],
          "967": [0.19444, 0.44444, 0, 0, 0.71805],
          "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
          "969": [0, 0.44444, 0.03704, 0, 0.71782],
          "977": [0, 0.69444, 0, 0, 0.69155],
          "981": [0.19444, 0.69444, 0, 0, 0.7125],
          "982": [0, 0.44444, 0.03194, 0, 0.975],
          "1009": [0.19444, 0.44444, 0, 0, 0.6118],
          "1013": [0, 0.44444, 0, 0, 0.48333],
          "57649": [0, 0.44444, 0, 0, 0.39352],
          "57911": [0.19444, 0.44444, 0, 0, 0.43889]
        },
        "Math-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "48": [0, 0.43056, 0, 0, 0.5],
          "49": [0, 0.43056, 0, 0, 0.5],
          "50": [0, 0.43056, 0, 0, 0.5],
          "51": [0.19444, 0.43056, 0, 0, 0.5],
          "52": [0.19444, 0.43056, 0, 0, 0.5],
          "53": [0.19444, 0.43056, 0, 0, 0.5],
          "54": [0, 0.64444, 0, 0, 0.5],
          "55": [0.19444, 0.43056, 0, 0, 0.5],
          "56": [0, 0.64444, 0, 0, 0.5],
          "57": [0.19444, 0.43056, 0, 0, 0.5],
          "65": [0, 0.68333, 0, 0.13889, 0.75],
          "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
          "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
          "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
          "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
          "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
          "71": [0, 0.68333, 0, 0.08334, 0.78625],
          "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
          "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
          "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
          "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
          "76": [0, 0.68333, 0, 0.02778, 0.68056],
          "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
          "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
          "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
          "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
          "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
          "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
          "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
          "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
          "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
          "86": [0, 0.68333, 0.22222, 0, 0.58333],
          "87": [0, 0.68333, 0.13889, 0, 0.94445],
          "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
          "89": [0, 0.68333, 0.22222, 0, 0.58056],
          "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
          "97": [0, 0.43056, 0, 0, 0.52859],
          "98": [0, 0.69444, 0, 0, 0.42917],
          "99": [0, 0.43056, 0, 0.05556, 0.43276],
          "100": [0, 0.69444, 0, 0.16667, 0.52049],
          "101": [0, 0.43056, 0, 0.05556, 0.46563],
          "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
          "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
          "104": [0, 0.69444, 0, 0, 0.57616],
          "105": [0, 0.65952, 0, 0, 0.34451],
          "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
          "107": [0, 0.69444, 0.03148, 0, 0.5206],
          "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
          "109": [0, 0.43056, 0, 0, 0.87801],
          "110": [0, 0.43056, 0, 0, 0.60023],
          "111": [0, 0.43056, 0, 0.05556, 0.48472],
          "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
          "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
          "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
          "115": [0, 0.43056, 0, 0.05556, 0.46875],
          "116": [0, 0.61508, 0, 0.08334, 0.36111],
          "117": [0, 0.43056, 0, 0.02778, 0.57246],
          "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
          "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
          "120": [0, 0.43056, 0, 0.02778, 0.57153],
          "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
          "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
          "160": [0, 0, 0, 0, 0.25],
          "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
          "916": [0, 0.68333, 0, 0.16667, 0.83334],
          "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
          "923": [0, 0.68333, 0, 0.16667, 0.69445],
          "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
          "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
          "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
          "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
          "934": [0, 0.68333, 0, 0.08334, 0.66667],
          "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
          "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
          "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
          "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
          "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
          "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
          "949": [0, 0.43056, 0, 0.08334, 0.46632],
          "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
          "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
          "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
          "953": [0, 0.43056, 0, 0.05556, 0.35394],
          "954": [0, 0.43056, 0, 0, 0.57616],
          "955": [0, 0.69444, 0, 0, 0.58334],
          "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
          "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
          "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
          "959": [0, 0.43056, 0, 0.05556, 0.48472],
          "960": [0, 0.43056, 0.03588, 0, 0.57003],
          "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
          "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
          "963": [0, 0.43056, 0.03588, 0, 0.57141],
          "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
          "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
          "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
          "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
          "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
          "969": [0, 0.43056, 0.03588, 0, 0.62245],
          "977": [0, 0.69444, 0, 0.08334, 0.59144],
          "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
          "982": [0, 0.43056, 0.02778, 0, 0.82813],
          "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
          "1013": [0, 0.43056, 0, 0.05556, 0.4059],
          "57649": [0, 0.43056, 0, 0.02778, 0.32246],
          "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
        },
        "SansSerif-Bold": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.36667],
          "34": [0, 0.69444, 0, 0, 0.55834],
          "35": [0.19444, 0.69444, 0, 0, 0.91667],
          "36": [0.05556, 0.75, 0, 0, 0.55],
          "37": [0.05556, 0.75, 0, 0, 1.02912],
          "38": [0, 0.69444, 0, 0, 0.83056],
          "39": [0, 0.69444, 0, 0, 0.30556],
          "40": [0.25, 0.75, 0, 0, 0.42778],
          "41": [0.25, 0.75, 0, 0, 0.42778],
          "42": [0, 0.75, 0, 0, 0.55],
          "43": [0.11667, 0.61667, 0, 0, 0.85556],
          "44": [0.10556, 0.13056, 0, 0, 0.30556],
          "45": [0, 0.45833, 0, 0, 0.36667],
          "46": [0, 0.13056, 0, 0, 0.30556],
          "47": [0.25, 0.75, 0, 0, 0.55],
          "48": [0, 0.69444, 0, 0, 0.55],
          "49": [0, 0.69444, 0, 0, 0.55],
          "50": [0, 0.69444, 0, 0, 0.55],
          "51": [0, 0.69444, 0, 0, 0.55],
          "52": [0, 0.69444, 0, 0, 0.55],
          "53": [0, 0.69444, 0, 0, 0.55],
          "54": [0, 0.69444, 0, 0, 0.55],
          "55": [0, 0.69444, 0, 0, 0.55],
          "56": [0, 0.69444, 0, 0, 0.55],
          "57": [0, 0.69444, 0, 0, 0.55],
          "58": [0, 0.45833, 0, 0, 0.30556],
          "59": [0.10556, 0.45833, 0, 0, 0.30556],
          "61": [-0.09375, 0.40625, 0, 0, 0.85556],
          "63": [0, 0.69444, 0, 0, 0.51945],
          "64": [0, 0.69444, 0, 0, 0.73334],
          "65": [0, 0.69444, 0, 0, 0.73334],
          "66": [0, 0.69444, 0, 0, 0.73334],
          "67": [0, 0.69444, 0, 0, 0.70278],
          "68": [0, 0.69444, 0, 0, 0.79445],
          "69": [0, 0.69444, 0, 0, 0.64167],
          "70": [0, 0.69444, 0, 0, 0.61111],
          "71": [0, 0.69444, 0, 0, 0.73334],
          "72": [0, 0.69444, 0, 0, 0.79445],
          "73": [0, 0.69444, 0, 0, 0.33056],
          "74": [0, 0.69444, 0, 0, 0.51945],
          "75": [0, 0.69444, 0, 0, 0.76389],
          "76": [0, 0.69444, 0, 0, 0.58056],
          "77": [0, 0.69444, 0, 0, 0.97778],
          "78": [0, 0.69444, 0, 0, 0.79445],
          "79": [0, 0.69444, 0, 0, 0.79445],
          "80": [0, 0.69444, 0, 0, 0.70278],
          "81": [0.10556, 0.69444, 0, 0, 0.79445],
          "82": [0, 0.69444, 0, 0, 0.70278],
          "83": [0, 0.69444, 0, 0, 0.61111],
          "84": [0, 0.69444, 0, 0, 0.73334],
          "85": [0, 0.69444, 0, 0, 0.76389],
          "86": [0, 0.69444, 0.01528, 0, 0.73334],
          "87": [0, 0.69444, 0.01528, 0, 1.03889],
          "88": [0, 0.69444, 0, 0, 0.73334],
          "89": [0, 0.69444, 0.0275, 0, 0.73334],
          "90": [0, 0.69444, 0, 0, 0.67223],
          "91": [0.25, 0.75, 0, 0, 0.34306],
          "93": [0.25, 0.75, 0, 0, 0.34306],
          "94": [0, 0.69444, 0, 0, 0.55],
          "95": [0.35, 0.10833, 0.03056, 0, 0.55],
          "97": [0, 0.45833, 0, 0, 0.525],
          "98": [0, 0.69444, 0, 0, 0.56111],
          "99": [0, 0.45833, 0, 0, 0.48889],
          "100": [0, 0.69444, 0, 0, 0.56111],
          "101": [0, 0.45833, 0, 0, 0.51111],
          "102": [0, 0.69444, 0.07639, 0, 0.33611],
          "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
          "104": [0, 0.69444, 0, 0, 0.56111],
          "105": [0, 0.69444, 0, 0, 0.25556],
          "106": [0.19444, 0.69444, 0, 0, 0.28611],
          "107": [0, 0.69444, 0, 0, 0.53056],
          "108": [0, 0.69444, 0, 0, 0.25556],
          "109": [0, 0.45833, 0, 0, 0.86667],
          "110": [0, 0.45833, 0, 0, 0.56111],
          "111": [0, 0.45833, 0, 0, 0.55],
          "112": [0.19444, 0.45833, 0, 0, 0.56111],
          "113": [0.19444, 0.45833, 0, 0, 0.56111],
          "114": [0, 0.45833, 0.01528, 0, 0.37222],
          "115": [0, 0.45833, 0, 0, 0.42167],
          "116": [0, 0.58929, 0, 0, 0.40417],
          "117": [0, 0.45833, 0, 0, 0.56111],
          "118": [0, 0.45833, 0.01528, 0, 0.5],
          "119": [0, 0.45833, 0.01528, 0, 0.74445],
          "120": [0, 0.45833, 0, 0, 0.5],
          "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
          "122": [0, 0.45833, 0, 0, 0.47639],
          "126": [0.35, 0.34444, 0, 0, 0.55],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.69444, 0, 0, 0.55],
          "176": [0, 0.69444, 0, 0, 0.73334],
          "180": [0, 0.69444, 0, 0, 0.55],
          "184": [0.17014, 0, 0, 0, 0.48889],
          "305": [0, 0.45833, 0, 0, 0.25556],
          "567": [0.19444, 0.45833, 0, 0, 0.28611],
          "710": [0, 0.69444, 0, 0, 0.55],
          "711": [0, 0.63542, 0, 0, 0.55],
          "713": [0, 0.63778, 0, 0, 0.55],
          "728": [0, 0.69444, 0, 0, 0.55],
          "729": [0, 0.69444, 0, 0, 0.30556],
          "730": [0, 0.69444, 0, 0, 0.73334],
          "732": [0, 0.69444, 0, 0, 0.55],
          "733": [0, 0.69444, 0, 0, 0.55],
          "915": [0, 0.69444, 0, 0, 0.58056],
          "916": [0, 0.69444, 0, 0, 0.91667],
          "920": [0, 0.69444, 0, 0, 0.85556],
          "923": [0, 0.69444, 0, 0, 0.67223],
          "926": [0, 0.69444, 0, 0, 0.73334],
          "928": [0, 0.69444, 0, 0, 0.79445],
          "931": [0, 0.69444, 0, 0, 0.79445],
          "933": [0, 0.69444, 0, 0, 0.85556],
          "934": [0, 0.69444, 0, 0, 0.79445],
          "936": [0, 0.69444, 0, 0, 0.85556],
          "937": [0, 0.69444, 0, 0, 0.79445],
          "8211": [0, 0.45833, 0.03056, 0, 0.55],
          "8212": [0, 0.45833, 0.03056, 0, 1.10001],
          "8216": [0, 0.69444, 0, 0, 0.30556],
          "8217": [0, 0.69444, 0, 0, 0.30556],
          "8220": [0, 0.69444, 0, 0, 0.55834],
          "8221": [0, 0.69444, 0, 0, 0.55834]
        },
        "SansSerif-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.05733, 0, 0.31945],
          "34": [0, 0.69444, 316e-5, 0, 0.5],
          "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
          "36": [0.05556, 0.75, 0.11156, 0, 0.5],
          "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
          "38": [0, 0.69444, 0.03058, 0, 0.75834],
          "39": [0, 0.69444, 0.07816, 0, 0.27778],
          "40": [0.25, 0.75, 0.13164, 0, 0.38889],
          "41": [0.25, 0.75, 0.02536, 0, 0.38889],
          "42": [0, 0.75, 0.11775, 0, 0.5],
          "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
          "44": [0.125, 0.08333, 0, 0, 0.27778],
          "45": [0, 0.44444, 0.01946, 0, 0.33333],
          "46": [0, 0.08333, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0.13164, 0, 0.5],
          "48": [0, 0.65556, 0.11156, 0, 0.5],
          "49": [0, 0.65556, 0.11156, 0, 0.5],
          "50": [0, 0.65556, 0.11156, 0, 0.5],
          "51": [0, 0.65556, 0.11156, 0, 0.5],
          "52": [0, 0.65556, 0.11156, 0, 0.5],
          "53": [0, 0.65556, 0.11156, 0, 0.5],
          "54": [0, 0.65556, 0.11156, 0, 0.5],
          "55": [0, 0.65556, 0.11156, 0, 0.5],
          "56": [0, 0.65556, 0.11156, 0, 0.5],
          "57": [0, 0.65556, 0.11156, 0, 0.5],
          "58": [0, 0.44444, 0.02502, 0, 0.27778],
          "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
          "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
          "63": [0, 0.69444, 0.11809, 0, 0.47222],
          "64": [0, 0.69444, 0.07555, 0, 0.66667],
          "65": [0, 0.69444, 0, 0, 0.66667],
          "66": [0, 0.69444, 0.08293, 0, 0.66667],
          "67": [0, 0.69444, 0.11983, 0, 0.63889],
          "68": [0, 0.69444, 0.07555, 0, 0.72223],
          "69": [0, 0.69444, 0.11983, 0, 0.59722],
          "70": [0, 0.69444, 0.13372, 0, 0.56945],
          "71": [0, 0.69444, 0.11983, 0, 0.66667],
          "72": [0, 0.69444, 0.08094, 0, 0.70834],
          "73": [0, 0.69444, 0.13372, 0, 0.27778],
          "74": [0, 0.69444, 0.08094, 0, 0.47222],
          "75": [0, 0.69444, 0.11983, 0, 0.69445],
          "76": [0, 0.69444, 0, 0, 0.54167],
          "77": [0, 0.69444, 0.08094, 0, 0.875],
          "78": [0, 0.69444, 0.08094, 0, 0.70834],
          "79": [0, 0.69444, 0.07555, 0, 0.73611],
          "80": [0, 0.69444, 0.08293, 0, 0.63889],
          "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
          "82": [0, 0.69444, 0.08293, 0, 0.64584],
          "83": [0, 0.69444, 0.09205, 0, 0.55556],
          "84": [0, 0.69444, 0.13372, 0, 0.68056],
          "85": [0, 0.69444, 0.08094, 0, 0.6875],
          "86": [0, 0.69444, 0.1615, 0, 0.66667],
          "87": [0, 0.69444, 0.1615, 0, 0.94445],
          "88": [0, 0.69444, 0.13372, 0, 0.66667],
          "89": [0, 0.69444, 0.17261, 0, 0.66667],
          "90": [0, 0.69444, 0.11983, 0, 0.61111],
          "91": [0.25, 0.75, 0.15942, 0, 0.28889],
          "93": [0.25, 0.75, 0.08719, 0, 0.28889],
          "94": [0, 0.69444, 0.0799, 0, 0.5],
          "95": [0.35, 0.09444, 0.08616, 0, 0.5],
          "97": [0, 0.44444, 981e-5, 0, 0.48056],
          "98": [0, 0.69444, 0.03057, 0, 0.51667],
          "99": [0, 0.44444, 0.08336, 0, 0.44445],
          "100": [0, 0.69444, 0.09483, 0, 0.51667],
          "101": [0, 0.44444, 0.06778, 0, 0.44445],
          "102": [0, 0.69444, 0.21705, 0, 0.30556],
          "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
          "104": [0, 0.69444, 0.01778, 0, 0.51667],
          "105": [0, 0.67937, 0.09718, 0, 0.23889],
          "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
          "107": [0, 0.69444, 0.08336, 0, 0.48889],
          "108": [0, 0.69444, 0.09483, 0, 0.23889],
          "109": [0, 0.44444, 0.01778, 0, 0.79445],
          "110": [0, 0.44444, 0.01778, 0, 0.51667],
          "111": [0, 0.44444, 0.06613, 0, 0.5],
          "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
          "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
          "114": [0, 0.44444, 0.10836, 0, 0.34167],
          "115": [0, 0.44444, 0.0778, 0, 0.38333],
          "116": [0, 0.57143, 0.07225, 0, 0.36111],
          "117": [0, 0.44444, 0.04169, 0, 0.51667],
          "118": [0, 0.44444, 0.10836, 0, 0.46111],
          "119": [0, 0.44444, 0.10836, 0, 0.68334],
          "120": [0, 0.44444, 0.09169, 0, 0.46111],
          "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
          "122": [0, 0.44444, 0.08752, 0, 0.43472],
          "126": [0.35, 0.32659, 0.08826, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.67937, 0.06385, 0, 0.5],
          "176": [0, 0.69444, 0, 0, 0.73752],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "305": [0, 0.44444, 0.04169, 0, 0.23889],
          "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
          "710": [0, 0.69444, 0.0799, 0, 0.5],
          "711": [0, 0.63194, 0.08432, 0, 0.5],
          "713": [0, 0.60889, 0.08776, 0, 0.5],
          "714": [0, 0.69444, 0.09205, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0.09483, 0, 0.5],
          "729": [0, 0.67937, 0.07774, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.73752],
          "732": [0, 0.67659, 0.08826, 0, 0.5],
          "733": [0, 0.69444, 0.09205, 0, 0.5],
          "915": [0, 0.69444, 0.13372, 0, 0.54167],
          "916": [0, 0.69444, 0, 0, 0.83334],
          "920": [0, 0.69444, 0.07555, 0, 0.77778],
          "923": [0, 0.69444, 0, 0, 0.61111],
          "926": [0, 0.69444, 0.12816, 0, 0.66667],
          "928": [0, 0.69444, 0.08094, 0, 0.70834],
          "931": [0, 0.69444, 0.11983, 0, 0.72222],
          "933": [0, 0.69444, 0.09031, 0, 0.77778],
          "934": [0, 0.69444, 0.04603, 0, 0.72222],
          "936": [0, 0.69444, 0.09031, 0, 0.77778],
          "937": [0, 0.69444, 0.08293, 0, 0.72222],
          "8211": [0, 0.44444, 0.08616, 0, 0.5],
          "8212": [0, 0.44444, 0.08616, 0, 1],
          "8216": [0, 0.69444, 0.07816, 0, 0.27778],
          "8217": [0, 0.69444, 0.07816, 0, 0.27778],
          "8220": [0, 0.69444, 0.14205, 0, 0.5],
          "8221": [0, 0.69444, 316e-5, 0, 0.5]
        },
        "SansSerif-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.31945],
          "34": [0, 0.69444, 0, 0, 0.5],
          "35": [0.19444, 0.69444, 0, 0, 0.83334],
          "36": [0.05556, 0.75, 0, 0, 0.5],
          "37": [0.05556, 0.75, 0, 0, 0.83334],
          "38": [0, 0.69444, 0, 0, 0.75834],
          "39": [0, 0.69444, 0, 0, 0.27778],
          "40": [0.25, 0.75, 0, 0, 0.38889],
          "41": [0.25, 0.75, 0, 0, 0.38889],
          "42": [0, 0.75, 0, 0, 0.5],
          "43": [0.08333, 0.58333, 0, 0, 0.77778],
          "44": [0.125, 0.08333, 0, 0, 0.27778],
          "45": [0, 0.44444, 0, 0, 0.33333],
          "46": [0, 0.08333, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0, 0, 0.5],
          "48": [0, 0.65556, 0, 0, 0.5],
          "49": [0, 0.65556, 0, 0, 0.5],
          "50": [0, 0.65556, 0, 0, 0.5],
          "51": [0, 0.65556, 0, 0, 0.5],
          "52": [0, 0.65556, 0, 0, 0.5],
          "53": [0, 0.65556, 0, 0, 0.5],
          "54": [0, 0.65556, 0, 0, 0.5],
          "55": [0, 0.65556, 0, 0, 0.5],
          "56": [0, 0.65556, 0, 0, 0.5],
          "57": [0, 0.65556, 0, 0, 0.5],
          "58": [0, 0.44444, 0, 0, 0.27778],
          "59": [0.125, 0.44444, 0, 0, 0.27778],
          "61": [-0.13, 0.37, 0, 0, 0.77778],
          "63": [0, 0.69444, 0, 0, 0.47222],
          "64": [0, 0.69444, 0, 0, 0.66667],
          "65": [0, 0.69444, 0, 0, 0.66667],
          "66": [0, 0.69444, 0, 0, 0.66667],
          "67": [0, 0.69444, 0, 0, 0.63889],
          "68": [0, 0.69444, 0, 0, 0.72223],
          "69": [0, 0.69444, 0, 0, 0.59722],
          "70": [0, 0.69444, 0, 0, 0.56945],
          "71": [0, 0.69444, 0, 0, 0.66667],
          "72": [0, 0.69444, 0, 0, 0.70834],
          "73": [0, 0.69444, 0, 0, 0.27778],
          "74": [0, 0.69444, 0, 0, 0.47222],
          "75": [0, 0.69444, 0, 0, 0.69445],
          "76": [0, 0.69444, 0, 0, 0.54167],
          "77": [0, 0.69444, 0, 0, 0.875],
          "78": [0, 0.69444, 0, 0, 0.70834],
          "79": [0, 0.69444, 0, 0, 0.73611],
          "80": [0, 0.69444, 0, 0, 0.63889],
          "81": [0.125, 0.69444, 0, 0, 0.73611],
          "82": [0, 0.69444, 0, 0, 0.64584],
          "83": [0, 0.69444, 0, 0, 0.55556],
          "84": [0, 0.69444, 0, 0, 0.68056],
          "85": [0, 0.69444, 0, 0, 0.6875],
          "86": [0, 0.69444, 0.01389, 0, 0.66667],
          "87": [0, 0.69444, 0.01389, 0, 0.94445],
          "88": [0, 0.69444, 0, 0, 0.66667],
          "89": [0, 0.69444, 0.025, 0, 0.66667],
          "90": [0, 0.69444, 0, 0, 0.61111],
          "91": [0.25, 0.75, 0, 0, 0.28889],
          "93": [0.25, 0.75, 0, 0, 0.28889],
          "94": [0, 0.69444, 0, 0, 0.5],
          "95": [0.35, 0.09444, 0.02778, 0, 0.5],
          "97": [0, 0.44444, 0, 0, 0.48056],
          "98": [0, 0.69444, 0, 0, 0.51667],
          "99": [0, 0.44444, 0, 0, 0.44445],
          "100": [0, 0.69444, 0, 0, 0.51667],
          "101": [0, 0.44444, 0, 0, 0.44445],
          "102": [0, 0.69444, 0.06944, 0, 0.30556],
          "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
          "104": [0, 0.69444, 0, 0, 0.51667],
          "105": [0, 0.67937, 0, 0, 0.23889],
          "106": [0.19444, 0.67937, 0, 0, 0.26667],
          "107": [0, 0.69444, 0, 0, 0.48889],
          "108": [0, 0.69444, 0, 0, 0.23889],
          "109": [0, 0.44444, 0, 0, 0.79445],
          "110": [0, 0.44444, 0, 0, 0.51667],
          "111": [0, 0.44444, 0, 0, 0.5],
          "112": [0.19444, 0.44444, 0, 0, 0.51667],
          "113": [0.19444, 0.44444, 0, 0, 0.51667],
          "114": [0, 0.44444, 0.01389, 0, 0.34167],
          "115": [0, 0.44444, 0, 0, 0.38333],
          "116": [0, 0.57143, 0, 0, 0.36111],
          "117": [0, 0.44444, 0, 0, 0.51667],
          "118": [0, 0.44444, 0.01389, 0, 0.46111],
          "119": [0, 0.44444, 0.01389, 0, 0.68334],
          "120": [0, 0.44444, 0, 0, 0.46111],
          "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
          "122": [0, 0.44444, 0, 0, 0.43472],
          "126": [0.35, 0.32659, 0, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.67937, 0, 0, 0.5],
          "176": [0, 0.69444, 0, 0, 0.66667],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "305": [0, 0.44444, 0, 0, 0.23889],
          "567": [0.19444, 0.44444, 0, 0, 0.26667],
          "710": [0, 0.69444, 0, 0, 0.5],
          "711": [0, 0.63194, 0, 0, 0.5],
          "713": [0, 0.60889, 0, 0, 0.5],
          "714": [0, 0.69444, 0, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0, 0, 0.5],
          "729": [0, 0.67937, 0, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.66667],
          "732": [0, 0.67659, 0, 0, 0.5],
          "733": [0, 0.69444, 0, 0, 0.5],
          "915": [0, 0.69444, 0, 0, 0.54167],
          "916": [0, 0.69444, 0, 0, 0.83334],
          "920": [0, 0.69444, 0, 0, 0.77778],
          "923": [0, 0.69444, 0, 0, 0.61111],
          "926": [0, 0.69444, 0, 0, 0.66667],
          "928": [0, 0.69444, 0, 0, 0.70834],
          "931": [0, 0.69444, 0, 0, 0.72222],
          "933": [0, 0.69444, 0, 0, 0.77778],
          "934": [0, 0.69444, 0, 0, 0.72222],
          "936": [0, 0.69444, 0, 0, 0.77778],
          "937": [0, 0.69444, 0, 0, 0.72222],
          "8211": [0, 0.44444, 0.02778, 0, 0.5],
          "8212": [0, 0.44444, 0.02778, 0, 1],
          "8216": [0, 0.69444, 0, 0, 0.27778],
          "8217": [0, 0.69444, 0, 0, 0.27778],
          "8220": [0, 0.69444, 0, 0, 0.5],
          "8221": [0, 0.69444, 0, 0, 0.5]
        },
        "Script-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.7, 0.22925, 0, 0.80253],
          "66": [0, 0.7, 0.04087, 0, 0.90757],
          "67": [0, 0.7, 0.1689, 0, 0.66619],
          "68": [0, 0.7, 0.09371, 0, 0.77443],
          "69": [0, 0.7, 0.18583, 0, 0.56162],
          "70": [0, 0.7, 0.13634, 0, 0.89544],
          "71": [0, 0.7, 0.17322, 0, 0.60961],
          "72": [0, 0.7, 0.29694, 0, 0.96919],
          "73": [0, 0.7, 0.19189, 0, 0.80907],
          "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
          "75": [0, 0.7, 0.31259, 0, 0.91364],
          "76": [0, 0.7, 0.19189, 0, 0.87373],
          "77": [0, 0.7, 0.15981, 0, 1.08031],
          "78": [0, 0.7, 0.3525, 0, 0.9015],
          "79": [0, 0.7, 0.08078, 0, 0.73787],
          "80": [0, 0.7, 0.08078, 0, 1.01262],
          "81": [0, 0.7, 0.03305, 0, 0.88282],
          "82": [0, 0.7, 0.06259, 0, 0.85],
          "83": [0, 0.7, 0.19189, 0, 0.86767],
          "84": [0, 0.7, 0.29087, 0, 0.74697],
          "85": [0, 0.7, 0.25815, 0, 0.79996],
          "86": [0, 0.7, 0.27523, 0, 0.62204],
          "87": [0, 0.7, 0.27523, 0, 0.80532],
          "88": [0, 0.7, 0.26006, 0, 0.94445],
          "89": [0, 0.7, 0.2939, 0, 0.70961],
          "90": [0, 0.7, 0.24037, 0, 0.8212],
          "160": [0, 0, 0, 0, 0.25]
        },
        "Size1-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.35001, 0.85, 0, 0, 0.45834],
          "41": [0.35001, 0.85, 0, 0, 0.45834],
          "47": [0.35001, 0.85, 0, 0, 0.57778],
          "91": [0.35001, 0.85, 0, 0, 0.41667],
          "92": [0.35001, 0.85, 0, 0, 0.57778],
          "93": [0.35001, 0.85, 0, 0, 0.41667],
          "123": [0.35001, 0.85, 0, 0, 0.58334],
          "125": [0.35001, 0.85, 0, 0, 0.58334],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.72222, 0, 0, 0.55556],
          "732": [0, 0.72222, 0, 0, 0.55556],
          "770": [0, 0.72222, 0, 0, 0.55556],
          "771": [0, 0.72222, 0, 0, 0.55556],
          "8214": [-99e-5, 0.601, 0, 0, 0.77778],
          "8593": [1e-5, 0.6, 0, 0, 0.66667],
          "8595": [1e-5, 0.6, 0, 0, 0.66667],
          "8657": [1e-5, 0.6, 0, 0, 0.77778],
          "8659": [1e-5, 0.6, 0, 0, 0.77778],
          "8719": [0.25001, 0.75, 0, 0, 0.94445],
          "8720": [0.25001, 0.75, 0, 0, 0.94445],
          "8721": [0.25001, 0.75, 0, 0, 1.05556],
          "8730": [0.35001, 0.85, 0, 0, 1],
          "8739": [-599e-5, 0.606, 0, 0, 0.33333],
          "8741": [-599e-5, 0.606, 0, 0, 0.55556],
          "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
          "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
          "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
          "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
          "8896": [0.25001, 0.75, 0, 0, 0.83334],
          "8897": [0.25001, 0.75, 0, 0, 0.83334],
          "8898": [0.25001, 0.75, 0, 0, 0.83334],
          "8899": [0.25001, 0.75, 0, 0, 0.83334],
          "8968": [0.35001, 0.85, 0, 0, 0.47222],
          "8969": [0.35001, 0.85, 0, 0, 0.47222],
          "8970": [0.35001, 0.85, 0, 0, 0.47222],
          "8971": [0.35001, 0.85, 0, 0, 0.47222],
          "9168": [-99e-5, 0.601, 0, 0, 0.66667],
          "10216": [0.35001, 0.85, 0, 0, 0.47222],
          "10217": [0.35001, 0.85, 0, 0, 0.47222],
          "10752": [0.25001, 0.75, 0, 0, 1.11111],
          "10753": [0.25001, 0.75, 0, 0, 1.11111],
          "10754": [0.25001, 0.75, 0, 0, 1.11111],
          "10756": [0.25001, 0.75, 0, 0, 0.83334],
          "10758": [0.25001, 0.75, 0, 0, 0.83334]
        },
        "Size2-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.65002, 1.15, 0, 0, 0.59722],
          "41": [0.65002, 1.15, 0, 0, 0.59722],
          "47": [0.65002, 1.15, 0, 0, 0.81111],
          "91": [0.65002, 1.15, 0, 0, 0.47222],
          "92": [0.65002, 1.15, 0, 0, 0.81111],
          "93": [0.65002, 1.15, 0, 0, 0.47222],
          "123": [0.65002, 1.15, 0, 0, 0.66667],
          "125": [0.65002, 1.15, 0, 0, 0.66667],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.75, 0, 0, 1],
          "732": [0, 0.75, 0, 0, 1],
          "770": [0, 0.75, 0, 0, 1],
          "771": [0, 0.75, 0, 0, 1],
          "8719": [0.55001, 1.05, 0, 0, 1.27778],
          "8720": [0.55001, 1.05, 0, 0, 1.27778],
          "8721": [0.55001, 1.05, 0, 0, 1.44445],
          "8730": [0.65002, 1.15, 0, 0, 1],
          "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
          "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
          "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
          "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
          "8896": [0.55001, 1.05, 0, 0, 1.11111],
          "8897": [0.55001, 1.05, 0, 0, 1.11111],
          "8898": [0.55001, 1.05, 0, 0, 1.11111],
          "8899": [0.55001, 1.05, 0, 0, 1.11111],
          "8968": [0.65002, 1.15, 0, 0, 0.52778],
          "8969": [0.65002, 1.15, 0, 0, 0.52778],
          "8970": [0.65002, 1.15, 0, 0, 0.52778],
          "8971": [0.65002, 1.15, 0, 0, 0.52778],
          "10216": [0.65002, 1.15, 0, 0, 0.61111],
          "10217": [0.65002, 1.15, 0, 0, 0.61111],
          "10752": [0.55001, 1.05, 0, 0, 1.51112],
          "10753": [0.55001, 1.05, 0, 0, 1.51112],
          "10754": [0.55001, 1.05, 0, 0, 1.51112],
          "10756": [0.55001, 1.05, 0, 0, 1.11111],
          "10758": [0.55001, 1.05, 0, 0, 1.11111]
        },
        "Size3-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.95003, 1.45, 0, 0, 0.73611],
          "41": [0.95003, 1.45, 0, 0, 0.73611],
          "47": [0.95003, 1.45, 0, 0, 1.04445],
          "91": [0.95003, 1.45, 0, 0, 0.52778],
          "92": [0.95003, 1.45, 0, 0, 1.04445],
          "93": [0.95003, 1.45, 0, 0, 0.52778],
          "123": [0.95003, 1.45, 0, 0, 0.75],
          "125": [0.95003, 1.45, 0, 0, 0.75],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.75, 0, 0, 1.44445],
          "732": [0, 0.75, 0, 0, 1.44445],
          "770": [0, 0.75, 0, 0, 1.44445],
          "771": [0, 0.75, 0, 0, 1.44445],
          "8730": [0.95003, 1.45, 0, 0, 1],
          "8968": [0.95003, 1.45, 0, 0, 0.58334],
          "8969": [0.95003, 1.45, 0, 0, 0.58334],
          "8970": [0.95003, 1.45, 0, 0, 0.58334],
          "8971": [0.95003, 1.45, 0, 0, 0.58334],
          "10216": [0.95003, 1.45, 0, 0, 0.75],
          "10217": [0.95003, 1.45, 0, 0, 0.75]
        },
        "Size4-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [1.25003, 1.75, 0, 0, 0.79167],
          "41": [1.25003, 1.75, 0, 0, 0.79167],
          "47": [1.25003, 1.75, 0, 0, 1.27778],
          "91": [1.25003, 1.75, 0, 0, 0.58334],
          "92": [1.25003, 1.75, 0, 0, 1.27778],
          "93": [1.25003, 1.75, 0, 0, 0.58334],
          "123": [1.25003, 1.75, 0, 0, 0.80556],
          "125": [1.25003, 1.75, 0, 0, 0.80556],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.825, 0, 0, 1.8889],
          "732": [0, 0.825, 0, 0, 1.8889],
          "770": [0, 0.825, 0, 0, 1.8889],
          "771": [0, 0.825, 0, 0, 1.8889],
          "8730": [1.25003, 1.75, 0, 0, 1],
          "8968": [1.25003, 1.75, 0, 0, 0.63889],
          "8969": [1.25003, 1.75, 0, 0, 0.63889],
          "8970": [1.25003, 1.75, 0, 0, 0.63889],
          "8971": [1.25003, 1.75, 0, 0, 0.63889],
          "9115": [0.64502, 1.155, 0, 0, 0.875],
          "9116": [1e-5, 0.6, 0, 0, 0.875],
          "9117": [0.64502, 1.155, 0, 0, 0.875],
          "9118": [0.64502, 1.155, 0, 0, 0.875],
          "9119": [1e-5, 0.6, 0, 0, 0.875],
          "9120": [0.64502, 1.155, 0, 0, 0.875],
          "9121": [0.64502, 1.155, 0, 0, 0.66667],
          "9122": [-99e-5, 0.601, 0, 0, 0.66667],
          "9123": [0.64502, 1.155, 0, 0, 0.66667],
          "9124": [0.64502, 1.155, 0, 0, 0.66667],
          "9125": [-99e-5, 0.601, 0, 0, 0.66667],
          "9126": [0.64502, 1.155, 0, 0, 0.66667],
          "9127": [1e-5, 0.9, 0, 0, 0.88889],
          "9128": [0.65002, 1.15, 0, 0, 0.88889],
          "9129": [0.90001, 0, 0, 0, 0.88889],
          "9130": [0, 0.3, 0, 0, 0.88889],
          "9131": [1e-5, 0.9, 0, 0, 0.88889],
          "9132": [0.65002, 1.15, 0, 0, 0.88889],
          "9133": [0.90001, 0, 0, 0, 0.88889],
          "9143": [0.88502, 0.915, 0, 0, 1.05556],
          "10216": [1.25003, 1.75, 0, 0, 0.80556],
          "10217": [1.25003, 1.75, 0, 0, 0.80556],
          "57344": [-499e-5, 0.605, 0, 0, 1.05556],
          "57345": [-499e-5, 0.605, 0, 0, 1.05556],
          "57680": [0, 0.12, 0, 0, 0.45],
          "57681": [0, 0.12, 0, 0, 0.45],
          "57682": [0, 0.12, 0, 0, 0.45],
          "57683": [0, 0.12, 0, 0, 0.45]
        },
        "Typewriter-Regular": {
          "32": [0, 0, 0, 0, 0.525],
          "33": [0, 0.61111, 0, 0, 0.525],
          "34": [0, 0.61111, 0, 0, 0.525],
          "35": [0, 0.61111, 0, 0, 0.525],
          "36": [0.08333, 0.69444, 0, 0, 0.525],
          "37": [0.08333, 0.69444, 0, 0, 0.525],
          "38": [0, 0.61111, 0, 0, 0.525],
          "39": [0, 0.61111, 0, 0, 0.525],
          "40": [0.08333, 0.69444, 0, 0, 0.525],
          "41": [0.08333, 0.69444, 0, 0, 0.525],
          "42": [0, 0.52083, 0, 0, 0.525],
          "43": [-0.08056, 0.53055, 0, 0, 0.525],
          "44": [0.13889, 0.125, 0, 0, 0.525],
          "45": [-0.08056, 0.53055, 0, 0, 0.525],
          "46": [0, 0.125, 0, 0, 0.525],
          "47": [0.08333, 0.69444, 0, 0, 0.525],
          "48": [0, 0.61111, 0, 0, 0.525],
          "49": [0, 0.61111, 0, 0, 0.525],
          "50": [0, 0.61111, 0, 0, 0.525],
          "51": [0, 0.61111, 0, 0, 0.525],
          "52": [0, 0.61111, 0, 0, 0.525],
          "53": [0, 0.61111, 0, 0, 0.525],
          "54": [0, 0.61111, 0, 0, 0.525],
          "55": [0, 0.61111, 0, 0, 0.525],
          "56": [0, 0.61111, 0, 0, 0.525],
          "57": [0, 0.61111, 0, 0, 0.525],
          "58": [0, 0.43056, 0, 0, 0.525],
          "59": [0.13889, 0.43056, 0, 0, 0.525],
          "60": [-0.05556, 0.55556, 0, 0, 0.525],
          "61": [-0.19549, 0.41562, 0, 0, 0.525],
          "62": [-0.05556, 0.55556, 0, 0, 0.525],
          "63": [0, 0.61111, 0, 0, 0.525],
          "64": [0, 0.61111, 0, 0, 0.525],
          "65": [0, 0.61111, 0, 0, 0.525],
          "66": [0, 0.61111, 0, 0, 0.525],
          "67": [0, 0.61111, 0, 0, 0.525],
          "68": [0, 0.61111, 0, 0, 0.525],
          "69": [0, 0.61111, 0, 0, 0.525],
          "70": [0, 0.61111, 0, 0, 0.525],
          "71": [0, 0.61111, 0, 0, 0.525],
          "72": [0, 0.61111, 0, 0, 0.525],
          "73": [0, 0.61111, 0, 0, 0.525],
          "74": [0, 0.61111, 0, 0, 0.525],
          "75": [0, 0.61111, 0, 0, 0.525],
          "76": [0, 0.61111, 0, 0, 0.525],
          "77": [0, 0.61111, 0, 0, 0.525],
          "78": [0, 0.61111, 0, 0, 0.525],
          "79": [0, 0.61111, 0, 0, 0.525],
          "80": [0, 0.61111, 0, 0, 0.525],
          "81": [0.13889, 0.61111, 0, 0, 0.525],
          "82": [0, 0.61111, 0, 0, 0.525],
          "83": [0, 0.61111, 0, 0, 0.525],
          "84": [0, 0.61111, 0, 0, 0.525],
          "85": [0, 0.61111, 0, 0, 0.525],
          "86": [0, 0.61111, 0, 0, 0.525],
          "87": [0, 0.61111, 0, 0, 0.525],
          "88": [0, 0.61111, 0, 0, 0.525],
          "89": [0, 0.61111, 0, 0, 0.525],
          "90": [0, 0.61111, 0, 0, 0.525],
          "91": [0.08333, 0.69444, 0, 0, 0.525],
          "92": [0.08333, 0.69444, 0, 0, 0.525],
          "93": [0.08333, 0.69444, 0, 0, 0.525],
          "94": [0, 0.61111, 0, 0, 0.525],
          "95": [0.09514, 0, 0, 0, 0.525],
          "96": [0, 0.61111, 0, 0, 0.525],
          "97": [0, 0.43056, 0, 0, 0.525],
          "98": [0, 0.61111, 0, 0, 0.525],
          "99": [0, 0.43056, 0, 0, 0.525],
          "100": [0, 0.61111, 0, 0, 0.525],
          "101": [0, 0.43056, 0, 0, 0.525],
          "102": [0, 0.61111, 0, 0, 0.525],
          "103": [0.22222, 0.43056, 0, 0, 0.525],
          "104": [0, 0.61111, 0, 0, 0.525],
          "105": [0, 0.61111, 0, 0, 0.525],
          "106": [0.22222, 0.61111, 0, 0, 0.525],
          "107": [0, 0.61111, 0, 0, 0.525],
          "108": [0, 0.61111, 0, 0, 0.525],
          "109": [0, 0.43056, 0, 0, 0.525],
          "110": [0, 0.43056, 0, 0, 0.525],
          "111": [0, 0.43056, 0, 0, 0.525],
          "112": [0.22222, 0.43056, 0, 0, 0.525],
          "113": [0.22222, 0.43056, 0, 0, 0.525],
          "114": [0, 0.43056, 0, 0, 0.525],
          "115": [0, 0.43056, 0, 0, 0.525],
          "116": [0, 0.55358, 0, 0, 0.525],
          "117": [0, 0.43056, 0, 0, 0.525],
          "118": [0, 0.43056, 0, 0, 0.525],
          "119": [0, 0.43056, 0, 0, 0.525],
          "120": [0, 0.43056, 0, 0, 0.525],
          "121": [0.22222, 0.43056, 0, 0, 0.525],
          "122": [0, 0.43056, 0, 0, 0.525],
          "123": [0.08333, 0.69444, 0, 0, 0.525],
          "124": [0.08333, 0.69444, 0, 0, 0.525],
          "125": [0.08333, 0.69444, 0, 0, 0.525],
          "126": [0, 0.61111, 0, 0, 0.525],
          "127": [0, 0.61111, 0, 0, 0.525],
          "160": [0, 0, 0, 0, 0.525],
          "176": [0, 0.61111, 0, 0, 0.525],
          "184": [0.19445, 0, 0, 0, 0.525],
          "305": [0, 0.43056, 0, 0, 0.525],
          "567": [0.22222, 0.43056, 0, 0, 0.525],
          "711": [0, 0.56597, 0, 0, 0.525],
          "713": [0, 0.56555, 0, 0, 0.525],
          "714": [0, 0.61111, 0, 0, 0.525],
          "715": [0, 0.61111, 0, 0, 0.525],
          "728": [0, 0.61111, 0, 0, 0.525],
          "730": [0, 0.61111, 0, 0, 0.525],
          "770": [0, 0.61111, 0, 0, 0.525],
          "771": [0, 0.61111, 0, 0, 0.525],
          "776": [0, 0.61111, 0, 0, 0.525],
          "915": [0, 0.61111, 0, 0, 0.525],
          "916": [0, 0.61111, 0, 0, 0.525],
          "920": [0, 0.61111, 0, 0, 0.525],
          "923": [0, 0.61111, 0, 0, 0.525],
          "926": [0, 0.61111, 0, 0, 0.525],
          "928": [0, 0.61111, 0, 0, 0.525],
          "931": [0, 0.61111, 0, 0, 0.525],
          "933": [0, 0.61111, 0, 0, 0.525],
          "934": [0, 0.61111, 0, 0, 0.525],
          "936": [0, 0.61111, 0, 0, 0.525],
          "937": [0, 0.61111, 0, 0, 0.525],
          "8216": [0, 0.61111, 0, 0, 0.525],
          "8217": [0, 0.61111, 0, 0, 0.525],
          "8242": [0, 0.61111, 0, 0, 0.525],
          "9251": [0.11111, 0.21944, 0, 0, 0.525]
        }
      };
      var sigmasAndXis = {
        slant: [0.25, 0.25, 0.25],
        space: [0, 0, 0],
        stretch: [0, 0, 0],
        shrink: [0, 0, 0],
        xHeight: [0.431, 0.431, 0.431],
        quad: [1, 1.171, 1.472],
        extraSpace: [0, 0, 0],
        num1: [0.677, 0.732, 0.925],
        num2: [0.394, 0.384, 0.387],
        num3: [0.444, 0.471, 0.504],
        denom1: [0.686, 0.752, 1.025],
        denom2: [0.345, 0.344, 0.532],
        sup1: [0.413, 0.503, 0.504],
        sup2: [0.363, 0.431, 0.404],
        sup3: [0.289, 0.286, 0.294],
        sub1: [0.15, 0.143, 0.2],
        sub2: [0.247, 0.286, 0.4],
        supDrop: [0.386, 0.353, 0.494],
        subDrop: [0.05, 0.071, 0.1],
        delim1: [2.39, 1.7, 1.98],
        delim2: [1.01, 1.157, 1.42],
        axisHeight: [0.25, 0.25, 0.25],
        defaultRuleThickness: [0.04, 0.049, 0.049],
        bigOpSpacing1: [0.111, 0.111, 0.111],
        bigOpSpacing2: [0.166, 0.166, 0.166],
        bigOpSpacing3: [0.2, 0.2, 0.2],
        bigOpSpacing4: [0.6, 0.611, 0.611],
        bigOpSpacing5: [0.1, 0.143, 0.143],
        sqrtRuleThickness: [0.04, 0.04, 0.04],
        ptPerEm: [10, 10, 10],
        doubleRuleSep: [0.2, 0.2, 0.2],
        arrayRuleWidth: [0.04, 0.04, 0.04],
        fboxsep: [0.3, 0.3, 0.3],
        fboxrule: [0.04, 0.04, 0.04]
      };
      var extraCharacterMap = {
        "\xC5": "A",
        "\xD0": "D",
        "\xDE": "o",
        "\xE5": "a",
        "\xF0": "d",
        "\xFE": "o",
        "\u0410": "A",
        "\u0411": "B",
        "\u0412": "B",
        "\u0413": "F",
        "\u0414": "A",
        "\u0415": "E",
        "\u0416": "K",
        "\u0417": "3",
        "\u0418": "N",
        "\u0419": "N",
        "\u041A": "K",
        "\u041B": "N",
        "\u041C": "M",
        "\u041D": "H",
        "\u041E": "O",
        "\u041F": "N",
        "\u0420": "P",
        "\u0421": "C",
        "\u0422": "T",
        "\u0423": "y",
        "\u0424": "O",
        "\u0425": "X",
        "\u0426": "U",
        "\u0427": "h",
        "\u0428": "W",
        "\u0429": "W",
        "\u042A": "B",
        "\u042B": "X",
        "\u042C": "B",
        "\u042D": "3",
        "\u042E": "X",
        "\u042F": "R",
        "\u0430": "a",
        "\u0431": "b",
        "\u0432": "a",
        "\u0433": "r",
        "\u0434": "y",
        "\u0435": "e",
        "\u0436": "m",
        "\u0437": "e",
        "\u0438": "n",
        "\u0439": "n",
        "\u043A": "n",
        "\u043B": "n",
        "\u043C": "m",
        "\u043D": "n",
        "\u043E": "o",
        "\u043F": "n",
        "\u0440": "p",
        "\u0441": "c",
        "\u0442": "o",
        "\u0443": "y",
        "\u0444": "b",
        "\u0445": "x",
        "\u0446": "n",
        "\u0447": "n",
        "\u0448": "w",
        "\u0449": "w",
        "\u044A": "a",
        "\u044B": "m",
        "\u044C": "a",
        "\u044D": "e",
        "\u044E": "m",
        "\u044F": "r"
      };
      function setFontMetrics(fontName, metrics) {
        fontMetricsData[fontName] = metrics;
      }
      function getCharacterMetrics(character, font, mode) {
        if (!fontMetricsData[font]) {
          throw new Error("Font metrics not found for font: " + font + ".");
        }
        var ch2 = character.charCodeAt(0);
        var metrics = fontMetricsData[font][ch2];
        if (!metrics && character[0] in extraCharacterMap) {
          ch2 = extraCharacterMap[character[0]].charCodeAt(0);
          metrics = fontMetricsData[font][ch2];
        }
        if (!metrics && mode === "text") {
          if (supportedCodepoint(ch2)) {
            metrics = fontMetricsData[font][77];
          }
        }
        if (metrics) {
          return {
            depth: metrics[0],
            height: metrics[1],
            italic: metrics[2],
            skew: metrics[3],
            width: metrics[4]
          };
        }
      }
      var fontMetricsBySizeIndex = {};
      function getGlobalMetrics(size) {
        var sizeIndex;
        if (size >= 5) {
          sizeIndex = 0;
        } else if (size >= 3) {
          sizeIndex = 1;
        } else {
          sizeIndex = 2;
        }
        if (!fontMetricsBySizeIndex[sizeIndex]) {
          var metrics = fontMetricsBySizeIndex[sizeIndex] = {
            cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
          };
          for (var key in sigmasAndXis) {
            if (sigmasAndXis.hasOwnProperty(key)) {
              metrics[key] = sigmasAndXis[key][sizeIndex];
            }
          }
        }
        return fontMetricsBySizeIndex[sizeIndex];
      }
      var sizeStyleMap = [
        [1, 1, 1],
        [2, 1, 1],
        [3, 1, 1],
        [4, 2, 1],
        [5, 2, 1],
        [6, 3, 1],
        [7, 4, 2],
        [8, 6, 3],
        [9, 7, 6],
        [10, 8, 7],
        [11, 10, 9]
      ];
      var sizeMultipliers = [
        0.5,
        0.6,
        0.7,
        0.8,
        0.9,
        1,
        1.2,
        1.44,
        1.728,
        2.074,
        2.488
      ];
      var sizeAtStyle = function sizeAtStyle2(size, style) {
        return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
      };
      var Options = function() {
        function Options2(data) {
          this.style = void 0;
          this.color = void 0;
          this.size = void 0;
          this.textSize = void 0;
          this.phantom = void 0;
          this.font = void 0;
          this.fontFamily = void 0;
          this.fontWeight = void 0;
          this.fontShape = void 0;
          this.sizeMultiplier = void 0;
          this.maxSize = void 0;
          this.minRuleThickness = void 0;
          this._fontMetrics = void 0;
          this.style = data.style;
          this.color = data.color;
          this.size = data.size || Options2.BASESIZE;
          this.textSize = data.textSize || this.size;
          this.phantom = !!data.phantom;
          this.font = data.font || "";
          this.fontFamily = data.fontFamily || "";
          this.fontWeight = data.fontWeight || "";
          this.fontShape = data.fontShape || "";
          this.sizeMultiplier = sizeMultipliers[this.size - 1];
          this.maxSize = data.maxSize;
          this.minRuleThickness = data.minRuleThickness;
          this._fontMetrics = void 0;
        }
        var _proto = Options2.prototype;
        _proto.extend = function extend(extension) {
          var data = {
            style: this.style,
            size: this.size,
            textSize: this.textSize,
            color: this.color,
            phantom: this.phantom,
            font: this.font,
            fontFamily: this.fontFamily,
            fontWeight: this.fontWeight,
            fontShape: this.fontShape,
            maxSize: this.maxSize,
            minRuleThickness: this.minRuleThickness
          };
          for (var key in extension) {
            if (extension.hasOwnProperty(key)) {
              data[key] = extension[key];
            }
          }
          return new Options2(data);
        };
        _proto.havingStyle = function havingStyle(style) {
          if (this.style === style) {
            return this;
          } else {
            return this.extend({
              style,
              size: sizeAtStyle(this.textSize, style)
            });
          }
        };
        _proto.havingCrampedStyle = function havingCrampedStyle() {
          return this.havingStyle(this.style.cramp());
        };
        _proto.havingSize = function havingSize(size) {
          if (this.size === size && this.textSize === size) {
            return this;
          } else {
            return this.extend({
              style: this.style.text(),
              size,
              textSize: size,
              sizeMultiplier: sizeMultipliers[size - 1]
            });
          }
        };
        _proto.havingBaseStyle = function havingBaseStyle(style) {
          style = style || this.style.text();
          var wantSize = sizeAtStyle(Options2.BASESIZE, style);
          if (this.size === wantSize && this.textSize === Options2.BASESIZE && this.style === style) {
            return this;
          } else {
            return this.extend({
              style,
              size: wantSize
            });
          }
        };
        _proto.havingBaseSizing = function havingBaseSizing() {
          var size;
          switch (this.style.id) {
            case 4:
            case 5:
              size = 3;
              break;
            case 6:
            case 7:
              size = 1;
              break;
            default:
              size = 6;
          }
          return this.extend({
            style: this.style.text(),
            size
          });
        };
        _proto.withColor = function withColor(color) {
          return this.extend({
            color
          });
        };
        _proto.withPhantom = function withPhantom() {
          return this.extend({
            phantom: true
          });
        };
        _proto.withFont = function withFont(font) {
          return this.extend({
            font
          });
        };
        _proto.withTextFontFamily = function withTextFontFamily(fontFamily) {
          return this.extend({
            fontFamily,
            font: ""
          });
        };
        _proto.withTextFontWeight = function withTextFontWeight(fontWeight) {
          return this.extend({
            fontWeight,
            font: ""
          });
        };
        _proto.withTextFontShape = function withTextFontShape(fontShape) {
          return this.extend({
            fontShape,
            font: ""
          });
        };
        _proto.sizingClasses = function sizingClasses(oldOptions) {
          if (oldOptions.size !== this.size) {
            return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
          } else {
            return [];
          }
        };
        _proto.baseSizingClasses = function baseSizingClasses() {
          if (this.size !== Options2.BASESIZE) {
            return ["sizing", "reset-size" + this.size, "size" + Options2.BASESIZE];
          } else {
            return [];
          }
        };
        _proto.fontMetrics = function fontMetrics() {
          if (!this._fontMetrics) {
            this._fontMetrics = getGlobalMetrics(this.size);
          }
          return this._fontMetrics;
        };
        _proto.getColor = function getColor() {
          if (this.phantom) {
            return "transparent";
          } else {
            return this.color;
          }
        };
        return Options2;
      }();
      Options.BASESIZE = 6;
      var src_Options = Options;
      var ptPerUnit = {
        "pt": 1,
        "mm": 7227 / 2540,
        "cm": 7227 / 254,
        "in": 72.27,
        "bp": 803 / 800,
        "pc": 12,
        "dd": 1238 / 1157,
        "cc": 14856 / 1157,
        "nd": 685 / 642,
        "nc": 1370 / 107,
        "sp": 1 / 65536,
        "px": 803 / 800
      };
      var relativeUnit = {
        "ex": true,
        "em": true,
        "mu": true
      };
      var validUnit = function validUnit2(unit) {
        if (typeof unit !== "string") {
          unit = unit.unit;
        }
        return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
      };
      var calculateSize = function calculateSize2(sizeValue, options) {
        var scale;
        if (sizeValue.unit in ptPerUnit) {
          scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
        } else if (sizeValue.unit === "mu") {
          scale = options.fontMetrics().cssEmPerMu;
        } else {
          var unitOptions;
          if (options.style.isTight()) {
            unitOptions = options.havingStyle(options.style.text());
          } else {
            unitOptions = options;
          }
          if (sizeValue.unit === "ex") {
            scale = unitOptions.fontMetrics().xHeight;
          } else if (sizeValue.unit === "em") {
            scale = unitOptions.fontMetrics().quad;
          } else {
            throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
          }
          if (unitOptions !== options) {
            scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
          }
        }
        return Math.min(sizeValue.number * scale, options.maxSize);
      };
      var makeEm = function makeEm2(n2) {
        return +n2.toFixed(4) + "em";
      };
      var createClass = function createClass2(classes) {
        return classes.filter(function(cls) {
          return cls;
        }).join(" ");
      };
      var initNode = function initNode2(classes, options, style) {
        this.classes = classes || [];
        this.attributes = {};
        this.height = 0;
        this.depth = 0;
        this.maxFontSize = 0;
        this.style = style || {};
        if (options) {
          if (options.style.isTight()) {
            this.classes.push("mtight");
          }
          var color = options.getColor();
          if (color) {
            this.style.color = color;
          }
        }
      };
      var _toNode = function toNode(tagName) {
        var node = document.createElement(tagName);
        node.className = createClass(this.classes);
        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            node.style[style] = this.style[style];
          }
        }
        for (var attr in this.attributes) {
          if (this.attributes.hasOwnProperty(attr)) {
            node.setAttribute(attr, this.attributes[attr]);
          }
        }
        for (var i3 = 0; i3 < this.children.length; i3++) {
          node.appendChild(this.children[i3].toNode());
        }
        return node;
      };
      var _toMarkup = function toMarkup(tagName) {
        var markup = "<" + tagName;
        if (this.classes.length) {
          markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
        }
        var styles2 = "";
        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
          }
        }
        if (styles2) {
          markup += ' style="' + utils.escape(styles2) + '"';
        }
        for (var attr in this.attributes) {
          if (this.attributes.hasOwnProperty(attr)) {
            markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
          }
        }
        markup += ">";
        for (var i3 = 0; i3 < this.children.length; i3++) {
          markup += this.children[i3].toMarkup();
        }
        markup += "</" + tagName + ">";
        return markup;
      };
      var Span = function() {
        function Span2(classes, children, options, style) {
          this.children = void 0;
          this.attributes = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.width = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          initNode.call(this, classes, options, style);
          this.children = children || [];
        }
        var _proto = Span2.prototype;
        _proto.setAttribute = function setAttribute(attribute, value) {
          this.attributes[attribute] = value;
        };
        _proto.hasClass = function hasClass(className) {
          return utils.contains(this.classes, className);
        };
        _proto.toNode = function toNode() {
          return _toNode.call(this, "span");
        };
        _proto.toMarkup = function toMarkup() {
          return _toMarkup.call(this, "span");
        };
        return Span2;
      }();
      var Anchor = function() {
        function Anchor2(href, classes, children, options) {
          this.children = void 0;
          this.attributes = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          initNode.call(this, classes, options);
          this.children = children || [];
          this.setAttribute("href", href);
        }
        var _proto2 = Anchor2.prototype;
        _proto2.setAttribute = function setAttribute(attribute, value) {
          this.attributes[attribute] = value;
        };
        _proto2.hasClass = function hasClass(className) {
          return utils.contains(this.classes, className);
        };
        _proto2.toNode = function toNode() {
          return _toNode.call(this, "a");
        };
        _proto2.toMarkup = function toMarkup() {
          return _toMarkup.call(this, "a");
        };
        return Anchor2;
      }();
      var Img = function() {
        function Img2(src, alt, style) {
          this.src = void 0;
          this.alt = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          this.alt = alt;
          this.src = src;
          this.classes = ["mord"];
          this.style = style;
        }
        var _proto3 = Img2.prototype;
        _proto3.hasClass = function hasClass(className) {
          return utils.contains(this.classes, className);
        };
        _proto3.toNode = function toNode() {
          var node = document.createElement("img");
          node.src = this.src;
          node.alt = this.alt;
          node.className = "mord";
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              node.style[style] = this.style[style];
            }
          }
          return node;
        };
        _proto3.toMarkup = function toMarkup() {
          var markup = "<img  src='" + this.src + " 'alt='" + this.alt + "' ";
          var styles2 = "";
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
            }
          }
          if (styles2) {
            markup += ' style="' + utils.escape(styles2) + '"';
          }
          markup += "'/>";
          return markup;
        };
        return Img2;
      }();
      var iCombinations = {
        "\xEE": "\u0131\u0302",
        "\xEF": "\u0131\u0308",
        "\xED": "\u0131\u0301",
        "\xEC": "\u0131\u0300"
      };
      var SymbolNode = function() {
        function SymbolNode2(text2, height, depth, italic, skew, width, classes, style) {
          this.text = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.italic = void 0;
          this.skew = void 0;
          this.width = void 0;
          this.maxFontSize = void 0;
          this.classes = void 0;
          this.style = void 0;
          this.text = text2;
          this.height = height || 0;
          this.depth = depth || 0;
          this.italic = italic || 0;
          this.skew = skew || 0;
          this.width = width || 0;
          this.classes = classes || [];
          this.style = style || {};
          this.maxFontSize = 0;
          var script = scriptFromCodepoint(this.text.charCodeAt(0));
          if (script) {
            this.classes.push(script + "_fallback");
          }
          if (/[îïíì]/.test(this.text)) {
            this.text = iCombinations[this.text];
          }
        }
        var _proto4 = SymbolNode2.prototype;
        _proto4.hasClass = function hasClass(className) {
          return utils.contains(this.classes, className);
        };
        _proto4.toNode = function toNode() {
          var node = document.createTextNode(this.text);
          var span = null;
          if (this.italic > 0) {
            span = document.createElement("span");
            span.style.marginRight = makeEm(this.italic);
          }
          if (this.classes.length > 0) {
            span = span || document.createElement("span");
            span.className = createClass(this.classes);
          }
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              span = span || document.createElement("span");
              span.style[style] = this.style[style];
            }
          }
          if (span) {
            span.appendChild(node);
            return span;
          } else {
            return node;
          }
        };
        _proto4.toMarkup = function toMarkup() {
          var needsSpan = false;
          var markup = "<span";
          if (this.classes.length) {
            needsSpan = true;
            markup += ' class="';
            markup += utils.escape(createClass(this.classes));
            markup += '"';
          }
          var styles2 = "";
          if (this.italic > 0) {
            styles2 += "margin-right:" + this.italic + "em;";
          }
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
            }
          }
          if (styles2) {
            needsSpan = true;
            markup += ' style="' + utils.escape(styles2) + '"';
          }
          var escaped = utils.escape(this.text);
          if (needsSpan) {
            markup += ">";
            markup += escaped;
            markup += "</span>";
            return markup;
          } else {
            return escaped;
          }
        };
        return SymbolNode2;
      }();
      var SvgNode = function() {
        function SvgNode2(children, attributes) {
          this.children = void 0;
          this.attributes = void 0;
          this.children = children || [];
          this.attributes = attributes || {};
        }
        var _proto5 = SvgNode2.prototype;
        _proto5.toNode = function toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node = document.createElementNS(svgNS, "svg");
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node.setAttribute(attr, this.attributes[attr]);
            }
          }
          for (var i3 = 0; i3 < this.children.length; i3++) {
            node.appendChild(this.children[i3].toNode());
          }
          return node;
        };
        _proto5.toMarkup = function toMarkup() {
          var markup = '<svg xmlns="http://www.w3.org/2000/svg"';
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + "='" + this.attributes[attr] + "'";
            }
          }
          markup += ">";
          for (var i3 = 0; i3 < this.children.length; i3++) {
            markup += this.children[i3].toMarkup();
          }
          markup += "</svg>";
          return markup;
        };
        return SvgNode2;
      }();
      var PathNode = function() {
        function PathNode2(pathName, alternate) {
          this.pathName = void 0;
          this.alternate = void 0;
          this.pathName = pathName;
          this.alternate = alternate;
        }
        var _proto6 = PathNode2.prototype;
        _proto6.toNode = function toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node = document.createElementNS(svgNS, "path");
          if (this.alternate) {
            node.setAttribute("d", this.alternate);
          } else {
            node.setAttribute("d", path[this.pathName]);
          }
          return node;
        };
        _proto6.toMarkup = function toMarkup() {
          if (this.alternate) {
            return "<path d='" + this.alternate + "'/>";
          } else {
            return "<path d='" + path[this.pathName] + "'/>";
          }
        };
        return PathNode2;
      }();
      var LineNode = function() {
        function LineNode2(attributes) {
          this.attributes = void 0;
          this.attributes = attributes || {};
        }
        var _proto7 = LineNode2.prototype;
        _proto7.toNode = function toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node = document.createElementNS(svgNS, "line");
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node.setAttribute(attr, this.attributes[attr]);
            }
          }
          return node;
        };
        _proto7.toMarkup = function toMarkup() {
          var markup = "<line";
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + "='" + this.attributes[attr] + "'";
            }
          }
          markup += "/>";
          return markup;
        };
        return LineNode2;
      }();
      function assertSymbolDomNode(group) {
        if (group instanceof SymbolNode) {
          return group;
        } else {
          throw new Error("Expected symbolNode but got " + String(group) + ".");
        }
      }
      function assertSpan(group) {
        if (group instanceof Span) {
          return group;
        } else {
          throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
        }
      }
      var ATOMS = {
        "bin": 1,
        "close": 1,
        "inner": 1,
        "open": 1,
        "punct": 1,
        "rel": 1
      };
      var NON_ATOMS = {
        "accent-token": 1,
        "mathord": 1,
        "op-token": 1,
        "spacing": 1,
        "textord": 1
      };
      var symbols = {
        "math": {},
        "text": {}
      };
      var src_symbols = symbols;
      function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
        symbols[mode][name] = {
          font,
          group,
          replace
        };
        if (acceptUnicodeChar && replace) {
          symbols[mode][replace] = symbols[mode][name];
        }
      }
      var math = "math";
      var symbols_text = "text";
      var main = "main";
      var ams = "ams";
      var accent = "accent-token";
      var bin = "bin";
      var symbols_close = "close";
      var inner = "inner";
      var mathord = "mathord";
      var op = "op-token";
      var symbols_open = "open";
      var punct = "punct";
      var rel = "rel";
      var spacing = "spacing";
      var textord = "textord";
      defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
      defineSymbol(math, main, rel, "\u227A", "\\prec", true);
      defineSymbol(math, main, rel, "\u227B", "\\succ", true);
      defineSymbol(math, main, rel, "\u223C", "\\sim", true);
      defineSymbol(math, main, rel, "\u22A5", "\\perp");
      defineSymbol(math, main, rel, "\u2AAF", "\\preceq", true);
      defineSymbol(math, main, rel, "\u2AB0", "\\succeq", true);
      defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
      defineSymbol(math, main, rel, "\u2223", "\\mid", true);
      defineSymbol(math, main, rel, "\u226A", "\\ll", true);
      defineSymbol(math, main, rel, "\u226B", "\\gg", true);
      defineSymbol(math, main, rel, "\u224D", "\\asymp", true);
      defineSymbol(math, main, rel, "\u2225", "\\parallel");
      defineSymbol(math, main, rel, "\u22C8", "\\bowtie", true);
      defineSymbol(math, main, rel, "\u2323", "\\smile", true);
      defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
      defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
      defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
      defineSymbol(math, main, rel, "\u2322", "\\frown", true);
      defineSymbol(math, main, rel, "\u220B", "\\ni", true);
      defineSymbol(math, main, rel, "\u221D", "\\propto", true);
      defineSymbol(math, main, rel, "\u22A2", "\\vdash", true);
      defineSymbol(math, main, rel, "\u22A3", "\\dashv", true);
      defineSymbol(math, main, rel, "\u220B", "\\owns");
      defineSymbol(math, main, punct, ".", "\\ldotp");
      defineSymbol(math, main, punct, "\u22C5", "\\cdotp");
      defineSymbol(math, main, textord, "#", "\\#");
      defineSymbol(symbols_text, main, textord, "#", "\\#");
      defineSymbol(math, main, textord, "&", "\\&");
      defineSymbol(symbols_text, main, textord, "&", "\\&");
      defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
      defineSymbol(math, main, textord, "\u2200", "\\forall", true);
      defineSymbol(math, main, textord, "\u210F", "\\hbar", true);
      defineSymbol(math, main, textord, "\u2203", "\\exists", true);
      defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
      defineSymbol(math, main, textord, "\u266D", "\\flat", true);
      defineSymbol(math, main, textord, "\u2113", "\\ell", true);
      defineSymbol(math, main, textord, "\u266E", "\\natural", true);
      defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
      defineSymbol(math, main, textord, "\u2118", "\\wp", true);
      defineSymbol(math, main, textord, "\u266F", "\\sharp", true);
      defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
      defineSymbol(math, main, textord, "\u211C", "\\Re", true);
      defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
      defineSymbol(math, main, textord, "\u2111", "\\Im", true);
      defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
      defineSymbol(math, main, textord, "\xA7", "\\S", true);
      defineSymbol(symbols_text, main, textord, "\xA7", "\\S");
      defineSymbol(math, main, textord, "\xB6", "\\P", true);
      defineSymbol(symbols_text, main, textord, "\xB6", "\\P");
      defineSymbol(math, main, textord, "\u2020", "\\dag");
      defineSymbol(symbols_text, main, textord, "\u2020", "\\dag");
      defineSymbol(symbols_text, main, textord, "\u2020", "\\textdagger");
      defineSymbol(math, main, textord, "\u2021", "\\ddag");
      defineSymbol(symbols_text, main, textord, "\u2021", "\\ddag");
      defineSymbol(symbols_text, main, textord, "\u2021", "\\textdaggerdbl");
      defineSymbol(math, main, symbols_close, "\u23B1", "\\rmoustache", true);
      defineSymbol(math, main, symbols_open, "\u23B0", "\\lmoustache", true);
      defineSymbol(math, main, symbols_close, "\u27EF", "\\rgroup", true);
      defineSymbol(math, main, symbols_open, "\u27EE", "\\lgroup", true);
      defineSymbol(math, main, bin, "\u2213", "\\mp", true);
      defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
      defineSymbol(math, main, bin, "\u228E", "\\uplus", true);
      defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
      defineSymbol(math, main, bin, "\u2217", "\\ast");
      defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
      defineSymbol(math, main, bin, "\u25EF", "\\bigcirc", true);
      defineSymbol(math, main, bin, "\u2219", "\\bullet", true);
      defineSymbol(math, main, bin, "\u2021", "\\ddagger");
      defineSymbol(math, main, bin, "\u2240", "\\wr", true);
      defineSymbol(math, main, bin, "\u2A3F", "\\amalg");
      defineSymbol(math, main, bin, "&", "\\And");
      defineSymbol(math, main, rel, "\u27F5", "\\longleftarrow", true);
      defineSymbol(math, main, rel, "\u21D0", "\\Leftarrow", true);
      defineSymbol(math, main, rel, "\u27F8", "\\Longleftarrow", true);
      defineSymbol(math, main, rel, "\u27F6", "\\longrightarrow", true);
      defineSymbol(math, main, rel, "\u21D2", "\\Rightarrow", true);
      defineSymbol(math, main, rel, "\u27F9", "\\Longrightarrow", true);
      defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
      defineSymbol(math, main, rel, "\u27F7", "\\longleftrightarrow", true);
      defineSymbol(math, main, rel, "\u21D4", "\\Leftrightarrow", true);
      defineSymbol(math, main, rel, "\u27FA", "\\Longleftrightarrow", true);
      defineSymbol(math, main, rel, "\u21A6", "\\mapsto", true);
      defineSymbol(math, main, rel, "\u27FC", "\\longmapsto", true);
      defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
      defineSymbol(math, main, rel, "\u21A9", "\\hookleftarrow", true);
      defineSymbol(math, main, rel, "\u21AA", "\\hookrightarrow", true);
      defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
      defineSymbol(math, main, rel, "\u21BC", "\\leftharpoonup", true);
      defineSymbol(math, main, rel, "\u21C0", "\\rightharpoonup", true);
      defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
      defineSymbol(math, main, rel, "\u21BD", "\\leftharpoondown", true);
      defineSymbol(math, main, rel, "\u21C1", "\\rightharpoondown", true);
      defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
      defineSymbol(math, main, rel, "\u21CC", "\\rightleftharpoons", true);
      defineSymbol(math, ams, rel, "\u226E", "\\nless", true);
      defineSymbol(math, ams, rel, "\uE010", "\\@nleqslant");
      defineSymbol(math, ams, rel, "\uE011", "\\@nleqq");
      defineSymbol(math, ams, rel, "\u2A87", "\\lneq", true);
      defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
      defineSymbol(math, ams, rel, "\uE00C", "\\@lvertneqq");
      defineSymbol(math, ams, rel, "\u22E6", "\\lnsim", true);
      defineSymbol(math, ams, rel, "\u2A89", "\\lnapprox", true);
      defineSymbol(math, ams, rel, "\u2280", "\\nprec", true);
      defineSymbol(math, ams, rel, "\u22E0", "\\npreceq", true);
      defineSymbol(math, ams, rel, "\u22E8", "\\precnsim", true);
      defineSymbol(math, ams, rel, "\u2AB9", "\\precnapprox", true);
      defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
      defineSymbol(math, ams, rel, "\uE006", "\\@nshortmid");
      defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
      defineSymbol(math, ams, rel, "\u22AC", "\\nvdash", true);
      defineSymbol(math, ams, rel, "\u22AD", "\\nvDash", true);
      defineSymbol(math, ams, rel, "\u22EA", "\\ntriangleleft");
      defineSymbol(math, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
      defineSymbol(math, ams, rel, "\u228A", "\\subsetneq", true);
      defineSymbol(math, ams, rel, "\uE01A", "\\@varsubsetneq");
      defineSymbol(math, ams, rel, "\u2ACB", "\\subsetneqq", true);
      defineSymbol(math, ams, rel, "\uE017", "\\@varsubsetneqq");
      defineSymbol(math, ams, rel, "\u226F", "\\ngtr", true);
      defineSymbol(math, ams, rel, "\uE00F", "\\@ngeqslant");
      defineSymbol(math, ams, rel, "\uE00E", "\\@ngeqq");
      defineSymbol(math, ams, rel, "\u2A88", "\\gneq", true);
      defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
      defineSymbol(math, ams, rel, "\uE00D", "\\@gvertneqq");
      defineSymbol(math, ams, rel, "\u22E7", "\\gnsim", true);
      defineSymbol(math, ams, rel, "\u2A8A", "\\gnapprox", true);
      defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true);
      defineSymbol(math, ams, rel, "\u22E1", "\\nsucceq", true);
      defineSymbol(math, ams, rel, "\u22E9", "\\succnsim", true);
      defineSymbol(math, ams, rel, "\u2ABA", "\\succnapprox", true);
      defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
      defineSymbol(math, ams, rel, "\uE007", "\\@nshortparallel");
      defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
      defineSymbol(math, ams, rel, "\u22AF", "\\nVDash", true);
      defineSymbol(math, ams, rel, "\u22EB", "\\ntriangleright");
      defineSymbol(math, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
      defineSymbol(math, ams, rel, "\uE018", "\\@nsupseteqq");
      defineSymbol(math, ams, rel, "\u228B", "\\supsetneq", true);
      defineSymbol(math, ams, rel, "\uE01B", "\\@varsupsetneq");
      defineSymbol(math, ams, rel, "\u2ACC", "\\supsetneqq", true);
      defineSymbol(math, ams, rel, "\uE019", "\\@varsupsetneqq");
      defineSymbol(math, ams, rel, "\u22AE", "\\nVdash", true);
      defineSymbol(math, ams, rel, "\u2AB5", "\\precneqq", true);
      defineSymbol(math, ams, rel, "\u2AB6", "\\succneqq", true);
      defineSymbol(math, ams, rel, "\uE016", "\\@nsubseteqq");
      defineSymbol(math, ams, bin, "\u22B4", "\\unlhd");
      defineSymbol(math, ams, bin, "\u22B5", "\\unrhd");
      defineSymbol(math, ams, rel, "\u219A", "\\nleftarrow", true);
      defineSymbol(math, ams, rel, "\u219B", "\\nrightarrow", true);
      defineSymbol(math, ams, rel, "\u21CD", "\\nLeftarrow", true);
      defineSymbol(math, ams, rel, "\u21CF", "\\nRightarrow", true);
      defineSymbol(math, ams, rel, "\u21AE", "\\nleftrightarrow", true);
      defineSymbol(math, ams, rel, "\u21CE", "\\nLeftrightarrow", true);
      defineSymbol(math, ams, rel, "\u25B3", "\\vartriangle");
      defineSymbol(math, ams, textord, "\u210F", "\\hslash");
      defineSymbol(math, ams, textord, "\u25BD", "\\triangledown");
      defineSymbol(math, ams, textord, "\u25CA", "\\lozenge");
      defineSymbol(math, ams, textord, "\u24C8", "\\circledS");
      defineSymbol(math, ams, textord, "\xAE", "\\circledR");
      defineSymbol(symbols_text, ams, textord, "\xAE", "\\circledR");
      defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
      defineSymbol(math, ams, textord, "\u2204", "\\nexists");
      defineSymbol(math, ams, textord, "\u2127", "\\mho");
      defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
      defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
      defineSymbol(math, ams, textord, "\u2035", "\\backprime");
      defineSymbol(math, ams, textord, "\u25B2", "\\blacktriangle");
      defineSymbol(math, ams, textord, "\u25BC", "\\blacktriangledown");
      defineSymbol(math, ams, textord, "\u25A0", "\\blacksquare");
      defineSymbol(math, ams, textord, "\u29EB", "\\blacklozenge");
      defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
      defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
      defineSymbol(math, ams, textord, "\u2201", "\\complement", true);
      defineSymbol(math, ams, textord, "\xF0", "\\eth", true);
      defineSymbol(symbols_text, main, textord, "\xF0", "\xF0");
      defineSymbol(math, ams, textord, "\u2571", "\\diagup");
      defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
      defineSymbol(math, ams, textord, "\u25A1", "\\square");
      defineSymbol(math, ams, textord, "\u25A1", "\\Box");
      defineSymbol(math, ams, textord, "\u25CA", "\\Diamond");
      defineSymbol(math, ams, textord, "\xA5", "\\yen", true);
      defineSymbol(symbols_text, ams, textord, "\xA5", "\\yen", true);
      defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
      defineSymbol(symbols_text, ams, textord, "\u2713", "\\checkmark");
      defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
      defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
      defineSymbol(math, ams, textord, "\u2137", "\\gimel", true);
      defineSymbol(math, ams, textord, "\u03DD", "\\digamma", true);
      defineSymbol(math, ams, textord, "\u03F0", "\\varkappa");
      defineSymbol(math, ams, symbols_open, "\u250C", "\\@ulcorner", true);
      defineSymbol(math, ams, symbols_close, "\u2510", "\\@urcorner", true);
      defineSymbol(math, ams, symbols_open, "\u2514", "\\@llcorner", true);
      defineSymbol(math, ams, symbols_close, "\u2518", "\\@lrcorner", true);
      defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
      defineSymbol(math, ams, rel, "\u2A7D", "\\leqslant", true);
      defineSymbol(math, ams, rel, "\u2A95", "\\eqslantless", true);
      defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
      defineSymbol(math, ams, rel, "\u2A85", "\\lessapprox", true);
      defineSymbol(math, ams, rel, "\u224A", "\\approxeq", true);
      defineSymbol(math, ams, bin, "\u22D6", "\\lessdot");
      defineSymbol(math, ams, rel, "\u22D8", "\\lll", true);
      defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
      defineSymbol(math, ams, rel, "\u22DA", "\\lesseqgtr", true);
      defineSymbol(math, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
      defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
      defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
      defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
      defineSymbol(math, ams, rel, "\u223D", "\\backsim", true);
      defineSymbol(math, ams, rel, "\u22CD", "\\backsimeq", true);
      defineSymbol(math, ams, rel, "\u2AC5", "\\subseteqq", true);
      defineSymbol(math, ams, rel, "\u22D0", "\\Subset", true);
      defineSymbol(math, ams, rel, "\u228F", "\\sqsubset", true);
      defineSymbol(math, ams, rel, "\u227C", "\\preccurlyeq", true);
      defineSymbol(math, ams, rel, "\u22DE", "\\curlyeqprec", true);
      defineSymbol(math, ams, rel, "\u227E", "\\precsim", true);
      defineSymbol(math, ams, rel, "\u2AB7", "\\precapprox", true);
      defineSymbol(math, ams, rel, "\u22B2", "\\vartriangleleft");
      defineSymbol(math, ams, rel, "\u22B4", "\\trianglelefteq");
      defineSymbol(math, ams, rel, "\u22A8", "\\vDash", true);
      defineSymbol(math, ams, rel, "\u22AA", "\\Vvdash", true);
      defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
      defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
      defineSymbol(math, ams, rel, "\u224F", "\\bumpeq", true);
      defineSymbol(math, ams, rel, "\u224E", "\\Bumpeq", true);
      defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
      defineSymbol(math, ams, rel, "\u2A7E", "\\geqslant", true);
      defineSymbol(math, ams, rel, "\u2A96", "\\eqslantgtr", true);
      defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
      defineSymbol(math, ams, rel, "\u2A86", "\\gtrapprox", true);
      defineSymbol(math, ams, bin, "\u22D7", "\\gtrdot");
      defineSymbol(math, ams, rel, "\u22D9", "\\ggg", true);
      defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
      defineSymbol(math, ams, rel, "\u22DB", "\\gtreqless", true);
      defineSymbol(math, ams, rel, "\u2A8C", "\\gtreqqless", true);
      defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
      defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
      defineSymbol(math, ams, rel, "\u225C", "\\triangleq", true);
      defineSymbol(math, ams, rel, "\u223C", "\\thicksim");
      defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
      defineSymbol(math, ams, rel, "\u2AC6", "\\supseteqq", true);
      defineSymbol(math, ams, rel, "\u22D1", "\\Supset", true);
      defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
      defineSymbol(math, ams, rel, "\u227D", "\\succcurlyeq", true);
      defineSymbol(math, ams, rel, "\u22DF", "\\curlyeqsucc", true);
      defineSymbol(math, ams, rel, "\u227F", "\\succsim", true);
      defineSymbol(math, ams, rel, "\u2AB8", "\\succapprox", true);
      defineSymbol(math, ams, rel, "\u22B3", "\\vartriangleright");
      defineSymbol(math, ams, rel, "\u22B5", "\\trianglerighteq");
      defineSymbol(math, ams, rel, "\u22A9", "\\Vdash", true);
      defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
      defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
      defineSymbol(math, ams, rel, "\u226C", "\\between", true);
      defineSymbol(math, ams, rel, "\u22D4", "\\pitchfork", true);
      defineSymbol(math, ams, rel, "\u221D", "\\varpropto");
      defineSymbol(math, ams, rel, "\u25C0", "\\blacktriangleleft");
      defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
      defineSymbol(math, ams, rel, "\u220D", "\\backepsilon");
      defineSymbol(math, ams, rel, "\u25B6", "\\blacktriangleright");
      defineSymbol(math, ams, rel, "\u2235", "\\because", true);
      defineSymbol(math, ams, rel, "\u22D8", "\\llless");
      defineSymbol(math, ams, rel, "\u22D9", "\\gggtr");
      defineSymbol(math, ams, bin, "\u22B2", "\\lhd");
      defineSymbol(math, ams, bin, "\u22B3", "\\rhd");
      defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
      defineSymbol(math, main, rel, "\u22C8", "\\Join");
      defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true);
      defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
      defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
      defineSymbol(math, ams, bin, "\u22D2", "\\Cap", true);
      defineSymbol(math, ams, bin, "\u22D3", "\\Cup", true);
      defineSymbol(math, ams, bin, "\u2A5E", "\\doublebarwedge", true);
      defineSymbol(math, ams, bin, "\u229F", "\\boxminus", true);
      defineSymbol(math, ams, bin, "\u229E", "\\boxplus", true);
      defineSymbol(math, ams, bin, "\u22C7", "\\divideontimes", true);
      defineSymbol(math, ams, bin, "\u22C9", "\\ltimes", true);
      defineSymbol(math, ams, bin, "\u22CA", "\\rtimes", true);
      defineSymbol(math, ams, bin, "\u22CB", "\\leftthreetimes", true);
      defineSymbol(math, ams, bin, "\u22CC", "\\rightthreetimes", true);
      defineSymbol(math, ams, bin, "\u22CF", "\\curlywedge", true);
      defineSymbol(math, ams, bin, "\u22CE", "\\curlyvee", true);
      defineSymbol(math, ams, bin, "\u229D", "\\circleddash", true);
      defineSymbol(math, ams, bin, "\u229B", "\\circledast", true);
      defineSymbol(math, ams, bin, "\u22C5", "\\centerdot");
      defineSymbol(math, ams, bin, "\u22BA", "\\intercal", true);
      defineSymbol(math, ams, bin, "\u22D2", "\\doublecap");
      defineSymbol(math, ams, bin, "\u22D3", "\\doublecup");
      defineSymbol(math, ams, bin, "\u22A0", "\\boxtimes", true);
      defineSymbol(math, ams, rel, "\u21E2", "\\dashrightarrow", true);
      defineSymbol(math, ams, rel, "\u21E0", "\\dashleftarrow", true);
      defineSymbol(math, ams, rel, "\u21C7", "\\leftleftarrows", true);
      defineSymbol(math, ams, rel, "\u21C6", "\\leftrightarrows", true);
      defineSymbol(math, ams, rel, "\u21DA", "\\Lleftarrow", true);
      defineSymbol(math, ams, rel, "\u219E", "\\twoheadleftarrow", true);
      defineSymbol(math, ams, rel, "\u21A2", "\\leftarrowtail", true);
      defineSymbol(math, ams, rel, "\u21AB", "\\looparrowleft", true);
      defineSymbol(math, ams, rel, "\u21CB", "\\leftrightharpoons", true);
      defineSymbol(math, ams, rel, "\u21B6", "\\curvearrowleft", true);
      defineSymbol(math, ams, rel, "\u21BA", "\\circlearrowleft", true);
      defineSymbol(math, ams, rel, "\u21B0", "\\Lsh", true);
      defineSymbol(math, ams, rel, "\u21C8", "\\upuparrows", true);
      defineSymbol(math, ams, rel, "\u21BF", "\\upharpoonleft", true);
      defineSymbol(math, ams, rel, "\u21C3", "\\downharpoonleft", true);
      defineSymbol(math, main, rel, "\u22B6", "\\origof", true);
      defineSymbol(math, main, rel, "\u22B7", "\\imageof", true);
      defineSymbol(math, ams, rel, "\u22B8", "\\multimap", true);
      defineSymbol(math, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
      defineSymbol(math, ams, rel, "\u21C9", "\\rightrightarrows", true);
      defineSymbol(math, ams, rel, "\u21C4", "\\rightleftarrows", true);
      defineSymbol(math, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
      defineSymbol(math, ams, rel, "\u21A3", "\\rightarrowtail", true);
      defineSymbol(math, ams, rel, "\u21AC", "\\looparrowright", true);
      defineSymbol(math, ams, rel, "\u21B7", "\\curvearrowright", true);
      defineSymbol(math, ams, rel, "\u21BB", "\\circlearrowright", true);
      defineSymbol(math, ams, rel, "\u21B1", "\\Rsh", true);
      defineSymbol(math, ams, rel, "\u21CA", "\\downdownarrows", true);
      defineSymbol(math, ams, rel, "\u21BE", "\\upharpoonright", true);
      defineSymbol(math, ams, rel, "\u21C2", "\\downharpoonright", true);
      defineSymbol(math, ams, rel, "\u21DD", "\\rightsquigarrow", true);
      defineSymbol(math, ams, rel, "\u21DD", "\\leadsto");
      defineSymbol(math, ams, rel, "\u21DB", "\\Rrightarrow", true);
      defineSymbol(math, ams, rel, "\u21BE", "\\restriction");
      defineSymbol(math, main, textord, "\u2018", "`");
      defineSymbol(math, main, textord, "$", "\\$");
      defineSymbol(symbols_text, main, textord, "$", "\\$");
      defineSymbol(symbols_text, main, textord, "$", "\\textdollar");
      defineSymbol(math, main, textord, "%", "\\%");
      defineSymbol(symbols_text, main, textord, "%", "\\%");
      defineSymbol(math, main, textord, "_", "\\_");
      defineSymbol(symbols_text, main, textord, "_", "\\_");
      defineSymbol(symbols_text, main, textord, "_", "\\textunderscore");
      defineSymbol(math, main, textord, "\u2220", "\\angle", true);
      defineSymbol(math, main, textord, "\u221E", "\\infty", true);
      defineSymbol(math, main, textord, "\u2032", "\\prime");
      defineSymbol(math, main, textord, "\u25B3", "\\triangle");
      defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
      defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
      defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
      defineSymbol(math, main, textord, "\u039B", "\\Lambda", true);
      defineSymbol(math, main, textord, "\u039E", "\\Xi", true);
      defineSymbol(math, main, textord, "\u03A0", "\\Pi", true);
      defineSymbol(math, main, textord, "\u03A3", "\\Sigma", true);
      defineSymbol(math, main, textord, "\u03A5", "\\Upsilon", true);
      defineSymbol(math, main, textord, "\u03A6", "\\Phi", true);
      defineSymbol(math, main, textord, "\u03A8", "\\Psi", true);
      defineSymbol(math, main, textord, "\u03A9", "\\Omega", true);
      defineSymbol(math, main, textord, "A", "\u0391");
      defineSymbol(math, main, textord, "B", "\u0392");
      defineSymbol(math, main, textord, "E", "\u0395");
      defineSymbol(math, main, textord, "Z", "\u0396");
      defineSymbol(math, main, textord, "H", "\u0397");
      defineSymbol(math, main, textord, "I", "\u0399");
      defineSymbol(math, main, textord, "K", "\u039A");
      defineSymbol(math, main, textord, "M", "\u039C");
      defineSymbol(math, main, textord, "N", "\u039D");
      defineSymbol(math, main, textord, "O", "\u039F");
      defineSymbol(math, main, textord, "P", "\u03A1");
      defineSymbol(math, main, textord, "T", "\u03A4");
      defineSymbol(math, main, textord, "X", "\u03A7");
      defineSymbol(math, main, textord, "\xAC", "\\neg", true);
      defineSymbol(math, main, textord, "\xAC", "\\lnot");
      defineSymbol(math, main, textord, "\u22A4", "\\top");
      defineSymbol(math, main, textord, "\u22A5", "\\bot");
      defineSymbol(math, main, textord, "\u2205", "\\emptyset");
      defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
      defineSymbol(math, main, mathord, "\u03B1", "\\alpha", true);
      defineSymbol(math, main, mathord, "\u03B2", "\\beta", true);
      defineSymbol(math, main, mathord, "\u03B3", "\\gamma", true);
      defineSymbol(math, main, mathord, "\u03B4", "\\delta", true);
      defineSymbol(math, main, mathord, "\u03F5", "\\epsilon", true);
      defineSymbol(math, main, mathord, "\u03B6", "\\zeta", true);
      defineSymbol(math, main, mathord, "\u03B7", "\\eta", true);
      defineSymbol(math, main, mathord, "\u03B8", "\\theta", true);
      defineSymbol(math, main, mathord, "\u03B9", "\\iota", true);
      defineSymbol(math, main, mathord, "\u03BA", "\\kappa", true);
      defineSymbol(math, main, mathord, "\u03BB", "\\lambda", true);
      defineSymbol(math, main, mathord, "\u03BC", "\\mu", true);
      defineSymbol(math, main, mathord, "\u03BD", "\\nu", true);
      defineSymbol(math, main, mathord, "\u03BE", "\\xi", true);
      defineSymbol(math, main, mathord, "\u03BF", "\\omicron", true);
      defineSymbol(math, main, mathord, "\u03C0", "\\pi", true);
      defineSymbol(math, main, mathord, "\u03C1", "\\rho", true);
      defineSymbol(math, main, mathord, "\u03C3", "\\sigma", true);
      defineSymbol(math, main, mathord, "\u03C4", "\\tau", true);
      defineSymbol(math, main, mathord, "\u03C5", "\\upsilon", true);
      defineSymbol(math, main, mathord, "\u03D5", "\\phi", true);
      defineSymbol(math, main, mathord, "\u03C7", "\\chi", true);
      defineSymbol(math, main, mathord, "\u03C8", "\\psi", true);
      defineSymbol(math, main, mathord, "\u03C9", "\\omega", true);
      defineSymbol(math, main, mathord, "\u03B5", "\\varepsilon", true);
      defineSymbol(math, main, mathord, "\u03D1", "\\vartheta", true);
      defineSymbol(math, main, mathord, "\u03D6", "\\varpi", true);
      defineSymbol(math, main, mathord, "\u03F1", "\\varrho", true);
      defineSymbol(math, main, mathord, "\u03C2", "\\varsigma", true);
      defineSymbol(math, main, mathord, "\u03C6", "\\varphi", true);
      defineSymbol(math, main, bin, "\u2217", "*", true);
      defineSymbol(math, main, bin, "+", "+");
      defineSymbol(math, main, bin, "\u2212", "-", true);
      defineSymbol(math, main, bin, "\u22C5", "\\cdot", true);
      defineSymbol(math, main, bin, "\u2218", "\\circ", true);
      defineSymbol(math, main, bin, "\xF7", "\\div", true);
      defineSymbol(math, main, bin, "\xB1", "\\pm", true);
      defineSymbol(math, main, bin, "\xD7", "\\times", true);
      defineSymbol(math, main, bin, "\u2229", "\\cap", true);
      defineSymbol(math, main, bin, "\u222A", "\\cup", true);
      defineSymbol(math, main, bin, "\u2216", "\\setminus", true);
      defineSymbol(math, main, bin, "\u2227", "\\land");
      defineSymbol(math, main, bin, "\u2228", "\\lor");
      defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
      defineSymbol(math, main, bin, "\u2228", "\\vee", true);
      defineSymbol(math, main, textord, "\u221A", "\\surd");
      defineSymbol(math, main, symbols_open, "\u27E8", "\\langle", true);
      defineSymbol(math, main, symbols_open, "\u2223", "\\lvert");
      defineSymbol(math, main, symbols_open, "\u2225", "\\lVert");
      defineSymbol(math, main, symbols_close, "?", "?");
      defineSymbol(math, main, symbols_close, "!", "!");
      defineSymbol(math, main, symbols_close, "\u27E9", "\\rangle", true);
      defineSymbol(math, main, symbols_close, "\u2223", "\\rvert");
      defineSymbol(math, main, symbols_close, "\u2225", "\\rVert");
      defineSymbol(math, main, rel, "=", "=");
      defineSymbol(math, main, rel, ":", ":");
      defineSymbol(math, main, rel, "\u2248", "\\approx", true);
      defineSymbol(math, main, rel, "\u2245", "\\cong", true);
      defineSymbol(math, main, rel, "\u2265", "\\ge");
      defineSymbol(math, main, rel, "\u2265", "\\geq", true);
      defineSymbol(math, main, rel, "\u2190", "\\gets");
      defineSymbol(math, main, rel, ">", "\\gt", true);
      defineSymbol(math, main, rel, "\u2208", "\\in", true);
      defineSymbol(math, main, rel, "\uE020", "\\@not");
      defineSymbol(math, main, rel, "\u2282", "\\subset", true);
      defineSymbol(math, main, rel, "\u2283", "\\supset", true);
      defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
      defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
      defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
      defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
      defineSymbol(math, main, rel, "\u22A8", "\\models");
      defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
      defineSymbol(math, main, rel, "\u2264", "\\le");
      defineSymbol(math, main, rel, "\u2264", "\\leq", true);
      defineSymbol(math, main, rel, "<", "\\lt", true);
      defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
      defineSymbol(math, main, rel, "\u2192", "\\to");
      defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
      defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
      defineSymbol(math, main, spacing, "\xA0", "\\ ");
      defineSymbol(math, main, spacing, "\xA0", "\\space");
      defineSymbol(math, main, spacing, "\xA0", "\\nobreakspace");
      defineSymbol(symbols_text, main, spacing, "\xA0", "\\ ");
      defineSymbol(symbols_text, main, spacing, "\xA0", " ");
      defineSymbol(symbols_text, main, spacing, "\xA0", "\\space");
      defineSymbol(symbols_text, main, spacing, "\xA0", "\\nobreakspace");
      defineSymbol(math, main, spacing, null, "\\nobreak");
      defineSymbol(math, main, spacing, null, "\\allowbreak");
      defineSymbol(math, main, punct, ",", ",");
      defineSymbol(math, main, punct, ";", ";");
      defineSymbol(math, ams, bin, "\u22BC", "\\barwedge", true);
      defineSymbol(math, ams, bin, "\u22BB", "\\veebar", true);
      defineSymbol(math, main, bin, "\u2299", "\\odot", true);
      defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
      defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
      defineSymbol(math, main, textord, "\u2202", "\\partial", true);
      defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
      defineSymbol(math, ams, bin, "\u229A", "\\circledcirc", true);
      defineSymbol(math, ams, bin, "\u22A1", "\\boxdot", true);
      defineSymbol(math, main, bin, "\u25B3", "\\bigtriangleup");
      defineSymbol(math, main, bin, "\u25BD", "\\bigtriangledown");
      defineSymbol(math, main, bin, "\u2020", "\\dagger");
      defineSymbol(math, main, bin, "\u22C4", "\\diamond");
      defineSymbol(math, main, bin, "\u22C6", "\\star");
      defineSymbol(math, main, bin, "\u25C3", "\\triangleleft");
      defineSymbol(math, main, bin, "\u25B9", "\\triangleright");
      defineSymbol(math, main, symbols_open, "{", "\\{");
      defineSymbol(symbols_text, main, textord, "{", "\\{");
      defineSymbol(symbols_text, main, textord, "{", "\\textbraceleft");
      defineSymbol(math, main, symbols_close, "}", "\\}");
      defineSymbol(symbols_text, main, textord, "}", "\\}");
      defineSymbol(symbols_text, main, textord, "}", "\\textbraceright");
      defineSymbol(math, main, symbols_open, "{", "\\lbrace");
      defineSymbol(math, main, symbols_close, "}", "\\rbrace");
      defineSymbol(math, main, symbols_open, "[", "\\lbrack", true);
      defineSymbol(symbols_text, main, textord, "[", "\\lbrack", true);
      defineSymbol(math, main, symbols_close, "]", "\\rbrack", true);
      defineSymbol(symbols_text, main, textord, "]", "\\rbrack", true);
      defineSymbol(math, main, symbols_open, "(", "\\lparen", true);
      defineSymbol(math, main, symbols_close, ")", "\\rparen", true);
      defineSymbol(symbols_text, main, textord, "<", "\\textless", true);
      defineSymbol(symbols_text, main, textord, ">", "\\textgreater", true);
      defineSymbol(math, main, symbols_open, "\u230A", "\\lfloor", true);
      defineSymbol(math, main, symbols_close, "\u230B", "\\rfloor", true);
      defineSymbol(math, main, symbols_open, "\u2308", "\\lceil", true);
      defineSymbol(math, main, symbols_close, "\u2309", "\\rceil", true);
      defineSymbol(math, main, textord, "\\", "\\backslash");
      defineSymbol(math, main, textord, "\u2223", "|");
      defineSymbol(math, main, textord, "\u2223", "\\vert");
      defineSymbol(symbols_text, main, textord, "|", "\\textbar", true);
      defineSymbol(math, main, textord, "\u2225", "\\|");
      defineSymbol(math, main, textord, "\u2225", "\\Vert");
      defineSymbol(symbols_text, main, textord, "\u2225", "\\textbardbl");
      defineSymbol(symbols_text, main, textord, "~", "\\textasciitilde");
      defineSymbol(symbols_text, main, textord, "\\", "\\textbackslash");
      defineSymbol(symbols_text, main, textord, "^", "\\textasciicircum");
      defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
      defineSymbol(math, main, rel, "\u21D1", "\\Uparrow", true);
      defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
      defineSymbol(math, main, rel, "\u21D3", "\\Downarrow", true);
      defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
      defineSymbol(math, main, rel, "\u21D5", "\\Updownarrow", true);
      defineSymbol(math, main, op, "\u2210", "\\coprod");
      defineSymbol(math, main, op, "\u22C1", "\\bigvee");
      defineSymbol(math, main, op, "\u22C0", "\\bigwedge");
      defineSymbol(math, main, op, "\u2A04", "\\biguplus");
      defineSymbol(math, main, op, "\u22C2", "\\bigcap");
      defineSymbol(math, main, op, "\u22C3", "\\bigcup");
      defineSymbol(math, main, op, "\u222B", "\\int");
      defineSymbol(math, main, op, "\u222B", "\\intop");
      defineSymbol(math, main, op, "\u222C", "\\iint");
      defineSymbol(math, main, op, "\u222D", "\\iiint");
      defineSymbol(math, main, op, "\u220F", "\\prod");
      defineSymbol(math, main, op, "\u2211", "\\sum");
      defineSymbol(math, main, op, "\u2A02", "\\bigotimes");
      defineSymbol(math, main, op, "\u2A01", "\\bigoplus");
      defineSymbol(math, main, op, "\u2A00", "\\bigodot");
      defineSymbol(math, main, op, "\u222E", "\\oint");
      defineSymbol(math, main, op, "\u222F", "\\oiint");
      defineSymbol(math, main, op, "\u2230", "\\oiiint");
      defineSymbol(math, main, op, "\u2A06", "\\bigsqcup");
      defineSymbol(math, main, op, "\u222B", "\\smallint");
      defineSymbol(symbols_text, main, inner, "\u2026", "\\textellipsis");
      defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
      defineSymbol(symbols_text, main, inner, "\u2026", "\\ldots", true);
      defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
      defineSymbol(math, main, inner, "\u22EF", "\\@cdots", true);
      defineSymbol(math, main, inner, "\u22F1", "\\ddots", true);
      defineSymbol(math, main, textord, "\u22EE", "\\varvdots");
      defineSymbol(math, main, accent, "\u02CA", "\\acute");
      defineSymbol(math, main, accent, "\u02CB", "\\grave");
      defineSymbol(math, main, accent, "\xA8", "\\ddot");
      defineSymbol(math, main, accent, "~", "\\tilde");
      defineSymbol(math, main, accent, "\u02C9", "\\bar");
      defineSymbol(math, main, accent, "\u02D8", "\\breve");
      defineSymbol(math, main, accent, "\u02C7", "\\check");
      defineSymbol(math, main, accent, "^", "\\hat");
      defineSymbol(math, main, accent, "\u20D7", "\\vec");
      defineSymbol(math, main, accent, "\u02D9", "\\dot");
      defineSymbol(math, main, accent, "\u02DA", "\\mathring");
      defineSymbol(math, main, mathord, "\uE131", "\\@imath");
      defineSymbol(math, main, mathord, "\uE237", "\\@jmath");
      defineSymbol(math, main, textord, "\u0131", "\u0131");
      defineSymbol(math, main, textord, "\u0237", "\u0237");
      defineSymbol(symbols_text, main, textord, "\u0131", "\\i", true);
      defineSymbol(symbols_text, main, textord, "\u0237", "\\j", true);
      defineSymbol(symbols_text, main, textord, "\xDF", "\\ss", true);
      defineSymbol(symbols_text, main, textord, "\xE6", "\\ae", true);
      defineSymbol(symbols_text, main, textord, "\u0153", "\\oe", true);
      defineSymbol(symbols_text, main, textord, "\xF8", "\\o", true);
      defineSymbol(symbols_text, main, textord, "\xC6", "\\AE", true);
      defineSymbol(symbols_text, main, textord, "\u0152", "\\OE", true);
      defineSymbol(symbols_text, main, textord, "\xD8", "\\O", true);
      defineSymbol(symbols_text, main, accent, "\u02CA", "\\'");
      defineSymbol(symbols_text, main, accent, "\u02CB", "\\`");
      defineSymbol(symbols_text, main, accent, "\u02C6", "\\^");
      defineSymbol(symbols_text, main, accent, "\u02DC", "\\~");
      defineSymbol(symbols_text, main, accent, "\u02C9", "\\=");
      defineSymbol(symbols_text, main, accent, "\u02D8", "\\u");
      defineSymbol(symbols_text, main, accent, "\u02D9", "\\.");
      defineSymbol(symbols_text, main, accent, "\xB8", "\\c");
      defineSymbol(symbols_text, main, accent, "\u02DA", "\\r");
      defineSymbol(symbols_text, main, accent, "\u02C7", "\\v");
      defineSymbol(symbols_text, main, accent, "\xA8", '\\"');
      defineSymbol(symbols_text, main, accent, "\u02DD", "\\H");
      defineSymbol(symbols_text, main, accent, "\u25EF", "\\textcircled");
      var ligatures = {
        "--": true,
        "---": true,
        "``": true,
        "''": true
      };
      defineSymbol(symbols_text, main, textord, "\u2013", "--", true);
      defineSymbol(symbols_text, main, textord, "\u2013", "\\textendash");
      defineSymbol(symbols_text, main, textord, "\u2014", "---", true);
      defineSymbol(symbols_text, main, textord, "\u2014", "\\textemdash");
      defineSymbol(symbols_text, main, textord, "\u2018", "`", true);
      defineSymbol(symbols_text, main, textord, "\u2018", "\\textquoteleft");
      defineSymbol(symbols_text, main, textord, "\u2019", "'", true);
      defineSymbol(symbols_text, main, textord, "\u2019", "\\textquoteright");
      defineSymbol(symbols_text, main, textord, "\u201C", "``", true);
      defineSymbol(symbols_text, main, textord, "\u201C", "\\textquotedblleft");
      defineSymbol(symbols_text, main, textord, "\u201D", "''", true);
      defineSymbol(symbols_text, main, textord, "\u201D", "\\textquotedblright");
      defineSymbol(math, main, textord, "\xB0", "\\degree", true);
      defineSymbol(symbols_text, main, textord, "\xB0", "\\degree");
      defineSymbol(symbols_text, main, textord, "\xB0", "\\textdegree", true);
      defineSymbol(math, main, textord, "\xA3", "\\pounds");
      defineSymbol(math, main, textord, "\xA3", "\\mathsterling", true);
      defineSymbol(symbols_text, main, textord, "\xA3", "\\pounds");
      defineSymbol(symbols_text, main, textord, "\xA3", "\\textsterling", true);
      defineSymbol(math, ams, textord, "\u2720", "\\maltese");
      defineSymbol(symbols_text, ams, textord, "\u2720", "\\maltese");
      var mathTextSymbols = '0123456789/@."';
      for (var i2 = 0; i2 < mathTextSymbols.length; i2++) {
        var ch = mathTextSymbols.charAt(i2);
        defineSymbol(math, main, textord, ch, ch);
      }
      var textSymbols = '0123456789!@*()-=+";:?/.,';
      for (var _i = 0; _i < textSymbols.length; _i++) {
        var _ch = textSymbols.charAt(_i);
        defineSymbol(symbols_text, main, textord, _ch, _ch);
      }
      var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
      for (var _i2 = 0; _i2 < letters.length; _i2++) {
        var _ch2 = letters.charAt(_i2);
        defineSymbol(math, main, mathord, _ch2, _ch2);
        defineSymbol(symbols_text, main, textord, _ch2, _ch2);
      }
      defineSymbol(math, ams, textord, "C", "\u2102");
      defineSymbol(symbols_text, ams, textord, "C", "\u2102");
      defineSymbol(math, ams, textord, "H", "\u210D");
      defineSymbol(symbols_text, ams, textord, "H", "\u210D");
      defineSymbol(math, ams, textord, "N", "\u2115");
      defineSymbol(symbols_text, ams, textord, "N", "\u2115");
      defineSymbol(math, ams, textord, "P", "\u2119");
      defineSymbol(symbols_text, ams, textord, "P", "\u2119");
      defineSymbol(math, ams, textord, "Q", "\u211A");
      defineSymbol(symbols_text, ams, textord, "Q", "\u211A");
      defineSymbol(math, ams, textord, "R", "\u211D");
      defineSymbol(symbols_text, ams, textord, "R", "\u211D");
      defineSymbol(math, ams, textord, "Z", "\u2124");
      defineSymbol(symbols_text, ams, textord, "Z", "\u2124");
      defineSymbol(math, main, mathord, "h", "\u210E");
      defineSymbol(symbols_text, main, mathord, "h", "\u210E");
      var wideChar = "";
      for (var _i3 = 0; _i3 < letters.length; _i3++) {
        var _ch3 = letters.charAt(_i3);
        wideChar = String.fromCharCode(55349, 56320 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56372 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56424 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56580 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56736 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56788 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56840 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56944 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        if (_i3 < 26) {
          wideChar = String.fromCharCode(55349, 56632 + _i3);
          defineSymbol(math, main, mathord, _ch3, wideChar);
          defineSymbol(symbols_text, main, textord, _ch3, wideChar);
          wideChar = String.fromCharCode(55349, 56476 + _i3);
          defineSymbol(math, main, mathord, _ch3, wideChar);
          defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        }
      }
      wideChar = String.fromCharCode(55349, 56668);
      defineSymbol(math, main, mathord, "k", wideChar);
      defineSymbol(symbols_text, main, textord, "k", wideChar);
      for (var _i4 = 0; _i4 < 10; _i4++) {
        var _ch4 = _i4.toString();
        wideChar = String.fromCharCode(55349, 57294 + _i4);
        defineSymbol(math, main, mathord, _ch4, wideChar);
        defineSymbol(symbols_text, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57314 + _i4);
        defineSymbol(math, main, mathord, _ch4, wideChar);
        defineSymbol(symbols_text, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57324 + _i4);
        defineSymbol(math, main, mathord, _ch4, wideChar);
        defineSymbol(symbols_text, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57334 + _i4);
        defineSymbol(math, main, mathord, _ch4, wideChar);
        defineSymbol(symbols_text, main, textord, _ch4, wideChar);
      }
      var extraLatin = "\xD0\xDE\xFE";
      for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
        var _ch5 = extraLatin.charAt(_i5);
        defineSymbol(math, main, mathord, _ch5, _ch5);
        defineSymbol(symbols_text, main, textord, _ch5, _ch5);
      }
      var wideLatinLetterData = [
        ["mathbf", "textbf", "Main-Bold"],
        ["mathbf", "textbf", "Main-Bold"],
        ["mathnormal", "textit", "Math-Italic"],
        ["mathnormal", "textit", "Math-Italic"],
        ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
        ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
        ["mathscr", "textscr", "Script-Regular"],
        ["", "", ""],
        ["", "", ""],
        ["", "", ""],
        ["mathfrak", "textfrak", "Fraktur-Regular"],
        ["mathfrak", "textfrak", "Fraktur-Regular"],
        ["mathbb", "textbb", "AMS-Regular"],
        ["mathbb", "textbb", "AMS-Regular"],
        ["", "", ""],
        ["", "", ""],
        ["mathsf", "textsf", "SansSerif-Regular"],
        ["mathsf", "textsf", "SansSerif-Regular"],
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        ["mathitsf", "textitsf", "SansSerif-Italic"],
        ["mathitsf", "textitsf", "SansSerif-Italic"],
        ["", "", ""],
        ["", "", ""],
        ["mathtt", "texttt", "Typewriter-Regular"],
        ["mathtt", "texttt", "Typewriter-Regular"]
      ];
      var wideNumeralData = [
        ["mathbf", "textbf", "Main-Bold"],
        ["", "", ""],
        ["mathsf", "textsf", "SansSerif-Regular"],
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        ["mathtt", "texttt", "Typewriter-Regular"]
      ];
      var wideCharacterFont = function wideCharacterFont2(wideChar2, mode) {
        var H2 = wideChar2.charCodeAt(0);
        var L2 = wideChar2.charCodeAt(1);
        var codePoint = (H2 - 55296) * 1024 + (L2 - 56320) + 65536;
        var j2 = mode === "math" ? 0 : 1;
        if (119808 <= codePoint && codePoint < 120484) {
          var i3 = Math.floor((codePoint - 119808) / 26);
          return [wideLatinLetterData[i3][2], wideLatinLetterData[i3][j2]];
        } else if (120782 <= codePoint && codePoint <= 120831) {
          var _i6 = Math.floor((codePoint - 120782) / 10);
          return [wideNumeralData[_i6][2], wideNumeralData[_i6][j2]];
        } else if (codePoint === 120485 || codePoint === 120486) {
          return [wideLatinLetterData[0][2], wideLatinLetterData[0][j2]];
        } else if (120486 < codePoint && codePoint < 120782) {
          return ["", ""];
        } else {
          throw new src_ParseError("Unsupported character: " + wideChar2);
        }
      };
      var lookupSymbol = function lookupSymbol2(value, fontName, mode) {
        if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
          value = src_symbols[mode][value].replace;
        }
        return {
          value,
          metrics: getCharacterMetrics(value, fontName, mode)
        };
      };
      var makeSymbol = function makeSymbol2(value, fontName, mode, options, classes) {
        var lookup = lookupSymbol(value, fontName, mode);
        var metrics = lookup.metrics;
        value = lookup.value;
        var symbolNode;
        if (metrics) {
          var italic = metrics.italic;
          if (mode === "text" || options && options.font === "mathit") {
            italic = 0;
          }
          symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
        } else {
          typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
          symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
        }
        if (options) {
          symbolNode.maxFontSize = options.sizeMultiplier;
          if (options.style.isTight()) {
            symbolNode.classes.push("mtight");
          }
          var color = options.getColor();
          if (color) {
            symbolNode.style.color = color;
          }
        }
        return symbolNode;
      };
      var mathsym = function mathsym2(value, mode, options, classes) {
        if (classes === void 0) {
          classes = [];
        }
        if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
          return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
        } else if (value === "\\" || src_symbols[mode][value].font === "main") {
          return makeSymbol(value, "Main-Regular", mode, options, classes);
        } else {
          return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
        }
      };
      var boldsymbol = function boldsymbol2(value, mode, options, classes, type) {
        if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
          return {
            fontName: "Math-BoldItalic",
            fontClass: "boldsymbol"
          };
        } else {
          return {
            fontName: "Main-Bold",
            fontClass: "mathbf"
          };
        }
      };
      var makeOrd = function makeOrd2(group, options, type) {
        var mode = group.mode;
        var text2 = group.text;
        var classes = ["mord"];
        var isFont = mode === "math" || mode === "text" && options.font;
        var fontOrFamily = isFont ? options.font : options.fontFamily;
        if (text2.charCodeAt(0) === 55349) {
          var _wideCharacterFont = wideCharacterFont(text2, mode), wideFontName = _wideCharacterFont[0], wideFontClass = _wideCharacterFont[1];
          return makeSymbol(text2, wideFontName, mode, options, classes.concat(wideFontClass));
        } else if (fontOrFamily) {
          var fontName;
          var fontClasses;
          if (fontOrFamily === "boldsymbol") {
            var fontData = boldsymbol(text2, mode, options, classes, type);
            fontName = fontData.fontName;
            fontClasses = [fontData.fontClass];
          } else if (isFont) {
            fontName = fontMap[fontOrFamily].fontName;
            fontClasses = [fontOrFamily];
          } else {
            fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
            fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
          }
          if (lookupSymbol(text2, fontName, mode).metrics) {
            return makeSymbol(text2, fontName, mode, options, classes.concat(fontClasses));
          } else if (ligatures.hasOwnProperty(text2) && fontName.slice(0, 10) === "Typewriter") {
            var parts = [];
            for (var i3 = 0; i3 < text2.length; i3++) {
              parts.push(makeSymbol(text2[i3], fontName, mode, options, classes.concat(fontClasses)));
            }
            return makeFragment(parts);
          }
        }
        if (type === "mathord") {
          return makeSymbol(text2, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
        } else if (type === "textord") {
          var font = src_symbols[mode][text2] && src_symbols[mode][text2].font;
          if (font === "ams") {
            var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
            return makeSymbol(text2, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
          } else if (font === "main" || !font) {
            var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
            return makeSymbol(text2, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
          } else {
            var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape);
            return makeSymbol(text2, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
          }
        } else {
          throw new Error("unexpected type: " + type + " in makeOrd");
        }
      };
      var canCombine = function canCombine2(prev, next) {
        if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
          return false;
        }
        if (prev.classes.length === 1) {
          var cls = prev.classes[0];
          if (cls === "mbin" || cls === "mord") {
            return false;
          }
        }
        for (var style in prev.style) {
          if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
            return false;
          }
        }
        for (var _style in next.style) {
          if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
            return false;
          }
        }
        return true;
      };
      var tryCombineChars = function tryCombineChars2(chars) {
        for (var i3 = 0; i3 < chars.length - 1; i3++) {
          var prev = chars[i3];
          var next = chars[i3 + 1];
          if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
            prev.text += next.text;
            prev.height = Math.max(prev.height, next.height);
            prev.depth = Math.max(prev.depth, next.depth);
            prev.italic = next.italic;
            chars.splice(i3 + 1, 1);
            i3--;
          }
        }
        return chars;
      };
      var sizeElementFromChildren = function sizeElementFromChildren2(elem) {
        var height = 0;
        var depth = 0;
        var maxFontSize = 0;
        for (var i3 = 0; i3 < elem.children.length; i3++) {
          var child = elem.children[i3];
          if (child.height > height) {
            height = child.height;
          }
          if (child.depth > depth) {
            depth = child.depth;
          }
          if (child.maxFontSize > maxFontSize) {
            maxFontSize = child.maxFontSize;
          }
        }
        elem.height = height;
        elem.depth = depth;
        elem.maxFontSize = maxFontSize;
      };
      var makeSpan = function makeSpan2(classes, children, options, style) {
        var span = new Span(classes, children, options, style);
        sizeElementFromChildren(span);
        return span;
      };
      var makeSvgSpan = function makeSvgSpan2(classes, children, options, style) {
        return new Span(classes, children, options, style);
      };
      var makeLineSpan = function makeLineSpan2(className, options, thickness) {
        var line = makeSpan([className], [], options);
        line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
        line.style.borderBottomWidth = makeEm(line.height);
        line.maxFontSize = 1;
        return line;
      };
      var makeAnchor = function makeAnchor2(href, classes, children, options) {
        var anchor = new Anchor(href, classes, children, options);
        sizeElementFromChildren(anchor);
        return anchor;
      };
      var makeFragment = function makeFragment2(children) {
        var fragment = new DocumentFragment(children);
        sizeElementFromChildren(fragment);
        return fragment;
      };
      var wrapFragment = function wrapFragment2(group, options) {
        if (group instanceof DocumentFragment) {
          return makeSpan([], [group], options);
        }
        return group;
      };
      var getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
        if (params.positionType === "individualShift") {
          var oldChildren = params.children;
          var children = [oldChildren[0]];
          var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
          var currPos = _depth;
          for (var i3 = 1; i3 < oldChildren.length; i3++) {
            var diff = -oldChildren[i3].shift - currPos - oldChildren[i3].elem.depth;
            var size = diff - (oldChildren[i3 - 1].elem.height + oldChildren[i3 - 1].elem.depth);
            currPos = currPos + diff;
            children.push({
              type: "kern",
              size
            });
            children.push(oldChildren[i3]);
          }
          return {
            children,
            depth: _depth
          };
        }
        var depth;
        if (params.positionType === "top") {
          var bottom = params.positionData;
          for (var _i6 = 0; _i6 < params.children.length; _i6++) {
            var child = params.children[_i6];
            bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
          }
          depth = bottom;
        } else if (params.positionType === "bottom") {
          depth = -params.positionData;
        } else {
          var firstChild = params.children[0];
          if (firstChild.type !== "elem") {
            throw new Error('First child must have type "elem".');
          }
          if (params.positionType === "shift") {
            depth = -firstChild.elem.depth - params.positionData;
          } else if (params.positionType === "firstBaseline") {
            depth = -firstChild.elem.depth;
          } else {
            throw new Error("Invalid positionType " + params.positionType + ".");
          }
        }
        return {
          children: params.children,
          depth
        };
      };
      var makeVList = function makeVList2(params, options) {
        var _getVListChildrenAndD = getVListChildrenAndDepth(params), children = _getVListChildrenAndD.children, depth = _getVListChildrenAndD.depth;
        var pstrutSize = 0;
        for (var i3 = 0; i3 < children.length; i3++) {
          var child = children[i3];
          if (child.type === "elem") {
            var elem = child.elem;
            pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
          }
        }
        pstrutSize += 2;
        var pstrut = makeSpan(["pstrut"], []);
        pstrut.style.height = makeEm(pstrutSize);
        var realChildren = [];
        var minPos = depth;
        var maxPos = depth;
        var currPos = depth;
        for (var _i22 = 0; _i22 < children.length; _i22++) {
          var _child = children[_i22];
          if (_child.type === "kern") {
            currPos += _child.size;
          } else {
            var _elem = _child.elem;
            var classes = _child.wrapperClasses || [];
            var style = _child.wrapperStyle || {};
            var childWrap = makeSpan(classes, [pstrut, _elem], void 0, style);
            childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);
            if (_child.marginLeft) {
              childWrap.style.marginLeft = _child.marginLeft;
            }
            if (_child.marginRight) {
              childWrap.style.marginRight = _child.marginRight;
            }
            realChildren.push(childWrap);
            currPos += _elem.height + _elem.depth;
          }
          minPos = Math.min(minPos, currPos);
          maxPos = Math.max(maxPos, currPos);
        }
        var vlist = makeSpan(["vlist"], realChildren);
        vlist.style.height = makeEm(maxPos);
        var rows;
        if (minPos < 0) {
          var emptySpan = makeSpan([], []);
          var depthStrut = makeSpan(["vlist"], [emptySpan]);
          depthStrut.style.height = makeEm(-minPos);
          var topStrut = makeSpan(["vlist-s"], [new SymbolNode("\u200B")]);
          rows = [makeSpan(["vlist-r"], [vlist, topStrut]), makeSpan(["vlist-r"], [depthStrut])];
        } else {
          rows = [makeSpan(["vlist-r"], [vlist])];
        }
        var vtable = makeSpan(["vlist-t"], rows);
        if (rows.length === 2) {
          vtable.classes.push("vlist-t2");
        }
        vtable.height = maxPos;
        vtable.depth = -minPos;
        return vtable;
      };
      var makeGlue = function makeGlue2(measurement, options) {
        var rule = makeSpan(["mspace"], [], options);
        var size = calculateSize(measurement, options);
        rule.style.marginRight = makeEm(size);
        return rule;
      };
      var retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
        var baseFontName = "";
        switch (fontFamily) {
          case "amsrm":
            baseFontName = "AMS";
            break;
          case "textrm":
            baseFontName = "Main";
            break;
          case "textsf":
            baseFontName = "SansSerif";
            break;
          case "texttt":
            baseFontName = "Typewriter";
            break;
          default:
            baseFontName = fontFamily;
        }
        var fontStylesName;
        if (fontWeight === "textbf" && fontShape === "textit") {
          fontStylesName = "BoldItalic";
        } else if (fontWeight === "textbf") {
          fontStylesName = "Bold";
        } else if (fontWeight === "textit") {
          fontStylesName = "Italic";
        } else {
          fontStylesName = "Regular";
        }
        return baseFontName + "-" + fontStylesName;
      };
      var fontMap = {
        "mathbf": {
          variant: "bold",
          fontName: "Main-Bold"
        },
        "mathrm": {
          variant: "normal",
          fontName: "Main-Regular"
        },
        "textit": {
          variant: "italic",
          fontName: "Main-Italic"
        },
        "mathit": {
          variant: "italic",
          fontName: "Main-Italic"
        },
        "mathnormal": {
          variant: "italic",
          fontName: "Math-Italic"
        },
        "mathbb": {
          variant: "double-struck",
          fontName: "AMS-Regular"
        },
        "mathcal": {
          variant: "script",
          fontName: "Caligraphic-Regular"
        },
        "mathfrak": {
          variant: "fraktur",
          fontName: "Fraktur-Regular"
        },
        "mathscr": {
          variant: "script",
          fontName: "Script-Regular"
        },
        "mathsf": {
          variant: "sans-serif",
          fontName: "SansSerif-Regular"
        },
        "mathtt": {
          variant: "monospace",
          fontName: "Typewriter-Regular"
        }
      };
      var svgData = {
        vec: ["vec", 0.471, 0.714],
        oiintSize1: ["oiintSize1", 0.957, 0.499],
        oiintSize2: ["oiintSize2", 1.472, 0.659],
        oiiintSize1: ["oiiintSize1", 1.304, 0.499],
        oiiintSize2: ["oiiintSize2", 1.98, 0.659]
      };
      var staticSvg = function staticSvg2(value, options) {
        var _svgData$value = svgData[value], pathName = _svgData$value[0], width = _svgData$value[1], height = _svgData$value[2];
        var path2 = new PathNode(pathName);
        var svgNode = new SvgNode([path2], {
          "width": makeEm(width),
          "height": makeEm(height),
          "style": "width:" + makeEm(width),
          "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
          "preserveAspectRatio": "xMinYMin"
        });
        var span = makeSvgSpan(["overlay"], [svgNode], options);
        span.height = height;
        span.style.height = makeEm(height);
        span.style.width = makeEm(width);
        return span;
      };
      var buildCommon = {
        fontMap,
        makeSymbol,
        mathsym,
        makeSpan,
        makeSvgSpan,
        makeLineSpan,
        makeAnchor,
        makeFragment,
        wrapFragment,
        makeVList,
        makeOrd,
        makeGlue,
        staticSvg,
        svgData,
        tryCombineChars
      };
      var thinspace = {
        number: 3,
        unit: "mu"
      };
      var mediumspace = {
        number: 4,
        unit: "mu"
      };
      var thickspace = {
        number: 5,
        unit: "mu"
      };
      var spacings = {
        mord: {
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          minner: thinspace
        },
        mop: {
          mord: thinspace,
          mop: thinspace,
          mrel: thickspace,
          minner: thinspace
        },
        mbin: {
          mord: mediumspace,
          mop: mediumspace,
          mopen: mediumspace,
          minner: mediumspace
        },
        mrel: {
          mord: thickspace,
          mop: thickspace,
          mopen: thickspace,
          minner: thickspace
        },
        mopen: {},
        mclose: {
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          minner: thinspace
        },
        mpunct: {
          mord: thinspace,
          mop: thinspace,
          mrel: thickspace,
          mopen: thinspace,
          mclose: thinspace,
          mpunct: thinspace,
          minner: thinspace
        },
        minner: {
          mord: thinspace,
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          mopen: thinspace,
          mpunct: thinspace,
          minner: thinspace
        }
      };
      var tightSpacings = {
        mord: {
          mop: thinspace
        },
        mop: {
          mord: thinspace,
          mop: thinspace
        },
        mbin: {},
        mrel: {},
        mopen: {},
        mclose: {
          mop: thinspace
        },
        mpunct: {},
        minner: {
          mop: thinspace
        }
      };
      var _functions = {};
      var _htmlGroupBuilders = {};
      var _mathmlGroupBuilders = {};
      function defineFunction(_ref) {
        var type = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder2 = _ref.htmlBuilder, mathmlBuilder2 = _ref.mathmlBuilder;
        var data = {
          type,
          numArgs: props.numArgs,
          argTypes: props.argTypes,
          allowedInArgument: !!props.allowedInArgument,
          allowedInText: !!props.allowedInText,
          allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
          numOptionalArgs: props.numOptionalArgs || 0,
          infix: !!props.infix,
          primitive: !!props.primitive,
          handler
        };
        for (var i3 = 0; i3 < names.length; ++i3) {
          _functions[names[i3]] = data;
        }
        if (type) {
          if (htmlBuilder2) {
            _htmlGroupBuilders[type] = htmlBuilder2;
          }
          if (mathmlBuilder2) {
            _mathmlGroupBuilders[type] = mathmlBuilder2;
          }
        }
      }
      function defineFunctionBuilders(_ref2) {
        var type = _ref2.type, htmlBuilder2 = _ref2.htmlBuilder, mathmlBuilder2 = _ref2.mathmlBuilder;
        defineFunction({
          type,
          names: [],
          props: {
            numArgs: 0
          },
          handler: function handler() {
            throw new Error("Should never be called.");
          },
          htmlBuilder: htmlBuilder2,
          mathmlBuilder: mathmlBuilder2
        });
      }
      var normalizeArgument = function normalizeArgument2(arg) {
        return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
      };
      var ordargument = function ordargument2(arg) {
        return arg.type === "ordgroup" ? arg.body : [arg];
      };
      var buildHTML_makeSpan = buildCommon.makeSpan;
      var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
      var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
      var styleMap = {
        "display": src_Style.DISPLAY,
        "text": src_Style.TEXT,
        "script": src_Style.SCRIPT,
        "scriptscript": src_Style.SCRIPTSCRIPT
      };
      var DomEnum = {
        mord: "mord",
        mop: "mop",
        mbin: "mbin",
        mrel: "mrel",
        mopen: "mopen",
        mclose: "mclose",
        mpunct: "mpunct",
        minner: "minner"
      };
      var buildExpression = function buildExpression2(expression, options, isRealGroup, surrounding) {
        if (surrounding === void 0) {
          surrounding = [null, null];
        }
        var groups = [];
        for (var i3 = 0; i3 < expression.length; i3++) {
          var output = buildGroup(expression[i3], options);
          if (output instanceof DocumentFragment) {
            var children = output.children;
            groups.push.apply(groups, children);
          } else {
            groups.push(output);
          }
        }
        buildCommon.tryCombineChars(groups);
        if (!isRealGroup) {
          return groups;
        }
        var glueOptions = options;
        if (expression.length === 1) {
          var node = expression[0];
          if (node.type === "sizing") {
            glueOptions = options.havingSize(node.size);
          } else if (node.type === "styling") {
            glueOptions = options.havingStyle(styleMap[node.style]);
          }
        }
        var dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
        var dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options);
        var isRoot = isRealGroup === "root";
        traverseNonSpaceNodes(groups, function(node2, prev) {
          var prevType = prev.classes[0];
          var type = node2.classes[0];
          if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
            prev.classes[0] = "mord";
          } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
            node2.classes[0] = "mord";
          }
        }, {
          node: dummyPrev
        }, dummyNext, isRoot);
        traverseNonSpaceNodes(groups, function(node2, prev) {
          var prevType = getTypeOfDomTree(prev);
          var type = getTypeOfDomTree(node2);
          var space = prevType && type ? node2.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
          if (space) {
            return buildCommon.makeGlue(space, glueOptions);
          }
        }, {
          node: dummyPrev
        }, dummyNext, isRoot);
        return groups;
      };
      var traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev, next, isRoot) {
        if (next) {
          nodes.push(next);
        }
        var i3 = 0;
        for (; i3 < nodes.length; i3++) {
          var node = nodes[i3];
          var partialGroup = checkPartialGroup(node);
          if (partialGroup) {
            traverseNonSpaceNodes2(partialGroup.children, callback, prev, null, isRoot);
            continue;
          }
          var nonspace = !node.hasClass("mspace");
          if (nonspace) {
            var result = callback(node, prev.node);
            if (result) {
              if (prev.insertAfter) {
                prev.insertAfter(result);
              } else {
                nodes.unshift(result);
                i3++;
              }
            }
          }
          if (nonspace) {
            prev.node = node;
          } else if (isRoot && node.hasClass("newline")) {
            prev.node = buildHTML_makeSpan(["leftmost"]);
          }
          prev.insertAfter = function(index) {
            return function(n2) {
              nodes.splice(index + 1, 0, n2);
              i3++;
            };
          }(i3);
        }
        if (next) {
          nodes.pop();
        }
      };
      var checkPartialGroup = function checkPartialGroup2(node) {
        if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
          return node;
        }
        return null;
      };
      var getOutermostNode = function getOutermostNode2(node, side) {
        var partialGroup = checkPartialGroup(node);
        if (partialGroup) {
          var children = partialGroup.children;
          if (children.length) {
            if (side === "right") {
              return getOutermostNode2(children[children.length - 1], "right");
            } else if (side === "left") {
              return getOutermostNode2(children[0], "left");
            }
          }
        }
        return node;
      };
      var getTypeOfDomTree = function getTypeOfDomTree2(node, side) {
        if (!node) {
          return null;
        }
        if (side) {
          node = getOutermostNode(node, side);
        }
        return DomEnum[node.classes[0]] || null;
      };
      var makeNullDelimiter = function makeNullDelimiter2(options, classes) {
        var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
        return buildHTML_makeSpan(classes.concat(moreClasses));
      };
      var buildGroup = function buildGroup2(group, options, baseOptions) {
        if (!group) {
          return buildHTML_makeSpan();
        }
        if (_htmlGroupBuilders[group.type]) {
          var groupNode = _htmlGroupBuilders[group.type](group, options);
          if (baseOptions && options.size !== baseOptions.size) {
            groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);
            var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
          }
          return groupNode;
        } else {
          throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
        }
      };
      function buildHTMLUnbreakable(children, options) {
        var body = buildHTML_makeSpan(["base"], children, options);
        var strut = buildHTML_makeSpan(["strut"]);
        strut.style.height = makeEm(body.height + body.depth);
        if (body.depth) {
          strut.style.verticalAlign = makeEm(-body.depth);
        }
        body.children.unshift(strut);
        return body;
      }
      function buildHTML(tree, options) {
        var tag = null;
        if (tree.length === 1 && tree[0].type === "tag") {
          tag = tree[0].tag;
          tree = tree[0].body;
        }
        var expression = buildExpression(tree, options, "root");
        var eqnNum;
        if (expression.length === 2 && expression[1].hasClass("tag")) {
          eqnNum = expression.pop();
        }
        var children = [];
        var parts = [];
        for (var i3 = 0; i3 < expression.length; i3++) {
          parts.push(expression[i3]);
          if (expression[i3].hasClass("mbin") || expression[i3].hasClass("mrel") || expression[i3].hasClass("allowbreak")) {
            var nobreak = false;
            while (i3 < expression.length - 1 && expression[i3 + 1].hasClass("mspace") && !expression[i3 + 1].hasClass("newline")) {
              i3++;
              parts.push(expression[i3]);
              if (expression[i3].hasClass("nobreak")) {
                nobreak = true;
              }
            }
            if (!nobreak) {
              children.push(buildHTMLUnbreakable(parts, options));
              parts = [];
            }
          } else if (expression[i3].hasClass("newline")) {
            parts.pop();
            if (parts.length > 0) {
              children.push(buildHTMLUnbreakable(parts, options));
              parts = [];
            }
            children.push(expression[i3]);
          }
        }
        if (parts.length > 0) {
          children.push(buildHTMLUnbreakable(parts, options));
        }
        var tagChild;
        if (tag) {
          tagChild = buildHTMLUnbreakable(buildExpression(tag, options, true));
          tagChild.classes = ["tag"];
          children.push(tagChild);
        } else if (eqnNum) {
          children.push(eqnNum);
        }
        var htmlNode = buildHTML_makeSpan(["katex-html"], children);
        htmlNode.setAttribute("aria-hidden", "true");
        if (tagChild) {
          var strut = tagChild.children[0];
          strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
          if (htmlNode.depth) {
            strut.style.verticalAlign = makeEm(-htmlNode.depth);
          }
        }
        return htmlNode;
      }
      function newDocumentFragment(children) {
        return new DocumentFragment(children);
      }
      var MathNode = function() {
        function MathNode2(type, children, classes) {
          this.type = void 0;
          this.attributes = void 0;
          this.children = void 0;
          this.classes = void 0;
          this.type = type;
          this.attributes = {};
          this.children = children || [];
          this.classes = classes || [];
        }
        var _proto = MathNode2.prototype;
        _proto.setAttribute = function setAttribute(name, value) {
          this.attributes[name] = value;
        };
        _proto.getAttribute = function getAttribute(name) {
          return this.attributes[name];
        };
        _proto.toNode = function toNode() {
          var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node.setAttribute(attr, this.attributes[attr]);
            }
          }
          if (this.classes.length > 0) {
            node.className = createClass(this.classes);
          }
          for (var i3 = 0; i3 < this.children.length; i3++) {
            node.appendChild(this.children[i3].toNode());
          }
          return node;
        };
        _proto.toMarkup = function toMarkup() {
          var markup = "<" + this.type;
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="';
              markup += utils.escape(this.attributes[attr]);
              markup += '"';
            }
          }
          if (this.classes.length > 0) {
            markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
          }
          markup += ">";
          for (var i3 = 0; i3 < this.children.length; i3++) {
            markup += this.children[i3].toMarkup();
          }
          markup += "</" + this.type + ">";
          return markup;
        };
        _proto.toText = function toText() {
          return this.children.map(function(child) {
            return child.toText();
          }).join("");
        };
        return MathNode2;
      }();
      var TextNode = function() {
        function TextNode2(text2) {
          this.text = void 0;
          this.text = text2;
        }
        var _proto2 = TextNode2.prototype;
        _proto2.toNode = function toNode() {
          return document.createTextNode(this.text);
        };
        _proto2.toMarkup = function toMarkup() {
          return utils.escape(this.toText());
        };
        _proto2.toText = function toText() {
          return this.text;
        };
        return TextNode2;
      }();
      var SpaceNode = function() {
        function SpaceNode2(width) {
          this.width = void 0;
          this.character = void 0;
          this.width = width;
          if (width >= 0.05555 && width <= 0.05556) {
            this.character = "\u200A";
          } else if (width >= 0.1666 && width <= 0.1667) {
            this.character = "\u2009";
          } else if (width >= 0.2222 && width <= 0.2223) {
            this.character = "\u2005";
          } else if (width >= 0.2777 && width <= 0.2778) {
            this.character = "\u2005\u200A";
          } else if (width >= -0.05556 && width <= -0.05555) {
            this.character = "\u200A\u2063";
          } else if (width >= -0.1667 && width <= -0.1666) {
            this.character = "\u2009\u2063";
          } else if (width >= -0.2223 && width <= -0.2222) {
            this.character = "\u205F\u2063";
          } else if (width >= -0.2778 && width <= -0.2777) {
            this.character = "\u2005\u2063";
          } else {
            this.character = null;
          }
        }
        var _proto3 = SpaceNode2.prototype;
        _proto3.toNode = function toNode() {
          if (this.character) {
            return document.createTextNode(this.character);
          } else {
            var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
            node.setAttribute("width", makeEm(this.width));
            return node;
          }
        };
        _proto3.toMarkup = function toMarkup() {
          if (this.character) {
            return "<mtext>" + this.character + "</mtext>";
          } else {
            return '<mspace width="' + makeEm(this.width) + '"/>';
          }
        };
        _proto3.toText = function toText() {
          if (this.character) {
            return this.character;
          } else {
            return " ";
          }
        };
        return SpaceNode2;
      }();
      var mathMLTree = {
        MathNode,
        TextNode,
        SpaceNode,
        newDocumentFragment
      };
      var makeText = function makeText2(text2, mode, options) {
        if (src_symbols[mode][text2] && src_symbols[mode][text2].replace && text2.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text2) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
          text2 = src_symbols[mode][text2].replace;
        }
        return new mathMLTree.TextNode(text2);
      };
      var makeRow = function makeRow2(body) {
        if (body.length === 1) {
          return body[0];
        } else {
          return new mathMLTree.MathNode("mrow", body);
        }
      };
      var getVariant = function getVariant2(group, options) {
        if (options.fontFamily === "texttt") {
          return "monospace";
        } else if (options.fontFamily === "textsf") {
          if (options.fontShape === "textit" && options.fontWeight === "textbf") {
            return "sans-serif-bold-italic";
          } else if (options.fontShape === "textit") {
            return "sans-serif-italic";
          } else if (options.fontWeight === "textbf") {
            return "bold-sans-serif";
          } else {
            return "sans-serif";
          }
        } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
          return "bold-italic";
        } else if (options.fontShape === "textit") {
          return "italic";
        } else if (options.fontWeight === "textbf") {
          return "bold";
        }
        var font = options.font;
        if (!font || font === "mathnormal") {
          return null;
        }
        var mode = group.mode;
        if (font === "mathit") {
          return "italic";
        } else if (font === "boldsymbol") {
          return group.type === "textord" ? "bold" : "bold-italic";
        } else if (font === "mathbf") {
          return "bold";
        } else if (font === "mathbb") {
          return "double-struck";
        } else if (font === "mathfrak") {
          return "fraktur";
        } else if (font === "mathscr" || font === "mathcal") {
          return "script";
        } else if (font === "mathsf") {
          return "sans-serif";
        } else if (font === "mathtt") {
          return "monospace";
        }
        var text2 = group.text;
        if (utils.contains(["\\imath", "\\jmath"], text2)) {
          return null;
        }
        if (src_symbols[mode][text2] && src_symbols[mode][text2].replace) {
          text2 = src_symbols[mode][text2].replace;
        }
        var fontName = buildCommon.fontMap[font].fontName;
        if (getCharacterMetrics(text2, fontName, mode)) {
          return buildCommon.fontMap[font].variant;
        }
        return null;
      };
      var buildMathML_buildExpression = function buildExpression2(expression, options, isOrdgroup) {
        if (expression.length === 1) {
          var group = buildMathML_buildGroup(expression[0], options);
          if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
            group.setAttribute("lspace", "0em");
            group.setAttribute("rspace", "0em");
          }
          return [group];
        }
        var groups = [];
        var lastGroup;
        for (var i3 = 0; i3 < expression.length; i3++) {
          var _group = buildMathML_buildGroup(expression[i3], options);
          if (_group instanceof MathNode && lastGroup instanceof MathNode) {
            if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
              var _lastGroup$children;
              (_lastGroup$children = lastGroup.children).push.apply(_lastGroup$children, _group.children);
              continue;
            } else if (_group.type === "mn" && lastGroup.type === "mn") {
              var _lastGroup$children2;
              (_lastGroup$children2 = lastGroup.children).push.apply(_lastGroup$children2, _group.children);
              continue;
            } else if (_group.type === "mi" && _group.children.length === 1 && lastGroup.type === "mn") {
              var child = _group.children[0];
              if (child instanceof TextNode && child.text === ".") {
                var _lastGroup$children3;
                (_lastGroup$children3 = lastGroup.children).push.apply(_lastGroup$children3, _group.children);
                continue;
              }
            } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
              var lastChild = lastGroup.children[0];
              if (lastChild instanceof TextNode && lastChild.text === "\u0338" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
                var _child = _group.children[0];
                if (_child instanceof TextNode && _child.text.length > 0) {
                  _child.text = _child.text.slice(0, 1) + "\u0338" + _child.text.slice(1);
                  groups.pop();
                }
              }
            }
          }
          groups.push(_group);
          lastGroup = _group;
        }
        return groups;
      };
      var buildExpressionRow = function buildExpressionRow2(expression, options, isOrdgroup) {
        return makeRow(buildMathML_buildExpression(expression, options, isOrdgroup));
      };
      var buildMathML_buildGroup = function buildGroup2(group, options) {
        if (!group) {
          return new mathMLTree.MathNode("mrow");
        }
        if (_mathmlGroupBuilders[group.type]) {
          var result = _mathmlGroupBuilders[group.type](group, options);
          return result;
        } else {
          throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
        }
      };
      function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
        var expression = buildMathML_buildExpression(tree, options);
        var wrapper;
        if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
          wrapper = expression[0];
        } else {
          wrapper = new mathMLTree.MathNode("mrow", expression);
        }
        var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
        annotation.setAttribute("encoding", "application/x-tex");
        var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
        var math2 = new mathMLTree.MathNode("math", [semantics]);
        math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
        if (isDisplayMode) {
          math2.setAttribute("display", "block");
        }
        var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
        return buildCommon.makeSpan([wrapperClass], [math2]);
      }
      var optionsFromSettings = function optionsFromSettings2(settings) {
        return new src_Options({
          style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
          maxSize: settings.maxSize,
          minRuleThickness: settings.minRuleThickness
        });
      };
      var displayWrap = function displayWrap2(node, settings) {
        if (settings.displayMode) {
          var classes = ["katex-display"];
          if (settings.leqno) {
            classes.push("leqno");
          }
          if (settings.fleqn) {
            classes.push("fleqn");
          }
          node = buildCommon.makeSpan(classes, [node]);
        }
        return node;
      };
      var buildTree = function buildTree2(tree, expression, settings) {
        var options = optionsFromSettings(settings);
        var katexNode;
        if (settings.output === "mathml") {
          return buildMathML(tree, expression, options, settings.displayMode, true);
        } else if (settings.output === "html") {
          var htmlNode = buildHTML(tree, options);
          katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
        } else {
          var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
          var _htmlNode = buildHTML(tree, options);
          katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
        }
        return displayWrap(katexNode, settings);
      };
      var buildHTMLTree = function buildHTMLTree2(tree, expression, settings) {
        var options = optionsFromSettings(settings);
        var htmlNode = buildHTML(tree, options);
        var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
        return displayWrap(katexNode, settings);
      };
      var stretchyCodePoint = {
        widehat: "^",
        widecheck: "\u02C7",
        widetilde: "~",
        utilde: "~",
        overleftarrow: "\u2190",
        underleftarrow: "\u2190",
        xleftarrow: "\u2190",
        overrightarrow: "\u2192",
        underrightarrow: "\u2192",
        xrightarrow: "\u2192",
        underbrace: "\u23DF",
        overbrace: "\u23DE",
        overgroup: "\u23E0",
        undergroup: "\u23E1",
        overleftrightarrow: "\u2194",
        underleftrightarrow: "\u2194",
        xleftrightarrow: "\u2194",
        Overrightarrow: "\u21D2",
        xRightarrow: "\u21D2",
        overleftharpoon: "\u21BC",
        xleftharpoonup: "\u21BC",
        overrightharpoon: "\u21C0",
        xrightharpoonup: "\u21C0",
        xLeftarrow: "\u21D0",
        xLeftrightarrow: "\u21D4",
        xhookleftarrow: "\u21A9",
        xhookrightarrow: "\u21AA",
        xmapsto: "\u21A6",
        xrightharpoondown: "\u21C1",
        xleftharpoondown: "\u21BD",
        xrightleftharpoons: "\u21CC",
        xleftrightharpoons: "\u21CB",
        xtwoheadleftarrow: "\u219E",
        xtwoheadrightarrow: "\u21A0",
        xlongequal: "=",
        xtofrom: "\u21C4",
        xrightleftarrows: "\u21C4",
        xrightequilibrium: "\u21CC",
        xleftequilibrium: "\u21CB",
        "\\cdrightarrow": "\u2192",
        "\\cdleftarrow": "\u2190",
        "\\cdlongequal": "="
      };
      var mathMLnode = function mathMLnode2(label) {
        var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
        node.setAttribute("stretchy", "true");
        return node;
      };
      var katexImagesData = {
        overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
        "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
        xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
        "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
        Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
        xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
        xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
        overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
        overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
        xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
        "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
        xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
        xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
        overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
        underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
        underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
        xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
        xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
        xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
        xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
        xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
        overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
        undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
        xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
        xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
        xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
        xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
        xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
      };
      var groupLength = function groupLength2(arg) {
        if (arg.type === "ordgroup") {
          return arg.body.length;
        } else {
          return 1;
        }
      };
      var svgSpan = function svgSpan2(group, options) {
        function buildSvgSpan_() {
          var viewBoxWidth = 4e5;
          var label = group.label.slice(1);
          if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
            var grp = group;
            var numChars = groupLength(grp.base);
            var viewBoxHeight;
            var pathName;
            var _height;
            if (numChars > 5) {
              if (label === "widehat" || label === "widecheck") {
                viewBoxHeight = 420;
                viewBoxWidth = 2364;
                _height = 0.42;
                pathName = label + "4";
              } else {
                viewBoxHeight = 312;
                viewBoxWidth = 2340;
                _height = 0.34;
                pathName = "tilde4";
              }
            } else {
              var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
              if (label === "widehat" || label === "widecheck") {
                viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                pathName = label + imgIndex;
              } else {
                viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                pathName = "tilde" + imgIndex;
              }
            }
            var path2 = new PathNode(pathName);
            var svgNode = new SvgNode([path2], {
              "width": "100%",
              "height": makeEm(_height),
              "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
              "preserveAspectRatio": "none"
            });
            return {
              span: buildCommon.makeSvgSpan([], [svgNode], options),
              minWidth: 0,
              height: _height
            };
          } else {
            var spans = [];
            var data = katexImagesData[label];
            var paths = data[0], _minWidth = data[1], _viewBoxHeight = data[2];
            var _height2 = _viewBoxHeight / 1e3;
            var numSvgChildren = paths.length;
            var widthClasses;
            var aligns;
            if (numSvgChildren === 1) {
              var align1 = data[3];
              widthClasses = ["hide-tail"];
              aligns = [align1];
            } else if (numSvgChildren === 2) {
              widthClasses = ["halfarrow-left", "halfarrow-right"];
              aligns = ["xMinYMin", "xMaxYMin"];
            } else if (numSvgChildren === 3) {
              widthClasses = ["brace-left", "brace-center", "brace-right"];
              aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
            } else {
              throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
            }
            for (var i3 = 0; i3 < numSvgChildren; i3++) {
              var _path = new PathNode(paths[i3]);
              var _svgNode = new SvgNode([_path], {
                "width": "400em",
                "height": makeEm(_height2),
                "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
                "preserveAspectRatio": aligns[i3] + " slice"
              });
              var _span = buildCommon.makeSvgSpan([widthClasses[i3]], [_svgNode], options);
              if (numSvgChildren === 1) {
                return {
                  span: _span,
                  minWidth: _minWidth,
                  height: _height2
                };
              } else {
                _span.style.height = makeEm(_height2);
                spans.push(_span);
              }
            }
            return {
              span: buildCommon.makeSpan(["stretchy"], spans, options),
              minWidth: _minWidth,
              height: _height2
            };
          }
        }
        var _buildSvgSpan_ = buildSvgSpan_(), span = _buildSvgSpan_.span, minWidth = _buildSvgSpan_.minWidth, height = _buildSvgSpan_.height;
        span.height = height;
        span.style.height = makeEm(height);
        if (minWidth > 0) {
          span.style.minWidth = makeEm(minWidth);
        }
        return span;
      };
      var encloseSpan = function encloseSpan2(inner2, label, topPad, bottomPad, options) {
        var img;
        var totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
        if (/fbox|color|angl/.test(label)) {
          img = buildCommon.makeSpan(["stretchy", label], [], options);
          if (label === "fbox") {
            var color = options.color && options.getColor();
            if (color) {
              img.style.borderColor = color;
            }
          }
        } else {
          var lines = [];
          if (/^[bx]cancel$/.test(label)) {
            lines.push(new LineNode({
              "x1": "0",
              "y1": "0",
              "x2": "100%",
              "y2": "100%",
              "stroke-width": "0.046em"
            }));
          }
          if (/^x?cancel$/.test(label)) {
            lines.push(new LineNode({
              "x1": "0",
              "y1": "100%",
              "x2": "100%",
              "y2": "0",
              "stroke-width": "0.046em"
            }));
          }
          var svgNode = new SvgNode(lines, {
            "width": "100%",
            "height": makeEm(totalHeight)
          });
          img = buildCommon.makeSvgSpan([], [svgNode], options);
        }
        img.height = totalHeight;
        img.style.height = makeEm(totalHeight);
        return img;
      };
      var stretchy = {
        encloseSpan,
        mathMLnode,
        svgSpan
      };
      function assertNodeType(node, type) {
        if (!node || node.type !== type) {
          throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
        }
        return node;
      }
      function assertSymbolNodeType(node) {
        var typedNode = checkSymbolNodeType(node);
        if (!typedNode) {
          throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
        }
        return typedNode;
      }
      function checkSymbolNodeType(node) {
        if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
          return node;
        }
        return null;
      }
      var htmlBuilder = function htmlBuilder2(grp, options) {
        var base;
        var group;
        var supSubGroup;
        if (grp && grp.type === "supsub") {
          group = assertNodeType(grp.base, "accent");
          base = group.base;
          grp.base = base;
          supSubGroup = assertSpan(buildGroup(grp, options));
          grp.base = group;
        } else {
          group = assertNodeType(grp, "accent");
          base = group.base;
        }
        var body = buildGroup(base, options.havingCrampedStyle());
        var mustShift = group.isShifty && utils.isCharacterBox(base);
        var skew = 0;
        if (mustShift) {
          var baseChar = utils.getBaseElem(base);
          var baseGroup = buildGroup(baseChar, options.havingCrampedStyle());
          skew = assertSymbolDomNode(baseGroup).skew;
        }
        var accentBelow = group.label === "\\c";
        var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight);
        var accentBody;
        if (!group.isStretchy) {
          var accent2;
          var width;
          if (group.label === "\\vec") {
            accent2 = buildCommon.staticSvg("vec", options);
            width = buildCommon.svgData.vec[1];
          } else {
            accent2 = buildCommon.makeOrd({
              mode: group.mode,
              text: group.label
            }, options, "textord");
            accent2 = assertSymbolDomNode(accent2);
            accent2.italic = 0;
            width = accent2.width;
            if (accentBelow) {
              clearance += accent2.depth;
            }
          }
          accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
          var accentFull = group.label === "\\textcircled";
          if (accentFull) {
            accentBody.classes.push("accent-full");
            clearance = body.height;
          }
          var left = skew;
          if (!accentFull) {
            left -= width / 2;
          }
          accentBody.style.left = makeEm(left);
          if (group.label === "\\textcircled") {
            accentBody.style.top = ".2em";
          }
          accentBody = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "kern",
              size: -clearance
            }, {
              type: "elem",
              elem: accentBody
            }]
          }, options);
        } else {
          accentBody = stretchy.svgSpan(group, options);
          accentBody = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "elem",
              elem: accentBody,
              wrapperClasses: ["svg-align"],
              wrapperStyle: skew > 0 ? {
                width: "calc(100% - " + makeEm(2 * skew) + ")",
                marginLeft: makeEm(2 * skew)
              } : void 0
            }]
          }, options);
        }
        var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
        if (supSubGroup) {
          supSubGroup.children[0] = accentWrap;
          supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
          supSubGroup.classes[0] = "mord";
          return supSubGroup;
        } else {
          return accentWrap;
        }
      };
      var mathmlBuilder = function mathmlBuilder2(group, options) {
        var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
        var node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
        node.setAttribute("accent", "true");
        return node;
      };
      var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(function(accent2) {
        return "\\" + accent2;
      }).join("|"));
      defineFunction({
        type: "accent",
        names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
        props: {
          numArgs: 1
        },
        handler: function handler(context, args) {
          var base = normalizeArgument(args[0]);
          var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
          var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
          return {
            type: "accent",
            mode: context.parser.mode,
            label: context.funcName,
            isStretchy,
            isShifty,
            base
          };
        },
        htmlBuilder,
        mathmlBuilder
      });
      defineFunction({
        type: "accent",
        names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
        props: {
          numArgs: 1,
          allowedInText: true,
          allowedInMath: true,
          argTypes: ["primitive"]
        },
        handler: function handler(context, args) {
          var base = args[0];
          var mode = context.parser.mode;
          if (mode === "math") {
            context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
            mode = "text";
          }
          return {
            type: "accent",
            mode,
            label: context.funcName,
            isStretchy: false,
            isShifty: true,
            base
          };
        },
        htmlBuilder,
        mathmlBuilder
      });
      defineFunction({
        type: "accentUnder",
        names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var base = args[0];
          return {
            type: "accentUnder",
            mode: parser.mode,
            label: funcName,
            base
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var innerGroup = buildGroup(group.base, options);
          var accentBody = stretchy.svgSpan(group, options);
          var kern = group.label === "\\utilde" ? 0.12 : 0;
          var vlist = buildCommon.makeVList({
            positionType: "top",
            positionData: innerGroup.height,
            children: [{
              type: "elem",
              elem: accentBody,
              wrapperClasses: ["svg-align"]
            }, {
              type: "kern",
              size: kern
            }, {
              type: "elem",
              elem: innerGroup
            }]
          }, options);
          return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var accentNode = stretchy.mathMLnode(group.label);
          var node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
          node.setAttribute("accentunder", "true");
          return node;
        }
      });
      var paddedNode = function paddedNode2(group) {
        var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
        node.setAttribute("width", "+0.6em");
        node.setAttribute("lspace", "0.3em");
        return node;
      };
      defineFunction({
        type: "xArrow",
        names: [
          "\\xleftarrow",
          "\\xrightarrow",
          "\\xLeftarrow",
          "\\xRightarrow",
          "\\xleftrightarrow",
          "\\xLeftrightarrow",
          "\\xhookleftarrow",
          "\\xhookrightarrow",
          "\\xmapsto",
          "\\xrightharpoondown",
          "\\xrightharpoonup",
          "\\xleftharpoondown",
          "\\xleftharpoonup",
          "\\xrightleftharpoons",
          "\\xleftrightharpoons",
          "\\xlongequal",
          "\\xtwoheadrightarrow",
          "\\xtwoheadleftarrow",
          "\\xtofrom",
          "\\xrightleftarrows",
          "\\xrightequilibrium",
          "\\xleftequilibrium",
          "\\\\cdrightarrow",
          "\\\\cdleftarrow",
          "\\\\cdlongequal"
        ],
        props: {
          numArgs: 1,
          numOptionalArgs: 1
        },
        handler: function handler(_ref, args, optArgs) {
          var parser = _ref.parser, funcName = _ref.funcName;
          return {
            type: "xArrow",
            mode: parser.mode,
            label: funcName,
            body: args[0],
            below: optArgs[0]
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var style = options.style;
          var newOptions = options.havingStyle(style.sup());
          var upperGroup = buildCommon.wrapFragment(buildGroup(group.body, newOptions, options), options);
          var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
          upperGroup.classes.push(arrowPrefix + "-arrow-pad");
          var lowerGroup;
          if (group.below) {
            newOptions = options.havingStyle(style.sub());
            lowerGroup = buildCommon.wrapFragment(buildGroup(group.below, newOptions, options), options);
            lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
          }
          var arrowBody = stretchy.svgSpan(group, options);
          var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
          var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
          if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
            upperShift -= upperGroup.depth;
          }
          var vlist;
          if (lowerGroup) {
            var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: upperGroup,
                shift: upperShift
              }, {
                type: "elem",
                elem: arrowBody,
                shift: arrowShift
              }, {
                type: "elem",
                elem: lowerGroup,
                shift: lowerShift
              }]
            }, options);
          } else {
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: upperGroup,
                shift: upperShift
              }, {
                type: "elem",
                elem: arrowBody,
                shift: arrowShift
              }]
            }, options);
          }
          vlist.children[0].children[0].children[1].classes.push("svg-align");
          return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var arrowNode = stretchy.mathMLnode(group.label);
          arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
          var node;
          if (group.body) {
            var upperNode = paddedNode(buildMathML_buildGroup(group.body, options));
            if (group.below) {
              var lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
              node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
            } else {
              node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
            }
          } else if (group.below) {
            var _lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
            node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
          } else {
            node = paddedNode();
            node = new mathMLTree.MathNode("mover", [arrowNode, node]);
          }
          return node;
        }
      });
      var mclass_makeSpan = buildCommon.makeSpan;
      function mclass_htmlBuilder(group, options) {
        var elements = buildExpression(group.body, options, true);
        return mclass_makeSpan([group.mclass], elements, options);
      }
      function mclass_mathmlBuilder(group, options) {
        var node;
        var inner2 = buildMathML_buildExpression(group.body, options);
        if (group.mclass === "minner") {
          node = new mathMLTree.MathNode("mpadded", inner2);
        } else if (group.mclass === "mord") {
          if (group.isCharacterBox) {
            node = inner2[0];
            node.type = "mi";
          } else {
            node = new mathMLTree.MathNode("mi", inner2);
          }
        } else {
          if (group.isCharacterBox) {
            node = inner2[0];
            node.type = "mo";
          } else {
            node = new mathMLTree.MathNode("mo", inner2);
          }
          if (group.mclass === "mbin") {
            node.attributes.lspace = "0.22em";
            node.attributes.rspace = "0.22em";
          } else if (group.mclass === "mpunct") {
            node.attributes.lspace = "0em";
            node.attributes.rspace = "0.17em";
          } else if (group.mclass === "mopen" || group.mclass === "mclose") {
            node.attributes.lspace = "0em";
            node.attributes.rspace = "0em";
          } else if (group.mclass === "minner") {
            node.attributes.lspace = "0.0556em";
            node.attributes.width = "+0.1111em";
          }
        }
        return node;
      }
      defineFunction({
        type: "mclass",
        names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var body = args[0];
          return {
            type: "mclass",
            mode: parser.mode,
            mclass: "m" + funcName.slice(5),
            body: ordargument(body),
            isCharacterBox: utils.isCharacterBox(body)
          };
        },
        htmlBuilder: mclass_htmlBuilder,
        mathmlBuilder: mclass_mathmlBuilder
      });
      var binrelClass = function binrelClass2(arg) {
        var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
        if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
          return "m" + atom.family;
        } else {
          return "mord";
        }
      };
      defineFunction({
        type: "mclass",
        names: ["\\@binrel"],
        props: {
          numArgs: 2
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser;
          return {
            type: "mclass",
            mode: parser.mode,
            mclass: binrelClass(args[0]),
            body: ordargument(args[1]),
            isCharacterBox: utils.isCharacterBox(args[1])
          };
        }
      });
      defineFunction({
        type: "mclass",
        names: ["\\stackrel", "\\overset", "\\underset"],
        props: {
          numArgs: 2
        },
        handler: function handler(_ref3, args) {
          var parser = _ref3.parser, funcName = _ref3.funcName;
          var baseArg = args[1];
          var shiftedArg = args[0];
          var mclass;
          if (funcName !== "\\stackrel") {
            mclass = binrelClass(baseArg);
          } else {
            mclass = "mrel";
          }
          var baseOp = {
            type: "op",
            mode: baseArg.mode,
            limits: true,
            alwaysHandleSupSub: true,
            parentIsSupSub: false,
            symbol: false,
            suppressBaseShift: funcName !== "\\stackrel",
            body: ordargument(baseArg)
          };
          var supsub = {
            type: "supsub",
            mode: shiftedArg.mode,
            base: baseOp,
            sup: funcName === "\\underset" ? null : shiftedArg,
            sub: funcName === "\\underset" ? shiftedArg : null
          };
          return {
            type: "mclass",
            mode: parser.mode,
            mclass,
            body: [supsub],
            isCharacterBox: utils.isCharacterBox(supsub)
          };
        },
        htmlBuilder: mclass_htmlBuilder,
        mathmlBuilder: mclass_mathmlBuilder
      });
      defineFunction({
        type: "pmb",
        names: ["\\pmb"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          return {
            type: "pmb",
            mode: parser.mode,
            mclass: binrelClass(args[0]),
            body: ordargument(args[0])
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var elements = buildExpression(group.body, options, true);
          var node = buildCommon.makeSpan([group.mclass], elements, options);
          node.style.textShadow = "0.02em 0.01em 0.04px";
          return node;
        },
        mathmlBuilder: function mathmlBuilder2(group, style) {
          var inner2 = buildMathML_buildExpression(group.body, style);
          var node = new mathMLTree.MathNode("mstyle", inner2);
          node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
          return node;
        }
      });
      var cdArrowFunctionName = {
        ">": "\\\\cdrightarrow",
        "<": "\\\\cdleftarrow",
        "=": "\\\\cdlongequal",
        "A": "\\uparrow",
        "V": "\\downarrow",
        "|": "\\Vert",
        ".": "no arrow"
      };
      var newCell = function newCell2() {
        return {
          type: "styling",
          body: [],
          mode: "math",
          style: "display"
        };
      };
      var isStartOfArrow = function isStartOfArrow2(node) {
        return node.type === "textord" && node.text === "@";
      };
      var isLabelEnd = function isLabelEnd2(node, endChar) {
        return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
      };
      function cdArrow(arrowChar, labels, parser) {
        var funcName = cdArrowFunctionName[arrowChar];
        switch (funcName) {
          case "\\\\cdrightarrow":
          case "\\\\cdleftarrow":
            return parser.callFunction(funcName, [labels[0]], [labels[1]]);
          case "\\uparrow":
          case "\\downarrow": {
            var leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
            var bareArrow = {
              type: "atom",
              text: funcName,
              mode: "math",
              family: "rel"
            };
            var sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
            var rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
            var arrowGroup = {
              type: "ordgroup",
              mode: "math",
              body: [leftLabel, sizedArrow, rightLabel]
            };
            return parser.callFunction("\\\\cdparent", [arrowGroup], []);
          }
          case "\\\\cdlongequal":
            return parser.callFunction("\\\\cdlongequal", [], []);
          case "\\Vert": {
            var arrow = {
              type: "textord",
              text: "\\Vert",
              mode: "math"
            };
            return parser.callFunction("\\Big", [arrow], []);
          }
          default:
            return {
              type: "textord",
              text: " ",
              mode: "math"
            };
        }
      }
      function parseCD(parser) {
        var parsedRows = [];
        parser.gullet.beginGroup();
        parser.gullet.macros.set("\\cr", "\\\\\\relax");
        parser.gullet.beginGroup();
        while (true) {
          parsedRows.push(parser.parseExpression(false, "\\\\"));
          parser.gullet.endGroup();
          parser.gullet.beginGroup();
          var next = parser.fetch().text;
          if (next === "&" || next === "\\\\") {
            parser.consume();
          } else if (next === "\\end") {
            if (parsedRows[parsedRows.length - 1].length === 0) {
              parsedRows.pop();
            }
            break;
          } else {
            throw new src_ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
          }
        }
        var row = [];
        var body = [row];
        for (var i3 = 0; i3 < parsedRows.length; i3++) {
          var rowNodes = parsedRows[i3];
          var cell = newCell();
          for (var j2 = 0; j2 < rowNodes.length; j2++) {
            if (!isStartOfArrow(rowNodes[j2])) {
              cell.body.push(rowNodes[j2]);
            } else {
              row.push(cell);
              j2 += 1;
              var arrowChar = assertSymbolNodeType(rowNodes[j2]).text;
              var labels = new Array(2);
              labels[0] = {
                type: "ordgroup",
                mode: "math",
                body: []
              };
              labels[1] = {
                type: "ordgroup",
                mode: "math",
                body: []
              };
              if ("=|.".indexOf(arrowChar) > -1)
                ;
              else if ("<>AV".indexOf(arrowChar) > -1) {
                for (var labelNum = 0; labelNum < 2; labelNum++) {
                  var inLabel = true;
                  for (var k2 = j2 + 1; k2 < rowNodes.length; k2++) {
                    if (isLabelEnd(rowNodes[k2], arrowChar)) {
                      inLabel = false;
                      j2 = k2;
                      break;
                    }
                    if (isStartOfArrow(rowNodes[k2])) {
                      throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k2]);
                    }
                    labels[labelNum].body.push(rowNodes[k2]);
                  }
                  if (inLabel) {
                    throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j2]);
                  }
                }
              } else {
                throw new src_ParseError('Expected one of "<>AV=|." after @', rowNodes[j2]);
              }
              var arrow = cdArrow(arrowChar, labels, parser);
              var wrappedArrow = {
                type: "styling",
                body: [arrow],
                mode: "math",
                style: "display"
              };
              row.push(wrappedArrow);
              cell = newCell();
            }
          }
          if (i3 % 2 === 0) {
            row.push(cell);
          } else {
            row.shift();
          }
          row = [];
          body.push(row);
        }
        parser.gullet.endGroup();
        parser.gullet.endGroup();
        var cols = new Array(body[0].length).fill({
          type: "align",
          align: "c",
          pregap: 0.25,
          postgap: 0.25
        });
        return {
          type: "array",
          mode: "math",
          body,
          arraystretch: 1,
          addJot: true,
          rowGaps: [null],
          cols,
          colSeparationType: "CD",
          hLinesBeforeRow: new Array(body.length + 1).fill([])
        };
      }
      defineFunction({
        type: "cdlabel",
        names: ["\\\\cdleft", "\\\\cdright"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          return {
            type: "cdlabel",
            mode: parser.mode,
            side: funcName.slice(4),
            label: args[0]
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var newOptions = options.havingStyle(options.style.sup());
          var label = buildCommon.wrapFragment(buildGroup(group.label, newOptions, options), options);
          label.classes.push("cd-label-" + group.side);
          label.style.bottom = makeEm(0.8 - label.depth);
          label.height = 0;
          label.depth = 0;
          return label;
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var label = new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.label, options)]);
          label = new mathMLTree.MathNode("mpadded", [label]);
          label.setAttribute("width", "0");
          if (group.side === "left") {
            label.setAttribute("lspace", "-1width");
          }
          label.setAttribute("voffset", "0.7em");
          label = new mathMLTree.MathNode("mstyle", [label]);
          label.setAttribute("displaystyle", "false");
          label.setAttribute("scriptlevel", "1");
          return label;
        }
      });
      defineFunction({
        type: "cdlabelparent",
        names: ["\\\\cdparent"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser;
          return {
            type: "cdlabelparent",
            mode: parser.mode,
            fragment: args[0]
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var parent = buildCommon.wrapFragment(buildGroup(group.fragment, options), options);
          parent.classes.push("cd-vert-arrow");
          return parent;
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          return new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.fragment, options)]);
        }
      });
      defineFunction({
        type: "textord",
        names: ["\\@char"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          var arg = assertNodeType(args[0], "ordgroup");
          var group = arg.body;
          var number = "";
          for (var i3 = 0; i3 < group.length; i3++) {
            var node = assertNodeType(group[i3], "textord");
            number += node.text;
          }
          var code = parseInt(number);
          var text2;
          if (isNaN(code)) {
            throw new src_ParseError("\\@char has non-numeric argument " + number);
          } else if (code < 0 || code >= 1114111) {
            throw new src_ParseError("\\@char with invalid code point " + number);
          } else if (code <= 65535) {
            text2 = String.fromCharCode(code);
          } else {
            code -= 65536;
            text2 = String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
          }
          return {
            type: "textord",
            mode: parser.mode,
            text: text2
          };
        }
      });
      var color_htmlBuilder = function htmlBuilder2(group, options) {
        var elements = buildExpression(group.body, options.withColor(group.color), false);
        return buildCommon.makeFragment(elements);
      };
      var color_mathmlBuilder = function mathmlBuilder2(group, options) {
        var inner2 = buildMathML_buildExpression(group.body, options.withColor(group.color));
        var node = new mathMLTree.MathNode("mstyle", inner2);
        node.setAttribute("mathcolor", group.color);
        return node;
      };
      defineFunction({
        type: "color",
        names: ["\\textcolor"],
        props: {
          numArgs: 2,
          allowedInText: true,
          argTypes: ["color", "original"]
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          var color = assertNodeType(args[0], "color-token").color;
          var body = args[1];
          return {
            type: "color",
            mode: parser.mode,
            color,
            body: ordargument(body)
          };
        },
        htmlBuilder: color_htmlBuilder,
        mathmlBuilder: color_mathmlBuilder
      });
      defineFunction({
        type: "color",
        names: ["\\color"],
        props: {
          numArgs: 1,
          allowedInText: true,
          argTypes: ["color"]
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser, breakOnTokenText = _ref2.breakOnTokenText;
          var color = assertNodeType(args[0], "color-token").color;
          parser.gullet.macros.set("\\current@color", color);
          var body = parser.parseExpression(true, breakOnTokenText);
          return {
            type: "color",
            mode: parser.mode,
            color,
            body
          };
        },
        htmlBuilder: color_htmlBuilder,
        mathmlBuilder: color_mathmlBuilder
      });
      defineFunction({
        type: "cr",
        names: ["\\\\"],
        props: {
          numArgs: 0,
          numOptionalArgs: 1,
          argTypes: ["size"],
          allowedInText: true
        },
        handler: function handler(_ref, args, optArgs) {
          var parser = _ref.parser;
          var size = optArgs[0];
          var newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
          return {
            type: "cr",
            mode: parser.mode,
            newLine,
            size: size && assertNodeType(size, "size").value
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var span = buildCommon.makeSpan(["mspace"], [], options);
          if (group.newLine) {
            span.classes.push("newline");
            if (group.size) {
              span.style.marginTop = makeEm(calculateSize(group.size, options));
            }
          }
          return span;
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node = new mathMLTree.MathNode("mspace");
          if (group.newLine) {
            node.setAttribute("linebreak", "newline");
            if (group.size) {
              node.setAttribute("height", makeEm(calculateSize(group.size, options)));
            }
          }
          return node;
        }
      });
      var globalMap = {
        "\\global": "\\global",
        "\\long": "\\\\globallong",
        "\\\\globallong": "\\\\globallong",
        "\\def": "\\gdef",
        "\\gdef": "\\gdef",
        "\\edef": "\\xdef",
        "\\xdef": "\\xdef",
        "\\let": "\\\\globallet",
        "\\futurelet": "\\\\globalfuture"
      };
      var checkControlSequence = function checkControlSequence2(tok) {
        var name = tok.text;
        if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
          throw new src_ParseError("Expected a control sequence", tok);
        }
        return name;
      };
      var getRHS = function getRHS2(parser) {
        var tok = parser.gullet.popToken();
        if (tok.text === "=") {
          tok = parser.gullet.popToken();
          if (tok.text === " ") {
            tok = parser.gullet.popToken();
          }
        }
        return tok;
      };
      var letCommand = function letCommand2(parser, name, tok, global2) {
        var macro = parser.gullet.macros.get(tok.text);
        if (macro == null) {
          tok.noexpand = true;
          macro = {
            tokens: [tok],
            numArgs: 0,
            unexpandable: !parser.gullet.isExpandable(tok.text)
          };
        }
        parser.gullet.macros.set(name, macro, global2);
      };
      defineFunction({
        type: "internal",
        names: [
          "\\global",
          "\\long",
          "\\\\globallong"
        ],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: function handler(_ref) {
          var parser = _ref.parser, funcName = _ref.funcName;
          parser.consumeSpaces();
          var token = parser.fetch();
          if (globalMap[token.text]) {
            if (funcName === "\\global" || funcName === "\\\\globallong") {
              token.text = globalMap[token.text];
            }
            return assertNodeType(parser.parseFunction(), "internal");
          }
          throw new src_ParseError("Invalid token after macro prefix", token);
        }
      });
      defineFunction({
        type: "internal",
        names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref2) {
          var parser = _ref2.parser, funcName = _ref2.funcName;
          var tok = parser.gullet.popToken();
          var name = tok.text;
          if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
            throw new src_ParseError("Expected a control sequence", tok);
          }
          var numArgs = 0;
          var insert;
          var delimiters2 = [[]];
          while (parser.gullet.future().text !== "{") {
            tok = parser.gullet.popToken();
            if (tok.text === "#") {
              if (parser.gullet.future().text === "{") {
                insert = parser.gullet.future();
                delimiters2[numArgs].push("{");
                break;
              }
              tok = parser.gullet.popToken();
              if (!/^[1-9]$/.test(tok.text)) {
                throw new src_ParseError('Invalid argument number "' + tok.text + '"');
              }
              if (parseInt(tok.text) !== numArgs + 1) {
                throw new src_ParseError('Argument number "' + tok.text + '" out of order');
              }
              numArgs++;
              delimiters2.push([]);
            } else if (tok.text === "EOF") {
              throw new src_ParseError("Expected a macro definition");
            } else {
              delimiters2[numArgs].push(tok.text);
            }
          }
          var _parser$gullet$consum = parser.gullet.consumeArg(), tokens = _parser$gullet$consum.tokens;
          if (insert) {
            tokens.unshift(insert);
          }
          if (funcName === "\\edef" || funcName === "\\xdef") {
            tokens = parser.gullet.expandTokens(tokens);
            tokens.reverse();
          }
          parser.gullet.macros.set(name, {
            tokens,
            numArgs,
            delimiters: delimiters2
          }, funcName === globalMap[funcName]);
          return {
            type: "internal",
            mode: parser.mode
          };
        }
      });
      defineFunction({
        type: "internal",
        names: [
          "\\let",
          "\\\\globallet"
        ],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref3) {
          var parser = _ref3.parser, funcName = _ref3.funcName;
          var name = checkControlSequence(parser.gullet.popToken());
          parser.gullet.consumeSpaces();
          var tok = getRHS(parser);
          letCommand(parser, name, tok, funcName === "\\\\globallet");
          return {
            type: "internal",
            mode: parser.mode
          };
        }
      });
      defineFunction({
        type: "internal",
        names: [
          "\\futurelet",
          "\\\\globalfuture"
        ],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref4) {
          var parser = _ref4.parser, funcName = _ref4.funcName;
          var name = checkControlSequence(parser.gullet.popToken());
          var middle = parser.gullet.popToken();
          var tok = parser.gullet.popToken();
          letCommand(parser, name, tok, funcName === "\\\\globalfuture");
          parser.gullet.pushToken(tok);
          parser.gullet.pushToken(middle);
          return {
            type: "internal",
            mode: parser.mode
          };
        }
      });
      var getMetrics = function getMetrics2(symbol, font, mode) {
        var replace = src_symbols.math[symbol] && src_symbols.math[symbol].replace;
        var metrics = getCharacterMetrics(replace || symbol, font, mode);
        if (!metrics) {
          throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
        }
        return metrics;
      };
      var styleWrap = function styleWrap2(delim, toStyle, options, classes) {
        var newOptions = options.havingBaseStyle(toStyle);
        var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
        var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
        span.height *= delimSizeMultiplier;
        span.depth *= delimSizeMultiplier;
        span.maxFontSize = newOptions.sizeMultiplier;
        return span;
      };
      var centerSpan = function centerSpan2(span, options, style) {
        var newOptions = options.havingBaseStyle(style);
        var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
        span.classes.push("delimcenter");
        span.style.top = makeEm(shift);
        span.height -= shift;
        span.depth += shift;
      };
      var makeSmallDelim = function makeSmallDelim2(delim, style, center, options, mode, classes) {
        var text2 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
        var span = styleWrap(text2, style, options, classes);
        if (center) {
          centerSpan(span, options, style);
        }
        return span;
      };
      var mathrmSize = function mathrmSize2(value, size, mode, options) {
        return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
      };
      var makeLargeDelim = function makeLargeDelim2(delim, size, center, options, mode, classes) {
        var inner2 = mathrmSize(delim, size, mode, options);
        var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner2], options), src_Style.TEXT, options, classes);
        if (center) {
          centerSpan(span, options, src_Style.TEXT);
        }
        return span;
      };
      var makeGlyphSpan = function makeGlyphSpan2(symbol, font, mode) {
        var sizeClass;
        if (font === "Size1-Regular") {
          sizeClass = "delim-size1";
        } else {
          sizeClass = "delim-size4";
        }
        var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
        return {
          type: "elem",
          elem: corner
        };
      };
      var makeInner = function makeInner2(ch2, height, options) {
        var width = fontMetricsData["Size4-Regular"][ch2.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch2.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch2.charCodeAt(0)][4];
        var path2 = new PathNode("inner", innerPath(ch2, Math.round(1e3 * height)));
        var svgNode = new SvgNode([path2], {
          "width": makeEm(width),
          "height": makeEm(height),
          "style": "width:" + makeEm(width),
          "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
          "preserveAspectRatio": "xMinYMin"
        });
        var span = buildCommon.makeSvgSpan([], [svgNode], options);
        span.height = height;
        span.style.height = makeEm(height);
        span.style.width = makeEm(width);
        return {
          type: "elem",
          elem: span
        };
      };
      var lapInEms = 8e-3;
      var lap = {
        type: "kern",
        size: -1 * lapInEms
      };
      var verts = ["|", "\\lvert", "\\rvert", "\\vert"];
      var doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
      var makeStackedDelim = function makeStackedDelim2(delim, heightTotal, center, options, mode, classes) {
        var top;
        var middle;
        var repeat;
        var bottom;
        var svgLabel = "";
        var viewBoxWidth = 0;
        top = repeat = bottom = delim;
        middle = null;
        var font = "Size1-Regular";
        if (delim === "\\uparrow") {
          repeat = bottom = "\u23D0";
        } else if (delim === "\\Uparrow") {
          repeat = bottom = "\u2016";
        } else if (delim === "\\downarrow") {
          top = repeat = "\u23D0";
        } else if (delim === "\\Downarrow") {
          top = repeat = "\u2016";
        } else if (delim === "\\updownarrow") {
          top = "\\uparrow";
          repeat = "\u23D0";
          bottom = "\\downarrow";
        } else if (delim === "\\Updownarrow") {
          top = "\\Uparrow";
          repeat = "\u2016";
          bottom = "\\Downarrow";
        } else if (utils.contains(verts, delim)) {
          repeat = "\u2223";
          svgLabel = "vert";
          viewBoxWidth = 333;
        } else if (utils.contains(doubleVerts, delim)) {
          repeat = "\u2225";
          svgLabel = "doublevert";
          viewBoxWidth = 556;
        } else if (delim === "[" || delim === "\\lbrack") {
          top = "\u23A1";
          repeat = "\u23A2";
          bottom = "\u23A3";
          font = "Size4-Regular";
          svgLabel = "lbrack";
          viewBoxWidth = 667;
        } else if (delim === "]" || delim === "\\rbrack") {
          top = "\u23A4";
          repeat = "\u23A5";
          bottom = "\u23A6";
          font = "Size4-Regular";
          svgLabel = "rbrack";
          viewBoxWidth = 667;
        } else if (delim === "\\lfloor" || delim === "\u230A") {
          repeat = top = "\u23A2";
          bottom = "\u23A3";
          font = "Size4-Regular";
          svgLabel = "lfloor";
          viewBoxWidth = 667;
        } else if (delim === "\\lceil" || delim === "\u2308") {
          top = "\u23A1";
          repeat = bottom = "\u23A2";
          font = "Size4-Regular";
          svgLabel = "lceil";
          viewBoxWidth = 667;
        } else if (delim === "\\rfloor" || delim === "\u230B") {
          repeat = top = "\u23A5";
          bottom = "\u23A6";
          font = "Size4-Regular";
          svgLabel = "rfloor";
          viewBoxWidth = 667;
        } else if (delim === "\\rceil" || delim === "\u2309") {
          top = "\u23A4";
          repeat = bottom = "\u23A5";
          font = "Size4-Regular";
          svgLabel = "rceil";
          viewBoxWidth = 667;
        } else if (delim === "(" || delim === "\\lparen") {
          top = "\u239B";
          repeat = "\u239C";
          bottom = "\u239D";
          font = "Size4-Regular";
          svgLabel = "lparen";
          viewBoxWidth = 875;
        } else if (delim === ")" || delim === "\\rparen") {
          top = "\u239E";
          repeat = "\u239F";
          bottom = "\u23A0";
          font = "Size4-Regular";
          svgLabel = "rparen";
          viewBoxWidth = 875;
        } else if (delim === "\\{" || delim === "\\lbrace") {
          top = "\u23A7";
          middle = "\u23A8";
          bottom = "\u23A9";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\}" || delim === "\\rbrace") {
          top = "\u23AB";
          middle = "\u23AC";
          bottom = "\u23AD";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\lgroup" || delim === "\u27EE") {
          top = "\u23A7";
          bottom = "\u23A9";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\rgroup" || delim === "\u27EF") {
          top = "\u23AB";
          bottom = "\u23AD";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\lmoustache" || delim === "\u23B0") {
          top = "\u23A7";
          bottom = "\u23AD";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\rmoustache" || delim === "\u23B1") {
          top = "\u23AB";
          bottom = "\u23A9";
          repeat = "\u23AA";
          font = "Size4-Regular";
        }
        var topMetrics = getMetrics(top, font, mode);
        var topHeightTotal = topMetrics.height + topMetrics.depth;
        var repeatMetrics = getMetrics(repeat, font, mode);
        var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
        var bottomMetrics = getMetrics(bottom, font, mode);
        var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
        var middleHeightTotal = 0;
        var middleFactor = 1;
        if (middle !== null) {
          var middleMetrics = getMetrics(middle, font, mode);
          middleHeightTotal = middleMetrics.height + middleMetrics.depth;
          middleFactor = 2;
        }
        var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
        var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
        var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
        var axisHeight = options.fontMetrics().axisHeight;
        if (center) {
          axisHeight *= options.sizeMultiplier;
        }
        var depth = realHeightTotal / 2 - axisHeight;
        var stack = [];
        if (svgLabel.length > 0) {
          var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
          var viewBoxHeight = Math.round(realHeightTotal * 1e3);
          var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
          var path2 = new PathNode(svgLabel, pathStr);
          var width = (viewBoxWidth / 1e3).toFixed(3) + "em";
          var height = (viewBoxHeight / 1e3).toFixed(3) + "em";
          var svg2 = new SvgNode([path2], {
            "width": width,
            "height": height,
            "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
          });
          var wrapper = buildCommon.makeSvgSpan([], [svg2], options);
          wrapper.height = viewBoxHeight / 1e3;
          wrapper.style.width = width;
          wrapper.style.height = height;
          stack.push({
            type: "elem",
            elem: wrapper
          });
        } else {
          stack.push(makeGlyphSpan(bottom, font, mode));
          stack.push(lap);
          if (middle === null) {
            var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
            stack.push(makeInner(repeat, innerHeight, options));
          } else {
            var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
            stack.push(makeInner(repeat, _innerHeight, options));
            stack.push(lap);
            stack.push(makeGlyphSpan(middle, font, mode));
            stack.push(lap);
            stack.push(makeInner(repeat, _innerHeight, options));
          }
          stack.push(lap);
          stack.push(makeGlyphSpan(top, font, mode));
        }
        var newOptions = options.havingBaseStyle(src_Style.TEXT);
        var inner2 = buildCommon.makeVList({
          positionType: "bottom",
          positionData: depth,
          children: stack
        }, newOptions);
        return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), src_Style.TEXT, options, classes);
      };
      var vbPad = 80;
      var emPad = 0.08;
      var sqrtSvg = function sqrtSvg2(sqrtName, height, viewBoxHeight, extraViniculum, options) {
        var path2 = sqrtPath(sqrtName, extraViniculum, viewBoxHeight);
        var pathNode = new PathNode(sqrtName, path2);
        var svg2 = new SvgNode([pathNode], {
          "width": "400em",
          "height": makeEm(height),
          "viewBox": "0 0 400000 " + viewBoxHeight,
          "preserveAspectRatio": "xMinYMin slice"
        });
        return buildCommon.makeSvgSpan(["hide-tail"], [svg2], options);
      };
      var makeSqrtImage = function makeSqrtImage2(height, options) {
        var newOptions = options.havingBaseSizing();
        var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
        var sizeMultiplier = newOptions.sizeMultiplier;
        var extraViniculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
        var span;
        var spanHeight = 0;
        var texHeight = 0;
        var viewBoxHeight = 0;
        var advanceWidth;
        if (delim.type === "small") {
          viewBoxHeight = 1e3 + 1e3 * extraViniculum + vbPad;
          if (height < 1) {
            sizeMultiplier = 1;
          } else if (height < 1.4) {
            sizeMultiplier = 0.7;
          }
          spanHeight = (1 + extraViniculum + emPad) / sizeMultiplier;
          texHeight = (1 + extraViniculum) / sizeMultiplier;
          span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraViniculum, options);
          span.style.minWidth = "0.853em";
          advanceWidth = 0.833 / sizeMultiplier;
        } else if (delim.type === "large") {
          viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
          texHeight = (sizeToMaxHeight[delim.size] + extraViniculum) / sizeMultiplier;
          spanHeight = (sizeToMaxHeight[delim.size] + extraViniculum + emPad) / sizeMultiplier;
          span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraViniculum, options);
          span.style.minWidth = "1.02em";
          advanceWidth = 1 / sizeMultiplier;
        } else {
          spanHeight = height + extraViniculum + emPad;
          texHeight = height + extraViniculum;
          viewBoxHeight = Math.floor(1e3 * height + extraViniculum) + vbPad;
          span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraViniculum, options);
          span.style.minWidth = "0.742em";
          advanceWidth = 1.056;
        }
        span.height = texHeight;
        span.style.height = makeEm(spanHeight);
        return {
          span,
          advanceWidth,
          ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraViniculum) * sizeMultiplier
        };
      };
      var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
      var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
      var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
      var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
      var makeSizedDelim = function makeSizedDelim2(delim, size, options, mode, classes) {
        if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
          delim = "\\langle";
        } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
          delim = "\\rangle";
        }
        if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
          return makeLargeDelim(delim, size, false, options, mode, classes);
        } else if (utils.contains(stackAlwaysDelimiters, delim)) {
          return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
        } else {
          throw new src_ParseError("Illegal delimiter: '" + delim + "'");
        }
      };
      var stackNeverDelimiterSequence = [{
        type: "small",
        style: src_Style.SCRIPTSCRIPT
      }, {
        type: "small",
        style: src_Style.SCRIPT
      }, {
        type: "small",
        style: src_Style.TEXT
      }, {
        type: "large",
        size: 1
      }, {
        type: "large",
        size: 2
      }, {
        type: "large",
        size: 3
      }, {
        type: "large",
        size: 4
      }];
      var stackAlwaysDelimiterSequence = [{
        type: "small",
        style: src_Style.SCRIPTSCRIPT
      }, {
        type: "small",
        style: src_Style.SCRIPT
      }, {
        type: "small",
        style: src_Style.TEXT
      }, {
        type: "stack"
      }];
      var stackLargeDelimiterSequence = [{
        type: "small",
        style: src_Style.SCRIPTSCRIPT
      }, {
        type: "small",
        style: src_Style.SCRIPT
      }, {
        type: "small",
        style: src_Style.TEXT
      }, {
        type: "large",
        size: 1
      }, {
        type: "large",
        size: 2
      }, {
        type: "large",
        size: 3
      }, {
        type: "large",
        size: 4
      }, {
        type: "stack"
      }];
      var delimTypeToFont = function delimTypeToFont2(type) {
        if (type.type === "small") {
          return "Main-Regular";
        } else if (type.type === "large") {
          return "Size" + type.size + "-Regular";
        } else if (type.type === "stack") {
          return "Size4-Regular";
        } else {
          throw new Error("Add support for delim type '" + type.type + "' here.");
        }
      };
      var traverseSequence = function traverseSequence2(delim, height, sequence, options) {
        var start = Math.min(2, 3 - options.style.size);
        for (var i3 = start; i3 < sequence.length; i3++) {
          if (sequence[i3].type === "stack") {
            break;
          }
          var metrics = getMetrics(delim, delimTypeToFont(sequence[i3]), "math");
          var heightDepth = metrics.height + metrics.depth;
          if (sequence[i3].type === "small") {
            var newOptions = options.havingBaseStyle(sequence[i3].style);
            heightDepth *= newOptions.sizeMultiplier;
          }
          if (heightDepth > height) {
            return sequence[i3];
          }
        }
        return sequence[sequence.length - 1];
      };
      var makeCustomSizedDelim = function makeCustomSizedDelim2(delim, height, center, options, mode, classes) {
        if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
          delim = "\\langle";
        } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
          delim = "\\rangle";
        }
        var sequence;
        if (utils.contains(stackNeverDelimiters, delim)) {
          sequence = stackNeverDelimiterSequence;
        } else if (utils.contains(stackLargeDelimiters, delim)) {
          sequence = stackLargeDelimiterSequence;
        } else {
          sequence = stackAlwaysDelimiterSequence;
        }
        var delimType = traverseSequence(delim, height, sequence, options);
        if (delimType.type === "small") {
          return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
        } else if (delimType.type === "large") {
          return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
        } else {
          return makeStackedDelim(delim, height, center, options, mode, classes);
        }
      };
      var makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options, mode, classes) {
        var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
        var delimiterFactor = 901;
        var delimiterExtend = 5 / options.fontMetrics().ptPerEm;
        var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
        var totalHeight = Math.max(
          maxDistFromAxis / 500 * delimiterFactor,
          2 * maxDistFromAxis - delimiterExtend
        );
        return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
      };
      var delimiter = {
        sqrtImage: makeSqrtImage,
        sizedDelim: makeSizedDelim,
        sizeToMaxHeight,
        customSizedDelim: makeCustomSizedDelim,
        leftRightDelim: makeLeftRightDelim
      };
      var delimiterSizes = {
        "\\bigl": {
          mclass: "mopen",
          size: 1
        },
        "\\Bigl": {
          mclass: "mopen",
          size: 2
        },
        "\\biggl": {
          mclass: "mopen",
          size: 3
        },
        "\\Biggl": {
          mclass: "mopen",
          size: 4
        },
        "\\bigr": {
          mclass: "mclose",
          size: 1
        },
        "\\Bigr": {
          mclass: "mclose",
          size: 2
        },
        "\\biggr": {
          mclass: "mclose",
          size: 3
        },
        "\\Biggr": {
          mclass: "mclose",
          size: 4
        },
        "\\bigm": {
          mclass: "mrel",
          size: 1
        },
        "\\Bigm": {
          mclass: "mrel",
          size: 2
        },
        "\\biggm": {
          mclass: "mrel",
          size: 3
        },
        "\\Biggm": {
          mclass: "mrel",
          size: 4
        },
        "\\big": {
          mclass: "mord",
          size: 1
        },
        "\\Big": {
          mclass: "mord",
          size: 2
        },
        "\\bigg": {
          mclass: "mord",
          size: 3
        },
        "\\Bigg": {
          mclass: "mord",
          size: 4
        }
      };
      var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
      function checkDelimiter(delim, context) {
        var symDelim = checkSymbolNodeType(delim);
        if (symDelim && utils.contains(delimiters, symDelim.text)) {
          return symDelim;
        } else if (symDelim) {
          throw new src_ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
        } else {
          throw new src_ParseError("Invalid delimiter type '" + delim.type + "'", delim);
        }
      }
      defineFunction({
        type: "delimsizing",
        names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
        props: {
          numArgs: 1,
          argTypes: ["primitive"]
        },
        handler: function handler(context, args) {
          var delim = checkDelimiter(args[0], context);
          return {
            type: "delimsizing",
            mode: context.parser.mode,
            size: delimiterSizes[context.funcName].size,
            mclass: delimiterSizes[context.funcName].mclass,
            delim: delim.text
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          if (group.delim === ".") {
            return buildCommon.makeSpan([group.mclass]);
          }
          return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
        },
        mathmlBuilder: function mathmlBuilder2(group) {
          var children = [];
          if (group.delim !== ".") {
            children.push(makeText(group.delim, group.mode));
          }
          var node = new mathMLTree.MathNode("mo", children);
          if (group.mclass === "mopen" || group.mclass === "mclose") {
            node.setAttribute("fence", "true");
          } else {
            node.setAttribute("fence", "false");
          }
          node.setAttribute("stretchy", "true");
          var size = makeEm(delimiter.sizeToMaxHeight[group.size]);
          node.setAttribute("minsize", size);
          node.setAttribute("maxsize", size);
          return node;
        }
      });
      function assertParsed(group) {
        if (!group.body) {
          throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
        }
      }
      defineFunction({
        type: "leftright-right",
        names: ["\\right"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(context, args) {
          var color = context.parser.gullet.macros.get("\\current@color");
          if (color && typeof color !== "string") {
            throw new src_ParseError("\\current@color set to non-string in \\right");
          }
          return {
            type: "leftright-right",
            mode: context.parser.mode,
            delim: checkDelimiter(args[0], context).text,
            color
          };
        }
      });
      defineFunction({
        type: "leftright",
        names: ["\\left"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(context, args) {
          var delim = checkDelimiter(args[0], context);
          var parser = context.parser;
          ++parser.leftrightDepth;
          var body = parser.parseExpression(false);
          --parser.leftrightDepth;
          parser.expect("\\right", false);
          var right = assertNodeType(parser.parseFunction(), "leftright-right");
          return {
            type: "leftright",
            mode: parser.mode,
            body,
            left: delim.text,
            right: right.delim,
            rightColor: right.color
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          assertParsed(group);
          var inner2 = buildExpression(group.body, options, true, ["mopen", "mclose"]);
          var innerHeight = 0;
          var innerDepth = 0;
          var hadMiddle = false;
          for (var i3 = 0; i3 < inner2.length; i3++) {
            if (inner2[i3].isMiddle) {
              hadMiddle = true;
            } else {
              innerHeight = Math.max(inner2[i3].height, innerHeight);
              innerDepth = Math.max(inner2[i3].depth, innerDepth);
            }
          }
          innerHeight *= options.sizeMultiplier;
          innerDepth *= options.sizeMultiplier;
          var leftDelim;
          if (group.left === ".") {
            leftDelim = makeNullDelimiter(options, ["mopen"]);
          } else {
            leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
          }
          inner2.unshift(leftDelim);
          if (hadMiddle) {
            for (var _i6 = 1; _i6 < inner2.length; _i6++) {
              var middleDelim = inner2[_i6];
              var isMiddle = middleDelim.isMiddle;
              if (isMiddle) {
                inner2[_i6] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
              }
            }
          }
          var rightDelim;
          if (group.right === ".") {
            rightDelim = makeNullDelimiter(options, ["mclose"]);
          } else {
            var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
            rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
          }
          inner2.push(rightDelim);
          return buildCommon.makeSpan(["minner"], inner2, options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          assertParsed(group);
          var inner2 = buildMathML_buildExpression(group.body, options);
          if (group.left !== ".") {
            var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
            leftNode.setAttribute("fence", "true");
            inner2.unshift(leftNode);
          }
          if (group.right !== ".") {
            var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
            rightNode.setAttribute("fence", "true");
            if (group.rightColor) {
              rightNode.setAttribute("mathcolor", group.rightColor);
            }
            inner2.push(rightNode);
          }
          return makeRow(inner2);
        }
      });
      defineFunction({
        type: "middle",
        names: ["\\middle"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(context, args) {
          var delim = checkDelimiter(args[0], context);
          if (!context.parser.leftrightDepth) {
            throw new src_ParseError("\\middle without preceding \\left", delim);
          }
          return {
            type: "middle",
            mode: context.parser.mode,
            delim: delim.text
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var middleDelim;
          if (group.delim === ".") {
            middleDelim = makeNullDelimiter(options, []);
          } else {
            middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
            var isMiddle = {
              delim: group.delim,
              options
            };
            middleDelim.isMiddle = isMiddle;
          }
          return middleDelim;
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
          var middleNode = new mathMLTree.MathNode("mo", [textNode]);
          middleNode.setAttribute("fence", "true");
          middleNode.setAttribute("lspace", "0.05em");
          middleNode.setAttribute("rspace", "0.05em");
          return middleNode;
        }
      });
      var enclose_htmlBuilder = function htmlBuilder2(group, options) {
        var inner2 = buildCommon.wrapFragment(buildGroup(group.body, options), options);
        var label = group.label.slice(1);
        var scale = options.sizeMultiplier;
        var img;
        var imgShift = 0;
        var isSingleChar = utils.isCharacterBox(group.body);
        if (label === "sout") {
          img = buildCommon.makeSpan(["stretchy", "sout"]);
          img.height = options.fontMetrics().defaultRuleThickness / scale;
          imgShift = -0.5 * options.fontMetrics().xHeight;
        } else if (label === "phase") {
          var lineWeight = calculateSize({
            number: 0.6,
            unit: "pt"
          }, options);
          var clearance = calculateSize({
            number: 0.35,
            unit: "ex"
          }, options);
          var newOptions = options.havingBaseSizing();
          scale = scale / newOptions.sizeMultiplier;
          var angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
          inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
          var viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
          var path2 = phasePath(viewBoxHeight);
          var svgNode = new SvgNode([new PathNode("phase", path2)], {
            "width": "400em",
            "height": makeEm(viewBoxHeight / 1e3),
            "viewBox": "0 0 400000 " + viewBoxHeight,
            "preserveAspectRatio": "xMinYMin slice"
          });
          img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
          img.style.height = makeEm(angleHeight);
          imgShift = inner2.depth + lineWeight + clearance;
        } else {
          if (/cancel/.test(label)) {
            if (!isSingleChar) {
              inner2.classes.push("cancel-pad");
            }
          } else if (label === "angl") {
            inner2.classes.push("anglpad");
          } else {
            inner2.classes.push("boxpad");
          }
          var topPad = 0;
          var bottomPad = 0;
          var ruleThickness = 0;
          if (/box/.test(label)) {
            ruleThickness = Math.max(
              options.fontMetrics().fboxrule,
              options.minRuleThickness
            );
            topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
            bottomPad = topPad;
          } else if (label === "angl") {
            ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
            topPad = 4 * ruleThickness;
            bottomPad = Math.max(0, 0.25 - inner2.depth);
          } else {
            topPad = isSingleChar ? 0.2 : 0;
            bottomPad = topPad;
          }
          img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options);
          if (/fbox|boxed|fcolorbox/.test(label)) {
            img.style.borderStyle = "solid";
            img.style.borderWidth = makeEm(ruleThickness);
          } else if (label === "angl" && ruleThickness !== 0.049) {
            img.style.borderTopWidth = makeEm(ruleThickness);
            img.style.borderRightWidth = makeEm(ruleThickness);
          }
          imgShift = inner2.depth + bottomPad;
          if (group.backgroundColor) {
            img.style.backgroundColor = group.backgroundColor;
            if (group.borderColor) {
              img.style.borderColor = group.borderColor;
            }
          }
        }
        var vlist;
        if (group.backgroundColor) {
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [
              {
                type: "elem",
                elem: img,
                shift: imgShift
              },
              {
                type: "elem",
                elem: inner2,
                shift: 0
              }
            ]
          }, options);
        } else {
          var classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [
              {
                type: "elem",
                elem: inner2,
                shift: 0
              },
              {
                type: "elem",
                elem: img,
                shift: imgShift,
                wrapperClasses: classes
              }
            ]
          }, options);
        }
        if (/cancel/.test(label)) {
          vlist.height = inner2.height;
          vlist.depth = inner2.depth;
        }
        if (/cancel/.test(label) && !isSingleChar) {
          return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
        } else {
          return buildCommon.makeSpan(["mord"], [vlist], options);
        }
      };
      var enclose_mathmlBuilder = function mathmlBuilder2(group, options) {
        var fboxsep = 0;
        var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);
        switch (group.label) {
          case "\\cancel":
            node.setAttribute("notation", "updiagonalstrike");
            break;
          case "\\bcancel":
            node.setAttribute("notation", "downdiagonalstrike");
            break;
          case "\\phase":
            node.setAttribute("notation", "phasorangle");
            break;
          case "\\sout":
            node.setAttribute("notation", "horizontalstrike");
            break;
          case "\\fbox":
            node.setAttribute("notation", "box");
            break;
          case "\\angl":
            node.setAttribute("notation", "actuarial");
            break;
          case "\\fcolorbox":
          case "\\colorbox":
            fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
            node.setAttribute("width", "+" + 2 * fboxsep + "pt");
            node.setAttribute("height", "+" + 2 * fboxsep + "pt");
            node.setAttribute("lspace", fboxsep + "pt");
            node.setAttribute("voffset", fboxsep + "pt");
            if (group.label === "\\fcolorbox") {
              var thk = Math.max(
                options.fontMetrics().fboxrule,
                options.minRuleThickness
              );
              node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
            }
            break;
          case "\\xcancel":
            node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
            break;
        }
        if (group.backgroundColor) {
          node.setAttribute("mathbackground", group.backgroundColor);
        }
        return node;
      };
      defineFunction({
        type: "enclose",
        names: ["\\colorbox"],
        props: {
          numArgs: 2,
          allowedInText: true,
          argTypes: ["color", "text"]
        },
        handler: function handler(_ref, args, optArgs) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var color = assertNodeType(args[0], "color-token").color;
          var body = args[1];
          return {
            type: "enclose",
            mode: parser.mode,
            label: funcName,
            backgroundColor: color,
            body
          };
        },
        htmlBuilder: enclose_htmlBuilder,
        mathmlBuilder: enclose_mathmlBuilder
      });
      defineFunction({
        type: "enclose",
        names: ["\\fcolorbox"],
        props: {
          numArgs: 3,
          allowedInText: true,
          argTypes: ["color", "color", "text"]
        },
        handler: function handler(_ref2, args, optArgs) {
          var parser = _ref2.parser, funcName = _ref2.funcName;
          var borderColor = assertNodeType(args[0], "color-token").color;
          var backgroundColor = assertNodeType(args[1], "color-token").color;
          var body = args[2];
          return {
            type: "enclose",
            mode: parser.mode,
            label: funcName,
            backgroundColor,
            borderColor,
            body
          };
        },
        htmlBuilder: enclose_htmlBuilder,
        mathmlBuilder: enclose_mathmlBuilder
      });
      defineFunction({
        type: "enclose",
        names: ["\\fbox"],
        props: {
          numArgs: 1,
          argTypes: ["hbox"],
          allowedInText: true
        },
        handler: function handler(_ref3, args) {
          var parser = _ref3.parser;
          return {
            type: "enclose",
            mode: parser.mode,
            label: "\\fbox",
            body: args[0]
          };
        }
      });
      defineFunction({
        type: "enclose",
        names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref4, args) {
          var parser = _ref4.parser, funcName = _ref4.funcName;
          var body = args[0];
          return {
            type: "enclose",
            mode: parser.mode,
            label: funcName,
            body
          };
        },
        htmlBuilder: enclose_htmlBuilder,
        mathmlBuilder: enclose_mathmlBuilder
      });
      defineFunction({
        type: "enclose",
        names: ["\\angl"],
        props: {
          numArgs: 1,
          argTypes: ["hbox"],
          allowedInText: false
        },
        handler: function handler(_ref5, args) {
          var parser = _ref5.parser;
          return {
            type: "enclose",
            mode: parser.mode,
            label: "\\angl",
            body: args[0]
          };
        }
      });
      var _environments = {};
      function defineEnvironment(_ref) {
        var type = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder2 = _ref.htmlBuilder, mathmlBuilder2 = _ref.mathmlBuilder;
        var data = {
          type,
          numArgs: props.numArgs || 0,
          allowedInText: false,
          numOptionalArgs: 0,
          handler
        };
        for (var i3 = 0; i3 < names.length; ++i3) {
          _environments[names[i3]] = data;
        }
        if (htmlBuilder2) {
          _htmlGroupBuilders[type] = htmlBuilder2;
        }
        if (mathmlBuilder2) {
          _mathmlGroupBuilders[type] = mathmlBuilder2;
        }
      }
      var _macros = {};
      function defineMacro(name, body) {
        _macros[name] = body;
      }
      var SourceLocation = function() {
        function SourceLocation2(lexer, start, end) {
          this.lexer = void 0;
          this.start = void 0;
          this.end = void 0;
          this.lexer = lexer;
          this.start = start;
          this.end = end;
        }
        SourceLocation2.range = function range(first, second) {
          if (!second) {
            return first && first.loc;
          } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
            return null;
          } else {
            return new SourceLocation2(first.loc.lexer, first.loc.start, second.loc.end);
          }
        };
        return SourceLocation2;
      }();
      var Token2 = function() {
        function Token3(text2, loc) {
          this.text = void 0;
          this.loc = void 0;
          this.noexpand = void 0;
          this.treatAsRelax = void 0;
          this.text = text2;
          this.loc = loc;
        }
        var _proto = Token3.prototype;
        _proto.range = function range(endToken, text2) {
          return new Token3(text2, SourceLocation.range(this, endToken));
        };
        return Token3;
      }();
      function getHLines(parser) {
        var hlineInfo = [];
        parser.consumeSpaces();
        var nxt = parser.fetch().text;
        if (nxt === "\\relax") {
          parser.consume();
          parser.consumeSpaces();
          nxt = parser.fetch().text;
        }
        while (nxt === "\\hline" || nxt === "\\hdashline") {
          parser.consume();
          hlineInfo.push(nxt === "\\hdashline");
          parser.consumeSpaces();
          nxt = parser.fetch().text;
        }
        return hlineInfo;
      }
      var validateAmsEnvironmentContext = function validateAmsEnvironmentContext2(context) {
        var settings = context.parser.settings;
        if (!settings.displayMode) {
          throw new src_ParseError("{" + context.envName + "} can be used only in display mode.");
        }
      };
      function getAutoTag(name) {
        if (name.indexOf("ed") === -1) {
          return name.indexOf("*") === -1;
        }
      }
      function parseArray(parser, _ref, style) {
        var hskipBeforeAndAfter = _ref.hskipBeforeAndAfter, addJot = _ref.addJot, cols = _ref.cols, arraystretch = _ref.arraystretch, colSeparationType = _ref.colSeparationType, autoTag = _ref.autoTag, singleRow = _ref.singleRow, emptySingleRow = _ref.emptySingleRow, maxNumCols = _ref.maxNumCols, leqno = _ref.leqno;
        parser.gullet.beginGroup();
        if (!singleRow) {
          parser.gullet.macros.set("\\cr", "\\\\\\relax");
        }
        if (!arraystretch) {
          var stretch = parser.gullet.expandMacroAsText("\\arraystretch");
          if (stretch == null) {
            arraystretch = 1;
          } else {
            arraystretch = parseFloat(stretch);
            if (!arraystretch || arraystretch < 0) {
              throw new src_ParseError("Invalid \\arraystretch: " + stretch);
            }
          }
        }
        parser.gullet.beginGroup();
        var row = [];
        var body = [row];
        var rowGaps = [];
        var hLinesBeforeRow = [];
        var tags = autoTag != null ? [] : void 0;
        function beginRow() {
          if (autoTag) {
            parser.gullet.macros.set("\\@eqnsw", "1", true);
          }
        }
        function endRow() {
          if (tags) {
            if (parser.gullet.macros.get("\\df@tag")) {
              tags.push(parser.subparse([new Token2("\\df@tag")]));
              parser.gullet.macros.set("\\df@tag", void 0, true);
            } else {
              tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
            }
          }
        }
        beginRow();
        hLinesBeforeRow.push(getHLines(parser));
        while (true) {
          var cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
          parser.gullet.endGroup();
          parser.gullet.beginGroup();
          cell = {
            type: "ordgroup",
            mode: parser.mode,
            body: cell
          };
          if (style) {
            cell = {
              type: "styling",
              mode: parser.mode,
              style,
              body: [cell]
            };
          }
          row.push(cell);
          var next = parser.fetch().text;
          if (next === "&") {
            if (maxNumCols && row.length === maxNumCols) {
              if (singleRow || colSeparationType) {
                throw new src_ParseError("Too many tab characters: &", parser.nextToken);
              } else {
                parser.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
              }
            }
            parser.consume();
          } else if (next === "\\end") {
            endRow();
            if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
              body.pop();
            }
            if (hLinesBeforeRow.length < body.length + 1) {
              hLinesBeforeRow.push([]);
            }
            break;
          } else if (next === "\\\\") {
            parser.consume();
            var size = void 0;
            if (parser.gullet.future().text !== " ") {
              size = parser.parseSizeGroup(true);
            }
            rowGaps.push(size ? size.value : null);
            endRow();
            hLinesBeforeRow.push(getHLines(parser));
            row = [];
            body.push(row);
            beginRow();
          } else {
            throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
          }
        }
        parser.gullet.endGroup();
        parser.gullet.endGroup();
        return {
          type: "array",
          mode: parser.mode,
          addJot,
          arraystretch,
          body,
          cols,
          rowGaps,
          hskipBeforeAndAfter,
          hLinesBeforeRow,
          colSeparationType,
          tags,
          leqno
        };
      }
      function dCellStyle(envName) {
        if (envName.slice(0, 1) === "d") {
          return "display";
        } else {
          return "text";
        }
      }
      var array_htmlBuilder = function htmlBuilder2(group, options) {
        var r2;
        var c2;
        var nr = group.body.length;
        var hLinesBeforeRow = group.hLinesBeforeRow;
        var nc = 0;
        var body = new Array(nr);
        var hlines = [];
        var ruleThickness = Math.max(
          options.fontMetrics().arrayRuleWidth,
          options.minRuleThickness
        );
        var pt = 1 / options.fontMetrics().ptPerEm;
        var arraycolsep = 5 * pt;
        if (group.colSeparationType && group.colSeparationType === "small") {
          var localMultiplier = options.havingStyle(src_Style.SCRIPT).sizeMultiplier;
          arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
        }
        var baselineskip = group.colSeparationType === "CD" ? calculateSize({
          number: 3,
          unit: "ex"
        }, options) : 12 * pt;
        var jot = 3 * pt;
        var arrayskip = group.arraystretch * baselineskip;
        var arstrutHeight = 0.7 * arrayskip;
        var arstrutDepth = 0.3 * arrayskip;
        var totalHeight = 0;
        function setHLinePos(hlinesInGap) {
          for (var i3 = 0; i3 < hlinesInGap.length; ++i3) {
            if (i3 > 0) {
              totalHeight += 0.25;
            }
            hlines.push({
              pos: totalHeight,
              isDashed: hlinesInGap[i3]
            });
          }
        }
        setHLinePos(hLinesBeforeRow[0]);
        for (r2 = 0; r2 < group.body.length; ++r2) {
          var inrow = group.body[r2];
          var height = arstrutHeight;
          var depth = arstrutDepth;
          if (nc < inrow.length) {
            nc = inrow.length;
          }
          var outrow = new Array(inrow.length);
          for (c2 = 0; c2 < inrow.length; ++c2) {
            var elt = buildGroup(inrow[c2], options);
            if (depth < elt.depth) {
              depth = elt.depth;
            }
            if (height < elt.height) {
              height = elt.height;
            }
            outrow[c2] = elt;
          }
          var rowGap = group.rowGaps[r2];
          var gap = 0;
          if (rowGap) {
            gap = calculateSize(rowGap, options);
            if (gap > 0) {
              gap += arstrutDepth;
              if (depth < gap) {
                depth = gap;
              }
              gap = 0;
            }
          }
          if (group.addJot) {
            depth += jot;
          }
          outrow.height = height;
          outrow.depth = depth;
          totalHeight += height;
          outrow.pos = totalHeight;
          totalHeight += depth + gap;
          body[r2] = outrow;
          setHLinePos(hLinesBeforeRow[r2 + 1]);
        }
        var offset = totalHeight / 2 + options.fontMetrics().axisHeight;
        var colDescriptions = group.cols || [];
        var cols = [];
        var colSep;
        var colDescrNum;
        var tagSpans = [];
        if (group.tags && group.tags.some(function(tag2) {
          return tag2;
        })) {
          for (r2 = 0; r2 < nr; ++r2) {
            var rw = body[r2];
            var shift = rw.pos - offset;
            var tag = group.tags[r2];
            var tagSpan = void 0;
            if (tag === true) {
              tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
            } else if (tag === false) {
              tagSpan = buildCommon.makeSpan([], [], options);
            } else {
              tagSpan = buildCommon.makeSpan([], buildExpression(tag, options, true), options);
            }
            tagSpan.depth = rw.depth;
            tagSpan.height = rw.height;
            tagSpans.push({
              type: "elem",
              elem: tagSpan,
              shift
            });
          }
        }
        for (c2 = 0, colDescrNum = 0; c2 < nc || colDescrNum < colDescriptions.length; ++c2, ++colDescrNum) {
          var colDescr = colDescriptions[colDescrNum] || {};
          var firstSeparator = true;
          while (colDescr.type === "separator") {
            if (!firstSeparator) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
              cols.push(colSep);
            }
            if (colDescr.separator === "|" || colDescr.separator === ":") {
              var lineType = colDescr.separator === "|" ? "solid" : "dashed";
              var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
              separator.style.height = makeEm(totalHeight);
              separator.style.borderRightWidth = makeEm(ruleThickness);
              separator.style.borderRightStyle = lineType;
              separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
              var _shift = totalHeight - offset;
              if (_shift) {
                separator.style.verticalAlign = makeEm(-_shift);
              }
              cols.push(separator);
            } else {
              throw new src_ParseError("Invalid separator type: " + colDescr.separator);
            }
            colDescrNum++;
            colDescr = colDescriptions[colDescrNum] || {};
            firstSeparator = false;
          }
          if (c2 >= nc) {
            continue;
          }
          var sepwidth = void 0;
          if (c2 > 0 || group.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
            if (sepwidth !== 0) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(sepwidth);
              cols.push(colSep);
            }
          }
          var col = [];
          for (r2 = 0; r2 < nr; ++r2) {
            var row = body[r2];
            var elem = row[c2];
            if (!elem) {
              continue;
            }
            var _shift2 = row.pos - offset;
            elem.depth = row.depth;
            elem.height = row.height;
            col.push({
              type: "elem",
              elem,
              shift: _shift2
            });
          }
          col = buildCommon.makeVList({
            positionType: "individualShift",
            children: col
          }, options);
          col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
          cols.push(col);
          if (c2 < nc - 1 || group.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
            if (sepwidth !== 0) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(sepwidth);
              cols.push(colSep);
            }
          }
        }
        body = buildCommon.makeSpan(["mtable"], cols);
        if (hlines.length > 0) {
          var line = buildCommon.makeLineSpan("hline", options, ruleThickness);
          var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
          var vListElems = [{
            type: "elem",
            elem: body,
            shift: 0
          }];
          while (hlines.length > 0) {
            var hline = hlines.pop();
            var lineShift = hline.pos - offset;
            if (hline.isDashed) {
              vListElems.push({
                type: "elem",
                elem: dashes,
                shift: lineShift
              });
            } else {
              vListElems.push({
                type: "elem",
                elem: line,
                shift: lineShift
              });
            }
          }
          body = buildCommon.makeVList({
            positionType: "individualShift",
            children: vListElems
          }, options);
        }
        if (tagSpans.length === 0) {
          return buildCommon.makeSpan(["mord"], [body], options);
        } else {
          var eqnNumCol = buildCommon.makeVList({
            positionType: "individualShift",
            children: tagSpans
          }, options);
          eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
          return buildCommon.makeFragment([body, eqnNumCol]);
        }
      };
      var alignMap = {
        c: "center ",
        l: "left ",
        r: "right "
      };
      var array_mathmlBuilder = function mathmlBuilder2(group, options) {
        var tbl = [];
        var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
        var tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
        for (var i3 = 0; i3 < group.body.length; i3++) {
          var rw = group.body[i3];
          var row = [];
          for (var j2 = 0; j2 < rw.length; j2++) {
            row.push(new mathMLTree.MathNode("mtd", [buildMathML_buildGroup(rw[j2], options)]));
          }
          if (group.tags && group.tags[i3]) {
            row.unshift(glue);
            row.push(glue);
            if (group.leqno) {
              row.unshift(tag);
            } else {
              row.push(tag);
            }
          }
          tbl.push(new mathMLTree.MathNode("mtr", row));
        }
        var table = new mathMLTree.MathNode("mtable", tbl);
        var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
        table.setAttribute("rowspacing", makeEm(gap));
        var menclose = "";
        var align = "";
        if (group.cols && group.cols.length > 0) {
          var cols = group.cols;
          var columnLines = "";
          var prevTypeWasAlign = false;
          var iStart = 0;
          var iEnd = cols.length;
          if (cols[0].type === "separator") {
            menclose += "top ";
            iStart = 1;
          }
          if (cols[cols.length - 1].type === "separator") {
            menclose += "bottom ";
            iEnd -= 1;
          }
          for (var _i6 = iStart; _i6 < iEnd; _i6++) {
            if (cols[_i6].type === "align") {
              align += alignMap[cols[_i6].align];
              if (prevTypeWasAlign) {
                columnLines += "none ";
              }
              prevTypeWasAlign = true;
            } else if (cols[_i6].type === "separator") {
              if (prevTypeWasAlign) {
                columnLines += cols[_i6].separator === "|" ? "solid " : "dashed ";
                prevTypeWasAlign = false;
              }
            }
          }
          table.setAttribute("columnalign", align.trim());
          if (/[sd]/.test(columnLines)) {
            table.setAttribute("columnlines", columnLines.trim());
          }
        }
        if (group.colSeparationType === "align") {
          var _cols = group.cols || [];
          var spacing2 = "";
          for (var _i22 = 1; _i22 < _cols.length; _i22++) {
            spacing2 += _i22 % 2 ? "0em " : "1em ";
          }
          table.setAttribute("columnspacing", spacing2.trim());
        } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
          table.setAttribute("columnspacing", "0em");
        } else if (group.colSeparationType === "small") {
          table.setAttribute("columnspacing", "0.2778em");
        } else if (group.colSeparationType === "CD") {
          table.setAttribute("columnspacing", "0.5em");
        } else {
          table.setAttribute("columnspacing", "1em");
        }
        var rowLines = "";
        var hlines = group.hLinesBeforeRow;
        menclose += hlines[0].length > 0 ? "left " : "";
        menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
        for (var _i32 = 1; _i32 < hlines.length - 1; _i32++) {
          rowLines += hlines[_i32].length === 0 ? "none " : hlines[_i32][0] ? "dashed " : "solid ";
        }
        if (/[sd]/.test(rowLines)) {
          table.setAttribute("rowlines", rowLines.trim());
        }
        if (menclose !== "") {
          table = new mathMLTree.MathNode("menclose", [table]);
          table.setAttribute("notation", menclose.trim());
        }
        if (group.arraystretch && group.arraystretch < 1) {
          table = new mathMLTree.MathNode("mstyle", [table]);
          table.setAttribute("scriptlevel", "1");
        }
        return table;
      };
      var alignedHandler = function alignedHandler2(context, args) {
        if (context.envName.indexOf("ed") === -1) {
          validateAmsEnvironmentContext(context);
        }
        var cols = [];
        var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
        var isSplit = context.envName === "split";
        var res = parseArray(context.parser, {
          cols,
          addJot: true,
          autoTag: isSplit ? void 0 : getAutoTag(context.envName),
          emptySingleRow: true,
          colSeparationType: separationType,
          maxNumCols: isSplit ? 2 : void 0,
          leqno: context.parser.settings.leqno
        }, "display");
        var numMaths;
        var numCols = 0;
        var emptyGroup = {
          type: "ordgroup",
          mode: context.mode,
          body: []
        };
        if (args[0] && args[0].type === "ordgroup") {
          var arg0 = "";
          for (var i3 = 0; i3 < args[0].body.length; i3++) {
            var textord2 = assertNodeType(args[0].body[i3], "textord");
            arg0 += textord2.text;
          }
          numMaths = Number(arg0);
          numCols = numMaths * 2;
        }
        var isAligned = !numCols;
        res.body.forEach(function(row) {
          for (var _i42 = 1; _i42 < row.length; _i42 += 2) {
            var styling = assertNodeType(row[_i42], "styling");
            var ordgroup = assertNodeType(styling.body[0], "ordgroup");
            ordgroup.body.unshift(emptyGroup);
          }
          if (!isAligned) {
            var curMaths = row.length / 2;
            if (numMaths < curMaths) {
              throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
            }
          } else if (numCols < row.length) {
            numCols = row.length;
          }
        });
        for (var _i52 = 0; _i52 < numCols; ++_i52) {
          var align = "r";
          var pregap = 0;
          if (_i52 % 2 === 1) {
            align = "l";
          } else if (_i52 > 0 && isAligned) {
            pregap = 1;
          }
          cols[_i52] = {
            type: "align",
            align,
            pregap,
            postgap: 0
          };
        }
        res.colSeparationType = isAligned ? "align" : "alignat";
        return res;
      };
      defineEnvironment({
        type: "array",
        names: ["array", "darray"],
        props: {
          numArgs: 1
        },
        handler: function handler(context, args) {
          var symNode = checkSymbolNodeType(args[0]);
          var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
          var cols = colalign.map(function(nde) {
            var node = assertSymbolNodeType(nde);
            var ca = node.text;
            if ("lcr".indexOf(ca) !== -1) {
              return {
                type: "align",
                align: ca
              };
            } else if (ca === "|") {
              return {
                type: "separator",
                separator: "|"
              };
            } else if (ca === ":") {
              return {
                type: "separator",
                separator: ":"
              };
            }
            throw new src_ParseError("Unknown column alignment: " + ca, nde);
          });
          var res = {
            cols,
            hskipBeforeAndAfter: true,
            maxNumCols: cols.length
          };
          return parseArray(context.parser, res, dCellStyle(context.envName));
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
        props: {
          numArgs: 0
        },
        handler: function handler(context) {
          var delimiters2 = {
            "matrix": null,
            "pmatrix": ["(", ")"],
            "bmatrix": ["[", "]"],
            "Bmatrix": ["\\{", "\\}"],
            "vmatrix": ["|", "|"],
            "Vmatrix": ["\\Vert", "\\Vert"]
          }[context.envName.replace("*", "")];
          var colAlign = "c";
          var payload = {
            hskipBeforeAndAfter: false,
            cols: [{
              type: "align",
              align: colAlign
            }]
          };
          if (context.envName.charAt(context.envName.length - 1) === "*") {
            var parser = context.parser;
            parser.consumeSpaces();
            if (parser.fetch().text === "[") {
              parser.consume();
              parser.consumeSpaces();
              colAlign = parser.fetch().text;
              if ("lcr".indexOf(colAlign) === -1) {
                throw new src_ParseError("Expected l or c or r", parser.nextToken);
              }
              parser.consume();
              parser.consumeSpaces();
              parser.expect("]");
              parser.consume();
              payload.cols = [{
                type: "align",
                align: colAlign
              }];
            }
          }
          var res = parseArray(context.parser, payload, dCellStyle(context.envName));
          var numCols = Math.max.apply(Math, [0].concat(res.body.map(function(row) {
            return row.length;
          })));
          res.cols = new Array(numCols).fill({
            type: "align",
            align: colAlign
          });
          return delimiters2 ? {
            type: "leftright",
            mode: context.mode,
            body: [res],
            left: delimiters2[0],
            right: delimiters2[1],
            rightColor: void 0
          } : res;
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["smallmatrix"],
        props: {
          numArgs: 0
        },
        handler: function handler(context) {
          var payload = {
            arraystretch: 0.5
          };
          var res = parseArray(context.parser, payload, "script");
          res.colSeparationType = "small";
          return res;
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["subarray"],
        props: {
          numArgs: 1
        },
        handler: function handler(context, args) {
          var symNode = checkSymbolNodeType(args[0]);
          var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
          var cols = colalign.map(function(nde) {
            var node = assertSymbolNodeType(nde);
            var ca = node.text;
            if ("lc".indexOf(ca) !== -1) {
              return {
                type: "align",
                align: ca
              };
            }
            throw new src_ParseError("Unknown column alignment: " + ca, nde);
          });
          if (cols.length > 1) {
            throw new src_ParseError("{subarray} can contain only one column");
          }
          var res = {
            cols,
            hskipBeforeAndAfter: false,
            arraystretch: 0.5
          };
          res = parseArray(context.parser, res, "script");
          if (res.body.length > 0 && res.body[0].length > 1) {
            throw new src_ParseError("{subarray} can contain only one column");
          }
          return res;
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["cases", "dcases", "rcases", "drcases"],
        props: {
          numArgs: 0
        },
        handler: function handler(context) {
          var payload = {
            arraystretch: 1.2,
            cols: [{
              type: "align",
              align: "l",
              pregap: 0,
              postgap: 1
            }, {
              type: "align",
              align: "l",
              pregap: 0,
              postgap: 0
            }]
          };
          var res = parseArray(context.parser, payload, dCellStyle(context.envName));
          return {
            type: "leftright",
            mode: context.mode,
            body: [res],
            left: context.envName.indexOf("r") > -1 ? "." : "\\{",
            right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
            rightColor: void 0
          };
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["align", "align*", "aligned", "split"],
        props: {
          numArgs: 0
        },
        handler: alignedHandler,
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["gathered", "gather", "gather*"],
        props: {
          numArgs: 0
        },
        handler: function handler(context) {
          if (utils.contains(["gather", "gather*"], context.envName)) {
            validateAmsEnvironmentContext(context);
          }
          var res = {
            cols: [{
              type: "align",
              align: "c"
            }],
            addJot: true,
            colSeparationType: "gather",
            autoTag: getAutoTag(context.envName),
            emptySingleRow: true,
            leqno: context.parser.settings.leqno
          };
          return parseArray(context.parser, res, "display");
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["alignat", "alignat*", "alignedat"],
        props: {
          numArgs: 1
        },
        handler: alignedHandler,
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["equation", "equation*"],
        props: {
          numArgs: 0
        },
        handler: function handler(context) {
          validateAmsEnvironmentContext(context);
          var res = {
            autoTag: getAutoTag(context.envName),
            emptySingleRow: true,
            singleRow: true,
            maxNumCols: 1,
            leqno: context.parser.settings.leqno
          };
          return parseArray(context.parser, res, "display");
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["CD"],
        props: {
          numArgs: 0
        },
        handler: function handler(context) {
          validateAmsEnvironmentContext(context);
          return parseCD(context.parser);
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
      defineMacro("\\notag", "\\nonumber");
      defineFunction({
        type: "text",
        names: ["\\hline", "\\hdashline"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: true
        },
        handler: function handler(context, args) {
          throw new src_ParseError(context.funcName + " valid only within array environment");
        }
      });
      var environments = _environments;
      var src_environments = environments;
      defineFunction({
        type: "environment",
        names: ["\\begin", "\\end"],
        props: {
          numArgs: 1,
          argTypes: ["text"]
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var nameGroup = args[0];
          if (nameGroup.type !== "ordgroup") {
            throw new src_ParseError("Invalid environment name", nameGroup);
          }
          var envName = "";
          for (var i3 = 0; i3 < nameGroup.body.length; ++i3) {
            envName += assertNodeType(nameGroup.body[i3], "textord").text;
          }
          if (funcName === "\\begin") {
            if (!src_environments.hasOwnProperty(envName)) {
              throw new src_ParseError("No such environment: " + envName, nameGroup);
            }
            var env = src_environments[envName];
            var _parser$parseArgument = parser.parseArguments("\\begin{" + envName + "}", env), _args = _parser$parseArgument.args, optArgs = _parser$parseArgument.optArgs;
            var context = {
              mode: parser.mode,
              envName,
              parser
            };
            var result = env.handler(context, _args, optArgs);
            parser.expect("\\end", false);
            var endNameToken = parser.nextToken;
            var end = assertNodeType(parser.parseFunction(), "environment");
            if (end.name !== envName) {
              throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
            }
            return result;
          }
          return {
            type: "environment",
            mode: parser.mode,
            name: envName,
            nameGroup
          };
        }
      });
      var font_htmlBuilder = function htmlBuilder2(group, options) {
        var font = group.font;
        var newOptions = options.withFont(font);
        return buildGroup(group.body, newOptions);
      };
      var font_mathmlBuilder = function mathmlBuilder2(group, options) {
        var font = group.font;
        var newOptions = options.withFont(font);
        return buildMathML_buildGroup(group.body, newOptions);
      };
      var fontAliases = {
        "\\Bbb": "\\mathbb",
        "\\bold": "\\mathbf",
        "\\frak": "\\mathfrak",
        "\\bm": "\\boldsymbol"
      };
      defineFunction({
        type: "font",
        names: [
          "\\mathrm",
          "\\mathit",
          "\\mathbf",
          "\\mathnormal",
          "\\mathbb",
          "\\mathcal",
          "\\mathfrak",
          "\\mathscr",
          "\\mathsf",
          "\\mathtt",
          "\\Bbb",
          "\\bold",
          "\\frak"
        ],
        props: {
          numArgs: 1,
          allowedInArgument: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var body = normalizeArgument(args[0]);
          var func = funcName;
          if (func in fontAliases) {
            func = fontAliases[func];
          }
          return {
            type: "font",
            mode: parser.mode,
            font: func.slice(1),
            body
          };
        },
        htmlBuilder: font_htmlBuilder,
        mathmlBuilder: font_mathmlBuilder
      });
      defineFunction({
        type: "mclass",
        names: ["\\boldsymbol", "\\bm"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser;
          var body = args[0];
          var isCharacterBox2 = utils.isCharacterBox(body);
          return {
            type: "mclass",
            mode: parser.mode,
            mclass: binrelClass(body),
            body: [{
              type: "font",
              mode: parser.mode,
              font: "boldsymbol",
              body
            }],
            isCharacterBox: isCharacterBox2
          };
        }
      });
      defineFunction({
        type: "font",
        names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: function handler(_ref3, args) {
          var parser = _ref3.parser, funcName = _ref3.funcName, breakOnTokenText = _ref3.breakOnTokenText;
          var mode = parser.mode;
          var body = parser.parseExpression(true, breakOnTokenText);
          var style = "math" + funcName.slice(1);
          return {
            type: "font",
            mode,
            font: style,
            body: {
              type: "ordgroup",
              mode: parser.mode,
              body
            }
          };
        },
        htmlBuilder: font_htmlBuilder,
        mathmlBuilder: font_mathmlBuilder
      });
      var adjustStyle = function adjustStyle2(size, originalStyle) {
        var style = originalStyle;
        if (size === "display") {
          style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
        } else if (size === "text" && style.size === src_Style.DISPLAY.size) {
          style = src_Style.TEXT;
        } else if (size === "script") {
          style = src_Style.SCRIPT;
        } else if (size === "scriptscript") {
          style = src_Style.SCRIPTSCRIPT;
        }
        return style;
      };
      var genfrac_htmlBuilder = function htmlBuilder2(group, options) {
        var style = adjustStyle(group.size, options.style);
        var nstyle = style.fracNum();
        var dstyle = style.fracDen();
        var newOptions;
        newOptions = options.havingStyle(nstyle);
        var numerm = buildGroup(group.numer, newOptions, options);
        if (group.continued) {
          var hStrut = 8.5 / options.fontMetrics().ptPerEm;
          var dStrut = 3.5 / options.fontMetrics().ptPerEm;
          numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
          numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
        }
        newOptions = options.havingStyle(dstyle);
        var denomm = buildGroup(group.denom, newOptions, options);
        var rule;
        var ruleWidth;
        var ruleSpacing;
        if (group.hasBarLine) {
          if (group.barSize) {
            ruleWidth = calculateSize(group.barSize, options);
            rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
          } else {
            rule = buildCommon.makeLineSpan("frac-line", options);
          }
          ruleWidth = rule.height;
          ruleSpacing = rule.height;
        } else {
          rule = null;
          ruleWidth = 0;
          ruleSpacing = options.fontMetrics().defaultRuleThickness;
        }
        var numShift;
        var clearance;
        var denomShift;
        if (style.size === src_Style.DISPLAY.size || group.size === "display") {
          numShift = options.fontMetrics().num1;
          if (ruleWidth > 0) {
            clearance = 3 * ruleSpacing;
          } else {
            clearance = 7 * ruleSpacing;
          }
          denomShift = options.fontMetrics().denom1;
        } else {
          if (ruleWidth > 0) {
            numShift = options.fontMetrics().num2;
            clearance = ruleSpacing;
          } else {
            numShift = options.fontMetrics().num3;
            clearance = 3 * ruleSpacing;
          }
          denomShift = options.fontMetrics().denom2;
        }
        var frac;
        if (!rule) {
          var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
          if (candidateClearance < clearance) {
            numShift += 0.5 * (clearance - candidateClearance);
            denomShift += 0.5 * (clearance - candidateClearance);
          }
          frac = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: denomm,
              shift: denomShift
            }, {
              type: "elem",
              elem: numerm,
              shift: -numShift
            }]
          }, options);
        } else {
          var axisHeight = options.fontMetrics().axisHeight;
          if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
            numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
          }
          if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
            denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
          }
          var midShift = -(axisHeight - 0.5 * ruleWidth);
          frac = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: denomm,
              shift: denomShift
            }, {
              type: "elem",
              elem: rule,
              shift: midShift
            }, {
              type: "elem",
              elem: numerm,
              shift: -numShift
            }]
          }, options);
        }
        newOptions = options.havingStyle(style);
        frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
        frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
        var delimSize;
        if (style.size === src_Style.DISPLAY.size) {
          delimSize = options.fontMetrics().delim1;
        } else if (style.size === src_Style.SCRIPTSCRIPT.size) {
          delimSize = options.havingStyle(src_Style.SCRIPT).fontMetrics().delim2;
        } else {
          delimSize = options.fontMetrics().delim2;
        }
        var leftDelim;
        var rightDelim;
        if (group.leftDelim == null) {
          leftDelim = makeNullDelimiter(options, ["mopen"]);
        } else {
          leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
        }
        if (group.continued) {
          rightDelim = buildCommon.makeSpan([]);
        } else if (group.rightDelim == null) {
          rightDelim = makeNullDelimiter(options, ["mclose"]);
        } else {
          rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
        }
        return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
      };
      var genfrac_mathmlBuilder = function mathmlBuilder2(group, options) {
        var node = new mathMLTree.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);
        if (!group.hasBarLine) {
          node.setAttribute("linethickness", "0px");
        } else if (group.barSize) {
          var ruleWidth = calculateSize(group.barSize, options);
          node.setAttribute("linethickness", makeEm(ruleWidth));
        }
        var style = adjustStyle(group.size, options.style);
        if (style.size !== options.style.size) {
          node = new mathMLTree.MathNode("mstyle", [node]);
          var isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
          node.setAttribute("displaystyle", isDisplay);
          node.setAttribute("scriptlevel", "0");
        }
        if (group.leftDelim != null || group.rightDelim != null) {
          var withDelims = [];
          if (group.leftDelim != null) {
            var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
            leftOp.setAttribute("fence", "true");
            withDelims.push(leftOp);
          }
          withDelims.push(node);
          if (group.rightDelim != null) {
            var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
            rightOp.setAttribute("fence", "true");
            withDelims.push(rightOp);
          }
          return makeRow(withDelims);
        }
        return node;
      };
      defineFunction({
        type: "genfrac",
        names: [
          "\\dfrac",
          "\\frac",
          "\\tfrac",
          "\\dbinom",
          "\\binom",
          "\\tbinom",
          "\\\\atopfrac",
          "\\\\bracefrac",
          "\\\\brackfrac"
        ],
        props: {
          numArgs: 2,
          allowedInArgument: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var numer = args[0];
          var denom = args[1];
          var hasBarLine;
          var leftDelim = null;
          var rightDelim = null;
          var size = "auto";
          switch (funcName) {
            case "\\dfrac":
            case "\\frac":
            case "\\tfrac":
              hasBarLine = true;
              break;
            case "\\\\atopfrac":
              hasBarLine = false;
              break;
            case "\\dbinom":
            case "\\binom":
            case "\\tbinom":
              hasBarLine = false;
              leftDelim = "(";
              rightDelim = ")";
              break;
            case "\\\\bracefrac":
              hasBarLine = false;
              leftDelim = "\\{";
              rightDelim = "\\}";
              break;
            case "\\\\brackfrac":
              hasBarLine = false;
              leftDelim = "[";
              rightDelim = "]";
              break;
            default:
              throw new Error("Unrecognized genfrac command");
          }
          switch (funcName) {
            case "\\dfrac":
            case "\\dbinom":
              size = "display";
              break;
            case "\\tfrac":
            case "\\tbinom":
              size = "text";
              break;
          }
          return {
            type: "genfrac",
            mode: parser.mode,
            continued: false,
            numer,
            denom,
            hasBarLine,
            leftDelim,
            rightDelim,
            size,
            barSize: null
          };
        },
        htmlBuilder: genfrac_htmlBuilder,
        mathmlBuilder: genfrac_mathmlBuilder
      });
      defineFunction({
        type: "genfrac",
        names: ["\\cfrac"],
        props: {
          numArgs: 2
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser;
          _ref2.funcName;
          var numer = args[0];
          var denom = args[1];
          return {
            type: "genfrac",
            mode: parser.mode,
            continued: true,
            numer,
            denom,
            hasBarLine: true,
            leftDelim: null,
            rightDelim: null,
            size: "display",
            barSize: null
          };
        }
      });
      defineFunction({
        type: "infix",
        names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
        props: {
          numArgs: 0,
          infix: true
        },
        handler: function handler(_ref3) {
          var parser = _ref3.parser, funcName = _ref3.funcName, token = _ref3.token;
          var replaceWith;
          switch (funcName) {
            case "\\over":
              replaceWith = "\\frac";
              break;
            case "\\choose":
              replaceWith = "\\binom";
              break;
            case "\\atop":
              replaceWith = "\\\\atopfrac";
              break;
            case "\\brace":
              replaceWith = "\\\\bracefrac";
              break;
            case "\\brack":
              replaceWith = "\\\\brackfrac";
              break;
            default:
              throw new Error("Unrecognized infix genfrac command");
          }
          return {
            type: "infix",
            mode: parser.mode,
            replaceWith,
            token
          };
        }
      });
      var stylArray = ["display", "text", "script", "scriptscript"];
      var delimFromValue = function delimFromValue2(delimString) {
        var delim = null;
        if (delimString.length > 0) {
          delim = delimString;
          delim = delim === "." ? null : delim;
        }
        return delim;
      };
      defineFunction({
        type: "genfrac",
        names: ["\\genfrac"],
        props: {
          numArgs: 6,
          allowedInArgument: true,
          argTypes: ["math", "math", "size", "text", "math", "math"]
        },
        handler: function handler(_ref4, args) {
          var parser = _ref4.parser;
          var numer = args[4];
          var denom = args[5];
          var leftNode = normalizeArgument(args[0]);
          var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
          var rightNode = normalizeArgument(args[1]);
          var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
          var barNode = assertNodeType(args[2], "size");
          var hasBarLine;
          var barSize = null;
          if (barNode.isBlank) {
            hasBarLine = true;
          } else {
            barSize = barNode.value;
            hasBarLine = barSize.number > 0;
          }
          var size = "auto";
          var styl = args[3];
          if (styl.type === "ordgroup") {
            if (styl.body.length > 0) {
              var textOrd = assertNodeType(styl.body[0], "textord");
              size = stylArray[Number(textOrd.text)];
            }
          } else {
            styl = assertNodeType(styl, "textord");
            size = stylArray[Number(styl.text)];
          }
          return {
            type: "genfrac",
            mode: parser.mode,
            numer,
            denom,
            continued: false,
            hasBarLine,
            barSize,
            leftDelim,
            rightDelim,
            size
          };
        },
        htmlBuilder: genfrac_htmlBuilder,
        mathmlBuilder: genfrac_mathmlBuilder
      });
      defineFunction({
        type: "infix",
        names: ["\\above"],
        props: {
          numArgs: 1,
          argTypes: ["size"],
          infix: true
        },
        handler: function handler(_ref5, args) {
          var parser = _ref5.parser;
          _ref5.funcName;
          var token = _ref5.token;
          return {
            type: "infix",
            mode: parser.mode,
            replaceWith: "\\\\abovefrac",
            size: assertNodeType(args[0], "size").value,
            token
          };
        }
      });
      defineFunction({
        type: "genfrac",
        names: ["\\\\abovefrac"],
        props: {
          numArgs: 3,
          argTypes: ["math", "size", "math"]
        },
        handler: function handler(_ref6, args) {
          var parser = _ref6.parser;
          _ref6.funcName;
          var numer = args[0];
          var barSize = assert(assertNodeType(args[1], "infix").size);
          var denom = args[2];
          var hasBarLine = barSize.number > 0;
          return {
            type: "genfrac",
            mode: parser.mode,
            numer,
            denom,
            continued: false,
            hasBarLine,
            barSize,
            leftDelim: null,
            rightDelim: null,
            size: "auto"
          };
        },
        htmlBuilder: genfrac_htmlBuilder,
        mathmlBuilder: genfrac_mathmlBuilder
      });
      var horizBrace_htmlBuilder = function htmlBuilder2(grp, options) {
        var style = options.style;
        var supSubGroup;
        var group;
        if (grp.type === "supsub") {
          supSubGroup = grp.sup ? buildGroup(grp.sup, options.havingStyle(style.sup()), options) : buildGroup(grp.sub, options.havingStyle(style.sub()), options);
          group = assertNodeType(grp.base, "horizBrace");
        } else {
          group = assertNodeType(grp, "horizBrace");
        }
        var body = buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY));
        var braceBody = stretchy.svgSpan(group, options);
        var vlist;
        if (group.isOver) {
          vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "kern",
              size: 0.1
            }, {
              type: "elem",
              elem: braceBody
            }]
          }, options);
          vlist.children[0].children[0].children[1].classes.push("svg-align");
        } else {
          vlist = buildCommon.makeVList({
            positionType: "bottom",
            positionData: body.depth + 0.1 + braceBody.height,
            children: [{
              type: "elem",
              elem: braceBody
            }, {
              type: "kern",
              size: 0.1
            }, {
              type: "elem",
              elem: body
            }]
          }, options);
          vlist.children[0].children[0].children[0].classes.push("svg-align");
        }
        if (supSubGroup) {
          var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
          if (group.isOver) {
            vlist = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: vSpan
              }, {
                type: "kern",
                size: 0.2
              }, {
                type: "elem",
                elem: supSubGroup
              }]
            }, options);
          } else {
            vlist = buildCommon.makeVList({
              positionType: "bottom",
              positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
              children: [{
                type: "elem",
                elem: supSubGroup
              }, {
                type: "kern",
                size: 0.2
              }, {
                type: "elem",
                elem: vSpan
              }]
            }, options);
          }
        }
        return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
      };
      var horizBrace_mathmlBuilder = function mathmlBuilder2(group, options) {
        var accentNode = stretchy.mathMLnode(group.label);
        return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
      };
      defineFunction({
        type: "horizBrace",
        names: ["\\overbrace", "\\underbrace"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          return {
            type: "horizBrace",
            mode: parser.mode,
            label: funcName,
            isOver: /^\\over/.test(funcName),
            base: args[0]
          };
        },
        htmlBuilder: horizBrace_htmlBuilder,
        mathmlBuilder: horizBrace_mathmlBuilder
      });
      defineFunction({
        type: "href",
        names: ["\\href"],
        props: {
          numArgs: 2,
          argTypes: ["url", "original"],
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          var body = args[1];
          var href = assertNodeType(args[0], "url").url;
          if (!parser.settings.isTrusted({
            command: "\\href",
            url: href
          })) {
            return parser.formatUnsupportedCmd("\\href");
          }
          return {
            type: "href",
            mode: parser.mode,
            href,
            body: ordargument(body)
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var elements = buildExpression(group.body, options, false);
          return buildCommon.makeAnchor(group.href, [], elements, options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var math2 = buildExpressionRow(group.body, options);
          if (!(math2 instanceof MathNode)) {
            math2 = new MathNode("mrow", [math2]);
          }
          math2.setAttribute("href", group.href);
          return math2;
        }
      });
      defineFunction({
        type: "href",
        names: ["\\url"],
        props: {
          numArgs: 1,
          argTypes: ["url"],
          allowedInText: true
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser;
          var href = assertNodeType(args[0], "url").url;
          if (!parser.settings.isTrusted({
            command: "\\url",
            url: href
          })) {
            return parser.formatUnsupportedCmd("\\url");
          }
          var chars = [];
          for (var i3 = 0; i3 < href.length; i3++) {
            var c2 = href[i3];
            if (c2 === "~") {
              c2 = "\\textasciitilde";
            }
            chars.push({
              type: "textord",
              mode: "text",
              text: c2
            });
          }
          var body = {
            type: "text",
            mode: parser.mode,
            font: "\\texttt",
            body: chars
          };
          return {
            type: "href",
            mode: parser.mode,
            href,
            body: ordargument(body)
          };
        }
      });
      defineFunction({
        type: "hbox",
        names: ["\\hbox"],
        props: {
          numArgs: 1,
          argTypes: ["text"],
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          return {
            type: "hbox",
            mode: parser.mode,
            body: ordargument(args[0])
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var elements = buildExpression(group.body, options, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          return new mathMLTree.MathNode("mrow", buildMathML_buildExpression(group.body, options));
        }
      });
      defineFunction({
        type: "html",
        names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
        props: {
          numArgs: 2,
          argTypes: ["raw", "original"],
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          _ref.token;
          var value = assertNodeType(args[0], "raw").string;
          var body = args[1];
          if (parser.settings.strict) {
            parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
          }
          var trustContext;
          var attributes = {};
          switch (funcName) {
            case "\\htmlClass":
              attributes.class = value;
              trustContext = {
                command: "\\htmlClass",
                class: value
              };
              break;
            case "\\htmlId":
              attributes.id = value;
              trustContext = {
                command: "\\htmlId",
                id: value
              };
              break;
            case "\\htmlStyle":
              attributes.style = value;
              trustContext = {
                command: "\\htmlStyle",
                style: value
              };
              break;
            case "\\htmlData": {
              var data = value.split(",");
              for (var i3 = 0; i3 < data.length; i3++) {
                var keyVal = data[i3].split("=");
                if (keyVal.length !== 2) {
                  throw new src_ParseError("Error parsing key-value for \\htmlData");
                }
                attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
              }
              trustContext = {
                command: "\\htmlData",
                attributes
              };
              break;
            }
            default:
              throw new Error("Unrecognized html command");
          }
          if (!parser.settings.isTrusted(trustContext)) {
            return parser.formatUnsupportedCmd(funcName);
          }
          return {
            type: "html",
            mode: parser.mode,
            attributes,
            body: ordargument(body)
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var elements = buildExpression(group.body, options, false);
          var classes = ["enclosing"];
          if (group.attributes.class) {
            classes.push.apply(classes, group.attributes.class.trim().split(/\s+/));
          }
          var span = buildCommon.makeSpan(classes, elements, options);
          for (var attr in group.attributes) {
            if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
              span.setAttribute(attr, group.attributes[attr]);
            }
          }
          return span;
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          return buildExpressionRow(group.body, options);
        }
      });
      defineFunction({
        type: "htmlmathml",
        names: ["\\html@mathml"],
        props: {
          numArgs: 2,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          return {
            type: "htmlmathml",
            mode: parser.mode,
            html: ordargument(args[0]),
            mathml: ordargument(args[1])
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var elements = buildExpression(group.html, options, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          return buildExpressionRow(group.mathml, options);
        }
      });
      var sizeData = function sizeData2(str) {
        if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
          return {
            number: +str,
            unit: "bp"
          };
        } else {
          var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
          if (!match) {
            throw new src_ParseError("Invalid size: '" + str + "' in \\includegraphics");
          }
          var data = {
            number: +(match[1] + match[2]),
            unit: match[3]
          };
          if (!validUnit(data)) {
            throw new src_ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
          }
          return data;
        }
      };
      defineFunction({
        type: "includegraphics",
        names: ["\\includegraphics"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1,
          argTypes: ["raw", "url"],
          allowedInText: false
        },
        handler: function handler(_ref, args, optArgs) {
          var parser = _ref.parser;
          var width = {
            number: 0,
            unit: "em"
          };
          var height = {
            number: 0.9,
            unit: "em"
          };
          var totalheight = {
            number: 0,
            unit: "em"
          };
          var alt = "";
          if (optArgs[0]) {
            var attributeStr = assertNodeType(optArgs[0], "raw").string;
            var attributes = attributeStr.split(",");
            for (var i3 = 0; i3 < attributes.length; i3++) {
              var keyVal = attributes[i3].split("=");
              if (keyVal.length === 2) {
                var str = keyVal[1].trim();
                switch (keyVal[0].trim()) {
                  case "alt":
                    alt = str;
                    break;
                  case "width":
                    width = sizeData(str);
                    break;
                  case "height":
                    height = sizeData(str);
                    break;
                  case "totalheight":
                    totalheight = sizeData(str);
                    break;
                  default:
                    throw new src_ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                }
              }
            }
          }
          var src = assertNodeType(args[0], "url").url;
          if (alt === "") {
            alt = src;
            alt = alt.replace(/^.*[\\/]/, "");
            alt = alt.substring(0, alt.lastIndexOf("."));
          }
          if (!parser.settings.isTrusted({
            command: "\\includegraphics",
            url: src
          })) {
            return parser.formatUnsupportedCmd("\\includegraphics");
          }
          return {
            type: "includegraphics",
            mode: parser.mode,
            alt,
            width,
            height,
            totalheight,
            src
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var height = calculateSize(group.height, options);
          var depth = 0;
          if (group.totalheight.number > 0) {
            depth = calculateSize(group.totalheight, options) - height;
          }
          var width = 0;
          if (group.width.number > 0) {
            width = calculateSize(group.width, options);
          }
          var style = {
            height: makeEm(height + depth)
          };
          if (width > 0) {
            style.width = makeEm(width);
          }
          if (depth > 0) {
            style.verticalAlign = makeEm(-depth);
          }
          var node = new Img(group.src, group.alt, style);
          node.height = height;
          node.depth = depth;
          return node;
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node = new mathMLTree.MathNode("mglyph", []);
          node.setAttribute("alt", group.alt);
          var height = calculateSize(group.height, options);
          var depth = 0;
          if (group.totalheight.number > 0) {
            depth = calculateSize(group.totalheight, options) - height;
            node.setAttribute("valign", makeEm(-depth));
          }
          node.setAttribute("height", makeEm(height + depth));
          if (group.width.number > 0) {
            var width = calculateSize(group.width, options);
            node.setAttribute("width", makeEm(width));
          }
          node.setAttribute("src", group.src);
          return node;
        }
      });
      defineFunction({
        type: "kern",
        names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
        props: {
          numArgs: 1,
          argTypes: ["size"],
          primitive: true,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var size = assertNodeType(args[0], "size");
          if (parser.settings.strict) {
            var mathFunction = funcName[1] === "m";
            var muUnit = size.value.unit === "mu";
            if (mathFunction) {
              if (!muUnit) {
                parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
              }
              if (parser.mode !== "math") {
                parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
              }
            } else {
              if (muUnit) {
                parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
              }
            }
          }
          return {
            type: "kern",
            mode: parser.mode,
            dimension: size.value
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          return buildCommon.makeGlue(group.dimension, options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var dimension = calculateSize(group.dimension, options);
          return new mathMLTree.SpaceNode(dimension);
        }
      });
      defineFunction({
        type: "lap",
        names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var body = args[0];
          return {
            type: "lap",
            mode: parser.mode,
            alignment: funcName.slice(5),
            body
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var inner2;
          if (group.alignment === "clap") {
            inner2 = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
            inner2 = buildCommon.makeSpan(["inner"], [inner2], options);
          } else {
            inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options)]);
          }
          var fix = buildCommon.makeSpan(["fix"], []);
          var node = buildCommon.makeSpan([group.alignment], [inner2, fix], options);
          var strut = buildCommon.makeSpan(["strut"]);
          strut.style.height = makeEm(node.height + node.depth);
          if (node.depth) {
            strut.style.verticalAlign = makeEm(-node.depth);
          }
          node.children.unshift(strut);
          node = buildCommon.makeSpan(["thinbox"], [node], options);
          return buildCommon.makeSpan(["mord", "vbox"], [node], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
          if (group.alignment !== "rlap") {
            var offset = group.alignment === "llap" ? "-1" : "-0.5";
            node.setAttribute("lspace", offset + "width");
          }
          node.setAttribute("width", "0px");
          return node;
        }
      });
      defineFunction({
        type: "styling",
        names: ["\\(", "$"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: false
        },
        handler: function handler(_ref, args) {
          var funcName = _ref.funcName, parser = _ref.parser;
          var outerMode = parser.mode;
          parser.switchMode("math");
          var close = funcName === "\\(" ? "\\)" : "$";
          var body = parser.parseExpression(false, close);
          parser.expect(close);
          parser.switchMode(outerMode);
          return {
            type: "styling",
            mode: parser.mode,
            style: "text",
            body
          };
        }
      });
      defineFunction({
        type: "text",
        names: ["\\)", "\\]"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: false
        },
        handler: function handler(context, args) {
          throw new src_ParseError("Mismatched " + context.funcName);
        }
      });
      var chooseMathStyle = function chooseMathStyle2(group, options) {
        switch (options.style.size) {
          case src_Style.DISPLAY.size:
            return group.display;
          case src_Style.TEXT.size:
            return group.text;
          case src_Style.SCRIPT.size:
            return group.script;
          case src_Style.SCRIPTSCRIPT.size:
            return group.scriptscript;
          default:
            return group.text;
        }
      };
      defineFunction({
        type: "mathchoice",
        names: ["\\mathchoice"],
        props: {
          numArgs: 4,
          primitive: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          return {
            type: "mathchoice",
            mode: parser.mode,
            display: ordargument(args[0]),
            text: ordargument(args[1]),
            script: ordargument(args[2]),
            scriptscript: ordargument(args[3])
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var body = chooseMathStyle(group, options);
          var elements = buildExpression(body, options, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var body = chooseMathStyle(group, options);
          return buildExpressionRow(body, options);
        }
      });
      var assembleSupSub = function assembleSupSub2(base, supGroup, subGroup, options, style, slant, baseShift) {
        base = buildCommon.makeSpan([], [base]);
        var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
        var sub;
        var sup;
        if (supGroup) {
          var elem = buildGroup(supGroup, options.havingStyle(style.sup()), options);
          sup = {
            elem,
            kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
          };
        }
        if (subGroup) {
          var _elem = buildGroup(subGroup, options.havingStyle(style.sub()), options);
          sub = {
            elem: _elem,
            kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
          };
        }
        var finalGroup;
        if (sup && sub) {
          var bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "bottom",
            positionData: bottom,
            children: [{
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub.elem,
              marginLeft: makeEm(-slant)
            }, {
              type: "kern",
              size: sub.kern
            }, {
              type: "elem",
              elem: base
            }, {
              type: "kern",
              size: sup.kern
            }, {
              type: "elem",
              elem: sup.elem,
              marginLeft: makeEm(slant)
            }, {
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }]
          }, options);
        } else if (sub) {
          var top = base.height - baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "top",
            positionData: top,
            children: [{
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub.elem,
              marginLeft: makeEm(-slant)
            }, {
              type: "kern",
              size: sub.kern
            }, {
              type: "elem",
              elem: base
            }]
          }, options);
        } else if (sup) {
          var _bottom = base.depth + baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "bottom",
            positionData: _bottom,
            children: [{
              type: "elem",
              elem: base
            }, {
              type: "kern",
              size: sup.kern
            }, {
              type: "elem",
              elem: sup.elem,
              marginLeft: makeEm(slant)
            }, {
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }]
          }, options);
        } else {
          return base;
        }
        var parts = [finalGroup];
        if (sub && slant !== 0 && !subIsSingleCharacter) {
          var spacer = buildCommon.makeSpan(["mspace"], [], options);
          spacer.style.marginRight = makeEm(slant);
          parts.unshift(spacer);
        }
        return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
      };
      var noSuccessor = ["\\smallint"];
      var op_htmlBuilder = function htmlBuilder2(grp, options) {
        var supGroup;
        var subGroup;
        var hasLimits = false;
        var group;
        if (grp.type === "supsub") {
          supGroup = grp.sup;
          subGroup = grp.sub;
          group = assertNodeType(grp.base, "op");
          hasLimits = true;
        } else {
          group = assertNodeType(grp, "op");
        }
        var style = options.style;
        var large = false;
        if (style.size === src_Style.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
          large = true;
        }
        var base;
        if (group.symbol) {
          var fontName = large ? "Size2-Regular" : "Size1-Regular";
          var stash = "";
          if (group.name === "\\oiint" || group.name === "\\oiiint") {
            stash = group.name.slice(1);
            group.name = stash === "oiint" ? "\\iint" : "\\iiint";
          }
          base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
          if (stash.length > 0) {
            var italic = base.italic;
            var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
            base = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: base,
                shift: 0
              }, {
                type: "elem",
                elem: oval,
                shift: large ? 0.08 : 0
              }]
            }, options);
            group.name = "\\" + stash;
            base.classes.unshift("mop");
            base.italic = italic;
          }
        } else if (group.body) {
          var inner2 = buildExpression(group.body, options, true);
          if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
            base = inner2[0];
            base.classes[0] = "mop";
          } else {
            base = buildCommon.makeSpan(["mop"], inner2, options);
          }
        } else {
          var output = [];
          for (var i3 = 1; i3 < group.name.length; i3++) {
            output.push(buildCommon.mathsym(group.name[i3], group.mode, options));
          }
          base = buildCommon.makeSpan(["mop"], output, options);
        }
        var baseShift = 0;
        var slant = 0;
        if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
          baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight;
          slant = base.italic;
        }
        if (hasLimits) {
          return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);
        } else {
          if (baseShift) {
            base.style.position = "relative";
            base.style.top = makeEm(baseShift);
          }
          return base;
        }
      };
      var op_mathmlBuilder = function mathmlBuilder2(group, options) {
        var node;
        if (group.symbol) {
          node = new MathNode("mo", [makeText(group.name, group.mode)]);
          if (utils.contains(noSuccessor, group.name)) {
            node.setAttribute("largeop", "false");
          }
        } else if (group.body) {
          node = new MathNode("mo", buildMathML_buildExpression(group.body, options));
        } else {
          node = new MathNode("mi", [new TextNode(group.name.slice(1))]);
          var operator = new MathNode("mo", [makeText("\u2061", "text")]);
          if (group.parentIsSupSub) {
            node = new MathNode("mrow", [node, operator]);
          } else {
            node = newDocumentFragment([node, operator]);
          }
        }
        return node;
      };
      var singleCharBigOps = {
        "\u220F": "\\prod",
        "\u2210": "\\coprod",
        "\u2211": "\\sum",
        "\u22C0": "\\bigwedge",
        "\u22C1": "\\bigvee",
        "\u22C2": "\\bigcap",
        "\u22C3": "\\bigcup",
        "\u2A00": "\\bigodot",
        "\u2A01": "\\bigoplus",
        "\u2A02": "\\bigotimes",
        "\u2A04": "\\biguplus",
        "\u2A06": "\\bigsqcup"
      };
      defineFunction({
        type: "op",
        names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
        props: {
          numArgs: 0
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var fName = funcName;
          if (fName.length === 1) {
            fName = singleCharBigOps[fName];
          }
          return {
            type: "op",
            mode: parser.mode,
            limits: true,
            parentIsSupSub: false,
            symbol: true,
            name: fName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      defineFunction({
        type: "op",
        names: ["\\mathop"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser;
          var body = args[0];
          return {
            type: "op",
            mode: parser.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: false,
            body: ordargument(body)
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      var singleCharIntegrals = {
        "\u222B": "\\int",
        "\u222C": "\\iint",
        "\u222D": "\\iiint",
        "\u222E": "\\oint",
        "\u222F": "\\oiint",
        "\u2230": "\\oiiint"
      };
      defineFunction({
        type: "op",
        names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
        props: {
          numArgs: 0
        },
        handler: function handler(_ref3) {
          var parser = _ref3.parser, funcName = _ref3.funcName;
          return {
            type: "op",
            mode: parser.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: false,
            name: funcName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      defineFunction({
        type: "op",
        names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
        props: {
          numArgs: 0
        },
        handler: function handler(_ref4) {
          var parser = _ref4.parser, funcName = _ref4.funcName;
          return {
            type: "op",
            mode: parser.mode,
            limits: true,
            parentIsSupSub: false,
            symbol: false,
            name: funcName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      defineFunction({
        type: "op",
        names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
        props: {
          numArgs: 0
        },
        handler: function handler(_ref5) {
          var parser = _ref5.parser, funcName = _ref5.funcName;
          var fName = funcName;
          if (fName.length === 1) {
            fName = singleCharIntegrals[fName];
          }
          return {
            type: "op",
            mode: parser.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: true,
            name: fName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      var operatorname_htmlBuilder = function htmlBuilder2(grp, options) {
        var supGroup;
        var subGroup;
        var hasLimits = false;
        var group;
        if (grp.type === "supsub") {
          supGroup = grp.sup;
          subGroup = grp.sub;
          group = assertNodeType(grp.base, "operatorname");
          hasLimits = true;
        } else {
          group = assertNodeType(grp, "operatorname");
        }
        var base;
        if (group.body.length > 0) {
          var body = group.body.map(function(child2) {
            var childText = child2.text;
            if (typeof childText === "string") {
              return {
                type: "textord",
                mode: child2.mode,
                text: childText
              };
            } else {
              return child2;
            }
          });
          var expression = buildExpression(body, options.withFont("mathrm"), true);
          for (var i3 = 0; i3 < expression.length; i3++) {
            var child = expression[i3];
            if (child instanceof SymbolNode) {
              child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
            }
          }
          base = buildCommon.makeSpan(["mop"], expression, options);
        } else {
          base = buildCommon.makeSpan(["mop"], [], options);
        }
        if (hasLimits) {
          return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
        } else {
          return base;
        }
      };
      var operatorname_mathmlBuilder = function mathmlBuilder2(group, options) {
        var expression = buildMathML_buildExpression(group.body, options.withFont("mathrm"));
        var isAllString = true;
        for (var i3 = 0; i3 < expression.length; i3++) {
          var node = expression[i3];
          if (node instanceof mathMLTree.SpaceNode)
            ;
          else if (node instanceof mathMLTree.MathNode) {
            switch (node.type) {
              case "mi":
              case "mn":
              case "ms":
              case "mspace":
              case "mtext":
                break;
              case "mo": {
                var child = node.children[0];
                if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                  child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                } else {
                  isAllString = false;
                }
                break;
              }
              default:
                isAllString = false;
            }
          } else {
            isAllString = false;
          }
        }
        if (isAllString) {
          var word = expression.map(function(node2) {
            return node2.toText();
          }).join("");
          expression = [new mathMLTree.TextNode(word)];
        }
        var identifier = new mathMLTree.MathNode("mi", expression);
        identifier.setAttribute("mathvariant", "normal");
        var operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
        if (group.parentIsSupSub) {
          return new mathMLTree.MathNode("mrow", [identifier, operator]);
        } else {
          return mathMLTree.newDocumentFragment([identifier, operator]);
        }
      };
      defineFunction({
        type: "operatorname",
        names: ["\\operatorname@", "\\operatornamewithlimits"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var body = args[0];
          return {
            type: "operatorname",
            mode: parser.mode,
            body: ordargument(body),
            alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
            limits: false,
            parentIsSupSub: false
          };
        },
        htmlBuilder: operatorname_htmlBuilder,
        mathmlBuilder: operatorname_mathmlBuilder
      });
      defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
      defineFunctionBuilders({
        type: "ordgroup",
        htmlBuilder: function htmlBuilder2(group, options) {
          if (group.semisimple) {
            return buildCommon.makeFragment(buildExpression(group.body, options, false));
          }
          return buildCommon.makeSpan(["mord"], buildExpression(group.body, options, true), options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          return buildExpressionRow(group.body, options, true);
        }
      });
      defineFunction({
        type: "overline",
        names: ["\\overline"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          var body = args[0];
          return {
            type: "overline",
            mode: parser.mode,
            body
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var innerGroup = buildGroup(group.body, options.havingCrampedStyle());
          var line = buildCommon.makeLineSpan("overline-line", options);
          var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
          var vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: innerGroup
            }, {
              type: "kern",
              size: 3 * defaultRuleThickness
            }, {
              type: "elem",
              elem: line
            }, {
              type: "kern",
              size: defaultRuleThickness
            }]
          }, options);
          return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
          operator.setAttribute("stretchy", "true");
          var node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator]);
          node.setAttribute("accent", "true");
          return node;
        }
      });
      defineFunction({
        type: "phantom",
        names: ["\\phantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          var body = args[0];
          return {
            type: "phantom",
            mode: parser.mode,
            body: ordargument(body)
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var elements = buildExpression(group.body, options.withPhantom(), false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var inner2 = buildMathML_buildExpression(group.body, options);
          return new mathMLTree.MathNode("mphantom", inner2);
        }
      });
      defineFunction({
        type: "hphantom",
        names: ["\\hphantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref2, args) {
          var parser = _ref2.parser;
          var body = args[0];
          return {
            type: "hphantom",
            mode: parser.mode,
            body
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var node = buildCommon.makeSpan([], [buildGroup(group.body, options.withPhantom())]);
          node.height = 0;
          node.depth = 0;
          if (node.children) {
            for (var i3 = 0; i3 < node.children.length; i3++) {
              node.children[i3].height = 0;
              node.children[i3].depth = 0;
            }
          }
          node = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: node
            }]
          }, options);
          return buildCommon.makeSpan(["mord"], [node], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var inner2 = buildMathML_buildExpression(ordargument(group.body), options);
          var phantom = new mathMLTree.MathNode("mphantom", inner2);
          var node = new mathMLTree.MathNode("mpadded", [phantom]);
          node.setAttribute("height", "0px");
          node.setAttribute("depth", "0px");
          return node;
        }
      });
      defineFunction({
        type: "vphantom",
        names: ["\\vphantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref3, args) {
          var parser = _ref3.parser;
          var body = args[0];
          return {
            type: "vphantom",
            mode: parser.mode,
            body
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options.withPhantom())]);
          var fix = buildCommon.makeSpan(["fix"], []);
          return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var inner2 = buildMathML_buildExpression(ordargument(group.body), options);
          var phantom = new mathMLTree.MathNode("mphantom", inner2);
          var node = new mathMLTree.MathNode("mpadded", [phantom]);
          node.setAttribute("width", "0px");
          return node;
        }
      });
      defineFunction({
        type: "raisebox",
        names: ["\\raisebox"],
        props: {
          numArgs: 2,
          argTypes: ["size", "hbox"],
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          var amount = assertNodeType(args[0], "size").value;
          var body = args[1];
          return {
            type: "raisebox",
            mode: parser.mode,
            dy: amount,
            body
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var body = buildGroup(group.body, options);
          var dy = calculateSize(group.dy, options);
          return buildCommon.makeVList({
            positionType: "shift",
            positionData: -dy,
            children: [{
              type: "elem",
              elem: body
            }]
          }, options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
          var dy = group.dy.number + group.dy.unit;
          node.setAttribute("voffset", dy);
          return node;
        }
      });
      defineFunction({
        type: "internal",
        names: ["\\relax"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: function handler(_ref) {
          var parser = _ref.parser;
          return {
            type: "internal",
            mode: parser.mode
          };
        }
      });
      defineFunction({
        type: "rule",
        names: ["\\rule"],
        props: {
          numArgs: 2,
          numOptionalArgs: 1,
          argTypes: ["size", "size", "size"]
        },
        handler: function handler(_ref, args, optArgs) {
          var parser = _ref.parser;
          var shift = optArgs[0];
          var width = assertNodeType(args[0], "size");
          var height = assertNodeType(args[1], "size");
          return {
            type: "rule",
            mode: parser.mode,
            shift: shift && assertNodeType(shift, "size").value,
            width: width.value,
            height: height.value
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var rule = buildCommon.makeSpan(["mord", "rule"], [], options);
          var width = calculateSize(group.width, options);
          var height = calculateSize(group.height, options);
          var shift = group.shift ? calculateSize(group.shift, options) : 0;
          rule.style.borderRightWidth = makeEm(width);
          rule.style.borderTopWidth = makeEm(height);
          rule.style.bottom = makeEm(shift);
          rule.width = width;
          rule.height = height + shift;
          rule.depth = -shift;
          rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
          return rule;
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var width = calculateSize(group.width, options);
          var height = calculateSize(group.height, options);
          var shift = group.shift ? calculateSize(group.shift, options) : 0;
          var color = options.color && options.getColor() || "black";
          var rule = new mathMLTree.MathNode("mspace");
          rule.setAttribute("mathbackground", color);
          rule.setAttribute("width", makeEm(width));
          rule.setAttribute("height", makeEm(height));
          var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
          if (shift >= 0) {
            wrapper.setAttribute("height", makeEm(shift));
          } else {
            wrapper.setAttribute("height", makeEm(shift));
            wrapper.setAttribute("depth", makeEm(-shift));
          }
          wrapper.setAttribute("voffset", makeEm(shift));
          return wrapper;
        }
      });
      function sizingGroup(value, options, baseOptions) {
        var inner2 = buildExpression(value, options, false);
        var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
        for (var i3 = 0; i3 < inner2.length; i3++) {
          var pos = inner2[i3].classes.indexOf("sizing");
          if (pos < 0) {
            Array.prototype.push.apply(inner2[i3].classes, options.sizingClasses(baseOptions));
          } else if (inner2[i3].classes[pos + 1] === "reset-size" + options.size) {
            inner2[i3].classes[pos + 1] = "reset-size" + baseOptions.size;
          }
          inner2[i3].height *= multiplier;
          inner2[i3].depth *= multiplier;
        }
        return buildCommon.makeFragment(inner2);
      }
      var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
      var sizing_htmlBuilder = function htmlBuilder2(group, options) {
        var newOptions = options.havingSize(group.size);
        return sizingGroup(group.body, newOptions, options);
      };
      defineFunction({
        type: "sizing",
        names: sizeFuncs,
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser = _ref.parser;
          var body = parser.parseExpression(false, breakOnTokenText);
          return {
            type: "sizing",
            mode: parser.mode,
            size: sizeFuncs.indexOf(funcName) + 1,
            body
          };
        },
        htmlBuilder: sizing_htmlBuilder,
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var newOptions = options.havingSize(group.size);
          var inner2 = buildMathML_buildExpression(group.body, newOptions);
          var node = new mathMLTree.MathNode("mstyle", inner2);
          node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
          return node;
        }
      });
      defineFunction({
        type: "smash",
        names: ["\\smash"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args, optArgs) {
          var parser = _ref.parser;
          var smashHeight = false;
          var smashDepth = false;
          var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
          if (tbArg) {
            var letter = "";
            for (var i3 = 0; i3 < tbArg.body.length; ++i3) {
              var node = tbArg.body[i3];
              letter = node.text;
              if (letter === "t") {
                smashHeight = true;
              } else if (letter === "b") {
                smashDepth = true;
              } else {
                smashHeight = false;
                smashDepth = false;
                break;
              }
            }
          } else {
            smashHeight = true;
            smashDepth = true;
          }
          var body = args[0];
          return {
            type: "smash",
            mode: parser.mode,
            body,
            smashHeight,
            smashDepth
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var node = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
          if (!group.smashHeight && !group.smashDepth) {
            return node;
          }
          if (group.smashHeight) {
            node.height = 0;
            if (node.children) {
              for (var i3 = 0; i3 < node.children.length; i3++) {
                node.children[i3].height = 0;
              }
            }
          }
          if (group.smashDepth) {
            node.depth = 0;
            if (node.children) {
              for (var _i6 = 0; _i6 < node.children.length; _i6++) {
                node.children[_i6].depth = 0;
              }
            }
          }
          var smashedNode = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: node
            }]
          }, options);
          return buildCommon.makeSpan(["mord"], [smashedNode], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
          if (group.smashHeight) {
            node.setAttribute("height", "0px");
          }
          if (group.smashDepth) {
            node.setAttribute("depth", "0px");
          }
          return node;
        }
      });
      defineFunction({
        type: "sqrt",
        names: ["\\sqrt"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1
        },
        handler: function handler(_ref, args, optArgs) {
          var parser = _ref.parser;
          var index = optArgs[0];
          var body = args[0];
          return {
            type: "sqrt",
            mode: parser.mode,
            body,
            index
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var inner2 = buildGroup(group.body, options.havingCrampedStyle());
          if (inner2.height === 0) {
            inner2.height = options.fontMetrics().xHeight;
          }
          inner2 = buildCommon.wrapFragment(inner2, options);
          var metrics = options.fontMetrics();
          var theta = metrics.defaultRuleThickness;
          var phi = theta;
          if (options.style.id < src_Style.TEXT.id) {
            phi = options.fontMetrics().xHeight;
          }
          var lineClearance = theta + phi / 4;
          var minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
          var _delimiter$sqrtImage = delimiter.sqrtImage(minDelimiterHeight, options), img = _delimiter$sqrtImage.span, ruleWidth = _delimiter$sqrtImage.ruleWidth, advanceWidth = _delimiter$sqrtImage.advanceWidth;
          var delimDepth = img.height - ruleWidth;
          if (delimDepth > inner2.height + inner2.depth + lineClearance) {
            lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
          }
          var imgShift = img.height - inner2.height - lineClearance - ruleWidth;
          inner2.style.paddingLeft = makeEm(advanceWidth);
          var body = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: inner2,
              wrapperClasses: ["svg-align"]
            }, {
              type: "kern",
              size: -(inner2.height + imgShift)
            }, {
              type: "elem",
              elem: img
            }, {
              type: "kern",
              size: ruleWidth
            }]
          }, options);
          if (!group.index) {
            return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
          } else {
            var newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);
            var rootm = buildGroup(group.index, newOptions, options);
            var toShift = 0.6 * (body.height - body.depth);
            var rootVList = buildCommon.makeVList({
              positionType: "shift",
              positionData: -toShift,
              children: [{
                type: "elem",
                elem: rootm
              }]
            }, options);
            var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
            return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
          }
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var body = group.body, index = group.index;
          return index ? new mathMLTree.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index, options)]) : new mathMLTree.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
        }
      });
      var styling_styleMap = {
        "display": src_Style.DISPLAY,
        "text": src_Style.TEXT,
        "script": src_Style.SCRIPT,
        "scriptscript": src_Style.SCRIPTSCRIPT
      };
      defineFunction({
        type: "styling",
        names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref, args) {
          var breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser = _ref.parser;
          var body = parser.parseExpression(true, breakOnTokenText);
          var style = funcName.slice(1, funcName.length - 5);
          return {
            type: "styling",
            mode: parser.mode,
            style,
            body
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var newStyle = styling_styleMap[group.style];
          var newOptions = options.havingStyle(newStyle).withFont("");
          return sizingGroup(group.body, newOptions, options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var newStyle = styling_styleMap[group.style];
          var newOptions = options.havingStyle(newStyle);
          var inner2 = buildMathML_buildExpression(group.body, newOptions);
          var node = new mathMLTree.MathNode("mstyle", inner2);
          var styleAttributes = {
            "display": ["0", "true"],
            "text": ["0", "false"],
            "script": ["1", "false"],
            "scriptscript": ["2", "false"]
          };
          var attr = styleAttributes[group.style];
          node.setAttribute("scriptlevel", attr[0]);
          node.setAttribute("displaystyle", attr[1]);
          return node;
        }
      });
      var htmlBuilderDelegate = function htmlBuilderDelegate2(group, options) {
        var base = group.base;
        if (!base) {
          return null;
        } else if (base.type === "op") {
          var delegate = base.limits && (options.style.size === src_Style.DISPLAY.size || base.alwaysHandleSupSub);
          return delegate ? op_htmlBuilder : null;
        } else if (base.type === "operatorname") {
          var _delegate = base.alwaysHandleSupSub && (options.style.size === src_Style.DISPLAY.size || base.limits);
          return _delegate ? operatorname_htmlBuilder : null;
        } else if (base.type === "accent") {
          return utils.isCharacterBox(base.base) ? htmlBuilder : null;
        } else if (base.type === "horizBrace") {
          var isSup = !group.sub;
          return isSup === base.isOver ? horizBrace_htmlBuilder : null;
        } else {
          return null;
        }
      };
      defineFunctionBuilders({
        type: "supsub",
        htmlBuilder: function htmlBuilder2(group, options) {
          var builderDelegate = htmlBuilderDelegate(group, options);
          if (builderDelegate) {
            return builderDelegate(group, options);
          }
          var valueBase = group.base, valueSup = group.sup, valueSub = group.sub;
          var base = buildGroup(valueBase, options);
          var supm;
          var subm;
          var metrics = options.fontMetrics();
          var supShift = 0;
          var subShift = 0;
          var isCharacterBox2 = valueBase && utils.isCharacterBox(valueBase);
          if (valueSup) {
            var newOptions = options.havingStyle(options.style.sup());
            supm = buildGroup(valueSup, newOptions, options);
            if (!isCharacterBox2) {
              supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
            }
          }
          if (valueSub) {
            var _newOptions = options.havingStyle(options.style.sub());
            subm = buildGroup(valueSub, _newOptions, options);
            if (!isCharacterBox2) {
              subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
            }
          }
          var minSupShift;
          if (options.style === src_Style.DISPLAY) {
            minSupShift = metrics.sup1;
          } else if (options.style.cramped) {
            minSupShift = metrics.sup3;
          } else {
            minSupShift = metrics.sup2;
          }
          var multiplier = options.sizeMultiplier;
          var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
          var marginLeft = null;
          if (subm) {
            var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
            if (base instanceof SymbolNode || isOiint) {
              marginLeft = makeEm(-base.italic);
            }
          }
          var supsub;
          if (supm && subm) {
            supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
            subShift = Math.max(subShift, metrics.sub2);
            var ruleWidth = metrics.defaultRuleThickness;
            var maxWidth = 4 * ruleWidth;
            if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
              subShift = maxWidth - (supShift - supm.depth) + subm.height;
              var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
              if (psi > 0) {
                supShift += psi;
                subShift -= psi;
              }
            }
            var vlistElem = [{
              type: "elem",
              elem: subm,
              shift: subShift,
              marginRight,
              marginLeft
            }, {
              type: "elem",
              elem: supm,
              shift: -supShift,
              marginRight
            }];
            supsub = buildCommon.makeVList({
              positionType: "individualShift",
              children: vlistElem
            }, options);
          } else if (subm) {
            subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
            var _vlistElem = [{
              type: "elem",
              elem: subm,
              marginLeft,
              marginRight
            }];
            supsub = buildCommon.makeVList({
              positionType: "shift",
              positionData: subShift,
              children: _vlistElem
            }, options);
          } else if (supm) {
            supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
            supsub = buildCommon.makeVList({
              positionType: "shift",
              positionData: -supShift,
              children: [{
                type: "elem",
                elem: supm,
                marginRight
              }]
            }, options);
          } else {
            throw new Error("supsub must have either sup or sub.");
          }
          var mclass = getTypeOfDomTree(base, "right") || "mord";
          return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var isBrace = false;
          var isOver;
          var isSup;
          if (group.base && group.base.type === "horizBrace") {
            isSup = !!group.sup;
            if (isSup === group.base.isOver) {
              isBrace = true;
              isOver = group.base.isOver;
            }
          }
          if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
            group.base.parentIsSupSub = true;
          }
          var children = [buildMathML_buildGroup(group.base, options)];
          if (group.sub) {
            children.push(buildMathML_buildGroup(group.sub, options));
          }
          if (group.sup) {
            children.push(buildMathML_buildGroup(group.sup, options));
          }
          var nodeType;
          if (isBrace) {
            nodeType = isOver ? "mover" : "munder";
          } else if (!group.sub) {
            var base = group.base;
            if (base && base.type === "op" && base.limits && (options.style === src_Style.DISPLAY || base.alwaysHandleSupSub)) {
              nodeType = "mover";
            } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === src_Style.DISPLAY)) {
              nodeType = "mover";
            } else {
              nodeType = "msup";
            }
          } else if (!group.sup) {
            var _base = group.base;
            if (_base && _base.type === "op" && _base.limits && (options.style === src_Style.DISPLAY || _base.alwaysHandleSupSub)) {
              nodeType = "munder";
            } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === src_Style.DISPLAY)) {
              nodeType = "munder";
            } else {
              nodeType = "msub";
            }
          } else {
            var _base2 = group.base;
            if (_base2 && _base2.type === "op" && _base2.limits && options.style === src_Style.DISPLAY) {
              nodeType = "munderover";
            } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === src_Style.DISPLAY || _base2.limits)) {
              nodeType = "munderover";
            } else {
              nodeType = "msubsup";
            }
          }
          return new mathMLTree.MathNode(nodeType, children);
        }
      });
      defineFunctionBuilders({
        type: "atom",
        htmlBuilder: function htmlBuilder2(group, options) {
          return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
          if (group.family === "bin") {
            var variant = getVariant(group, options);
            if (variant === "bold-italic") {
              node.setAttribute("mathvariant", variant);
            }
          } else if (group.family === "punct") {
            node.setAttribute("separator", "true");
          } else if (group.family === "open" || group.family === "close") {
            node.setAttribute("stretchy", "false");
          }
          return node;
        }
      });
      var defaultVariant = {
        "mi": "italic",
        "mn": "normal",
        "mtext": "normal"
      };
      defineFunctionBuilders({
        type: "mathord",
        htmlBuilder: function htmlBuilder2(group, options) {
          return buildCommon.makeOrd(group, options, "mathord");
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
          var variant = getVariant(group, options) || "italic";
          if (variant !== defaultVariant[node.type]) {
            node.setAttribute("mathvariant", variant);
          }
          return node;
        }
      });
      defineFunctionBuilders({
        type: "textord",
        htmlBuilder: function htmlBuilder2(group, options) {
          return buildCommon.makeOrd(group, options, "textord");
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var text2 = makeText(group.text, group.mode, options);
          var variant = getVariant(group, options) || "normal";
          var node;
          if (group.mode === "text") {
            node = new mathMLTree.MathNode("mtext", [text2]);
          } else if (/[0-9]/.test(group.text)) {
            node = new mathMLTree.MathNode("mn", [text2]);
          } else if (group.text === "\\prime") {
            node = new mathMLTree.MathNode("mo", [text2]);
          } else {
            node = new mathMLTree.MathNode("mi", [text2]);
          }
          if (variant !== defaultVariant[node.type]) {
            node.setAttribute("mathvariant", variant);
          }
          return node;
        }
      });
      var cssSpace = {
        "\\nobreak": "nobreak",
        "\\allowbreak": "allowbreak"
      };
      var regularSpace = {
        " ": {},
        "\\ ": {},
        "~": {
          className: "nobreak"
        },
        "\\space": {},
        "\\nobreakspace": {
          className: "nobreak"
        }
      };
      defineFunctionBuilders({
        type: "spacing",
        htmlBuilder: function htmlBuilder2(group, options) {
          if (regularSpace.hasOwnProperty(group.text)) {
            var className = regularSpace[group.text].className || "";
            if (group.mode === "text") {
              var ord = buildCommon.makeOrd(group, options, "textord");
              ord.classes.push(className);
              return ord;
            } else {
              return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
            }
          } else if (cssSpace.hasOwnProperty(group.text)) {
            return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
          } else {
            throw new src_ParseError('Unknown type of space "' + group.text + '"');
          }
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node;
          if (regularSpace.hasOwnProperty(group.text)) {
            node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
          } else if (cssSpace.hasOwnProperty(group.text)) {
            return new mathMLTree.MathNode("mspace");
          } else {
            throw new src_ParseError('Unknown type of space "' + group.text + '"');
          }
          return node;
        }
      });
      var pad = function pad2() {
        var padNode = new mathMLTree.MathNode("mtd", []);
        padNode.setAttribute("width", "50%");
        return padNode;
      };
      defineFunctionBuilders({
        type: "tag",
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
          table.setAttribute("width", "100%");
          return table;
        }
      });
      var textFontFamilies = {
        "\\text": void 0,
        "\\textrm": "textrm",
        "\\textsf": "textsf",
        "\\texttt": "texttt",
        "\\textnormal": "textrm"
      };
      var textFontWeights = {
        "\\textbf": "textbf",
        "\\textmd": "textmd"
      };
      var textFontShapes = {
        "\\textit": "textit",
        "\\textup": "textup"
      };
      var optionsWithFont = function optionsWithFont2(group, options) {
        var font = group.font;
        if (!font) {
          return options;
        } else if (textFontFamilies[font]) {
          return options.withTextFontFamily(textFontFamilies[font]);
        } else if (textFontWeights[font]) {
          return options.withTextFontWeight(textFontWeights[font]);
        } else {
          return options.withTextFontShape(textFontShapes[font]);
        }
      };
      defineFunction({
        type: "text",
        names: [
          "\\text",
          "\\textrm",
          "\\textsf",
          "\\texttt",
          "\\textnormal",
          "\\textbf",
          "\\textmd",
          "\\textit",
          "\\textup"
        ],
        props: {
          numArgs: 1,
          argTypes: ["text"],
          allowedInArgument: true,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser, funcName = _ref.funcName;
          var body = args[0];
          return {
            type: "text",
            mode: parser.mode,
            body: ordargument(body),
            font: funcName
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var newOptions = optionsWithFont(group, options);
          var inner2 = buildExpression(group.body, newOptions, true);
          return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var newOptions = optionsWithFont(group, options);
          return buildExpressionRow(group.body, newOptions);
        }
      });
      defineFunction({
        type: "underline",
        names: ["\\underline"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          return {
            type: "underline",
            mode: parser.mode,
            body: args[0]
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var innerGroup = buildGroup(group.body, options);
          var line = buildCommon.makeLineSpan("underline-line", options);
          var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
          var vlist = buildCommon.makeVList({
            positionType: "top",
            positionData: innerGroup.height,
            children: [{
              type: "kern",
              size: defaultRuleThickness
            }, {
              type: "elem",
              elem: line
            }, {
              type: "kern",
              size: 3 * defaultRuleThickness
            }, {
              type: "elem",
              elem: innerGroup
            }]
          }, options);
          return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
          operator.setAttribute("stretchy", "true");
          var node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator]);
          node.setAttribute("accentunder", "true");
          return node;
        }
      });
      defineFunction({
        type: "vcenter",
        names: ["\\vcenter"],
        props: {
          numArgs: 1,
          argTypes: ["original"],
          allowedInText: false
        },
        handler: function handler(_ref, args) {
          var parser = _ref.parser;
          return {
            type: "vcenter",
            mode: parser.mode,
            body: args[0]
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var body = buildGroup(group.body, options);
          var axisHeight = options.fontMetrics().axisHeight;
          var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
          return buildCommon.makeVList({
            positionType: "shift",
            positionData: dy,
            children: [{
              type: "elem",
              elem: body
            }]
          }, options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          return new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)], ["vcenter"]);
        }
      });
      defineFunction({
        type: "verb",
        names: ["\\verb"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: function handler(context, args, optArgs) {
          throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var text2 = makeVerb(group);
          var body = [];
          var newOptions = options.havingStyle(options.style.text());
          for (var i3 = 0; i3 < text2.length; i3++) {
            var c2 = text2[i3];
            if (c2 === "~") {
              c2 = "\\textasciitilde";
            }
            body.push(buildCommon.makeSymbol(c2, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
          }
          return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var text2 = new mathMLTree.TextNode(makeVerb(group));
          var node = new mathMLTree.MathNode("mtext", [text2]);
          node.setAttribute("mathvariant", "monospace");
          return node;
        }
      });
      var makeVerb = function makeVerb2(group) {
        return group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");
      };
      var functions = _functions;
      var src_functions = functions;
      var spaceRegexString = "[ \r\n	]";
      var controlWordRegexString = "\\\\[a-zA-Z@]+";
      var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
      var controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
      var controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
      var combiningDiacriticalMarkString = "[\u0300-\u036F]";
      var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
      var tokenRegexString = "(" + spaceRegexString + "+)|" + (controlSpaceRegexString + "|") + "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + (combiningDiacriticalMarkString + "*") + "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + (combiningDiacriticalMarkString + "*") + "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + ("|" + controlWordWhitespaceRegexString) + ("|" + controlSymbolRegexString + ")");
      var Lexer = function() {
        function Lexer2(input, settings) {
          this.input = void 0;
          this.settings = void 0;
          this.tokenRegex = void 0;
          this.catcodes = void 0;
          this.input = input;
          this.settings = settings;
          this.tokenRegex = new RegExp(tokenRegexString, "g");
          this.catcodes = {
            "%": 14,
            "~": 13
          };
        }
        var _proto = Lexer2.prototype;
        _proto.setCatcode = function setCatcode(char, code) {
          this.catcodes[char] = code;
        };
        _proto.lex = function lex() {
          var input = this.input;
          var pos = this.tokenRegex.lastIndex;
          if (pos === input.length) {
            return new Token2("EOF", new SourceLocation(this, pos, pos));
          }
          var match = this.tokenRegex.exec(input);
          if (match === null || match.index !== pos) {
            throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token2(input[pos], new SourceLocation(this, pos, pos + 1)));
          }
          var text2 = match[6] || match[3] || (match[2] ? "\\ " : " ");
          if (this.catcodes[text2] === 14) {
            var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
            if (nlIndex === -1) {
              this.tokenRegex.lastIndex = input.length;
              this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
            } else {
              this.tokenRegex.lastIndex = nlIndex + 1;
            }
            return this.lex();
          }
          return new Token2(text2, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
        };
        return Lexer2;
      }();
      var Namespace = function() {
        function Namespace2(builtins, globalMacros) {
          if (builtins === void 0) {
            builtins = {};
          }
          if (globalMacros === void 0) {
            globalMacros = {};
          }
          this.current = void 0;
          this.builtins = void 0;
          this.undefStack = void 0;
          this.current = globalMacros;
          this.builtins = builtins;
          this.undefStack = [];
        }
        var _proto = Namespace2.prototype;
        _proto.beginGroup = function beginGroup() {
          this.undefStack.push({});
        };
        _proto.endGroup = function endGroup() {
          if (this.undefStack.length === 0) {
            throw new src_ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
          }
          var undefs = this.undefStack.pop();
          for (var undef in undefs) {
            if (undefs.hasOwnProperty(undef)) {
              if (undefs[undef] == null) {
                delete this.current[undef];
              } else {
                this.current[undef] = undefs[undef];
              }
            }
          }
        };
        _proto.endGroups = function endGroups() {
          while (this.undefStack.length > 0) {
            this.endGroup();
          }
        };
        _proto.has = function has(name) {
          return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
        };
        _proto.get = function get(name) {
          if (this.current.hasOwnProperty(name)) {
            return this.current[name];
          } else {
            return this.builtins[name];
          }
        };
        _proto.set = function set(name, value, global2) {
          if (global2 === void 0) {
            global2 = false;
          }
          if (global2) {
            for (var i3 = 0; i3 < this.undefStack.length; i3++) {
              delete this.undefStack[i3][name];
            }
            if (this.undefStack.length > 0) {
              this.undefStack[this.undefStack.length - 1][name] = value;
            }
          } else {
            var top = this.undefStack[this.undefStack.length - 1];
            if (top && !top.hasOwnProperty(name)) {
              top[name] = this.current[name];
            }
          }
          if (value == null) {
            delete this.current[name];
          } else {
            this.current[name] = value;
          }
        };
        return Namespace2;
      }();
      var macros = _macros;
      var src_macros = macros;
      defineMacro("\\noexpand", function(context) {
        var t2 = context.popToken();
        if (context.isExpandable(t2.text)) {
          t2.noexpand = true;
          t2.treatAsRelax = true;
        }
        return {
          tokens: [t2],
          numArgs: 0
        };
      });
      defineMacro("\\expandafter", function(context) {
        var t2 = context.popToken();
        context.expandOnce(true);
        return {
          tokens: [t2],
          numArgs: 0
        };
      });
      defineMacro("\\@firstoftwo", function(context) {
        var args = context.consumeArgs(2);
        return {
          tokens: args[0],
          numArgs: 0
        };
      });
      defineMacro("\\@secondoftwo", function(context) {
        var args = context.consumeArgs(2);
        return {
          tokens: args[1],
          numArgs: 0
        };
      });
      defineMacro("\\@ifnextchar", function(context) {
        var args = context.consumeArgs(3);
        context.consumeSpaces();
        var nextToken = context.future();
        if (args[0].length === 1 && args[0][0].text === nextToken.text) {
          return {
            tokens: args[1],
            numArgs: 0
          };
        } else {
          return {
            tokens: args[2],
            numArgs: 0
          };
        }
      });
      defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
      defineMacro("\\TextOrMath", function(context) {
        var args = context.consumeArgs(2);
        if (context.mode === "text") {
          return {
            tokens: args[0],
            numArgs: 0
          };
        } else {
          return {
            tokens: args[1],
            numArgs: 0
          };
        }
      });
      var digitToNumber = {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "a": 10,
        "A": 10,
        "b": 11,
        "B": 11,
        "c": 12,
        "C": 12,
        "d": 13,
        "D": 13,
        "e": 14,
        "E": 14,
        "f": 15,
        "F": 15
      };
      defineMacro("\\char", function(context) {
        var token = context.popToken();
        var base;
        var number = "";
        if (token.text === "'") {
          base = 8;
          token = context.popToken();
        } else if (token.text === '"') {
          base = 16;
          token = context.popToken();
        } else if (token.text === "`") {
          token = context.popToken();
          if (token.text[0] === "\\") {
            number = token.text.charCodeAt(1);
          } else if (token.text === "EOF") {
            throw new src_ParseError("\\char` missing argument");
          } else {
            number = token.text.charCodeAt(0);
          }
        } else {
          base = 10;
        }
        if (base) {
          number = digitToNumber[token.text];
          if (number == null || number >= base) {
            throw new src_ParseError("Invalid base-" + base + " digit " + token.text);
          }
          var digit;
          while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
            number *= base;
            number += digit;
            context.popToken();
          }
        }
        return "\\@char{" + number + "}";
      });
      var newcommand = function newcommand2(context, existsOK, nonexistsOK) {
        var arg = context.consumeArg().tokens;
        if (arg.length !== 1) {
          throw new src_ParseError("\\newcommand's first argument must be a macro name");
        }
        var name = arg[0].text;
        var exists = context.isDefined(name);
        if (exists && !existsOK) {
          throw new src_ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
        }
        if (!exists && !nonexistsOK) {
          throw new src_ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
        }
        var numArgs = 0;
        arg = context.consumeArg().tokens;
        if (arg.length === 1 && arg[0].text === "[") {
          var argText = "";
          var token = context.expandNextToken();
          while (token.text !== "]" && token.text !== "EOF") {
            argText += token.text;
            token = context.expandNextToken();
          }
          if (!argText.match(/^\s*[0-9]+\s*$/)) {
            throw new src_ParseError("Invalid number of arguments: " + argText);
          }
          numArgs = parseInt(argText);
          arg = context.consumeArg().tokens;
        }
        context.macros.set(name, {
          tokens: arg,
          numArgs
        });
        return "";
      };
      defineMacro("\\newcommand", function(context) {
        return newcommand(context, false, true);
      });
      defineMacro("\\renewcommand", function(context) {
        return newcommand(context, true, false);
      });
      defineMacro("\\providecommand", function(context) {
        return newcommand(context, true, true);
      });
      defineMacro("\\message", function(context) {
        var arg = context.consumeArgs(1)[0];
        console.log(arg.reverse().map(function(token) {
          return token.text;
        }).join(""));
        return "";
      });
      defineMacro("\\errmessage", function(context) {
        var arg = context.consumeArgs(1)[0];
        console.error(arg.reverse().map(function(token) {
          return token.text;
        }).join(""));
        return "";
      });
      defineMacro("\\show", function(context) {
        var tok = context.popToken();
        var name = tok.text;
        console.log(tok, context.macros.get(name), src_functions[name], src_symbols.math[name], src_symbols.text[name]);
        return "";
      });
      defineMacro("\\bgroup", "{");
      defineMacro("\\egroup", "}");
      defineMacro("~", "\\nobreakspace");
      defineMacro("\\lq", "`");
      defineMacro("\\rq", "'");
      defineMacro("\\aa", "\\r a");
      defineMacro("\\AA", "\\r A");
      defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
      defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
      defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
      defineMacro("\u212C", "\\mathscr{B}");
      defineMacro("\u2130", "\\mathscr{E}");
      defineMacro("\u2131", "\\mathscr{F}");
      defineMacro("\u210B", "\\mathscr{H}");
      defineMacro("\u2110", "\\mathscr{I}");
      defineMacro("\u2112", "\\mathscr{L}");
      defineMacro("\u2133", "\\mathscr{M}");
      defineMacro("\u211B", "\\mathscr{R}");
      defineMacro("\u212D", "\\mathfrak{C}");
      defineMacro("\u210C", "\\mathfrak{H}");
      defineMacro("\u2128", "\\mathfrak{Z}");
      defineMacro("\\Bbbk", "\\Bbb{k}");
      defineMacro("\xB7", "\\cdotp");
      defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
      defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
      defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
      defineMacro("\\mathstrut", "\\vphantom{(}");
      defineMacro("\\underbar", "\\underline{\\text{#1}}");
      defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
      defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
      defineMacro("\\ne", "\\neq");
      defineMacro("\u2260", "\\neq");
      defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
      defineMacro("\u2209", "\\notin");
      defineMacro("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
      defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
      defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
      defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
      defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
      defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
      defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
      defineMacro("\u27C2", "\\perp");
      defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
      defineMacro("\u220C", "\\notni");
      defineMacro("\u231C", "\\ulcorner");
      defineMacro("\u231D", "\\urcorner");
      defineMacro("\u231E", "\\llcorner");
      defineMacro("\u231F", "\\lrcorner");
      defineMacro("\xA9", "\\copyright");
      defineMacro("\xAE", "\\textregistered");
      defineMacro("\uFE0F", "\\textregistered");
      defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
      defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
      defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
      defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
      defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
      defineMacro("\u22EE", "\\vdots");
      defineMacro("\\varGamma", "\\mathit{\\Gamma}");
      defineMacro("\\varDelta", "\\mathit{\\Delta}");
      defineMacro("\\varTheta", "\\mathit{\\Theta}");
      defineMacro("\\varLambda", "\\mathit{\\Lambda}");
      defineMacro("\\varXi", "\\mathit{\\Xi}");
      defineMacro("\\varPi", "\\mathit{\\Pi}");
      defineMacro("\\varSigma", "\\mathit{\\Sigma}");
      defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
      defineMacro("\\varPhi", "\\mathit{\\Phi}");
      defineMacro("\\varPsi", "\\mathit{\\Psi}");
      defineMacro("\\varOmega", "\\mathit{\\Omega}");
      defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
      defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
      defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
      defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
      defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
      defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
      var dotsByToken = {
        ",": "\\dotsc",
        "\\not": "\\dotsb",
        "+": "\\dotsb",
        "=": "\\dotsb",
        "<": "\\dotsb",
        ">": "\\dotsb",
        "-": "\\dotsb",
        "*": "\\dotsb",
        ":": "\\dotsb",
        "\\DOTSB": "\\dotsb",
        "\\coprod": "\\dotsb",
        "\\bigvee": "\\dotsb",
        "\\bigwedge": "\\dotsb",
        "\\biguplus": "\\dotsb",
        "\\bigcap": "\\dotsb",
        "\\bigcup": "\\dotsb",
        "\\prod": "\\dotsb",
        "\\sum": "\\dotsb",
        "\\bigotimes": "\\dotsb",
        "\\bigoplus": "\\dotsb",
        "\\bigodot": "\\dotsb",
        "\\bigsqcup": "\\dotsb",
        "\\And": "\\dotsb",
        "\\longrightarrow": "\\dotsb",
        "\\Longrightarrow": "\\dotsb",
        "\\longleftarrow": "\\dotsb",
        "\\Longleftarrow": "\\dotsb",
        "\\longleftrightarrow": "\\dotsb",
        "\\Longleftrightarrow": "\\dotsb",
        "\\mapsto": "\\dotsb",
        "\\longmapsto": "\\dotsb",
        "\\hookrightarrow": "\\dotsb",
        "\\doteq": "\\dotsb",
        "\\mathbin": "\\dotsb",
        "\\mathrel": "\\dotsb",
        "\\relbar": "\\dotsb",
        "\\Relbar": "\\dotsb",
        "\\xrightarrow": "\\dotsb",
        "\\xleftarrow": "\\dotsb",
        "\\DOTSI": "\\dotsi",
        "\\int": "\\dotsi",
        "\\oint": "\\dotsi",
        "\\iint": "\\dotsi",
        "\\iiint": "\\dotsi",
        "\\iiiint": "\\dotsi",
        "\\idotsint": "\\dotsi",
        "\\DOTSX": "\\dotsx"
      };
      defineMacro("\\dots", function(context) {
        var thedots = "\\dotso";
        var next = context.expandAfterFuture().text;
        if (next in dotsByToken) {
          thedots = dotsByToken[next];
        } else if (next.slice(0, 4) === "\\not") {
          thedots = "\\dotsb";
        } else if (next in src_symbols.math) {
          if (utils.contains(["bin", "rel"], src_symbols.math[next].group)) {
            thedots = "\\dotsb";
          }
        }
        return thedots;
      });
      var spaceAfterDots = {
        ")": true,
        "]": true,
        "\\rbrack": true,
        "\\}": true,
        "\\rbrace": true,
        "\\rangle": true,
        "\\rceil": true,
        "\\rfloor": true,
        "\\rgroup": true,
        "\\rmoustache": true,
        "\\right": true,
        "\\bigr": true,
        "\\biggr": true,
        "\\Bigr": true,
        "\\Biggr": true,
        "$": true,
        ";": true,
        ".": true,
        ",": true
      };
      defineMacro("\\dotso", function(context) {
        var next = context.future().text;
        if (next in spaceAfterDots) {
          return "\\ldots\\,";
        } else {
          return "\\ldots";
        }
      });
      defineMacro("\\dotsc", function(context) {
        var next = context.future().text;
        if (next in spaceAfterDots && next !== ",") {
          return "\\ldots\\,";
        } else {
          return "\\ldots";
        }
      });
      defineMacro("\\cdots", function(context) {
        var next = context.future().text;
        if (next in spaceAfterDots) {
          return "\\@cdots\\,";
        } else {
          return "\\@cdots";
        }
      });
      defineMacro("\\dotsb", "\\cdots");
      defineMacro("\\dotsm", "\\cdots");
      defineMacro("\\dotsi", "\\!\\cdots");
      defineMacro("\\dotsx", "\\ldots\\,");
      defineMacro("\\DOTSI", "\\relax");
      defineMacro("\\DOTSB", "\\relax");
      defineMacro("\\DOTSX", "\\relax");
      defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
      defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
      defineMacro("\\thinspace", "\\,");
      defineMacro("\\>", "\\mskip{4mu}");
      defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
      defineMacro("\\medspace", "\\:");
      defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
      defineMacro("\\thickspace", "\\;");
      defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
      defineMacro("\\negthinspace", "\\!");
      defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
      defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
      defineMacro("\\enspace", "\\kern.5em ");
      defineMacro("\\enskip", "\\hskip.5em\\relax");
      defineMacro("\\quad", "\\hskip1em\\relax");
      defineMacro("\\qquad", "\\hskip2em\\relax");
      defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
      defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
      defineMacro("\\tag@literal", function(context) {
        if (context.macros.get("\\df@tag")) {
          throw new src_ParseError("Multiple \\tag");
        }
        return "\\gdef\\df@tag{\\text{#1}}";
      });
      defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
      defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
      defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
      defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
      defineMacro("\\newline", "\\\\\\relax");
      defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
      var latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
      defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
      defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
      defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
      defineMacro("\\@hspace", "\\hskip #1\\relax");
      defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
      defineMacro("\\ordinarycolon", ":");
      defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
      defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
      defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
      defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
      defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
      defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
      defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
      defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
      defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
      defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
      defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
      defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
      defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
      defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
      defineMacro("\u2237", "\\dblcolon");
      defineMacro("\u2239", "\\eqcolon");
      defineMacro("\u2254", "\\coloneqq");
      defineMacro("\u2255", "\\eqqcolon");
      defineMacro("\u2A74", "\\Coloneqq");
      defineMacro("\\ratio", "\\vcentcolon");
      defineMacro("\\coloncolon", "\\dblcolon");
      defineMacro("\\colonequals", "\\coloneqq");
      defineMacro("\\coloncolonequals", "\\Coloneqq");
      defineMacro("\\equalscolon", "\\eqqcolon");
      defineMacro("\\equalscoloncolon", "\\Eqqcolon");
      defineMacro("\\colonminus", "\\coloneq");
      defineMacro("\\coloncolonminus", "\\Coloneq");
      defineMacro("\\minuscolon", "\\eqcolon");
      defineMacro("\\minuscoloncolon", "\\Eqcolon");
      defineMacro("\\coloncolonapprox", "\\Colonapprox");
      defineMacro("\\coloncolonsim", "\\Colonsim");
      defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
      defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
      defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
      defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
      defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
      defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
      defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
      defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
      defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
      defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
      defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
      defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
      defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
      defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
      defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
      defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
      defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
      defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
      defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
      defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
      defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
      defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
      defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
      defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
      defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
      defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
      defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
      defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
      defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
      defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
      defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
      defineMacro("\u27E6", "\\llbracket");
      defineMacro("\u27E7", "\\rrbracket");
      defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
      defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
      defineMacro("\u2983", "\\lBrace");
      defineMacro("\u2984", "\\rBrace");
      defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
      defineMacro("\u29B5", "\\minuso");
      defineMacro("\\darr", "\\downarrow");
      defineMacro("\\dArr", "\\Downarrow");
      defineMacro("\\Darr", "\\Downarrow");
      defineMacro("\\lang", "\\langle");
      defineMacro("\\rang", "\\rangle");
      defineMacro("\\uarr", "\\uparrow");
      defineMacro("\\uArr", "\\Uparrow");
      defineMacro("\\Uarr", "\\Uparrow");
      defineMacro("\\N", "\\mathbb{N}");
      defineMacro("\\R", "\\mathbb{R}");
      defineMacro("\\Z", "\\mathbb{Z}");
      defineMacro("\\alef", "\\aleph");
      defineMacro("\\alefsym", "\\aleph");
      defineMacro("\\Alpha", "\\mathrm{A}");
      defineMacro("\\Beta", "\\mathrm{B}");
      defineMacro("\\bull", "\\bullet");
      defineMacro("\\Chi", "\\mathrm{X}");
      defineMacro("\\clubs", "\\clubsuit");
      defineMacro("\\cnums", "\\mathbb{C}");
      defineMacro("\\Complex", "\\mathbb{C}");
      defineMacro("\\Dagger", "\\ddagger");
      defineMacro("\\diamonds", "\\diamondsuit");
      defineMacro("\\empty", "\\emptyset");
      defineMacro("\\Epsilon", "\\mathrm{E}");
      defineMacro("\\Eta", "\\mathrm{H}");
      defineMacro("\\exist", "\\exists");
      defineMacro("\\harr", "\\leftrightarrow");
      defineMacro("\\hArr", "\\Leftrightarrow");
      defineMacro("\\Harr", "\\Leftrightarrow");
      defineMacro("\\hearts", "\\heartsuit");
      defineMacro("\\image", "\\Im");
      defineMacro("\\infin", "\\infty");
      defineMacro("\\Iota", "\\mathrm{I}");
      defineMacro("\\isin", "\\in");
      defineMacro("\\Kappa", "\\mathrm{K}");
      defineMacro("\\larr", "\\leftarrow");
      defineMacro("\\lArr", "\\Leftarrow");
      defineMacro("\\Larr", "\\Leftarrow");
      defineMacro("\\lrarr", "\\leftrightarrow");
      defineMacro("\\lrArr", "\\Leftrightarrow");
      defineMacro("\\Lrarr", "\\Leftrightarrow");
      defineMacro("\\Mu", "\\mathrm{M}");
      defineMacro("\\natnums", "\\mathbb{N}");
      defineMacro("\\Nu", "\\mathrm{N}");
      defineMacro("\\Omicron", "\\mathrm{O}");
      defineMacro("\\plusmn", "\\pm");
      defineMacro("\\rarr", "\\rightarrow");
      defineMacro("\\rArr", "\\Rightarrow");
      defineMacro("\\Rarr", "\\Rightarrow");
      defineMacro("\\real", "\\Re");
      defineMacro("\\reals", "\\mathbb{R}");
      defineMacro("\\Reals", "\\mathbb{R}");
      defineMacro("\\Rho", "\\mathrm{P}");
      defineMacro("\\sdot", "\\cdot");
      defineMacro("\\sect", "\\S");
      defineMacro("\\spades", "\\spadesuit");
      defineMacro("\\sub", "\\subset");
      defineMacro("\\sube", "\\subseteq");
      defineMacro("\\supe", "\\supseteq");
      defineMacro("\\Tau", "\\mathrm{T}");
      defineMacro("\\thetasym", "\\vartheta");
      defineMacro("\\weierp", "\\wp");
      defineMacro("\\Zeta", "\\mathrm{Z}");
      defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
      defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
      defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
      defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
      defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
      defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
      defineMacro("\\Bra", "\\left\\langle#1\\right|");
      defineMacro("\\Ket", "\\left|#1\\right\\rangle");
      var braketHelper = function braketHelper2(one) {
        return function(context) {
          var left = context.consumeArg().tokens;
          var middle = context.consumeArg().tokens;
          var middleDouble = context.consumeArg().tokens;
          var right = context.consumeArg().tokens;
          var oldMiddle = context.macros.get("|");
          var oldMiddleDouble = context.macros.get("\\|");
          context.macros.beginGroup();
          var midMacro = function midMacro2(double) {
            return function(context2) {
              if (one) {
                context2.macros.set("|", oldMiddle);
                if (middleDouble.length) {
                  context2.macros.set("\\|", oldMiddleDouble);
                }
              }
              var doubled = double;
              if (!double && middleDouble.length) {
                var nextToken = context2.future();
                if (nextToken.text === "|") {
                  context2.popToken();
                  doubled = true;
                }
              }
              return {
                tokens: doubled ? middleDouble : middle,
                numArgs: 0
              };
            };
          };
          context.macros.set("|", midMacro(false));
          if (middleDouble.length) {
            context.macros.set("\\|", midMacro(true));
          }
          var arg = context.consumeArg().tokens;
          var expanded = context.expandTokens([].concat(right, arg, left));
          context.macros.endGroup();
          return {
            tokens: expanded.reverse(),
            numArgs: 0
          };
        };
      };
      defineMacro("\\bra@ket", braketHelper(false));
      defineMacro("\\bra@set", braketHelper(true));
      defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
      defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
      defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
      defineMacro("\\angln", "{\\angl n}");
      defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
      defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
      defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
      defineMacro("\\red", "\\textcolor{##df0030}{#1}");
      defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
      defineMacro("\\gray", "\\textcolor{gray}{#1}");
      defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
      defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
      defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
      defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
      defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
      defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
      defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
      defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
      defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
      defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
      defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
      defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
      defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
      defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
      defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
      defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
      defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
      defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
      defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
      defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
      defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
      defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
      defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
      defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
      defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
      defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
      defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
      defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
      defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
      defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
      defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
      defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
      defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
      defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
      defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
      defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
      defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
      defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
      defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
      defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
      defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
      defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
      defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
      defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
      defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
      defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
      defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
      defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
      defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
      defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
      var implicitCommands = {
        "^": true,
        "_": true,
        "\\limits": true,
        "\\nolimits": true
      };
      var MacroExpander = function() {
        function MacroExpander2(input, settings, mode) {
          this.settings = void 0;
          this.expansionCount = void 0;
          this.lexer = void 0;
          this.macros = void 0;
          this.stack = void 0;
          this.mode = void 0;
          this.settings = settings;
          this.expansionCount = 0;
          this.feed(input);
          this.macros = new Namespace(src_macros, settings.macros);
          this.mode = mode;
          this.stack = [];
        }
        var _proto = MacroExpander2.prototype;
        _proto.feed = function feed(input) {
          this.lexer = new Lexer(input, this.settings);
        };
        _proto.switchMode = function switchMode(newMode) {
          this.mode = newMode;
        };
        _proto.beginGroup = function beginGroup() {
          this.macros.beginGroup();
        };
        _proto.endGroup = function endGroup() {
          this.macros.endGroup();
        };
        _proto.endGroups = function endGroups() {
          this.macros.endGroups();
        };
        _proto.future = function future() {
          if (this.stack.length === 0) {
            this.pushToken(this.lexer.lex());
          }
          return this.stack[this.stack.length - 1];
        };
        _proto.popToken = function popToken() {
          this.future();
          return this.stack.pop();
        };
        _proto.pushToken = function pushToken(token) {
          this.stack.push(token);
        };
        _proto.pushTokens = function pushTokens(tokens) {
          var _this$stack;
          (_this$stack = this.stack).push.apply(_this$stack, tokens);
        };
        _proto.scanArgument = function scanArgument(isOptional) {
          var start;
          var end;
          var tokens;
          if (isOptional) {
            this.consumeSpaces();
            if (this.future().text !== "[") {
              return null;
            }
            start = this.popToken();
            var _this$consumeArg = this.consumeArg(["]"]);
            tokens = _this$consumeArg.tokens;
            end = _this$consumeArg.end;
          } else {
            var _this$consumeArg2 = this.consumeArg();
            tokens = _this$consumeArg2.tokens;
            start = _this$consumeArg2.start;
            end = _this$consumeArg2.end;
          }
          this.pushToken(new Token2("EOF", end.loc));
          this.pushTokens(tokens);
          return start.range(end, "");
        };
        _proto.consumeSpaces = function consumeSpaces() {
          for (; ; ) {
            var token = this.future();
            if (token.text === " ") {
              this.stack.pop();
            } else {
              break;
            }
          }
        };
        _proto.consumeArg = function consumeArg(delims) {
          var tokens = [];
          var isDelimited = delims && delims.length > 0;
          if (!isDelimited) {
            this.consumeSpaces();
          }
          var start = this.future();
          var tok;
          var depth = 0;
          var match = 0;
          do {
            tok = this.popToken();
            tokens.push(tok);
            if (tok.text === "{") {
              ++depth;
            } else if (tok.text === "}") {
              --depth;
              if (depth === -1) {
                throw new src_ParseError("Extra }", tok);
              }
            } else if (tok.text === "EOF") {
              throw new src_ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
            }
            if (delims && isDelimited) {
              if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
                ++match;
                if (match === delims.length) {
                  tokens.splice(-match, match);
                  break;
                }
              } else {
                match = 0;
              }
            }
          } while (depth !== 0 || isDelimited);
          if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
            tokens.pop();
            tokens.shift();
          }
          tokens.reverse();
          return {
            tokens,
            start,
            end: tok
          };
        };
        _proto.consumeArgs = function consumeArgs(numArgs, delimiters2) {
          if (delimiters2) {
            if (delimiters2.length !== numArgs + 1) {
              throw new src_ParseError("The length of delimiters doesn't match the number of args!");
            }
            var delims = delimiters2[0];
            for (var i3 = 0; i3 < delims.length; i3++) {
              var tok = this.popToken();
              if (delims[i3] !== tok.text) {
                throw new src_ParseError("Use of the macro doesn't match its definition", tok);
              }
            }
          }
          var args = [];
          for (var _i6 = 0; _i6 < numArgs; _i6++) {
            args.push(this.consumeArg(delimiters2 && delimiters2[_i6 + 1]).tokens);
          }
          return args;
        };
        _proto.expandOnce = function expandOnce(expandableOnly) {
          var topToken = this.popToken();
          var name = topToken.text;
          var expansion = !topToken.noexpand ? this._getExpansion(name) : null;
          if (expansion == null || expandableOnly && expansion.unexpandable) {
            if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
              throw new src_ParseError("Undefined control sequence: " + name);
            }
            this.pushToken(topToken);
            return topToken;
          }
          this.expansionCount++;
          if (this.expansionCount > this.settings.maxExpand) {
            throw new src_ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
          }
          var tokens = expansion.tokens;
          var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
          if (expansion.numArgs) {
            tokens = tokens.slice();
            for (var i3 = tokens.length - 1; i3 >= 0; --i3) {
              var tok = tokens[i3];
              if (tok.text === "#") {
                if (i3 === 0) {
                  throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
                }
                tok = tokens[--i3];
                if (tok.text === "#") {
                  tokens.splice(i3 + 1, 1);
                } else if (/^[1-9]$/.test(tok.text)) {
                  var _tokens;
                  (_tokens = tokens).splice.apply(_tokens, [i3, 2].concat(args[+tok.text - 1]));
                } else {
                  throw new src_ParseError("Not a valid argument number", tok);
                }
              }
            }
          }
          this.pushTokens(tokens);
          return tokens;
        };
        _proto.expandAfterFuture = function expandAfterFuture() {
          this.expandOnce();
          return this.future();
        };
        _proto.expandNextToken = function expandNextToken() {
          for (; ; ) {
            var expanded = this.expandOnce();
            if (expanded instanceof Token2) {
              if (expanded.treatAsRelax) {
                expanded.text = "\\relax";
              }
              return this.stack.pop();
            }
          }
          throw new Error();
        };
        _proto.expandMacro = function expandMacro(name) {
          return this.macros.has(name) ? this.expandTokens([new Token2(name)]) : void 0;
        };
        _proto.expandTokens = function expandTokens(tokens) {
          var output = [];
          var oldStackLength = this.stack.length;
          this.pushTokens(tokens);
          while (this.stack.length > oldStackLength) {
            var expanded = this.expandOnce(true);
            if (expanded instanceof Token2) {
              if (expanded.treatAsRelax) {
                expanded.noexpand = false;
                expanded.treatAsRelax = false;
              }
              output.push(this.stack.pop());
            }
          }
          return output;
        };
        _proto.expandMacroAsText = function expandMacroAsText(name) {
          var tokens = this.expandMacro(name);
          if (tokens) {
            return tokens.map(function(token) {
              return token.text;
            }).join("");
          } else {
            return tokens;
          }
        };
        _proto._getExpansion = function _getExpansion(name) {
          var definition = this.macros.get(name);
          if (definition == null) {
            return definition;
          }
          if (name.length === 1) {
            var catcode = this.lexer.catcodes[name];
            if (catcode != null && catcode !== 13) {
              return;
            }
          }
          var expansion = typeof definition === "function" ? definition(this) : definition;
          if (typeof expansion === "string") {
            var numArgs = 0;
            if (expansion.indexOf("#") !== -1) {
              var stripped = expansion.replace(/##/g, "");
              while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                ++numArgs;
              }
            }
            var bodyLexer = new Lexer(expansion, this.settings);
            var tokens = [];
            var tok = bodyLexer.lex();
            while (tok.text !== "EOF") {
              tokens.push(tok);
              tok = bodyLexer.lex();
            }
            tokens.reverse();
            var expanded = {
              tokens,
              numArgs
            };
            return expanded;
          }
          return expansion;
        };
        _proto.isDefined = function isDefined(name) {
          return this.macros.has(name) || src_functions.hasOwnProperty(name) || src_symbols.math.hasOwnProperty(name) || src_symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
        };
        _proto.isExpandable = function isExpandable(name) {
          var macro = this.macros.get(name);
          return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : src_functions.hasOwnProperty(name) && !src_functions[name].primitive;
        };
        return MacroExpander2;
      }();
      var unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;
      var uSubsAndSups = Object.freeze({
        "\u208A": "+",
        "\u208B": "-",
        "\u208C": "=",
        "\u208D": "(",
        "\u208E": ")",
        "\u2080": "0",
        "\u2081": "1",
        "\u2082": "2",
        "\u2083": "3",
        "\u2084": "4",
        "\u2085": "5",
        "\u2086": "6",
        "\u2087": "7",
        "\u2088": "8",
        "\u2089": "9",
        "\u2090": "a",
        "\u2091": "e",
        "\u2095": "h",
        "\u1D62": "i",
        "\u2C7C": "j",
        "\u2096": "k",
        "\u2097": "l",
        "\u2098": "m",
        "\u2099": "n",
        "\u2092": "o",
        "\u209A": "p",
        "\u1D63": "r",
        "\u209B": "s",
        "\u209C": "t",
        "\u1D64": "u",
        "\u1D65": "v",
        "\u2093": "x",
        "\u1D66": "\u03B2",
        "\u1D67": "\u03B3",
        "\u1D68": "\u03C1",
        "\u1D69": "\u03D5",
        "\u1D6A": "\u03C7",
        "\u207A": "+",
        "\u207B": "-",
        "\u207C": "=",
        "\u207D": "(",
        "\u207E": ")",
        "\u2070": "0",
        "\xB9": "1",
        "\xB2": "2",
        "\xB3": "3",
        "\u2074": "4",
        "\u2075": "5",
        "\u2076": "6",
        "\u2077": "7",
        "\u2078": "8",
        "\u2079": "9",
        "\u1D2C": "A",
        "\u1D2E": "B",
        "\u1D30": "D",
        "\u1D31": "E",
        "\u1D33": "G",
        "\u1D34": "H",
        "\u1D35": "I",
        "\u1D36": "J",
        "\u1D37": "K",
        "\u1D38": "L",
        "\u1D39": "M",
        "\u1D3A": "N",
        "\u1D3C": "O",
        "\u1D3E": "P",
        "\u1D3F": "R",
        "\u1D40": "T",
        "\u1D41": "U",
        "\u2C7D": "V",
        "\u1D42": "W",
        "\u1D43": "a",
        "\u1D47": "b",
        "\u1D9C": "c",
        "\u1D48": "d",
        "\u1D49": "e",
        "\u1DA0": "f",
        "\u1D4D": "g",
        "\u02B0": "h",
        "\u2071": "i",
        "\u02B2": "j",
        "\u1D4F": "k",
        "\u02E1": "l",
        "\u1D50": "m",
        "\u207F": "n",
        "\u1D52": "o",
        "\u1D56": "p",
        "\u02B3": "r",
        "\u02E2": "s",
        "\u1D57": "t",
        "\u1D58": "u",
        "\u1D5B": "v",
        "\u02B7": "w",
        "\u02E3": "x",
        "\u02B8": "y",
        "\u1DBB": "z",
        "\u1D5D": "\u03B2",
        "\u1D5E": "\u03B3",
        "\u1D5F": "\u03B4",
        "\u1D60": "\u03D5",
        "\u1D61": "\u03C7",
        "\u1DBF": "\u03B8"
      });
      var unicodeAccents = {
        "\u0301": {
          "text": "\\'",
          "math": "\\acute"
        },
        "\u0300": {
          "text": "\\`",
          "math": "\\grave"
        },
        "\u0308": {
          "text": '\\"',
          "math": "\\ddot"
        },
        "\u0303": {
          "text": "\\~",
          "math": "\\tilde"
        },
        "\u0304": {
          "text": "\\=",
          "math": "\\bar"
        },
        "\u0306": {
          "text": "\\u",
          "math": "\\breve"
        },
        "\u030C": {
          "text": "\\v",
          "math": "\\check"
        },
        "\u0302": {
          "text": "\\^",
          "math": "\\hat"
        },
        "\u0307": {
          "text": "\\.",
          "math": "\\dot"
        },
        "\u030A": {
          "text": "\\r",
          "math": "\\mathring"
        },
        "\u030B": {
          "text": "\\H"
        },
        "\u0327": {
          "text": "\\c"
        }
      };
      var unicodeSymbols = {
        "\xE1": "a\u0301",
        "\xE0": "a\u0300",
        "\xE4": "a\u0308",
        "\u01DF": "a\u0308\u0304",
        "\xE3": "a\u0303",
        "\u0101": "a\u0304",
        "\u0103": "a\u0306",
        "\u1EAF": "a\u0306\u0301",
        "\u1EB1": "a\u0306\u0300",
        "\u1EB5": "a\u0306\u0303",
        "\u01CE": "a\u030C",
        "\xE2": "a\u0302",
        "\u1EA5": "a\u0302\u0301",
        "\u1EA7": "a\u0302\u0300",
        "\u1EAB": "a\u0302\u0303",
        "\u0227": "a\u0307",
        "\u01E1": "a\u0307\u0304",
        "\xE5": "a\u030A",
        "\u01FB": "a\u030A\u0301",
        "\u1E03": "b\u0307",
        "\u0107": "c\u0301",
        "\u1E09": "c\u0327\u0301",
        "\u010D": "c\u030C",
        "\u0109": "c\u0302",
        "\u010B": "c\u0307",
        "\xE7": "c\u0327",
        "\u010F": "d\u030C",
        "\u1E0B": "d\u0307",
        "\u1E11": "d\u0327",
        "\xE9": "e\u0301",
        "\xE8": "e\u0300",
        "\xEB": "e\u0308",
        "\u1EBD": "e\u0303",
        "\u0113": "e\u0304",
        "\u1E17": "e\u0304\u0301",
        "\u1E15": "e\u0304\u0300",
        "\u0115": "e\u0306",
        "\u1E1D": "e\u0327\u0306",
        "\u011B": "e\u030C",
        "\xEA": "e\u0302",
        "\u1EBF": "e\u0302\u0301",
        "\u1EC1": "e\u0302\u0300",
        "\u1EC5": "e\u0302\u0303",
        "\u0117": "e\u0307",
        "\u0229": "e\u0327",
        "\u1E1F": "f\u0307",
        "\u01F5": "g\u0301",
        "\u1E21": "g\u0304",
        "\u011F": "g\u0306",
        "\u01E7": "g\u030C",
        "\u011D": "g\u0302",
        "\u0121": "g\u0307",
        "\u0123": "g\u0327",
        "\u1E27": "h\u0308",
        "\u021F": "h\u030C",
        "\u0125": "h\u0302",
        "\u1E23": "h\u0307",
        "\u1E29": "h\u0327",
        "\xED": "i\u0301",
        "\xEC": "i\u0300",
        "\xEF": "i\u0308",
        "\u1E2F": "i\u0308\u0301",
        "\u0129": "i\u0303",
        "\u012B": "i\u0304",
        "\u012D": "i\u0306",
        "\u01D0": "i\u030C",
        "\xEE": "i\u0302",
        "\u01F0": "j\u030C",
        "\u0135": "j\u0302",
        "\u1E31": "k\u0301",
        "\u01E9": "k\u030C",
        "\u0137": "k\u0327",
        "\u013A": "l\u0301",
        "\u013E": "l\u030C",
        "\u013C": "l\u0327",
        "\u1E3F": "m\u0301",
        "\u1E41": "m\u0307",
        "\u0144": "n\u0301",
        "\u01F9": "n\u0300",
        "\xF1": "n\u0303",
        "\u0148": "n\u030C",
        "\u1E45": "n\u0307",
        "\u0146": "n\u0327",
        "\xF3": "o\u0301",
        "\xF2": "o\u0300",
        "\xF6": "o\u0308",
        "\u022B": "o\u0308\u0304",
        "\xF5": "o\u0303",
        "\u1E4D": "o\u0303\u0301",
        "\u1E4F": "o\u0303\u0308",
        "\u022D": "o\u0303\u0304",
        "\u014D": "o\u0304",
        "\u1E53": "o\u0304\u0301",
        "\u1E51": "o\u0304\u0300",
        "\u014F": "o\u0306",
        "\u01D2": "o\u030C",
        "\xF4": "o\u0302",
        "\u1ED1": "o\u0302\u0301",
        "\u1ED3": "o\u0302\u0300",
        "\u1ED7": "o\u0302\u0303",
        "\u022F": "o\u0307",
        "\u0231": "o\u0307\u0304",
        "\u0151": "o\u030B",
        "\u1E55": "p\u0301",
        "\u1E57": "p\u0307",
        "\u0155": "r\u0301",
        "\u0159": "r\u030C",
        "\u1E59": "r\u0307",
        "\u0157": "r\u0327",
        "\u015B": "s\u0301",
        "\u1E65": "s\u0301\u0307",
        "\u0161": "s\u030C",
        "\u1E67": "s\u030C\u0307",
        "\u015D": "s\u0302",
        "\u1E61": "s\u0307",
        "\u015F": "s\u0327",
        "\u1E97": "t\u0308",
        "\u0165": "t\u030C",
        "\u1E6B": "t\u0307",
        "\u0163": "t\u0327",
        "\xFA": "u\u0301",
        "\xF9": "u\u0300",
        "\xFC": "u\u0308",
        "\u01D8": "u\u0308\u0301",
        "\u01DC": "u\u0308\u0300",
        "\u01D6": "u\u0308\u0304",
        "\u01DA": "u\u0308\u030C",
        "\u0169": "u\u0303",
        "\u1E79": "u\u0303\u0301",
        "\u016B": "u\u0304",
        "\u1E7B": "u\u0304\u0308",
        "\u016D": "u\u0306",
        "\u01D4": "u\u030C",
        "\xFB": "u\u0302",
        "\u016F": "u\u030A",
        "\u0171": "u\u030B",
        "\u1E7D": "v\u0303",
        "\u1E83": "w\u0301",
        "\u1E81": "w\u0300",
        "\u1E85": "w\u0308",
        "\u0175": "w\u0302",
        "\u1E87": "w\u0307",
        "\u1E98": "w\u030A",
        "\u1E8D": "x\u0308",
        "\u1E8B": "x\u0307",
        "\xFD": "y\u0301",
        "\u1EF3": "y\u0300",
        "\xFF": "y\u0308",
        "\u1EF9": "y\u0303",
        "\u0233": "y\u0304",
        "\u0177": "y\u0302",
        "\u1E8F": "y\u0307",
        "\u1E99": "y\u030A",
        "\u017A": "z\u0301",
        "\u017E": "z\u030C",
        "\u1E91": "z\u0302",
        "\u017C": "z\u0307",
        "\xC1": "A\u0301",
        "\xC0": "A\u0300",
        "\xC4": "A\u0308",
        "\u01DE": "A\u0308\u0304",
        "\xC3": "A\u0303",
        "\u0100": "A\u0304",
        "\u0102": "A\u0306",
        "\u1EAE": "A\u0306\u0301",
        "\u1EB0": "A\u0306\u0300",
        "\u1EB4": "A\u0306\u0303",
        "\u01CD": "A\u030C",
        "\xC2": "A\u0302",
        "\u1EA4": "A\u0302\u0301",
        "\u1EA6": "A\u0302\u0300",
        "\u1EAA": "A\u0302\u0303",
        "\u0226": "A\u0307",
        "\u01E0": "A\u0307\u0304",
        "\xC5": "A\u030A",
        "\u01FA": "A\u030A\u0301",
        "\u1E02": "B\u0307",
        "\u0106": "C\u0301",
        "\u1E08": "C\u0327\u0301",
        "\u010C": "C\u030C",
        "\u0108": "C\u0302",
        "\u010A": "C\u0307",
        "\xC7": "C\u0327",
        "\u010E": "D\u030C",
        "\u1E0A": "D\u0307",
        "\u1E10": "D\u0327",
        "\xC9": "E\u0301",
        "\xC8": "E\u0300",
        "\xCB": "E\u0308",
        "\u1EBC": "E\u0303",
        "\u0112": "E\u0304",
        "\u1E16": "E\u0304\u0301",
        "\u1E14": "E\u0304\u0300",
        "\u0114": "E\u0306",
        "\u1E1C": "E\u0327\u0306",
        "\u011A": "E\u030C",
        "\xCA": "E\u0302",
        "\u1EBE": "E\u0302\u0301",
        "\u1EC0": "E\u0302\u0300",
        "\u1EC4": "E\u0302\u0303",
        "\u0116": "E\u0307",
        "\u0228": "E\u0327",
        "\u1E1E": "F\u0307",
        "\u01F4": "G\u0301",
        "\u1E20": "G\u0304",
        "\u011E": "G\u0306",
        "\u01E6": "G\u030C",
        "\u011C": "G\u0302",
        "\u0120": "G\u0307",
        "\u0122": "G\u0327",
        "\u1E26": "H\u0308",
        "\u021E": "H\u030C",
        "\u0124": "H\u0302",
        "\u1E22": "H\u0307",
        "\u1E28": "H\u0327",
        "\xCD": "I\u0301",
        "\xCC": "I\u0300",
        "\xCF": "I\u0308",
        "\u1E2E": "I\u0308\u0301",
        "\u0128": "I\u0303",
        "\u012A": "I\u0304",
        "\u012C": "I\u0306",
        "\u01CF": "I\u030C",
        "\xCE": "I\u0302",
        "\u0130": "I\u0307",
        "\u0134": "J\u0302",
        "\u1E30": "K\u0301",
        "\u01E8": "K\u030C",
        "\u0136": "K\u0327",
        "\u0139": "L\u0301",
        "\u013D": "L\u030C",
        "\u013B": "L\u0327",
        "\u1E3E": "M\u0301",
        "\u1E40": "M\u0307",
        "\u0143": "N\u0301",
        "\u01F8": "N\u0300",
        "\xD1": "N\u0303",
        "\u0147": "N\u030C",
        "\u1E44": "N\u0307",
        "\u0145": "N\u0327",
        "\xD3": "O\u0301",
        "\xD2": "O\u0300",
        "\xD6": "O\u0308",
        "\u022A": "O\u0308\u0304",
        "\xD5": "O\u0303",
        "\u1E4C": "O\u0303\u0301",
        "\u1E4E": "O\u0303\u0308",
        "\u022C": "O\u0303\u0304",
        "\u014C": "O\u0304",
        "\u1E52": "O\u0304\u0301",
        "\u1E50": "O\u0304\u0300",
        "\u014E": "O\u0306",
        "\u01D1": "O\u030C",
        "\xD4": "O\u0302",
        "\u1ED0": "O\u0302\u0301",
        "\u1ED2": "O\u0302\u0300",
        "\u1ED6": "O\u0302\u0303",
        "\u022E": "O\u0307",
        "\u0230": "O\u0307\u0304",
        "\u0150": "O\u030B",
        "\u1E54": "P\u0301",
        "\u1E56": "P\u0307",
        "\u0154": "R\u0301",
        "\u0158": "R\u030C",
        "\u1E58": "R\u0307",
        "\u0156": "R\u0327",
        "\u015A": "S\u0301",
        "\u1E64": "S\u0301\u0307",
        "\u0160": "S\u030C",
        "\u1E66": "S\u030C\u0307",
        "\u015C": "S\u0302",
        "\u1E60": "S\u0307",
        "\u015E": "S\u0327",
        "\u0164": "T\u030C",
        "\u1E6A": "T\u0307",
        "\u0162": "T\u0327",
        "\xDA": "U\u0301",
        "\xD9": "U\u0300",
        "\xDC": "U\u0308",
        "\u01D7": "U\u0308\u0301",
        "\u01DB": "U\u0308\u0300",
        "\u01D5": "U\u0308\u0304",
        "\u01D9": "U\u0308\u030C",
        "\u0168": "U\u0303",
        "\u1E78": "U\u0303\u0301",
        "\u016A": "U\u0304",
        "\u1E7A": "U\u0304\u0308",
        "\u016C": "U\u0306",
        "\u01D3": "U\u030C",
        "\xDB": "U\u0302",
        "\u016E": "U\u030A",
        "\u0170": "U\u030B",
        "\u1E7C": "V\u0303",
        "\u1E82": "W\u0301",
        "\u1E80": "W\u0300",
        "\u1E84": "W\u0308",
        "\u0174": "W\u0302",
        "\u1E86": "W\u0307",
        "\u1E8C": "X\u0308",
        "\u1E8A": "X\u0307",
        "\xDD": "Y\u0301",
        "\u1EF2": "Y\u0300",
        "\u0178": "Y\u0308",
        "\u1EF8": "Y\u0303",
        "\u0232": "Y\u0304",
        "\u0176": "Y\u0302",
        "\u1E8E": "Y\u0307",
        "\u0179": "Z\u0301",
        "\u017D": "Z\u030C",
        "\u1E90": "Z\u0302",
        "\u017B": "Z\u0307",
        "\u03AC": "\u03B1\u0301",
        "\u1F70": "\u03B1\u0300",
        "\u1FB1": "\u03B1\u0304",
        "\u1FB0": "\u03B1\u0306",
        "\u03AD": "\u03B5\u0301",
        "\u1F72": "\u03B5\u0300",
        "\u03AE": "\u03B7\u0301",
        "\u1F74": "\u03B7\u0300",
        "\u03AF": "\u03B9\u0301",
        "\u1F76": "\u03B9\u0300",
        "\u03CA": "\u03B9\u0308",
        "\u0390": "\u03B9\u0308\u0301",
        "\u1FD2": "\u03B9\u0308\u0300",
        "\u1FD1": "\u03B9\u0304",
        "\u1FD0": "\u03B9\u0306",
        "\u03CC": "\u03BF\u0301",
        "\u1F78": "\u03BF\u0300",
        "\u03CD": "\u03C5\u0301",
        "\u1F7A": "\u03C5\u0300",
        "\u03CB": "\u03C5\u0308",
        "\u03B0": "\u03C5\u0308\u0301",
        "\u1FE2": "\u03C5\u0308\u0300",
        "\u1FE1": "\u03C5\u0304",
        "\u1FE0": "\u03C5\u0306",
        "\u03CE": "\u03C9\u0301",
        "\u1F7C": "\u03C9\u0300",
        "\u038E": "\u03A5\u0301",
        "\u1FEA": "\u03A5\u0300",
        "\u03AB": "\u03A5\u0308",
        "\u1FE9": "\u03A5\u0304",
        "\u1FE8": "\u03A5\u0306",
        "\u038F": "\u03A9\u0301",
        "\u1FFA": "\u03A9\u0300"
      };
      var Parser3 = function() {
        function Parser4(input, settings) {
          this.mode = void 0;
          this.gullet = void 0;
          this.settings = void 0;
          this.leftrightDepth = void 0;
          this.nextToken = void 0;
          this.mode = "math";
          this.gullet = new MacroExpander(input, settings, this.mode);
          this.settings = settings;
          this.leftrightDepth = 0;
        }
        var _proto = Parser4.prototype;
        _proto.expect = function expect(text2, consume) {
          if (consume === void 0) {
            consume = true;
          }
          if (this.fetch().text !== text2) {
            throw new src_ParseError("Expected '" + text2 + "', got '" + this.fetch().text + "'", this.fetch());
          }
          if (consume) {
            this.consume();
          }
        };
        _proto.consume = function consume() {
          this.nextToken = null;
        };
        _proto.fetch = function fetch() {
          if (this.nextToken == null) {
            this.nextToken = this.gullet.expandNextToken();
          }
          return this.nextToken;
        };
        _proto.switchMode = function switchMode(newMode) {
          this.mode = newMode;
          this.gullet.switchMode(newMode);
        };
        _proto.parse = function parse() {
          if (!this.settings.globalGroup) {
            this.gullet.beginGroup();
          }
          if (this.settings.colorIsTextColor) {
            this.gullet.macros.set("\\color", "\\textcolor");
          }
          try {
            var parse2 = this.parseExpression(false);
            this.expect("EOF");
            if (!this.settings.globalGroup) {
              this.gullet.endGroup();
            }
            return parse2;
          } finally {
            this.gullet.endGroups();
          }
        };
        _proto.subparse = function subparse(tokens) {
          var oldToken = this.nextToken;
          this.consume();
          this.gullet.pushToken(new Token2("}"));
          this.gullet.pushTokens(tokens);
          var parse = this.parseExpression(false);
          this.expect("}");
          this.nextToken = oldToken;
          return parse;
        };
        _proto.parseExpression = function parseExpression(breakOnInfix, breakOnTokenText) {
          var body = [];
          while (true) {
            if (this.mode === "math") {
              this.consumeSpaces();
            }
            var lex = this.fetch();
            if (Parser4.endOfExpression.indexOf(lex.text) !== -1) {
              break;
            }
            if (breakOnTokenText && lex.text === breakOnTokenText) {
              break;
            }
            if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
              break;
            }
            var atom = this.parseAtom(breakOnTokenText);
            if (!atom) {
              break;
            } else if (atom.type === "internal") {
              continue;
            }
            body.push(atom);
          }
          if (this.mode === "text") {
            this.formLigatures(body);
          }
          return this.handleInfixNodes(body);
        };
        _proto.handleInfixNodes = function handleInfixNodes(body) {
          var overIndex = -1;
          var funcName;
          for (var i3 = 0; i3 < body.length; i3++) {
            if (body[i3].type === "infix") {
              if (overIndex !== -1) {
                throw new src_ParseError("only one infix operator per group", body[i3].token);
              }
              overIndex = i3;
              funcName = body[i3].replaceWith;
            }
          }
          if (overIndex !== -1 && funcName) {
            var numerNode;
            var denomNode;
            var numerBody = body.slice(0, overIndex);
            var denomBody = body.slice(overIndex + 1);
            if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
              numerNode = numerBody[0];
            } else {
              numerNode = {
                type: "ordgroup",
                mode: this.mode,
                body: numerBody
              };
            }
            if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
              denomNode = denomBody[0];
            } else {
              denomNode = {
                type: "ordgroup",
                mode: this.mode,
                body: denomBody
              };
            }
            var node;
            if (funcName === "\\\\abovefrac") {
              node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
            } else {
              node = this.callFunction(funcName, [numerNode, denomNode], []);
            }
            return [node];
          } else {
            return body;
          }
        };
        _proto.handleSupSubscript = function handleSupSubscript(name) {
          var symbolToken = this.fetch();
          var symbol = symbolToken.text;
          this.consume();
          this.consumeSpaces();
          var group = this.parseGroup(name);
          if (!group) {
            throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
          }
          return group;
        };
        _proto.formatUnsupportedCmd = function formatUnsupportedCmd(text2) {
          var textordArray = [];
          for (var i3 = 0; i3 < text2.length; i3++) {
            textordArray.push({
              type: "textord",
              mode: "text",
              text: text2[i3]
            });
          }
          var textNode = {
            type: "text",
            mode: this.mode,
            body: textordArray
          };
          var colorNode = {
            type: "color",
            mode: this.mode,
            color: this.settings.errorColor,
            body: [textNode]
          };
          return colorNode;
        };
        _proto.parseAtom = function parseAtom(breakOnTokenText) {
          var base = this.parseGroup("atom", breakOnTokenText);
          if (this.mode === "text") {
            return base;
          }
          var superscript;
          var subscript;
          while (true) {
            this.consumeSpaces();
            var lex = this.fetch();
            if (lex.text === "\\limits" || lex.text === "\\nolimits") {
              if (base && base.type === "op") {
                var limits = lex.text === "\\limits";
                base.limits = limits;
                base.alwaysHandleSupSub = true;
              } else if (base && base.type === "operatorname") {
                if (base.alwaysHandleSupSub) {
                  base.limits = lex.text === "\\limits";
                }
              } else {
                throw new src_ParseError("Limit controls must follow a math operator", lex);
              }
              this.consume();
            } else if (lex.text === "^") {
              if (superscript) {
                throw new src_ParseError("Double superscript", lex);
              }
              superscript = this.handleSupSubscript("superscript");
            } else if (lex.text === "_") {
              if (subscript) {
                throw new src_ParseError("Double subscript", lex);
              }
              subscript = this.handleSupSubscript("subscript");
            } else if (lex.text === "'") {
              if (superscript) {
                throw new src_ParseError("Double superscript", lex);
              }
              var prime = {
                type: "textord",
                mode: this.mode,
                text: "\\prime"
              };
              var primes = [prime];
              this.consume();
              while (this.fetch().text === "'") {
                primes.push(prime);
                this.consume();
              }
              if (this.fetch().text === "^") {
                primes.push(this.handleSupSubscript("superscript"));
              }
              superscript = {
                type: "ordgroup",
                mode: this.mode,
                body: primes
              };
            } else if (uSubsAndSups[lex.text]) {
              var str = uSubsAndSups[lex.text];
              var isSub = unicodeSubRegEx.test(lex.text);
              this.consume();
              while (true) {
                var token = this.fetch().text;
                if (!uSubsAndSups[token]) {
                  break;
                }
                if (unicodeSubRegEx.test(token) !== isSub) {
                  break;
                }
                this.consume();
                str += uSubsAndSups[token];
              }
              var body = new Parser4(str, this.settings).parse();
              if (isSub) {
                subscript = {
                  type: "ordgroup",
                  mode: "math",
                  body
                };
              } else {
                superscript = {
                  type: "ordgroup",
                  mode: "math",
                  body
                };
              }
            } else {
              break;
            }
          }
          if (superscript || subscript) {
            return {
              type: "supsub",
              mode: this.mode,
              base,
              sup: superscript,
              sub: subscript
            };
          } else {
            return base;
          }
        };
        _proto.parseFunction = function parseFunction(breakOnTokenText, name) {
          var token = this.fetch();
          var func = token.text;
          var funcData = src_functions[func];
          if (!funcData) {
            return null;
          }
          this.consume();
          if (name && name !== "atom" && !funcData.allowedInArgument) {
            throw new src_ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
          } else if (this.mode === "text" && !funcData.allowedInText) {
            throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
          } else if (this.mode === "math" && funcData.allowedInMath === false) {
            throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
          }
          var _this$parseArguments = this.parseArguments(func, funcData), args = _this$parseArguments.args, optArgs = _this$parseArguments.optArgs;
          return this.callFunction(func, args, optArgs, token, breakOnTokenText);
        };
        _proto.callFunction = function callFunction(name, args, optArgs, token, breakOnTokenText) {
          var context = {
            funcName: name,
            parser: this,
            token,
            breakOnTokenText
          };
          var func = src_functions[name];
          if (func && func.handler) {
            return func.handler(context, args, optArgs);
          } else {
            throw new src_ParseError("No function handler for " + name);
          }
        };
        _proto.parseArguments = function parseArguments(func, funcData) {
          var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
          if (totalArgs === 0) {
            return {
              args: [],
              optArgs: []
            };
          }
          var args = [];
          var optArgs = [];
          for (var i3 = 0; i3 < totalArgs; i3++) {
            var argType = funcData.argTypes && funcData.argTypes[i3];
            var isOptional = i3 < funcData.numOptionalArgs;
            if (funcData.primitive && argType == null || funcData.type === "sqrt" && i3 === 1 && optArgs[0] == null) {
              argType = "primitive";
            }
            var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
            if (isOptional) {
              optArgs.push(arg);
            } else if (arg != null) {
              args.push(arg);
            } else {
              throw new src_ParseError("Null argument, please report this as a bug");
            }
          }
          return {
            args,
            optArgs
          };
        };
        _proto.parseGroupOfType = function parseGroupOfType(name, type, optional) {
          switch (type) {
            case "color":
              return this.parseColorGroup(optional);
            case "size":
              return this.parseSizeGroup(optional);
            case "url":
              return this.parseUrlGroup(optional);
            case "math":
            case "text":
              return this.parseArgumentGroup(optional, type);
            case "hbox": {
              var group = this.parseArgumentGroup(optional, "text");
              return group != null ? {
                type: "styling",
                mode: group.mode,
                body: [group],
                style: "text"
              } : null;
            }
            case "raw": {
              var token = this.parseStringGroup("raw", optional);
              return token != null ? {
                type: "raw",
                mode: "text",
                string: token.text
              } : null;
            }
            case "primitive": {
              if (optional) {
                throw new src_ParseError("A primitive argument cannot be optional");
              }
              var _group = this.parseGroup(name);
              if (_group == null) {
                throw new src_ParseError("Expected group as " + name, this.fetch());
              }
              return _group;
            }
            case "original":
            case null:
            case void 0:
              return this.parseArgumentGroup(optional);
            default:
              throw new src_ParseError("Unknown group type as " + name, this.fetch());
          }
        };
        _proto.consumeSpaces = function consumeSpaces() {
          while (this.fetch().text === " ") {
            this.consume();
          }
        };
        _proto.parseStringGroup = function parseStringGroup(modeName, optional) {
          var argToken = this.gullet.scanArgument(optional);
          if (argToken == null) {
            return null;
          }
          var str = "";
          var nextToken;
          while ((nextToken = this.fetch()).text !== "EOF") {
            str += nextToken.text;
            this.consume();
          }
          this.consume();
          argToken.text = str;
          return argToken;
        };
        _proto.parseRegexGroup = function parseRegexGroup(regex, modeName) {
          var firstToken = this.fetch();
          var lastToken = firstToken;
          var str = "";
          var nextToken;
          while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
            lastToken = nextToken;
            str += lastToken.text;
            this.consume();
          }
          if (str === "") {
            throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
          }
          return firstToken.range(lastToken, str);
        };
        _proto.parseColorGroup = function parseColorGroup(optional) {
          var res = this.parseStringGroup("color", optional);
          if (res == null) {
            return null;
          }
          var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
          if (!match) {
            throw new src_ParseError("Invalid color: '" + res.text + "'", res);
          }
          var color = match[0];
          if (/^[0-9a-f]{6}$/i.test(color)) {
            color = "#" + color;
          }
          return {
            type: "color-token",
            mode: this.mode,
            color
          };
        };
        _proto.parseSizeGroup = function parseSizeGroup(optional) {
          var res;
          var isBlank = false;
          this.gullet.consumeSpaces();
          if (!optional && this.gullet.future().text !== "{") {
            res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
          } else {
            res = this.parseStringGroup("size", optional);
          }
          if (!res) {
            return null;
          }
          if (!optional && res.text.length === 0) {
            res.text = "0pt";
            isBlank = true;
          }
          var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
          if (!match) {
            throw new src_ParseError("Invalid size: '" + res.text + "'", res);
          }
          var data = {
            number: +(match[1] + match[2]),
            unit: match[3]
          };
          if (!validUnit(data)) {
            throw new src_ParseError("Invalid unit: '" + data.unit + "'", res);
          }
          return {
            type: "size",
            mode: this.mode,
            value: data,
            isBlank
          };
        };
        _proto.parseUrlGroup = function parseUrlGroup(optional) {
          this.gullet.lexer.setCatcode("%", 13);
          this.gullet.lexer.setCatcode("~", 12);
          var res = this.parseStringGroup("url", optional);
          this.gullet.lexer.setCatcode("%", 14);
          this.gullet.lexer.setCatcode("~", 13);
          if (res == null) {
            return null;
          }
          var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
          return {
            type: "url",
            mode: this.mode,
            url
          };
        };
        _proto.parseArgumentGroup = function parseArgumentGroup(optional, mode) {
          var argToken = this.gullet.scanArgument(optional);
          if (argToken == null) {
            return null;
          }
          var outerMode = this.mode;
          if (mode) {
            this.switchMode(mode);
          }
          this.gullet.beginGroup();
          var expression = this.parseExpression(false, "EOF");
          this.expect("EOF");
          this.gullet.endGroup();
          var result = {
            type: "ordgroup",
            mode: this.mode,
            loc: argToken.loc,
            body: expression
          };
          if (mode) {
            this.switchMode(outerMode);
          }
          return result;
        };
        _proto.parseGroup = function parseGroup(name, breakOnTokenText) {
          var firstToken = this.fetch();
          var text2 = firstToken.text;
          var result;
          if (text2 === "{" || text2 === "\\begingroup") {
            this.consume();
            var groupEnd = text2 === "{" ? "}" : "\\endgroup";
            this.gullet.beginGroup();
            var expression = this.parseExpression(false, groupEnd);
            var lastToken = this.fetch();
            this.expect(groupEnd);
            this.gullet.endGroup();
            result = {
              type: "ordgroup",
              mode: this.mode,
              loc: SourceLocation.range(firstToken, lastToken),
              body: expression,
              semisimple: text2 === "\\begingroup" || void 0
            };
          } else {
            result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
            if (result == null && text2[0] === "\\" && !implicitCommands.hasOwnProperty(text2)) {
              if (this.settings.throwOnError) {
                throw new src_ParseError("Undefined control sequence: " + text2, firstToken);
              }
              result = this.formatUnsupportedCmd(text2);
              this.consume();
            }
          }
          return result;
        };
        _proto.formLigatures = function formLigatures(group) {
          var n2 = group.length - 1;
          for (var i3 = 0; i3 < n2; ++i3) {
            var a2 = group[i3];
            var v2 = a2.text;
            if (v2 === "-" && group[i3 + 1].text === "-") {
              if (i3 + 1 < n2 && group[i3 + 2].text === "-") {
                group.splice(i3, 3, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a2, group[i3 + 2]),
                  text: "---"
                });
                n2 -= 2;
              } else {
                group.splice(i3, 2, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a2, group[i3 + 1]),
                  text: "--"
                });
                n2 -= 1;
              }
            }
            if ((v2 === "'" || v2 === "`") && group[i3 + 1].text === v2) {
              group.splice(i3, 2, {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(a2, group[i3 + 1]),
                text: v2 + v2
              });
              n2 -= 1;
            }
          }
        };
        _proto.parseSymbol = function parseSymbol() {
          var nucleus = this.fetch();
          var text2 = nucleus.text;
          if (/^\\verb[^a-zA-Z]/.test(text2)) {
            this.consume();
            var arg = text2.slice(5);
            var star = arg.charAt(0) === "*";
            if (star) {
              arg = arg.slice(1);
            }
            if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
              throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
            }
            arg = arg.slice(1, -1);
            return {
              type: "verb",
              mode: "text",
              body: arg,
              star
            };
          }
          if (unicodeSymbols.hasOwnProperty(text2[0]) && !src_symbols[this.mode][text2[0]]) {
            if (this.settings.strict && this.mode === "math") {
              this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text2[0] + '" used in math mode', nucleus);
            }
            text2 = unicodeSymbols[text2[0]] + text2.slice(1);
          }
          var match = combiningDiacriticalMarksEndRegex.exec(text2);
          if (match) {
            text2 = text2.substring(0, match.index);
            if (text2 === "i") {
              text2 = "\u0131";
            } else if (text2 === "j") {
              text2 = "\u0237";
            }
          }
          var symbol;
          if (src_symbols[this.mode][text2]) {
            if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text2) >= 0) {
              this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text2[0] + '" used in math mode', nucleus);
            }
            var group = src_symbols[this.mode][text2].group;
            var loc = SourceLocation.range(nucleus);
            var s2;
            if (ATOMS.hasOwnProperty(group)) {
              var family = group;
              s2 = {
                type: "atom",
                mode: this.mode,
                family,
                loc,
                text: text2
              };
            } else {
              s2 = {
                type: group,
                mode: this.mode,
                loc,
                text: text2
              };
            }
            symbol = s2;
          } else if (text2.charCodeAt(0) >= 128) {
            if (this.settings.strict) {
              if (!supportedCodepoint(text2.charCodeAt(0))) {
                this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text2[0] + '"' + (" (" + text2.charCodeAt(0) + ")"), nucleus);
              } else if (this.mode === "math") {
                this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text2[0] + '" used in math mode', nucleus);
              }
            }
            symbol = {
              type: "textord",
              mode: "text",
              loc: SourceLocation.range(nucleus),
              text: text2
            };
          } else {
            return null;
          }
          this.consume();
          if (match) {
            for (var i3 = 0; i3 < match[0].length; i3++) {
              var accent2 = match[0][i3];
              if (!unicodeAccents[accent2]) {
                throw new src_ParseError("Unknown accent ' " + accent2 + "'", nucleus);
              }
              var command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
              if (!command) {
                throw new src_ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
              }
              symbol = {
                type: "accent",
                mode: this.mode,
                loc: SourceLocation.range(nucleus),
                label: command,
                isStretchy: false,
                isShifty: true,
                base: symbol
              };
            }
          }
          return symbol;
        };
        return Parser4;
      }();
      Parser3.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
      var parseTree = function parseTree2(toParse, settings) {
        if (!(typeof toParse === "string" || toParse instanceof String)) {
          throw new TypeError("KaTeX can only parse string typed expression");
        }
        var parser = new Parser3(toParse, settings);
        delete parser.gullet.macros.current["\\df@tag"];
        var tree = parser.parse();
        delete parser.gullet.macros.current["\\current@color"];
        delete parser.gullet.macros.current["\\color"];
        if (parser.gullet.macros.get("\\df@tag")) {
          if (!settings.displayMode) {
            throw new src_ParseError("\\tag works only in display equations");
          }
          tree = [{
            type: "tag",
            mode: "text",
            body: tree,
            tag: parser.subparse([new Token2("\\df@tag")])
          }];
        }
        return tree;
      };
      var src_parseTree = parseTree;
      var render = function render2(expression, baseNode, options) {
        baseNode.textContent = "";
        var node = renderToDomTree(expression, options).toNode();
        baseNode.appendChild(node);
      };
      if (typeof document !== "undefined") {
        if (document.compatMode !== "CSS1Compat") {
          typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
          render = function render2() {
            throw new src_ParseError("KaTeX doesn't work in quirks mode.");
          };
        }
      }
      var renderToString = function renderToString2(expression, options) {
        var markup = renderToDomTree(expression, options).toMarkup();
        return markup;
      };
      var generateParseTree = function generateParseTree2(expression, options) {
        var settings = new Settings(options);
        return src_parseTree(expression, settings);
      };
      var renderError = function renderError2(error, expression, options) {
        if (options.throwOnError || !(error instanceof src_ParseError)) {
          throw error;
        }
        var node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
        node.setAttribute("title", error.toString());
        node.setAttribute("style", "color:" + options.errorColor);
        return node;
      };
      var renderToDomTree = function renderToDomTree2(expression, options) {
        var settings = new Settings(options);
        try {
          var tree = src_parseTree(expression, settings);
          return buildTree(tree, expression, settings);
        } catch (error) {
          return renderError(error, expression, settings);
        }
      };
      var renderToHTMLTree = function renderToHTMLTree2(expression, options) {
        var settings = new Settings(options);
        try {
          var tree = src_parseTree(expression, settings);
          return buildHTMLTree(tree, expression, settings);
        } catch (error) {
          return renderError(error, expression, settings);
        }
      };
      var katex2 = {
        version: "0.16.3",
        render,
        renderToString,
        ParseError: src_ParseError,
        SETTINGS_SCHEMA,
        __parse: generateParseTree,
        __renderToDomTree: renderToDomTree,
        __renderToHTMLTree: renderToHTMLTree,
        __setFontMetrics: setFontMetrics,
        __defineSymbol: defineSymbol,
        __defineMacro: defineMacro,
        __domTree: {
          Span,
          Anchor,
          SymbolNode,
          SvgNode,
          PathNode,
          LineNode
        }
      };
      var katex_webpack = katex2;
      __webpack_exports__ = __webpack_exports__["default"];
      return __webpack_exports__;
    }();
  });
})(katex);
var Katex = katex.exports;
var defaultSource = `% \\f is defined as #1f(#2) using the macro
\\f\\relax{x} = \\int_{-\\infty}^\\infty
    \\f\\hat\\xi\\,e^{2 \\pi i \\xi x}
    \\,d\\xi`;
function domToVDom(el) {
  const attrs = {};
  el.getAttributeNames().forEach((key) => {
    attrs[key] = el.getAttribute(key);
  });
  return VElement.createElement(el.tagName.toLowerCase(), attrs, Array.from(el.childNodes).map((child) => {
    if (child.nodeType === Node.ELEMENT_NODE) {
      return domToVDom(child);
    }
    return child.textContent || "";
  }));
}
var katexComponent = defineComponent({
  type: ContentType.InlineComponent,
  name: "KatexComponent",
  setup(initData) {
    let state = (initData === null || initData === void 0 ? void 0 : initData.state) || {
      source: defaultSource
    };
    state.source = state.source || defaultSource;
    const stateController = useState(state);
    const sub = stateController.onChange.subscribe((newState) => {
      state = newState;
    });
    const injector = useContext();
    const i18n = injector.get(I18n);
    const dialog = injector.get(Dialog);
    const childI18n = i18n.getContext("components.katexComponent.setter");
    function changeSource() {
      const form = new Form({
        title: childI18n.get("title"),
        cancelBtnText: childI18n.get("cancelBtnText"),
        confirmBtnText: childI18n.get("confirmBtnText"),
        items: [
          new FormTextarea({
            name: "source",
            value: state.source,
            placeholder: childI18n.get("placeholder"),
            label: childI18n.get("label"),
            height: "260px",
            width: "400px"
          })
        ]
      });
      dialog.show(form.elementRef);
      form.onComplete.subscribe((data) => {
        stateController.update((draft) => {
          draft.source = data.source;
        });
        dialog.hide();
      });
      form.onCancel.subscribe(() => dialog.hide());
    }
    onDestroy(() => {
      sub.unsubscribe();
    });
    return {
      render() {
        let htmlString;
        try {
          htmlString = Katex.renderToString(state.source, {
            displayMode: true,
            leqno: false,
            fleqn: false,
            throwOnError: true,
            errorColor: "#cc0000",
            strict: "warn",
            output: "html",
            trust: false,
            macros: { "\\f": "#1f(#2)" }
          });
        } catch (e) {
          htmlString = `<span style="color: red">${e.stack.split("\n").join("<br>")}</span>`;
        }
        const dom = new DOMParser().parseFromString(htmlString, "text/html").body.children[0];
        return VElement.createElement("tb-katex", { source: encodeURIComponent(state.source), onClick: changeSource }, dom ? [domToVDom(dom)] : []);
      }
    };
  }
});
var katexComponentLoader = {
  match(element) {
    return element.tagName.toLowerCase() === "tb-katex";
  },
  read(element, context) {
    return katexComponent.createInstance(context, {
      state: {
        source: decodeURIComponent(element.getAttribute("source") || "")
      }
    });
  }
};
var listComponent = defineComponent({
  type: ContentType.BlockComponent,
  name: "ListComponent",
  separable: true,
  zenCoding: {
    key: " ",
    match: /^(1\.|[+*])$/,
    generateInitData(content) {
      return {
        state: /[-+*]/.test(content) ? "ul" : "ol"
      };
    }
  },
  setup(data) {
    const injector = useContext();
    const selection = injector.get(Selection);
    let state = (data === null || data === void 0 ? void 0 : data.state) || "ul";
    const stateController = useState(state);
    const sub = stateController.onChange.subscribe((v2) => {
      state = v2;
    });
    onDestroy(() => {
      sub.unsubscribe();
    });
    const slots = useSlots((data === null || data === void 0 ? void 0 : data.slots) || [new Slot([
      ContentType.Text,
      ContentType.InlineComponent
    ])]);
    onBreak((ev) => {
      if (ev.target.isEmpty && ev.target === slots.last) {
        const paragraph = paragraphComponent.createInstance(injector);
        const parentComponent = selection.commonAncestorComponent;
        const parentSlot = parentComponent.parent;
        const index = parentSlot.indexOf(parentComponent);
        parentSlot.retain(index + 1);
        if (slots.length > 1) {
          slots.remove(slots.last);
        }
        parentSlot.insert(paragraph);
        selection.setPosition(paragraph.slots.get(0), 0);
        ev.preventDefault();
        return;
      }
      const nextLi = ev.target.cut(ev.data.index);
      slots.insertAfter(nextLi, ev.target);
      selection.setPosition(nextLi, 0);
      ev.preventDefault();
    });
    return {
      type: state,
      render(slotRender) {
        const Tag = state;
        return VElement.createElement(Tag, null, slots.toArray().map((i2) => {
          return slotRender(i2, (children) => {
            return VElement.createElement("li", { class: "tb-list-item" }, children);
          });
        }));
      },
      split(startIndex, endIndex) {
        return {
          before: slots.slice(0, startIndex),
          middle: slots.slice(startIndex, endIndex),
          after: slots.slice(endIndex)
        };
      }
    };
  }
});
var listComponentLoader = {
  match(element) {
    return element.tagName === "OL" || element.tagName === "UL";
  },
  read(element, injector, slotParser) {
    const slots = [];
    const childNodes = Array.from(element.childNodes);
    while (childNodes.length) {
      const slot = new Slot([
        ContentType.Text,
        ContentType.InlineComponent
      ]);
      let first = childNodes.shift();
      let newLi = null;
      while (first) {
        if (/^li$/i.test(first.nodeName)) {
          slots.push(slot);
          slotParser(slot, first);
          break;
        }
        if (!newLi) {
          if (first.nodeType === Node.TEXT_NODE && (/^\s+$/.test(first.textContent) || first.textContent === "")) {
            break;
          }
          newLi = document.createElement("li");
        }
        newLi.appendChild(first);
        first = childNodes.shift();
      }
      if (newLi) {
        slots.push(slot);
        slotParser(slot, newLi);
        newLi = null;
      }
    }
    return listComponent.createInstance(injector, {
      slots,
      state: element.tagName.toLowerCase()
    });
  }
};
(function(Prism2) {
  Prism2.languages.typescript = Prism2.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: true,
      greedy: true,
      inside: null
    },
    "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  });
  Prism2.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    /\btype\b(?=\s*(?:[\{*]|$))/
  );
  delete Prism2.languages.typescript["parameter"];
  delete Prism2.languages.typescript["literal-property"];
  var typeInside = Prism2.languages.extend("typescript", {});
  delete typeInside["class-name"];
  Prism2.languages.typescript["class-name"].inside = typeInside;
  Prism2.languages.insertBefore("typescript", "function", {
    "decorator": {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        "at": {
          pattern: /^@/,
          alias: "operator"
        },
        "function": /^[\s\S]+/
      }
    },
    "generic-function": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: true,
      inside: {
        "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        "generic": {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: typeInside
        }
      }
    }
  });
  Prism2.languages.ts = Prism2.languages.typescript;
})(Prism);
(function(Prism2) {
  var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
  var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
  var className = {
    pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: true,
    inside: {
      "namespace": {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          "punctuation": /\./
        }
      },
      "punctuation": /\./
    }
  };
  Prism2.languages.java = Prism2.languages.extend("clike", {
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: true,
      greedy: true
    },
    "class-name": [
      className,
      {
        pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
        lookbehind: true,
        inside: className.inside
      },
      {
        pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
        lookbehind: true,
        inside: className.inside
      }
    ],
    "keyword": keywords,
    "function": [
      Prism2.languages.clike.function,
      {
        pattern: /(::\s*)[a-z_]\w*/,
        lookbehind: true
      }
    ],
    "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    "operator": {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: true
    },
    "constant": /\b[A-Z][A-Z_\d]+\b/
  });
  Prism2.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: true,
      alias: "string"
    },
    "char": {
      pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
      greedy: true
    }
  });
  Prism2.languages.insertBefore("java", "class-name", {
    "annotation": {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: true,
      alias: "punctuation"
    },
    "generics": {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": className,
        "keyword": keywords,
        "punctuation": /[<>(),.:]/,
        "operator": /[?&|]/
      }
    },
    "import": [
      {
        pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
        lookbehind: true,
        inside: {
          "namespace": className.inside.namespace,
          "punctuation": /\./,
          "operator": /\*/,
          "class-name": /\w+/
        }
      },
      {
        pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
        lookbehind: true,
        alias: "static",
        inside: {
          "namespace": className.inside.namespace,
          "static": /\b\w+$/,
          "punctuation": /\./,
          "operator": /\*/,
          "class-name": /\w+/
        }
      }
    ],
    "namespace": {
      pattern: RegExp(
        /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
          return keywords.source;
        })
      ),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    }
  });
})(Prism);
(function(Prism2) {
  var powershell = Prism2.languages.powershell = {
    "comment": [
      {
        pattern: /(^|[^`])<#[\s\S]*?#>/,
        lookbehind: true
      },
      {
        pattern: /(^|[^`])#.*/,
        lookbehind: true
      }
    ],
    "string": [
      {
        pattern: /"(?:`[\s\S]|[^`"])*"/,
        greedy: true,
        inside: null
      },
      {
        pattern: /'(?:[^']|'')*'/,
        greedy: true
      }
    ],
    "namespace": /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
    "boolean": /\$(?:false|true)\b/i,
    "variable": /\$\w+\b/,
    "function": [
      /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
      /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
    ],
    "keyword": /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
    "operator": {
      pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
      lookbehind: true
    },
    "punctuation": /[|{}[\];(),.]/
  };
  powershell.string[0].inside = {
    "function": {
      pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
      lookbehind: true,
      inside: powershell
    },
    "boolean": powershell.boolean,
    "variable": powershell.variable
  };
})(Prism);
Prism.languages.swift = {
  "comment": {
    pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
    lookbehind: true,
    greedy: true
  },
  "string-literal": [
    {
      pattern: RegExp(
        /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\\($/,
          alias: "punctuation"
        },
        "punctuation": /\\(?=[\r\n])/,
        "string": /[\s\S]+/
      }
    },
    {
      pattern: RegExp(
        /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\#+\($/,
          alias: "punctuation"
        },
        "string": /[\s\S]+/
      }
    }
  ],
  "directive": {
    pattern: RegExp(
      /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
    ),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      "boolean": /\b(?:false|true)\b/,
      "number": /\b\d+(?:\.\d+)*\b/,
      "operator": /!|&&|\|\||[<>]=?/,
      "punctuation": /[(),]/
    }
  },
  "literal": {
    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    alias: "constant"
  },
  "other-directive": {
    pattern: /#\w+\b/,
    alias: "property"
  },
  "attribute": {
    pattern: /@\w+/,
    alias: "atrule"
  },
  "function-definition": {
    pattern: /(\bfunc\s+)\w+/,
    lookbehind: true,
    alias: "function"
  },
  "label": {
    pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
    lookbehind: true,
    alias: "important"
  },
  "keyword": /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  "boolean": /\b(?:false|true)\b/,
  "nil": {
    pattern: /\bnil\b/,
    alias: "constant"
  },
  "short-argument": /\$\d+\b/,
  "omit": {
    pattern: /\b_\b/,
    alias: "keyword"
  },
  "number": /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "constant": /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  "operator": /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  "punctuation": /[{}[\]();,.:\\]/
};
Prism.languages.swift["string-literal"].forEach(function(rule) {
  rule.inside["interpolation"].inside = Prism.languages.swift;
});
Prism.languages.json = {
  "property": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "comment": {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "punctuation": /[{}[\],]/,
  "operator": /:/,
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
Prism.languages.webmanifest = Prism.languages.json;
(function(Prism2) {
  var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
      }
    },
    "url": {
      pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);
Prism.languages.less = Prism.languages.extend("css", {
  "comment": [
    /\/\*[\s\S]*?\*\//,
    {
      pattern: /(^|[^\\])\/\/.*/,
      lookbehind: true
    }
  ],
  "atrule": {
    pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: {
      "punctuation": /[:()]/
    }
  },
  "selector": {
    pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: {
      "variable": /@+[\w-]+/
    }
  },
  "property": /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
  "operator": /[+\-*\/]/
});
Prism.languages.insertBefore("less", "property", {
  "variable": [
    {
      pattern: /@[\w-]+\s*:/,
      inside: {
        "punctuation": /:/
      }
    },
    /@@?[\w-]+/
  ],
  "mixin-usage": {
    pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
    lookbehind: true,
    alias: "function"
  }
});
Prism.languages.scss = Prism.languages.extend("css", {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
    lookbehind: true
  },
  "atrule": {
    pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
    inside: {
      "rule": /@[\w-]+/
    }
  },
  "url": /(?:[-a-z]+-)?url(?=\()/i,
  "selector": {
    pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
    inside: {
      "parent": {
        pattern: /&/,
        alias: "important"
      },
      "placeholder": /%[-\w]+/,
      "variable": /\$[-\w]+|#\{\$[-\w]+\}/
    }
  },
  "property": {
    pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
    inside: {
      "variable": /\$[-\w]+|#\{\$[-\w]+\}/
    }
  }
});
Prism.languages.insertBefore("scss", "atrule", {
  "keyword": [
    /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
    {
      pattern: /( )(?:from|through)(?= )/,
      lookbehind: true
    }
  ]
});
Prism.languages.insertBefore("scss", "important", {
  "variable": /\$[-\w]+|#\{\$[-\w]+\}/
});
Prism.languages.insertBefore("scss", "function", {
  "module-modifier": {
    pattern: /\b(?:as|hide|show|with)\b/i,
    alias: "keyword"
  },
  "placeholder": {
    pattern: /%[-\w]+/,
    alias: "selector"
  },
  "statement": {
    pattern: /\B!(?:default|optional)\b/i,
    alias: "keyword"
  },
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  },
  "operator": {
    pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
    lookbehind: true
  }
});
Prism.languages.scss["atrule"].inside.rest = Prism.languages.scss;
(function(Prism2) {
  var unit = {
    pattern: /(\b\d+)(?:%|[a-z]+)/,
    lookbehind: true
  };
  var number = {
    pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
    lookbehind: true
  };
  var inside = {
    "comment": {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true
    },
    "url": {
      pattern: /\burl\((["']?).*?\1\)/i,
      greedy: true
    },
    "string": {
      pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
      greedy: true
    },
    "interpolation": null,
    "func": null,
    "important": /\B!(?:important|optional)\b/i,
    "keyword": {
      pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
      lookbehind: true
    },
    "hexcode": /#[\da-f]{3,6}/i,
    "color": [
      /\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i,
      {
        pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
        inside: {
          "unit": unit,
          "number": number,
          "function": /[\w-]+(?=\()/,
          "punctuation": /[(),]/
        }
      }
    ],
    "entity": /\\[\da-f]{1,8}/i,
    "unit": unit,
    "boolean": /\b(?:false|true)\b/,
    "operator": [
      /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
    ],
    "number": number,
    "punctuation": /[{}()\[\];:,]/
  };
  inside["interpolation"] = {
    pattern: /\{[^\r\n}:]+\}/,
    alias: "variable",
    inside: {
      "delimiter": {
        pattern: /^\{|\}$/,
        alias: "punctuation"
      },
      rest: inside
    }
  };
  inside["func"] = {
    pattern: /[\w-]+\([^)]*\).*/,
    inside: {
      "function": /^[^(]+/,
      rest: inside
    }
  };
  Prism2.languages.stylus = {
    "atrule-declaration": {
      pattern: /(^[ \t]*)@.+/m,
      lookbehind: true,
      inside: {
        "atrule": /^@[\w-]+/,
        rest: inside
      }
    },
    "variable-declaration": {
      pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
      lookbehind: true,
      inside: {
        "variable": /^\S+/,
        rest: inside
      }
    },
    "statement": {
      pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
      lookbehind: true,
      inside: {
        "keyword": /^\S+/,
        rest: inside
      }
    },
    "property-declaration": {
      pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
      lookbehind: true,
      inside: {
        "property": {
          pattern: /^[^\s:]+/,
          inside: {
            "interpolation": inside.interpolation
          }
        },
        rest: inside
      }
    },
    "selector": {
      pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
      lookbehind: true,
      inside: {
        "interpolation": inside.interpolation,
        "comment": inside.comment,
        "punctuation": /[{},]/
      }
    },
    "func": inside.func,
    "string": inside.string,
    "comment": {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true,
      greedy: true
    },
    "interpolation": inside.interpolation,
    "punctuation": /[{}()\[\];:.]/
  };
})(Prism);
Prism.languages.c = Prism.languages.extend("clike", {
  "comment": {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "string": {
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: true
  },
  "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
Prism.languages.insertBefore("c", "string", {
  "char": {
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: true
  }
});
Prism.languages.insertBefore("c", "string", {
  "macro": {
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: "property",
    inside: {
      "string": [
        {
          pattern: /^(#\s*include\s*)<[^>]+>/,
          lookbehind: true
        },
        Prism.languages.c["string"]
      ],
      "char": Prism.languages.c["char"],
      "comment": Prism.languages.c["comment"],
      "macro-name": [
        {
          pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
          lookbehind: true
        },
        {
          pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
          lookbehind: true,
          alias: "function"
        }
      ],
      "directive": {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: true,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      "punctuation": /##|\\(?=[\r\n])/,
      "expression": {
        pattern: /\S[\s\S]*/,
        inside: Prism.languages.c
      }
    }
  }
});
Prism.languages.insertBefore("c", "function", {
  "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete Prism.languages.c["boolean"];
(function(Prism2) {
  var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
  var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return keyword.source;
  });
  Prism2.languages.cpp = Prism2.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
          return keyword.source;
        })),
        lookbehind: true
      },
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    "keyword": keyword,
    "number": {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: true
    },
    "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    "boolean": /\b(?:false|true)\b/
  });
  Prism2.languages.insertBefore("cpp", "string", {
    "module": {
      pattern: RegExp(
        /(\b(?:import|module)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
          return modName;
        }) + ")"
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "string": /^[<"][\s\S]+/,
        "operator": /:/,
        "punctuation": /\./
      }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: true
    }
  });
  Prism2.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        "function": /^\w+/,
        "generic": {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: Prism2.languages.cpp
        }
      }
    }
  });
  Prism2.languages.insertBefore("cpp", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("cpp", "class-name", {
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: Prism2.languages.extend("cpp", {})
    }
  });
  Prism2.languages.insertBefore("inside", "double-colon", {
    "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
  }, Prism2.languages.cpp["base-clause"]);
})(Prism);
(function(Prism2) {
  function replace(pattern, replacements) {
    return pattern.replace(/<<(\d+)>>/g, function(m2, index) {
      return "(?:" + replacements[+index] + ")";
    });
  }
  function re(pattern, replacements, flags) {
    return RegExp(replace(pattern, replacements), flags || "");
  }
  function nested(pattern, depthLog2) {
    for (var i2 = 0; i2 < depthLog2; i2++) {
      pattern = pattern.replace(/<<self>>/g, function() {
        return "(?:" + pattern + ")";
      });
    }
    return pattern.replace(/<<self>>/g, "[^\\s\\S]");
  }
  var keywordKinds = {
    type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
    typeDeclaration: "class enum interface record struct",
    contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
    other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
  };
  function keywordsToPattern(words) {
    return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
  }
  var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
  var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
  var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
  var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other);
  var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
  var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
  var name = /@?\b[A-Za-z_]\w*\b/.source;
  var genericName = replace(/<<0>>(?:\s*<<1>>)?/.source, [name, generic]);
  var identifier = replace(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [nonTypeKeywords, genericName]);
  var array = /\[\s*(?:,\s*)*\]/.source;
  var typeExpressionWithoutTuple = replace(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [identifier, array]);
  var tupleElement = replace(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [generic, nestedRound, array]);
  var tuple = replace(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
  var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [tuple, identifier, array]);
  var typeInside = {
    "keyword": keywords,
    "punctuation": /[<>()?,.:[\]]/
  };
  var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
  var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
  var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
  Prism2.languages.csharp = Prism2.languages.extend("clike", {
    "string": [
      {
        pattern: re(/(^|[^$\\])<<0>>/.source, [verbatimString]),
        lookbehind: true,
        greedy: true
      },
      {
        pattern: re(/(^|[^@$\\])<<0>>/.source, [regularString]),
        lookbehind: true,
        greedy: true
      }
    ],
    "class-name": [
      {
        pattern: re(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [identifier]),
        lookbehind: true,
        inside: typeInside
      },
      {
        pattern: re(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [name, typeExpression]),
        lookbehind: true,
        inside: typeInside
      },
      {
        pattern: re(/(\busing\s+)<<0>>(?=\s*=)/.source, [name]),
        lookbehind: true
      },
      {
        pattern: re(/(\b<<0>>\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),
        lookbehind: true,
        inside: typeInside
      },
      {
        pattern: re(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier]),
        lookbehind: true,
        inside: typeInside
      },
      {
        pattern: re(/(\bwhere\s+)<<0>>/.source, [name]),
        lookbehind: true
      },
      {
        pattern: re(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [typeExpressionWithoutTuple]),
        lookbehind: true,
        inside: typeInside
      },
      {
        pattern: re(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [typeExpression, nonContextualKeywords, name]),
        inside: typeInside
      }
    ],
    "keyword": keywords,
    "number": /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
    "operator": />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
    "punctuation": /\?\.?|::|[{}[\];(),.:]/
  });
  Prism2.languages.insertBefore("csharp", "number", {
    "range": {
      pattern: /\.\./,
      alias: "operator"
    }
  });
  Prism2.languages.insertBefore("csharp", "punctuation", {
    "named-parameter": {
      pattern: re(/([(,]\s*)<<0>>(?=\s*:)/.source, [name]),
      lookbehind: true,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("csharp", "class-name", {
    "namespace": {
      pattern: re(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [name]),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    },
    "type-expression": {
      pattern: re(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [nestedRound]),
      lookbehind: true,
      alias: "class-name",
      inside: typeInside
    },
    "return-type": {
      pattern: re(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [typeExpression, identifier]),
      inside: typeInside,
      alias: "class-name"
    },
    "constructor-invocation": {
      pattern: re(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
      lookbehind: true,
      inside: typeInside,
      alias: "class-name"
    },
    "generic-method": {
      pattern: re(/<<0>>\s*<<1>>(?=\s*\()/.source, [name, generic]),
      inside: {
        "function": re(/^<<0>>/.source, [name]),
        "generic": {
          pattern: RegExp(generic),
          alias: "class-name",
          inside: typeInside
        }
      }
    },
    "type-list": {
      pattern: re(
        /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
        [typeDeclarationKeywords, genericName, name, typeExpression, keywords.source, nestedRound, /\bnew\s*\(\s*\)/.source]
      ),
      lookbehind: true,
      inside: {
        "record-arguments": {
          pattern: re(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [genericName, nestedRound]),
          lookbehind: true,
          greedy: true,
          inside: Prism2.languages.csharp
        },
        "keyword": keywords,
        "class-name": {
          pattern: RegExp(typeExpression),
          greedy: true,
          inside: typeInside
        },
        "punctuation": /[,()]/
      }
    },
    "preprocessor": {
      pattern: /(^[\t ]*)#.*/m,
      lookbehind: true,
      alias: "property",
      inside: {
        "directive": {
          pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
          lookbehind: true,
          alias: "keyword"
        }
      }
    }
  });
  var regularStringOrCharacter = regularString + "|" + character;
  var regularStringCharacterOrComment = replace(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [regularStringOrCharacter]);
  var roundExpression = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
  var attr = replace(/<<0>>(?:\s*\(<<1>>*\))?/.source, [identifier, roundExpression]);
  Prism2.languages.insertBefore("csharp", "class-name", {
    "attribute": {
      pattern: re(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [attrTarget, attr]),
      lookbehind: true,
      greedy: true,
      inside: {
        "target": {
          pattern: re(/^<<0>>(?=\s*:)/.source, [attrTarget]),
          alias: "keyword"
        },
        "attribute-arguments": {
          pattern: re(/\(<<0>>*\)/.source, [roundExpression]),
          inside: Prism2.languages.csharp
        },
        "class-name": {
          pattern: RegExp(identifier),
          inside: {
            "punctuation": /\./
          }
        },
        "punctuation": /[:,]/
      }
    }
  });
  var formatString = /:[^}\r\n]+/.source;
  var mInterpolationRound = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var mInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [mInterpolationRound, formatString]);
  var sInterpolationRound = nested(replace(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [regularStringOrCharacter]), 2);
  var sInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [sInterpolationRound, formatString]);
  function createInterpolationInside(interpolation, interpolationRound) {
    return {
      "interpolation": {
        pattern: re(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
        lookbehind: true,
        inside: {
          "format-string": {
            pattern: re(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [interpolationRound, formatString]),
            lookbehind: true,
            inside: {
              "punctuation": /^:/
            }
          },
          "punctuation": /^\{|\}$/,
          "expression": {
            pattern: /[\s\S]+/,
            alias: "language-csharp",
            inside: Prism2.languages.csharp
          }
        }
      },
      "string": /[\s\S]+/
    };
  }
  Prism2.languages.insertBefore("csharp", "string", {
    "interpolation-string": [
      {
        pattern: re(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [mInterpolation]),
        lookbehind: true,
        greedy: true,
        inside: createInterpolationInside(mInterpolation, mInterpolationRound)
      },
      {
        pattern: re(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [sInterpolation]),
        lookbehind: true,
        greedy: true,
        inside: createInterpolationInside(sInterpolation, sInterpolationRound)
      }
    ],
    "char": {
      pattern: RegExp(character),
      greedy: true
    }
  });
  Prism2.languages.dotnet = Prism2.languages.cs = Prism2.languages.csharp;
})(Prism);
Prism.languages.go = Prism.languages.extend("clike", {
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
    lookbehind: true,
    greedy: true
  },
  "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
  "boolean": /\b(?:_|false|iota|nil|true)\b/,
  "number": [
    /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
    /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
    /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
  ],
  "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
  "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
});
Prism.languages.insertBefore("go", "string", {
  "char": {
    pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
    greedy: true
  }
});
delete Prism.languages.go["class-name"];
(function(Prism2) {
  var javascript = Prism2.util.clone(Prism2.languages.javascript);
  var space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
  var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
  var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function re(source, flags) {
    source = source.replace(/<S>/g, function() {
      return space;
    }).replace(/<BRACES>/g, function() {
      return braces;
    }).replace(/<SPREAD>/g, function() {
      return spread;
    });
    return RegExp(source, flags);
  }
  spread = re(spread).source;
  Prism2.languages.jsx = Prism2.languages.extend("markup", javascript);
  Prism2.languages.jsx.tag.pattern = re(
    /<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source
  );
  Prism2.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
  Prism2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
  Prism2.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
  Prism2.languages.jsx.tag.inside["comment"] = javascript["comment"];
  Prism2.languages.insertBefore("inside", "attr-name", {
    "spread": {
      pattern: re(/<SPREAD>/.source),
      inside: Prism2.languages.jsx
    }
  }, Prism2.languages.jsx.tag);
  Prism2.languages.insertBefore("inside", "special-attr", {
    "script": {
      pattern: re(/=<BRACES>/.source),
      alias: "language-javascript",
      inside: {
        "script-punctuation": {
          pattern: /^=(?=\{)/,
          alias: "punctuation"
        },
        rest: Prism2.languages.jsx
      }
    }
  }, Prism2.languages.jsx.tag);
  var stringifyToken = function(token) {
    if (!token) {
      return "";
    }
    if (typeof token === "string") {
      return token;
    }
    if (typeof token.content === "string") {
      return token.content;
    }
    return token.content.map(stringifyToken).join("");
  };
  var walkTokens = function(tokens) {
    var openedTags = [];
    for (var i2 = 0; i2 < tokens.length; i2++) {
      var token = tokens[i2];
      var notTagNorBrace = false;
      if (typeof token !== "string") {
        if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") {
          if (token.content[0].content[0].content === "</") {
            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
              openedTags.pop();
            }
          } else {
            if (token.content[token.content.length - 1].content === "/>")
              ;
            else {
              openedTags.push({
                tagName: stringifyToken(token.content[0].content[1]),
                openedBraces: 0
              });
            }
          }
        } else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{") {
          openedTags[openedTags.length - 1].openedBraces++;
        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") {
          openedTags[openedTags.length - 1].openedBraces--;
        } else {
          notTagNorBrace = true;
        }
      }
      if (notTagNorBrace || typeof token === "string") {
        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
          var plainText = stringifyToken(token);
          if (i2 < tokens.length - 1 && (typeof tokens[i2 + 1] === "string" || tokens[i2 + 1].type === "plain-text")) {
            plainText += stringifyToken(tokens[i2 + 1]);
            tokens.splice(i2 + 1, 1);
          }
          if (i2 > 0 && (typeof tokens[i2 - 1] === "string" || tokens[i2 - 1].type === "plain-text")) {
            plainText = stringifyToken(tokens[i2 - 1]) + plainText;
            tokens.splice(i2 - 1, 1);
            i2--;
          }
          tokens[i2] = new Prism2.Token("plain-text", plainText, null, plainText);
        }
      }
      if (token.content && typeof token.content !== "string") {
        walkTokens(token.content);
      }
    }
  };
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "jsx" && env.language !== "tsx") {
      return;
    }
    walkTokens(env.tokens);
  });
})(Prism);
(function(Prism2) {
  var typescript = Prism2.util.clone(Prism2.languages.typescript);
  Prism2.languages.tsx = Prism2.languages.extend("jsx", typescript);
  delete Prism2.languages.tsx["parameter"];
  delete Prism2.languages.tsx["literal-property"];
  var tag = Prism2.languages.tsx.tag;
  tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")", tag.pattern.flags);
  tag.lookbehind = true;
})(Prism);
function useComponentToolbar() {
  let isShow = false;
  const self2 = useSelf();
  onFocus(() => {
    isShow = true;
    self2.changeMarker.forceMarkDirtied();
  });
  onBlur(() => {
    isShow = false;
    self2.changeMarker.forceMarkDirtied();
  });
  return function(props) {
    return VElement.createElement(
      "div",
      { class: "tb-component-toolbar", style: {
        display: isShow ? "block" : "none"
      }, onMousedown: (ev) => {
        ev.preventDefault();
        return false;
      } },
      VElement.createElement("div", { class: "tb-component-toolbar-inner" }, props.children)
    );
  };
}
function useSelector(config, callback) {
  let isOpen = false;
  const self2 = useSelf();
  onBlur(() => {
    isOpen = false;
    self2.changeMarker.forceMarkDirtied();
  });
  let current = config.items.find((item) => {
    return item.value === config.defaultValue;
  });
  const container = useContext(VIEW_DOCUMENT);
  const subscription = fromEvent(container, "mousedown").subscribe(() => {
    if (isOpen) {
      isOpen = false;
      self2.changeMarker.forceMarkDirtied();
    }
  });
  onDestroy(() => {
    subscription.unsubscribe();
  });
  return function() {
    return VElement.createElement(
      "div",
      { class: (0, import_classnames.default)("textbus-toolbar-dropdown", {
        "textbus-toolbar-dropdown-open": isOpen
      }) },
      VElement.createElement(
        "div",
        { class: "textbus-toolbar-dropdown-button" },
        VElement.createElement(
          "span",
          { class: "textbus-toolbar-item textbus-toolbar-dropdown" },
          VElement.createElement(
            "button",
            { class: "textbus-toolbar-button", type: "button", onClick: () => {
              isOpen = !isOpen;
              self2.changeMarker.forceMarkDirtied();
            } },
            VElement.createElement("span", { class: "textbus-toolbar-select-label" }, (current === null || current === void 0 ? void 0 : current.label) || " "),
            VElement.createElement("span", { class: "textbus-dropdown-caret" })
          )
        )
      ),
      VElement.createElement(
        "div",
        { class: "textbus-toolbar-dropdown-menu" },
        VElement.createElement("div", { class: "textbus-toolbar-select-options" }, config.items.map((item) => {
          return VElement.createElement(
            "button",
            { class: "textbus-toolbar-option", onMousedown: (ev) => ev.stopPropagation(), type: "button", onClick: () => {
              current = item;
              isOpen = false;
              callback(item);
              self2.changeMarker.forceMarkDirtied();
            } },
            VElement.createElement("span", { class: "textbus-toolbar-option-label" }, item.label)
          );
        }))
      )
    );
  };
}
var codeStyles = {
  keyword: "keyword",
  string: "string",
  function: "function",
  number: "number",
  tag: "tag",
  comment: "comment",
  boolean: "boolean",
  operator: false,
  builtin: "builtin",
  punctuation: false,
  regex: "regex",
  selector: "selector",
  property: "attr-name",
  "class-name": "class-name",
  "attr-name": "attr-name",
  "attr-value": "attr-value",
  "template-punctuation": "string"
};
var languageList = [{
  label: "JavaScript",
  value: "JavaScript"
}, {
  label: "HTML",
  value: "HTML"
}, {
  label: "CSS",
  value: "CSS"
}, {
  label: "TypeScript",
  value: "TypeScript"
}, {
  label: "Java",
  value: "Java"
}, {
  label: "C",
  value: "C"
}, {
  label: "C++",
  value: "CPP"
}, {
  label: "C#",
  value: "CSharp"
}, {
  label: "Swift",
  value: "Swift"
}, {
  label: "Go",
  value: "Go"
}, {
  label: "JSON",
  value: "JSON"
}, {
  label: "Less",
  value: "Less"
}, {
  label: "SCSS",
  value: "SCSS"
}, {
  label: "Stylus",
  value: "Stylus"
}, {
  label: "Jsx",
  value: "Jsx"
}, {
  label: "Tsx",
  value: "Tsx"
}, {
  label: "",
  value: ""
}];
var CodeStyleFormatter = class {
  constructor() {
    this.priority = 0;
    this.name = "code" + Math.random();
    this.columned = false;
  }
  render(children, formatValue) {
    return new VElement("span", {
      class: "tb-hl-" + formatValue
    }, children);
  }
};
var codeStyleFormatter = new CodeStyleFormatter();
function getLanguageBlockCommentStart(lang) {
  const types = {
    HTML: ["<!--", "-->"],
    JavaScript: ["/*", "*/"],
    CSS: ["/*", "*/"],
    TypeScript: ["/*", "*/"],
    Java: ["/*", "*/"],
    Swift: ["/*", "*/"],
    Go: ["/*", "*/"],
    JSON: ["", ""],
    Less: ["/*", "*/"],
    SCSS: ["/*", "*/"],
    Stylus: ["/*", "*/"],
    C: ["/*", "*/"],
    CPP: ["/*", "*/"],
    CSharp: ["/*", "*/"],
    Tsx: ["/*", "*/"],
    Jsx: ["/*", "*/"]
  };
  return types[lang] || ["", ""];
}
function getLanguageGrammar(lang) {
  return {
    HTML: import_prismjs.languages.html,
    JavaScript: import_prismjs.languages.javascript,
    CSS: import_prismjs.languages.css,
    TypeScript: import_prismjs.languages.typescript,
    Java: import_prismjs.languages.java,
    Swift: import_prismjs.languages.swift,
    JSON: import_prismjs.languages.json,
    Go: import_prismjs.languages.go,
    Ruby: import_prismjs.languages.ruby,
    Less: import_prismjs.languages.less,
    SCSS: import_prismjs.languages.scss,
    Stylus: import_prismjs.languages.stylus,
    C: import_prismjs.languages.c,
    CPP: import_prismjs.languages.cpp,
    CSharp: import_prismjs.languages.csharp,
    Jsx: import_prismjs.languages.jsx,
    Tsx: import_prismjs.languages.tsx
  }[lang] || null;
}
function format(tokens, slot, index) {
  tokens.forEach((token) => {
    if (token instanceof import_prismjs.Token) {
      const styleName = codeStyles[token.type];
      slot.retain(index);
      slot.retain(token.length, codeStyleFormatter, styleName || null);
      if (Array.isArray(token.content)) {
        format(token.content, slot, index);
      }
    }
    index += token.length;
  });
}
function formatCodeLines(lines, startBlock, blockCommentStartString, blockCommentEndString, languageGrammar) {
  return lines.map((item) => {
    let i2 = item.code;
    const slot = createCodeSlot();
    slot.updateState((draft) => {
      draft.blockCommentStart = startBlock;
      draft.emphasize = item.emphasize;
    });
    if (slot.state.blockCommentStart) {
      i2 = blockCommentStartString + i2;
    }
    slot.insert(i2);
    if (languageGrammar) {
      const tokens = (0, import_prismjs.tokenize)(i2, languageGrammar);
      format(tokens, slot, 0);
      if (slot.state.blockCommentStart) {
        slot.retain(0);
        slot.delete(2);
      }
      const lastToken = tokens.pop();
      if (lastToken && typeof lastToken !== "string" && lastToken.type === "comment" && lastToken.content.indexOf(blockCommentStartString) === 0) {
        const regString = blockCommentEndString.replace(new RegExp(`[${blockCommentEndString}]`, "g"), (i3) => "\\" + i3);
        slot.updateState((draft) => {
          draft.blockCommentEnd = new RegExp(regString + "$").test(lastToken.content);
        });
        startBlock = !slot.state.blockCommentEnd;
      } else {
        startBlock = false;
      }
    } else {
      slot.updateState((draft) => {
        draft.blockCommentEnd = true;
      });
    }
    return slot;
  });
}
function reformat(slots, startSlot, languageGrammar, blockCommentStartString, blockCommentEndString, forceFormat = false) {
  const list = slots.toArray();
  let i2 = list.indexOf(startSlot);
  for (; i2 < list.length; i2++) {
    const slot = list[i2];
    let code = slot.sliceContent()[0];
    if (slot.state.blockCommentStart) {
      code = blockCommentStartString + code;
    }
    const shadow = new Slot([ContentType.Text]);
    shadow.insert(code);
    const tokens = (0, import_prismjs.tokenize)(code, languageGrammar);
    format(tokens, shadow, 0);
    if (slot.state.blockCommentStart) {
      shadow.retain(0);
      shadow.delete(2);
    }
    slot.retain(0);
    slot.retain(slot.length, codeStyleFormatter, null);
    shadow.getFormats().forEach((i3) => {
      slot.retain(i3.startIndex);
      slot.retain(i3.endIndex - i3.startIndex, i3.formatter, i3.value);
    });
    const lastToken = tokens.pop();
    if (lastToken && typeof lastToken !== "string" && lastToken.type === "comment" && lastToken.content.indexOf(blockCommentStartString) === 0) {
      const regString = blockCommentEndString.replace(new RegExp(`[${blockCommentEndString}]`, "g"), (i3) => "\\" + i3);
      slot.updateState((draft) => {
        draft.blockCommentEnd = new RegExp(regString + "$").test(lastToken.content);
      });
    } else {
      slot.updateState((draft) => {
        draft.blockCommentEnd = true;
      });
    }
    const next = list[i2 + 1];
    if (next) {
      if (!forceFormat && next.state.blockCommentStart === !slot.state.blockCommentEnd) {
        break;
      }
      next.updateState((draft) => {
        draft.blockCommentStart = !slot.state.blockCommentEnd;
      });
    }
  }
}
function createCodeSlot() {
  return new Slot([
    ContentType.Text
  ], {
    blockCommentEnd: true,
    blockCommentStart: false,
    emphasize: false
  });
}
var preComponent = defineComponent({
  type: ContentType.BlockComponent,
  name: "PreComponent",
  separable: false,
  zenCoding: {
    key: "Enter",
    match(c2) {
      const matchString = languageList.map((i2) => i2.label || i2.value).concat("js", "ts").join("|").replace(/\+/, "\\+");
      const reg = new RegExp(`^\`\`\`(${matchString})$`, "i");
      return reg.test(c2);
    },
    generateInitData(content) {
      const matchString = content.replace(/`/g, "").replace(/\+/, "\\+");
      for (const item of languageList) {
        const reg = new RegExp(`^${matchString}$`, "i");
        if (reg.test(item.label || item.value)) {
          return {
            state: {
              lang: item.value,
              theme: ""
            },
            slots: [createCodeSlot()]
          };
        }
      }
      if (/^js$/i.test(matchString)) {
        return {
          state: {
            lang: "JavaScript",
            theme: ""
          },
          slots: [createCodeSlot()]
        };
      }
      if (/^ts$/i.test(matchString)) {
        return {
          state: {
            lang: "TypeScript",
            theme: ""
          },
          slots: [createCodeSlot()]
        };
      }
      return {
        state: {
          lang: "",
          theme: ""
        },
        slots: [createCodeSlot()]
      };
    }
  },
  setup(data = {
    slots: [],
    state: {
      lang: "",
      theme: ""
    }
  }) {
    var _a2, _b2, _c, _d;
    let state = {
      lang: data.state.lang,
      theme: ((_a2 = data.state) === null || _a2 === void 0 ? void 0 : _a2.theme) || "Light",
      lineNumber: ((_b2 = data.state) === null || _b2 === void 0 ? void 0 : _b2.lineNumber) !== false
    };
    let languageGrammar = getLanguageGrammar(state.lang);
    let [blockCommentStartString, blockCommentEndString] = getLanguageBlockCommentStart(state.lang);
    const stateController = useState(state);
    const injector = useContext();
    const i18n = injector.get(I18n);
    const selection = injector.get(Selection);
    stateController.onChange.subscribe((newState) => {
      state = newState;
      languageGrammar = getLanguageGrammar(newState.lang);
      [blockCommentStartString, blockCommentEndString] = getLanguageBlockCommentStart(newState.lang);
      isStop = true;
      slots.toArray().forEach((i2) => {
        i2.updateState((draft) => {
          draft.blockCommentStart = false;
          draft.blockCommentEnd = false;
        });
      });
      if (!languageGrammar) {
        slots.toArray().forEach((i2) => {
          i2.retain(0);
          i2.retain(i2.length, codeStyleFormatter, null);
        });
      } else {
        reformat(slots, slots.get(0), languageGrammar, blockCommentStartString, blockCommentEndString, true);
      }
      isStop = false;
    });
    const codeConfig = (data.slots || [createCodeSlot()]).map((i2) => {
      var _a3;
      return {
        emphasize: ((_a3 = i2.state) === null || _a3 === void 0 ? void 0 : _a3.emphasize) || false,
        code: i2.toString()
      };
    });
    const slotList = formatCodeLines(codeConfig, false, blockCommentStartString, blockCommentEndString, languageGrammar);
    const slots = useSlots(slotList);
    let isStop = false;
    slots.onChildSlotChange.subscribe((slot) => {
      if (languageGrammar && !isStop) {
        isStop = true;
        const index = slot.index;
        reformat(slots, slot, languageGrammar, blockCommentStartString, blockCommentEndString);
        slot.retain(index);
        isStop = false;
      }
    });
    useDynamicShortcut({
      keymap: {
        key: "/",
        ctrlKey: true
      },
      action: () => {
        const startIndex = slots.indexOf(selection.startSlot);
        const endIndex = slots.indexOf(selection.endSlot);
        const selectedSlots = slots.slice(startIndex, endIndex + 1);
        const isAllComment = selectedSlots.every((f2) => {
          return /^\s*\/\//.test(f2.toString());
        });
        if (isAllComment) {
          selectedSlots.forEach((f2) => {
            const code = f2.toString();
            const index = code.indexOf("// ");
            const index2 = code.indexOf("//");
            if (index >= 0) {
              f2.cut(index, index + 3);
              if (f2 === selection.anchorSlot) {
                selection.setAnchor(f2, selection.startOffset - 3);
              }
              if (f2 === selection.focusSlot) {
                selection.setFocus(f2, selection.endOffset - 3);
              }
            } else {
              f2.cut(index2, index2 + 2);
              if (f2 === selection.anchorSlot) {
                selection.setAnchor(f2, selection.startOffset - 2);
              }
              if (f2 === selection.focusSlot) {
                selection.setFocus(f2, selection.endOffset - 2);
              }
            }
          });
        } else {
          selectedSlots.forEach((f2) => {
            f2.retain(0);
            f2.insert("// ");
          });
          selection.setBaseAndExtent(selection.startSlot, selection.startOffset + 3, selection.endSlot, selection.endOffset + 3);
        }
      }
    });
    onBreak((ev) => {
      if (ev.target.isEmpty && ev.target === slots.last) {
        const prevSlot = slots.get(slots.length - 2);
        if (prevSlot === null || prevSlot === void 0 ? void 0 : prevSlot.isEmpty) {
          const paragraph = paragraphComponent.createInstance(injector);
          const parentComponent = selection.commonAncestorComponent;
          const parentSlot = parentComponent.parent;
          const index = parentSlot.indexOf(parentComponent);
          parentSlot.retain(index + 1);
          slots.remove(slots.last);
          if (slots.length > 1) {
            slots.remove(prevSlot);
          }
          parentSlot.insert(paragraph);
          selection.setPosition(paragraph.slots.get(0), 0);
          ev.preventDefault();
          return;
        }
      }
      const nextSlot = ev.target.cutTo(createCodeSlot(), ev.data.index);
      slots.insertAfter(nextSlot, ev.target);
      if (languageGrammar && !isStop) {
        isStop = true;
        const index = nextSlot.index;
        reformat(slots, nextSlot, languageGrammar, blockCommentStartString, blockCommentEndString);
        nextSlot.retain(index);
        isStop = false;
      }
      selection.setPosition(nextSlot, 0);
      ev.preventDefault();
    });
    function emphasize() {
      var _a3;
      const { startSlot, endSlot } = selection;
      let startIndex = slots.indexOf(startSlot);
      const endIndex = slots.indexOf(endSlot) + 1;
      for (; startIndex < endIndex; startIndex++) {
        (_a3 = slots.get(startIndex)) === null || _a3 === void 0 ? void 0 : _a3.updateState((draft) => {
          draft.emphasize = true;
        });
      }
    }
    function cancelEmphasize() {
      var _a3;
      const { startSlot, endSlot } = selection;
      let startIndex = slots.indexOf(startSlot);
      const endIndex = slots.indexOf(endSlot) + 1;
      for (; startIndex < endIndex; startIndex++) {
        (_a3 = slots.get(startIndex)) === null || _a3 === void 0 ? void 0 : _a3.updateState((draft) => {
          draft.emphasize = false;
        });
      }
    }
    onContextMenu((event) => {
      event.useMenus([{
        iconClasses: ["textbus-icon-source-code"],
        label: i18n.get("components.preComponent.contextMenuLabel"),
        submenu: languageList.map((i2) => {
          return {
            label: i2.label || i18n.get("components.preComponent.defaultLang"),
            onClick() {
              if (i2.value !== state.lang) {
                state.lang = i2.value;
                stateController.update((draft) => {
                  draft.lang = i2.value;
                });
              }
            }
          };
        })
      }, {
        label: i18n.get("components.preComponent.changeTheme"),
        submenu: [{
          label: "Light",
          onClick() {
            stateController.update((draft) => {
              draft.theme = "light";
            });
          }
        }, {
          label: "Vitality",
          onClick() {
            stateController.update((draft) => {
              draft.theme = "vitality";
            });
          }
        }, {
          label: "Dark",
          onClick() {
            stateController.update((draft) => {
              draft.theme = "dark";
            });
          }
        }, {
          label: "Starry",
          onClick() {
            stateController.update((draft) => {
              draft.theme = "starry";
            });
          }
        }]
      }, {
        label: i18n.get("components.preComponent.emphasize"),
        disabled: !selection.isSelected,
        onClick: emphasize
      }, {
        label: i18n.get("components.preComponent.cancelEmphasize"),
        disabled: !selection.isSelected,
        onClick: cancelEmphasize
      }]);
    });
    onPaste((ev) => {
      const codeList = [];
      const sourceCode = ev.data.text;
      let str = "";
      let isBreak = true;
      for (let i2 = 0; i2 < sourceCode.length; i2++) {
        const char = sourceCode[i2];
        if (char === "\r") {
          if (sourceCode[i2 + 1] === "\n") {
            i2++;
          }
          if (str) {
            codeList.push(str);
            str = "";
          }
          if (!isBreak) {
            codeList.push("");
          } else {
            isBreak = false;
          }
        } else if (char === "\n") {
          if (str) {
            codeList.push(str);
            str = "";
          }
          if (!isBreak) {
            codeList.push("");
          } else {
            isBreak = false;
          }
        } else {
          isBreak = true;
          str += char;
        }
      }
      if (str) {
        codeList.push(str);
      }
      const firstCode = codeList.shift();
      const target = ev.target;
      if (firstCode) {
        target.insert(firstCode);
      }
      const index = slots.indexOf(target);
      if (codeList.length) {
        slots.retain(index + 1);
        const slotList2 = formatCodeLines(codeList.map((i2) => {
          return {
            code: i2,
            emphasize: false
          };
        }), !target.state.blockCommentEnd, blockCommentStartString, blockCommentEndString, languageGrammar);
        const last = slotList2[slotList2.length - 1];
        slots.insert(...slotList2);
        selection.setPosition(last, last.length);
      } else {
        selection.setPosition(target, target.index);
      }
      ev.preventDefault();
    });
    const ComponentToolbar = useComponentToolbar();
    const LanguageSelector = useSelector({
      items: languageList.map((item) => {
        if (item.label) {
          return item;
        }
        return Object.assign(Object.assign({}, item), { label: i18n.get("components.preComponent.defaultLang") });
      }),
      defaultValue: (_c = data.state) === null || _c === void 0 ? void 0 : _c.lang
    }, (current) => {
      stateController.update((draft) => {
        draft.lang = current.value;
      });
    });
    const ThemeSelector = useSelector({
      items: [{
        label: "Light",
        value: "light"
      }, {
        label: "Vitality",
        value: "vitality"
      }, {
        label: "Dark",
        value: "dark"
      }, {
        label: "Starry",
        value: "starry"
      }],
      defaultValue: ((_d = data.state) === null || _d === void 0 ? void 0 : _d.theme) || "light"
    }, (current) => {
      stateController.update((draft) => {
        draft.theme = current.value;
      });
    });
    return {
      render(slotRender, renderMode) {
        let lang = "";
        languageList.forEach((i2) => {
          if (i2.value === state.lang) {
            lang = i2.label;
          }
        });
        const blockHighlight = slots.toArray().some((i2) => {
          var _a3;
          return ((_a3 = i2.state) === null || _a3 === void 0 ? void 0 : _a3.emphasize) === true;
        });
        return VElement.createElement(
          "pre",
          { class: "tb-pre" + (state.lineNumber ? "" : " tb-pre-hide-line-number"), lang, theme: state.theme || null, "line-number": state.lineNumber },
          renderMode === RenderMode.Editing ? VElement.createElement(
            ComponentToolbar,
            null,
            VElement.createElement(
              "label",
              null,
              i18n.get("components.preComponent.lineNumber"),
              ":",
              VElement.createElement("input", { type: "checkbox", checked: state.lineNumber, onChange: (ev) => {
                stateController.update((draft) => {
                  draft.lineNumber = ev.target.checked;
                });
              } })
            ),
            VElement.createElement(LanguageSelector, null),
            VElement.createElement(ThemeSelector, null),
            VElement.createElement("button", { type: "button", class: "textbus-toolbar-button", onClick: emphasize }, i18n.get("components.preComponent.emphasize")),
            VElement.createElement("button", { type: "button", class: "textbus-toolbar-button", onClick: cancelEmphasize }, i18n.get("components.preComponent.cancelEmphasize"))
          ) : null,
          VElement.createElement(
            "div",
            { class: "tb-pre-content" },
            VElement.createElement("div", { class: "tb-code-line-number-bg ", style: {
              width: Math.max(String(slots.length).length, 2.5) + "em"
            } }),
            VElement.createElement("div", { class: "tb-code-content" + (blockHighlight ? " tb-color-content-highlight" : "") }, slots.toArray().map((item) => {
              return slotRender(item, (children) => {
                var _a3;
                return VElement.createElement("div", { class: (((_a3 = item.state) === null || _a3 === void 0 ? void 0 : _a3.emphasize) ? "tb-code-line-emphasize " : "") + "tb-code-line" }, children);
              });
            })),
            VElement.createElement("span", { class: "tb-pre-lang" }, lang)
          )
        );
      }
    };
  }
});
var preComponentLoader = {
  match(element) {
    return element.tagName === "PRE";
  },
  read(el, injector) {
    const lines = el.querySelectorAll(".tb-code-line");
    let slots = [];
    if (lines.length) {
      slots = Array.from(lines).map((i2) => {
        const code = i2.innerText.replace(/[\s\n]+$/, "");
        const slot = createCodeSlot();
        slot.updateState((draft) => {
          draft.emphasize = i2.classList.contains("tb-code-line-emphasize");
        });
        slot.insert(code);
        return slot;
      });
    } else {
      el.querySelectorAll("br").forEach((br) => {
        br.parentNode.replaceChild(document.createTextNode("\n"), br);
      });
      slots = el.innerText.split("\n").map((code) => {
        const slot = createCodeSlot();
        slot.insert(code);
        return slot;
      });
    }
    return preComponent.createInstance(injector, {
      state: {
        lang: el.getAttribute("lang") || "",
        theme: el.getAttribute("theme") || "",
        lineNumber: !el.classList.contains("tb-pre-hide-line-number")
      },
      slots
    });
  }
};
var blockTags = "div,p,h1,h2,h3,h4,h5,h6,nav,header,footer,td,th,li,article".split(",");
var inlineTags = "span,em,i,s,del,sup,sub,u,strong,img".split(",");
var BlockAttrLoader = class extends Matcher {
  constructor(attrName, attribute, rule) {
    super(attribute, rule);
    this.attrName = attrName;
  }
  match(p2) {
    const reg = new RegExp(`^(${blockTags.join("|")})$`, "i");
    if (!reg.test(p2.tagName)) {
      return false;
    }
    return super.match(p2);
  }
  read(node) {
    var _a2;
    return {
      attribute: this.target,
      value: (_a2 = this.extractFormatData(node, {
        attrs: [this.attrName]
      }).attrs) === null || _a2 === void 0 ? void 0 : _a2[this.attrName]
    };
  }
};
var BlockAttrFormatter = class {
  constructor(name, attrName) {
    this.name = name;
    this.attrName = attrName;
  }
  render(host, formatValue) {
    host.attrs.set(this.attrName, formatValue);
  }
};
var dirFormatter = new BlockAttrFormatter("dir", "dir");
var dirFormatLoader = new BlockAttrLoader("dir", dirFormatter, {
  attrs: [{
    key: "dir",
    value: ["ltr", "rtl"]
  }]
});
var BlockStyleFormatLoader = class extends Matcher {
  constructor(styleName, formatter, rule) {
    super(formatter, rule);
    this.styleName = styleName;
  }
  match(p2) {
    const reg = new RegExp(`^(${blockTags.join("|")})$`, "i");
    if (!reg.test(p2.tagName)) {
      return false;
    }
    return super.match(p2);
  }
  read(node) {
    return {
      attribute: this.target,
      value: this.extractFormatData(node, {
        styleName: this.styleName
      }).styles[this.styleName]
    };
  }
};
var BlockStyleFormatter = class {
  constructor(name, styleName) {
    this.name = name;
    this.styleName = styleName;
  }
  render(host, formatValue) {
    host.styles.set(this.styleName, formatValue);
  }
};
var textIndentFormatter = new BlockStyleFormatter("textIndent", "textIndent");
var textAlignFormatter = new BlockStyleFormatter("textAlign", "textAlign");
var blockBackgroundColorFormatter = new BlockStyleFormatter("blockBackgroundColor", "backgroundColor");
var textIndentFormatLoader = new BlockStyleFormatLoader("textIndent", textIndentFormatter, {
  styles: {
    textIndent: /.+/
  }
});
var textAlignFormatLoader = new BlockStyleFormatLoader("textAlign", textAlignFormatter, {
  styles: {
    textAlign: /.+/
  }
});
var blockBackgroundColorFormatLoader = new BlockStyleFormatLoader("backgroundColor", blockBackgroundColorFormatter, {
  styles: {
    backgroundColor: /.+/
  }
});
var InlineTagFormatLoader = class extends Matcher {
  constructor(formatter, rule) {
    super(formatter, rule);
  }
  read() {
    return {
      formatter: this.target,
      value: true
    };
  }
};
var InlineElementFormatter = class {
  constructor(name, tagName, columned) {
    this.name = name;
    this.tagName = tagName;
    this.columned = columned;
    this.priority = 0;
  }
  render(children) {
    return new VElement(this.tagName, null, children);
  }
};
var boldFormatter = new InlineElementFormatter("bold", "strong", false);
var italicFormatter = new InlineElementFormatter("italic", "em", false);
var strikeThroughFormatter = new InlineElementFormatter("strikeThrough", "del", true);
var underlineFormatter = new InlineElementFormatter("underline", "u", true);
var subscriptFormatter = new InlineElementFormatter("subscript", "sub", false);
var superscriptFormatter = new InlineElementFormatter("superscript", "sup", false);
var codeFormatter = new InlineElementFormatter("code", "code", false);
var boldFormatLoader = new InlineTagFormatLoader(boldFormatter, {
  tags: ["strong", "b"],
  styles: {
    fontWeight: ["bold", "500", "600", "700", "800", "900"]
  },
  excludeStyles: {
    fontWeight: ["normal", "lighter", "100", "200", "300", "400"]
  }
});
var italicFormatLoader = new InlineTagFormatLoader(italicFormatter, {
  tags: ["em", "i"],
  styles: {
    fontStyle: ["italic"]
  },
  excludeStyles: {
    fontStyle: /(?!italic).+/
  }
});
var strikeThroughFormatLoader = new InlineTagFormatLoader(strikeThroughFormatter, {
  tags: ["strike", "del", "s"],
  styles: {
    textDecoration: /\bline-through\b/
  }
});
var underlineFormatLoader = new InlineTagFormatLoader(underlineFormatter, {
  tags: ["u"],
  styles: {
    textDecoration: /\bunderline\b/
  }
});
var subscriptFormatLoader = new InlineTagFormatLoader(subscriptFormatter, {
  tags: ["sub"]
});
var superscriptFormatLoader = new InlineTagFormatLoader(superscriptFormatter, {
  tags: ["sup"]
});
var codeFormatLoader = new InlineTagFormatLoader(codeFormatter, {
  tags: ["code"]
});
var InlineStyleFormatLoader = class extends Matcher {
  constructor(styleName, formatter, rule) {
    super(formatter, rule);
    this.styleName = styleName;
  }
  read(node) {
    return {
      formatter: this.target,
      value: this.extractFormatData(node, {
        styleName: this.styleName
      }).styles[this.styleName]
    };
  }
};
var InlineStyleFormatter = class {
  constructor(name, styleName) {
    this.name = name;
    this.styleName = styleName;
    this.priority = 0;
    this.columned = false;
  }
  render(children, formatValue) {
    return {
      fallbackTagName: "span",
      attach: (host) => {
        host.styles.set(this.styleName, formatValue);
      }
    };
  }
};
var letterSpacingFormatter = new InlineStyleFormatter("letterSpacing", "letterSpacing");
var fontFamilyFormatter = new InlineStyleFormatter("fontFamily", "fontFamily");
var lineHeightFormatter = new InlineStyleFormatter("lineHeight", "lineHeight");
var letterSpacingFormatLoader = new InlineStyleFormatLoader("letterSpacing", letterSpacingFormatter, {
  styles: {
    letterSpacing: /.+/
  }
});
var fontFamilyFormatLoader = new InlineStyleFormatLoader("fontFamily", fontFamilyFormatter, {
  styles: {
    fontFamily: /.+/
  }
});
var lineHeightFormatLoader = new InlineStyleFormatLoader("lineHeight", lineHeightFormatter, {
  styles: {
    lineHeight: /.+/
  }
});
var OuterStyleFormatLoader = class extends Matcher {
  constructor(styleName, formatter, rule) {
    super(formatter, rule);
    this.styleName = styleName;
  }
  read(node) {
    return {
      formatter: this.target,
      value: this.extractFormatData(node, {
        styleName: this.styleName
      }).styles[this.styleName]
    };
  }
};
var OuterStyleFormatter = class {
  constructor(name, styleName) {
    this.name = name;
    this.styleName = styleName;
    this.priority = 0;
    this.columned = false;
  }
  render(children, formatValue) {
    return {
      fallbackTagName: "span",
      attach: (host) => {
        host.styles.set(this.styleName, formatValue);
      }
    };
  }
};
var colorFormatter = new OuterStyleFormatter("color", "color");
var colorFormatLoader = new OuterStyleFormatLoader("color", colorFormatter, {
  styles: {
    color: /.+/
  }
});
var fontSizeFormatter = new OuterStyleFormatter("fontSize", "fontSize");
var fontSizeFormatLoader = new OuterStyleFormatLoader("fontSize", fontSizeFormatter, {
  styles: {
    fontSize: /.+/
  }
});
var InlineTagStyleFormatLoader = class extends Matcher {
  constructor(styleName, formatter, rule, forceMatchTags = false) {
    super(formatter, rule);
    this.styleName = styleName;
    this.forceMatchTags = forceMatchTags;
  }
  match(element) {
    if (this.forceMatchTags) {
      const reg = new RegExp(`^(${inlineTags.join("|")})$`, "i");
      if (!reg.test(element.tagName)) {
        return false;
      }
    }
    return super.match(element);
  }
  read(node) {
    return {
      formatter: this.target,
      value: this.extractFormatData(node, {
        styleName: this.styleName
      }).styles[this.styleName]
    };
  }
};
var InlineTagStyleFormatter = class {
  constructor(name, styleName) {
    this.name = name;
    this.styleName = styleName;
    this.columned = false;
    this.priority = 0;
  }
  render(children, formatValue) {
    if (children.length === 1 && children[0] instanceof VElement) {
      const node = children[0];
      if (node instanceof VElement) {
        const reg = new RegExp(`^(${inlineTags.join("|")})$`, "i");
        if (node && reg.test(node.tagName)) {
          node.styles.set(this.styleName, formatValue);
          return node;
        }
      }
    }
    return new VElement("span", {
      style: {
        [this.styleName]: formatValue
      }
    }, children);
  }
};
var InlineTagLeafStyleFormatter = class extends InlineTagStyleFormatter {
  constructor() {
    super(...arguments);
    this.columned = true;
  }
};
var verticalAlignFormatter = new InlineTagStyleFormatter("verticalAlign", "verticalAlign");
var textBackgroundColorFormatter = new InlineTagLeafStyleFormatter("textBackgroundColor", "backgroundColor");
var verticalAlignFormatLoader = new InlineTagStyleFormatLoader("verticalAlign", verticalAlignFormatter, {
  styles: {
    verticalAlign: /.+/
  }
}, true);
var textBackgroundColorFormatLoader = new InlineTagStyleFormatLoader("backgroundColor", textBackgroundColorFormatter, {
  styles: {
    backgroundColor: /.+/
  }
}, true);
function createStepSlot(injector) {
  const slot = new Slot([
    ContentType.Text,
    ContentType.InlineComponent,
    ContentType.BlockComponent
  ]);
  const title = blockComponent.createInstance(injector);
  title.slots.first.insert("\u6807\u9898", [
    [fontSizeFormatter, "18px"],
    [boldFormatter, true]
  ]);
  const content = paragraphComponent.createInstance(injector);
  content.slots.first.insert("\u63CF\u8FF0\u4FE1\u606F...");
  slot.insert(title);
  slot.insert(content);
  return slot;
}
var stepComponent = defineComponent({
  type: ContentType.BlockComponent,
  name: "StepComponent",
  setup(initData) {
    let state = (initData === null || initData === void 0 ? void 0 : initData.state) || {
      step: 0
    };
    const injector = useContext();
    const slots = useSlots((initData === null || initData === void 0 ? void 0 : initData.slots) || []);
    if (slots.length === 0) {
      slots.push(createStepSlot(injector));
    }
    const stateController = useState(state);
    const sub = stateController.onChange.subscribe((newState) => {
      state = newState;
    });
    onDestroy(() => {
      sub.unsubscribe();
    });
    return {
      render(slotRender, renderMode) {
        const currentStep = state.step;
        return VElement.createElement("tb-step", { step: state.step }, slots.toArray().map((slot, index) => {
          let state2 = "tb-waiting";
          if (index < currentStep) {
            state2 = "tb-complete";
          } else if (index === currentStep) {
            state2 = "tb-current";
          }
          return VElement.createElement(
            "div",
            { class: "tb-step-item " + state2 },
            VElement.createElement(
              "div",
              { class: "tb-step-item-header" },
              VElement.createElement("div", { class: "tb-step-item-line" }),
              VElement.createElement("div", { class: "tb-step-item-icon", onClick: () => {
                let step;
                if (index === currentStep) {
                  step = index + 1;
                } else if (index + 1 === currentStep) {
                  step = index - 1;
                } else {
                  step = index;
                }
                stateController.update((draft) => {
                  draft.step = step;
                });
              } }, index + 1)
            ),
            slotRender(slot, (children) => {
              return VElement.createElement("div", { class: "tb-step-item-content" }, children);
            }),
            renderMode === RenderMode.Editing && VElement.createElement("span", { class: "tb-step-item-add", onClick: () => {
              slots.insertByIndex(createStepSlot(injector), index + 1);
            } })
          );
        }));
      }
    };
  }
});
var stepComponentLoader = {
  match(element) {
    return element.nodeName.toLowerCase() === "tb-step";
  },
  read(element, context, slotParser) {
    return stepComponent.createInstance(context, {
      state: {
        step: Number(element.getAttribute("step")) || 0
      },
      slots: Array.from(element.children).map((child) => {
        return slotParser(new Slot([
          ContentType.BlockComponent,
          ContentType.InlineComponent,
          ContentType.Text
        ]), child.querySelector(".tb-step-item-content"));
      })
    });
  }
};
var TableComponentSelectionAwarenessDelegate = class TableComponentSelectionAwarenessDelegate2 extends CollaborateSelectionAwarenessDelegate {
  constructor(renderer, selection) {
    super();
    this.renderer = renderer;
    this.selection = selection;
  }
  getRects(abstractSelection) {
    const { focusSlot, anchorSlot } = abstractSelection;
    const focusPaths = this.selection.getPathsBySlot(focusSlot);
    const anchorPaths = this.selection.getPathsBySlot(anchorSlot);
    const focusIsStart = Selection.compareSelectionPaths(focusPaths, anchorPaths);
    let startSlot;
    let endSlot;
    if (focusIsStart) {
      startSlot = focusSlot;
      endSlot = anchorSlot;
    } else {
      startSlot = anchorSlot;
      endSlot = focusSlot;
    }
    const commonAncestorComponent = Selection.getCommonAncestorComponent(startSlot, endSlot);
    if ((commonAncestorComponent === null || commonAncestorComponent === void 0 ? void 0 : commonAncestorComponent.name) !== tableComponent.name) {
      return false;
    }
    const startFocusSlot = findFocusCell(commonAncestorComponent, startSlot);
    const endFocusSlot = findFocusCell(commonAncestorComponent, endSlot);
    const state = commonAncestorComponent.state;
    const { startPosition, endPosition } = selectCells(startFocusSlot, endFocusSlot, commonAncestorComponent, state.columnCount);
    const renderer = this.renderer;
    const startRect = renderer.getNativeNodeByVNode(renderer.getVNodeBySlot(startPosition.cell)).getBoundingClientRect();
    const endRect = renderer.getNativeNodeByVNode(renderer.getVNodeBySlot(endPosition.cell)).getBoundingClientRect();
    return [{
      left: startRect.left,
      top: startRect.top,
      width: endRect.left + endRect.width - startRect.left,
      height: endRect.top + endRect.height - startRect.top
    }];
  }
};
TableComponentSelectionAwarenessDelegate = __decorate3([
  Injectable(),
  __metadata3("design:paramtypes", [
    Renderer,
    Selection
  ])
], TableComponentSelectionAwarenessDelegate);
var tableComponent = defineComponent({
  type: ContentType.BlockComponent,
  name: "TableComponent",
  separable: false,
  setup(data = {
    slots: Array.from({ length: 9 }).fill(null).map(() => createCell()),
    state: {
      columnCount: 3,
      rowCount: 3,
      useTextbusStyle: false
    }
  }) {
    var _a2;
    let tableCells = slotsToTable(data.slots || [], data.state.columnCount);
    const injector = useContext();
    const i18n = injector.get(I18n);
    const selection = injector.get(Selection);
    const commander = injector.get(Commander);
    let tableInfo = {
      columnCount: tableCells[0].map((i2) => i2.state.colspan).reduce((v2, n2) => v2 + n2, 0),
      useTextbusStyle: ((_a2 = data.state) === null || _a2 === void 0 ? void 0 : _a2.useTextbusStyle) || false,
      rowCount: tableCells.length
    };
    const stateController = useState(tableInfo);
    stateController.onChange.subscribe((s2) => {
      tableInfo = s2;
    });
    const self2 = useSelf();
    const slots = useSlots(tableCells.flat());
    let startPosition;
    let endPosition;
    let hasMultipleCell = false;
    useTableMultipleRange(slots, stateController, tableInfo, (tableRange) => {
      startPosition = tableRange.startPosition;
      endPosition = tableRange.endPosition;
      const is = tableRange.selectedCells.length > 1;
      if (is !== hasMultipleCell) {
        hasMultipleCell = is;
        self2.changeMarker.forceMarkDirtied();
      }
    });
    onSlotRemove((ev) => {
      ev.preventDefault();
    });
    onContextMenu((event) => {
      event.useMenus([{
        iconClasses: ["textbus-icon-table"],
        label: i18n.get("components.tableComponent.contextMenuLabel"),
        submenu: [{
          iconClasses: ["textbus-icon-table-add-column-left"],
          label: i18n.get("components.tableComponent.addColumnToLeft"),
          onClick() {
            instance.addColumnToLeft();
          }
        }, {
          iconClasses: ["textbus-icon-table-add-column-right"],
          label: i18n.get("components.tableComponent.addColumnToRight"),
          onClick() {
            instance.addColumnToRight();
          }
        }, {
          iconClasses: ["textbus-icon-table-add-row-top"],
          label: i18n.get("components.tableComponent.insertRowBefore"),
          onClick() {
            instance.addRowToTop();
          }
        }, {
          iconClasses: ["textbus-icon-table-add-row-bottom"],
          label: i18n.get("components.tableComponent.insertRowAfter"),
          onClick() {
            instance.addRowToBottom();
          }
        }, {
          iconClasses: ["textbus-icon-table-delete-column-left"],
          label: i18n.get("components.tableComponent.deleteColumns"),
          onClick() {
            instance.deleteColumns();
          }
        }, {
          iconClasses: ["textbus-icon-table-delete-row-top"],
          label: i18n.get("components.tableComponent.deleteRows"),
          onClick() {
            instance.deleteRows();
          }
        }, {
          iconClasses: ["textbus-icon-table-split-columns"],
          label: i18n.get("components.tableComponent.mergeCells"),
          onClick() {
            instance.mergeCells();
          }
        }, {
          iconClasses: ["textbus-icon-table"],
          label: i18n.get("components.tableComponent.splitCells"),
          onClick() {
            instance.splitCells();
          }
        }]
      }, {
        iconClasses: ["textbus-icon-table-remove"],
        label: i18n.get("components.tableComponent.contextMenuRemoveTable"),
        onClick() {
          commander.removeComponent(self2);
        }
      }]);
    });
    const ComponentToolbar = useComponentToolbar();
    const instance = {
      mergeCells() {
        if (!startPosition || !endPosition) {
          return;
        }
        const serializedCells = serialize(tableCells);
        const minRow = startPosition.rowIndex;
        const minColumn = startPosition.columnIndex;
        const maxRow = endPosition.rowIndex + 1;
        const maxColumn = endPosition.columnIndex + 1;
        const selectedCells = serializedCells.slice(minRow, maxRow).map((row) => row.cellsPosition.slice(minColumn, maxColumn).filter((c2) => {
          return c2.offsetRow === 0 && c2.offsetColumn === 0;
        })).reduce((p2, n2) => {
          return p2.concat(n2);
        });
        const newNode = selectedCells.shift();
        newNode.cell.updateState((draft) => {
          draft.rowspan = maxRow - minRow;
          draft.colspan = maxColumn - minColumn;
        });
        selectedCells.forEach((cell) => {
          var _a3;
          slots.remove(cell.cell);
          const lastContent2 = cell.cell.getContentAtIndex(cell.cell.length - 1);
          if (cell.cell.isEmpty || cell.cell.length === 1 && typeof lastContent2 !== "string" && ((_a3 = lastContent2.slots.last) === null || _a3 === void 0 ? void 0 : _a3.isEmpty)) {
            return;
          }
          const slot = newNode.cell;
          const index = slot.isEmpty ? 0 : slot.length;
          slot.retain(index);
          cell.cell.cutTo(slot);
          slot.retain(index);
        });
        const lastContent = newNode.cell.getContentAtIndex(newNode.cell.length - 1);
        if (typeof lastContent !== "string") {
          const lastContentSlot = lastContent.slots.first;
          selection.setPosition(lastContentSlot, lastContentSlot.length);
        } else {
          selection.setPosition(newNode.cell, 0);
        }
      },
      splitCells() {
        if (!startPosition || !endPosition) {
          return;
        }
        const serializedCells = serialize(tableCells);
        const minRow = startPosition.rowIndex;
        const minColumn = startPosition.columnIndex;
        const maxRow = endPosition.rowIndex + 1;
        const maxColumn = endPosition.columnIndex + 1;
        const table = serializedCells.map((tr, i2) => {
          if (i2 < minRow || i2 >= maxRow) {
            return tr.cellsPosition.map((i3) => i3.cell);
          }
          return tr.cellsPosition.map((td, index) => {
            if (index < minColumn || index >= maxColumn) {
              return td.cell;
            }
            if (td.offsetRow === 0 && td.offsetColumn === 0) {
              const state = td.cell.state;
              if (state.rowspan > 1 || state.colspan > 1) {
                td.cell.updateState((draft) => {
                  draft.rowspan = 1;
                  draft.colspan = 1;
                });
              }
              return td.cell;
            }
            return createCell();
          });
        });
        const cells = Array.from(new Set(table.flat()));
        cells.forEach((newCell, index) => {
          const cell = slots.get(index);
          if (cell === newCell) {
            return;
          }
          slots.insertByIndex(newCell, index);
        });
      },
      deleteColumns() {
        if (!startPosition || !endPosition) {
          return;
        }
        const startIndex = startPosition.columnIndex;
        const endIndex = endPosition.columnIndex;
        instance.deleteColumnByIndex(startIndex, endIndex);
      },
      deleteRows() {
        if (!startPosition || !endPosition) {
          return;
        }
        const startIndex = startPosition.rowIndex;
        const endIndex = endPosition.rowIndex;
        instance.deleteRowByIndex(startIndex, endIndex);
      },
      addRowToBottom() {
        if (!startPosition || !endPosition) {
          return;
        }
        this.insertRow(endPosition.rowIndex + 1);
      },
      addRowToTop() {
        if (!startPosition || !endPosition) {
          return;
        }
        this.insertRow(startPosition.rowIndex);
      },
      addColumnToRight() {
        if (!startPosition || !endPosition) {
          return;
        }
        this.insertColumn(endPosition.columnIndex + 1);
      },
      addColumnToLeft() {
        if (!startPosition || !endPosition) {
          return;
        }
        this.insertColumn(startPosition.columnIndex);
      },
      deleteColumnByIndex(startIndex, endIndex) {
        var _a3, _b2;
        if (tableInfo.columnCount === 1) {
          (_a3 = self2.parent) === null || _a3 === void 0 ? void 0 : _a3.removeComponent(self2);
          return;
        }
        const serializedCells = serialize(tableCells);
        stateController.update((draft) => {
          draft.columnCount = tableInfo.columnCount - (endIndex - startIndex + 1);
        });
        serializedCells.forEach((tr) => {
          for (let i2 = startIndex; i2 <= endIndex; i2++) {
            const td = tr.cellsPosition[i2];
            const startColumnIndex = td.columnIndex - td.offsetColumn;
            if (startColumnIndex < startIndex) {
              if (startColumnIndex + td.cell.state.colspan > endIndex) {
                td.cell.updateState((draft) => {
                  draft.colspan = td.cell.state.colspan - (endIndex - startIndex + 1);
                });
              } else {
                td.cell.updateState((draft) => {
                  draft.colspan = startIndex - td.columnIndex;
                });
              }
            } else if (startColumnIndex + td.cell.state.colspan - 1 > endIndex) {
              td.cell.updateState((draft) => {
                draft.colspan = td.cell.state.colspan - (endIndex - startIndex + 1);
              });
              td.cell.cut();
            } else {
              const index = td.row.indexOf(td.cell);
              if (index > -1) {
                td.row.splice(index, 1);
              }
              slots.remove(td.cell);
            }
          }
        });
        if (slots.length === 0) {
          (_b2 = self2.parent) === null || _b2 === void 0 ? void 0 : _b2.removeComponent(self2);
        }
      },
      deleteRowByIndex(startIndex, endIndex) {
        var _a3, _b2;
        if (tableInfo.rowCount === 1) {
          (_a3 = self2.parent) === null || _a3 === void 0 ? void 0 : _a3.removeComponent(self2);
          return;
        }
        const serializedCells = serialize(tableCells);
        stateController.update((draft) => {
          draft.rowCount = tableInfo.rowCount - (endIndex - startIndex + 1);
        });
        for (let i2 = startIndex; i2 <= endIndex; i2++) {
          const tr = serializedCells[i2];
          tr.cellsPosition.forEach((td) => {
            const startRowIndex = td.rowIndex - td.offsetRow;
            if (startRowIndex < startIndex) {
              if (startRowIndex + td.cell.state.rowspan > endIndex) {
                td.cell.updateState((draft) => {
                  draft.rowspan = td.cell.state.rowspan - (endIndex - startIndex + 1);
                });
              } else {
                td.cell.updateState((draft) => {
                  draft.rowspan = startIndex - td.rowIndex;
                });
              }
            } else if (startRowIndex + td.cell.state.rowspan - 1 > endIndex) {
              td.cell.updateState((draft) => {
                draft.rowspan = td.cell.state.rowspan - (endIndex - startIndex + 1);
              });
              td.cell.cut();
              const nextTr = serializedCells[i2 + 1];
              const afterTd = nextTr.cellsPosition.find((td2) => td2.cell === td.cell);
              afterTd.row.splice(afterTd.row.indexOf(afterTd.cell), 0, td.cell);
            } else {
              slots.remove(td.cell);
            }
          });
        }
        if (slots.length === 0) {
          (_b2 = self2.parent) === null || _b2 === void 0 ? void 0 : _b2.removeComponent(self2);
        }
      },
      insertRow(index) {
        const serializedCells = serialize(tableCells);
        const tr = [];
        stateController.update((draft) => {
          draft.rowCount = tableInfo.rowCount + 1;
        });
        if (index === 0 || index === serializedCells.length) {
          for (let i2 = 0; i2 < tableInfo.columnCount; i2++) {
            tr.push(createCell());
          }
          if (index === 0) {
            slots.insertByIndex(tr, 0);
          } else {
            slots.insertByIndex(tr, slots.length);
          }
          return;
        }
        const row = serializedCells[index];
        row.cellsPosition.forEach((cell) => {
          if (cell.offsetRow > 0) {
            if (cell.offsetColumn === 0) {
              cell.cell.updateState((draft) => {
                draft.rowspan = cell.cell.state.rowspan + 1;
              });
            }
          } else {
            tr.push(createCell());
          }
        });
        tableCells.splice(tableCells.indexOf(row.cells), 0, tr);
        const result = Array.from(new Set(tableCells.flat()));
        result.forEach((newCell, index2) => {
          const cell = slots.get(index2);
          if (cell === newCell) {
            return;
          }
          slots.insertByIndex(newCell, index2);
        });
      },
      insertColumn(index) {
        if (index < 0) {
          index = 0;
        }
        if (index > tableInfo.columnCount) {
          index = tableInfo.columnCount;
        }
        const serializedCells = serialize(tableCells);
        const table = serializedCells.map((tr) => {
          return tr.cellsPosition.map((td) => {
            return td.cell;
          });
        });
        const recordCells = [];
        serializedCells.forEach((row, rowIndex) => {
          if (index === 0) {
            table[rowIndex].unshift(createCell());
          } else if (index === tableInfo.columnCount) {
            table[rowIndex].push(createCell());
          } else {
            const cell = row.cellsPosition[index];
            if (cell.offsetColumn > 0) {
              if (recordCells.includes(cell.cell)) {
                return;
              }
              cell.cell.updateState((draft) => {
                draft.colspan = cell.cell.state.colspan + 1;
              });
              recordCells.push(cell.cell);
            } else {
              table[rowIndex].splice(index, 0, createCell());
            }
          }
        });
        const cells = table.flat();
        const result = Array.from(new Set(cells));
        result.forEach((newCell, index2) => {
          const cell = slots.get(index2);
          if (cell === newCell) {
            return;
          }
          slots.insertByIndex(newCell, index2);
        });
        stateController.update((draft) => {
          draft.columnCount = tableInfo.columnCount + 1;
        });
        tableCells = slotsToTable(slots.toArray(), tableInfo.columnCount);
      },
      render(slotRender, renderMode) {
        tableCells = slotsToTable(slots.toArray(), tableInfo.columnCount);
        const table = VElement.createElement(
          "table",
          { class: "tb-table" + (data.state.useTextbusStyle ? " tb-table-textbus" : "") + (hasMultipleCell ? " td-table-multiple-select" : "") },
          VElement.createElement("tbody", null, tableCells.map((row) => {
            return VElement.createElement("tr", null, row.map((col) => {
              return slotRender(col, (children) => {
                var _a3, _b2;
                return VElement.createElement("td", { colSpan: (_a3 = col.state) === null || _a3 === void 0 ? void 0 : _a3.colspan, rowSpan: (_b2 = col.state) === null || _b2 === void 0 ? void 0 : _b2.rowspan }, children);
              });
            }));
          }))
        );
        return VElement.createElement(
          "div",
          { "data-component": tableComponent.name },
          renderMode === RenderMode.Editing ? VElement.createElement(
            ComponentToolbar,
            null,
            VElement.createElement(
              "button",
              { type: "button", title: i18n.get("components.tableComponent.addColumnToLeft"), class: "textbus-toolbar-button", onClick: () => {
                instance.addColumnToLeft();
              } },
              VElement.createElement("span", { class: "textbus-icon-table-add-column-left" })
            ),
            VElement.createElement(
              "button",
              { type: "button", title: i18n.get("components.tableComponent.addColumnToRight"), class: "textbus-toolbar-button", onClick: () => {
                instance.addColumnToRight();
              } },
              VElement.createElement("span", { class: "textbus-icon-table-add-column-right" })
            ),
            VElement.createElement(
              "button",
              { type: "button", title: i18n.get("components.tableComponent.insertRowBefore"), class: "textbus-toolbar-button", onClick: () => {
                instance.addRowToTop();
              } },
              VElement.createElement("span", { class: "textbus-icon-table-add-row-top" })
            ),
            VElement.createElement(
              "button",
              { type: "button", title: i18n.get("components.tableComponent.insertRowAfter"), class: "textbus-toolbar-button", onClick: () => {
                instance.addRowToBottom();
              } },
              VElement.createElement("span", { class: "textbus-icon-table-add-row-bottom" })
            ),
            VElement.createElement("span", { class: "textbus-toolbar-split-line" }),
            VElement.createElement(
              "button",
              { type: "button", title: i18n.get("components.tableComponent.deleteColumns"), class: "textbus-toolbar-button", onClick: () => {
                instance.deleteColumns();
              } },
              VElement.createElement("span", { class: "textbus-icon-table-delete-column-left" })
            ),
            VElement.createElement(
              "button",
              { type: "button", title: i18n.get("components.tableComponent.deleteRows"), class: "textbus-toolbar-button", onClick: () => {
                instance.deleteRows();
              } },
              VElement.createElement("span", { class: "textbus-icon-table-delete-row-top" })
            ),
            VElement.createElement("span", { class: "textbus-toolbar-split-line" }),
            VElement.createElement(
              "button",
              { type: "button", title: i18n.get("components.tableComponent.mergeCells"), class: "textbus-toolbar-button", onClick: () => {
                instance.mergeCells();
              } },
              VElement.createElement("span", { class: "textbus-icon-table-split-columns" })
            ),
            VElement.createElement(
              "button",
              { type: "button", title: i18n.get("components.tableComponent.splitCells"), class: "textbus-toolbar-button", onClick: () => {
                instance.splitCells();
              } },
              VElement.createElement("span", { class: "textbus-icon-table" })
            ),
            VElement.createElement("span", { class: "textbus-toolbar-split-line" }),
            VElement.createElement(
              "button",
              { type: "button", title: i18n.get("components.tableComponent.contextMenuRemoveTable"), class: "textbus-toolbar-button", onClick: () => {
                commander.removeComponent(self2);
              } },
              VElement.createElement("span", { class: "textbus-icon-table-remove" })
            )
          ) : null,
          table
        );
      }
    };
    return instance;
  }
});
var tableComponentLoader = {
  match(element) {
    return element.tagName === "TABLE" || element.tagName === "DIV" && element.dataset.component === tableComponent.name;
  },
  read(element, injector, slotParser) {
    if (element.tagName === "DIV") {
      element = element.children[0];
    }
    const { tHead, tBodies, tFoot } = element;
    const headers = [];
    const bodies = [];
    if (tHead) {
      Array.from(tHead.rows).forEach((row) => {
        const arr = [];
        headers.push(arr);
        Array.from(row.cells).forEach((cell) => {
          const slot = createCell(cell.colSpan, cell.rowSpan);
          arr.push(slot);
          slotParser(slot, cell);
        });
      });
    }
    if (tBodies) {
      Array.of(...Array.from(tBodies), tFoot || { rows: [] }).reduce((value, next) => {
        return value.concat(Array.from(next.rows));
      }, []).forEach((row) => {
        const arr = [];
        bodies.push(arr);
        Array.from(row.cells).forEach((cell) => {
          const slot = createCell(cell.colSpan, cell.rowSpan);
          arr.push(slot);
          slotParser(slot, cell);
        });
      });
    }
    bodies.unshift(...headers);
    const cells = autoComplete(bodies);
    return tableComponent.createInstance(injector, {
      slots: bodies.flat(),
      state: {
        useTextbusStyle: element.classList.contains("tb-table-textbus"),
        columnCount: cells[0].map((i2) => i2.state.colspan).reduce((v2, n2) => v2 + n2, 0),
        rowCount: cells.length
      }
    });
  }
};
var timelineTypes = ["primary", "info", "success", "warning", "danger", "dark", "gray"];
function createTimelineItem(injector, type = "primary") {
  const slot = new Slot([
    ContentType.BlockComponent,
    ContentType.Text,
    ContentType.InlineComponent
  ], {
    type
  });
  const title = blockComponent.createInstance(injector);
  title.slots.first.insert("\u65F6\u95F4\u4E3B\u9898", [
    [fontSizeFormatter, "18px"],
    [boldFormatter, true]
  ]);
  title.slots.first.insert(" 2020-02-02", [
    [fontSizeFormatter, "15px"],
    [colorFormatter, "#777"]
  ]);
  const desc = paragraphComponent.createInstance(injector);
  desc.slots.first.insert("\u63CF\u8FF0\u4FE1\u606F...");
  slot.insert(title);
  slot.insert(desc);
  return slot;
}
var timelineComponent = defineComponent({
  type: ContentType.BlockComponent,
  name: "TimelineComponent",
  setup(initData) {
    const injector = useContext();
    const slots = useSlots((initData === null || initData === void 0 ? void 0 : initData.slots) || [
      createTimelineItem(injector)
    ]);
    if (slots.length === 0) {
      slots.push(createTimelineItem(injector));
    }
    return {
      render(slotRender, renderMode) {
        return VElement.createElement("tb-timeline", null, slots.toArray().map((slot) => {
          const type = slot.state.type;
          const classes = ["tb-timeline-item"];
          if (type) {
            classes.push("tb-timeline-item-" + type);
          }
          return VElement.createElement(
            "div",
            { class: classes.join(" ") },
            VElement.createElement("div", { class: "tb-timeline-line" }),
            VElement.createElement("div", { class: "tb-timeline-icon", title: renderMode === RenderMode.Editing ? null : "\u70B9\u51FB\u5207\u6362\u989C\u8272", onClick: () => {
              if (!type) {
                slot.updateState((draft) => {
                  draft.type = timelineTypes[0];
                });
              } else {
                slot.updateState((draft) => {
                  draft.type = timelineTypes[timelineTypes.indexOf(type) + 1] || null;
                });
              }
            } }),
            renderMode === RenderMode.Editing && VElement.createElement("span", { class: "tb-timeline-add", onClick: () => {
              const index = slots.indexOf(slot) + 1;
              slots.insertByIndex(createTimelineItem(injector, type), index);
            } }),
            slotRender(slot, (children) => {
              return VElement.createElement("div", { class: "tb-timeline-content" }, children);
            })
          );
        }));
      }
    };
  }
});
var timelineComponentLoader = {
  match(element) {
    return element.nodeName.toLowerCase() === "tb-timeline";
  },
  read(element, context, slotParser) {
    return timelineComponent.createInstance(context, {
      slots: Array.from(element.children).map((child) => {
        let type = "primary";
        for (const k2 of timelineTypes) {
          if (child.classList.contains("tb-timeline-item-" + k2)) {
            type = k2;
            break;
          }
        }
        const slot = new Slot([
          ContentType.InlineComponent,
          ContentType.Text,
          ContentType.BlockComponent
        ], {
          type
        });
        return slotParser(slot, child.querySelector("div.tb-timeline-content") || document.createElement("div"));
      })
    });
  }
};
var todolistComponent = defineComponent({
  type: ContentType.BlockComponent,
  name: "TodolistComponent",
  separable: true,
  zenCoding: {
    match: /^-\s\[(x|\s)?\\]$/,
    key: " ",
    generateInitData(content) {
      const isChecked = content.charAt(3) === "x";
      return {
        slots: [
          new Slot([
            ContentType.Text,
            ContentType.InlineComponent
          ], {
            active: isChecked,
            disabled: false
          })
        ]
      };
    }
  },
  setup(initData) {
    const { Text, InlineComponent } = ContentType;
    const slots = useSlots(initData.slots || [
      new Slot([Text, InlineComponent])
    ]);
    if (slots.length === 0) {
      slots.push(new Slot([Text, InlineComponent]));
    }
    const injector = useContext();
    const self2 = useSelf();
    const selection = injector.get(Selection);
    const commander = injector.get(Commander);
    onBreak((ev) => {
      const slot = ev.target;
      const index = ev.data.index;
      ev.preventDefault();
      if (slot.isEmpty && index === 0 && slots.length > 1 && slot === slots.last) {
        const p2 = paragraphComponent.createInstance(injector);
        commander.insertAfter(p2, self2);
        slots.remove(slot);
        const firstSlot = p2.slots.get(0);
        selection.setPosition(firstSlot, 0);
      } else {
        const nextSlot = slot.cut(index);
        slots.insertAfter(nextSlot, slot);
        selection.setPosition(nextSlot, 0);
      }
    });
    const stateCollection = [{
      active: false,
      disabled: false
    }, {
      active: true,
      disabled: false
    }, {
      active: false,
      disabled: true
    }, {
      active: true,
      disabled: true
    }];
    function getStateIndex(active, disabled) {
      for (let i2 = 0; i2 < 4; i2++) {
        const item = stateCollection[i2];
        if (item.active === active && item.disabled === disabled) {
          return i2;
        }
      }
      return -1;
    }
    return {
      render(slotRender) {
        return VElement.createElement("tb-todolist", null, slots.toArray().map((slot) => {
          const state = slot.state;
          const classes = ["tb-todolist-state"];
          if (state.active) {
            classes.push("tb-todolist-state-active");
          }
          if (state.disabled) {
            classes.push("tb-todolist-state-disabled");
          }
          return VElement.createElement(
            "div",
            { class: "tb-todolist-item" },
            VElement.createElement(
              "div",
              { class: "tb-todolist-btn" },
              VElement.createElement("div", { class: classes.join(" "), onClick: () => {
                const i2 = (getStateIndex(state.active, state.disabled) + 1) % 4;
                const newState = stateCollection[i2];
                slot.updateState((draft) => {
                  draft.active = newState.active;
                  draft.disabled = newState.disabled;
                });
              } })
            ),
            slotRender(slot, (children) => {
              return VElement.createElement("div", { class: "tb-todolist-content" }, children);
            })
          );
        }));
      }
    };
  }
});
var todolistComponentLoader = {
  match(element) {
    return element.nodeName.toLowerCase() === "tb-todolist";
  },
  read(element, context, slotParser) {
    const listConfig = Array.from(element.children).map((child) => {
      const stateElement = child.querySelector(".tb-todolist-state");
      return {
        childSlot: child.querySelector(".tb-todolist-content"),
        slot: new Slot([
          ContentType.Text,
          ContentType.InlineComponent
        ], {
          active: !!(stateElement === null || stateElement === void 0 ? void 0 : stateElement.classList.contains("tb-todolist-state-active")),
          disabled: !!(stateElement === null || stateElement === void 0 ? void 0 : stateElement.classList.contains("tb-todolist-state-disabled"))
        })
      };
    });
    return todolistComponent.createInstance(context, {
      slots: listConfig.map((i2) => {
        return slotParser(i2.slot, i2.childSlot);
      })
    });
  }
};
var videoComponent = defineComponent({
  name: "VideoComponent",
  type: ContentType.InlineComponent,
  setup(data) {
    let state = (data === null || data === void 0 ? void 0 : data.state) || {
      src: "",
      autoplay: false,
      controls: true,
      width: "100%",
      height: ""
    };
    const controller = useState(state);
    controller.onChange.subscribe((s2) => {
      state = s2;
    });
    const ref = useRef();
    useDragResize(ref, (rect) => {
      state = controller.update((draft) => {
        Object.assign(draft, rect);
      });
    });
    return {
      render() {
        const vNode = VElement.createElement("video", { src: state.src, ref, controls: state.controls, style: {
          width: state.width,
          height: state.height
        } });
        if (state.autoplay) {
          vNode.attrs.set("autoPlay", "autoplay");
        }
        return vNode;
      },
      mergeProps(props) {
        state = controller.update((draft) => {
          Object.assign(draft, props);
        });
      }
    };
  }
});
var videoComponentLoader = {
  match(element) {
    return element.nodeName.toLowerCase() === "video";
  },
  read(element, context) {
    return videoComponent.createInstance(context, {
      state: {
        src: element.src,
        width: element.style.width || element.width + "",
        height: element.style.height || element.height + "",
        autoplay: element.autoplay,
        controls: element.controls
      }
    });
  }
};
var wordExplainComponent = defineComponent({
  type: ContentType.BlockComponent,
  name: "WordExplainComponent",
  separable: false,
  setup(initData) {
    const slots = useSlots((initData === null || initData === void 0 ? void 0 : initData.slots) || []);
    let state = (initData === null || initData === void 0 ? void 0 : initData.state) || {
      width: "140px"
    };
    while (slots.length < 3) {
      slots.push(new Slot([ContentType.Text, ContentType.InlineComponent]));
    }
    const stateController = useState(state);
    const sub = stateController.onChange.subscribe((newState) => {
      state = newState;
    });
    const injector = useContext();
    const commander = injector.get(Commander);
    const i18n = injector.get(I18n);
    const dialog = injector.get(Dialog);
    const self2 = useSelf();
    onDestroy(() => {
      sub.unsubscribe();
    });
    onSlotRemove((ev) => {
      ev.preventDefault();
    });
    const childI18n = i18n.getContext("components.wordExplainComponent.setter");
    function setting() {
      const form = new Form({
        title: childI18n.get("title"),
        confirmBtnText: childI18n.get("confirmBtnText"),
        cancelBtnText: childI18n.get("cancelBtnText"),
        items: [
          new FormTextField({
            name: "width",
            value: state.width,
            placeholder: childI18n.get("widthInputPlaceholder"),
            label: childI18n.get("widthLabel")
          })
        ]
      });
      dialog.show(form.elementRef);
      const sub2 = form.onComplete.subscribe((data) => {
        stateController.update((draft) => {
          draft.width = data.width;
        });
        dialog.hide();
        sub2.unsubscribe();
      });
      sub2.add(form.onCancel.subscribe(() => {
        dialog.hide();
        sub2.unsubscribe();
      }));
    }
    onContextMenu((event) => {
      event.useMenus([{
        label: childI18n.get("title"),
        onClick() {
          setting();
        }
      }]);
    });
    return {
      render(slotRenderFn, renderMode) {
        return VElement.createElement(
          "tb-word-explain",
          null,
          VElement.createElement(
            "div",
            { class: "tb-word-explain-title-group", style: { width: state.width } },
            slotRenderFn(slots.get(0), (children) => {
              return VElement.createElement("div", { class: "tb-word-explain-title" }, children);
            }),
            slotRenderFn(slots.get(1), (children) => {
              return VElement.createElement("div", { class: "tb-word-explain-subtitle" }, children);
            })
          ),
          slotRenderFn(slots.get(2), (children) => {
            return VElement.createElement("div", { class: "tb-word-explain-detail" }, children);
          }),
          renderMode === RenderMode.Editing && VElement.createElement("span", { class: "tb-word-explain-close", onClick: () => {
            commander.removeComponent(self2);
          } })
        );
      }
    };
  }
});
var wordExplainComponentLoader = {
  match(element) {
    return element.nodeName.toLowerCase() === "tb-word-explain";
  },
  read(element, context, slotParser) {
    const title = element.querySelector(".tb-word-explain-title");
    const subtitle = element.querySelector(".tb-word-explain-subtitle");
    const detail = element.querySelector(".tb-word-explain-detail");
    const { Text, InlineComponent } = ContentType;
    const titleSlot = new Slot([Text, InlineComponent]);
    const subtitleSlot = new Slot([Text, InlineComponent]);
    const detailSlot = new Slot([Text, InlineComponent]);
    const width = element.querySelector(".tb-word-explain-title-group").style.width;
    slotParser(titleSlot, title);
    slotParser(subtitleSlot, subtitle);
    slotParser(detailSlot, detail);
    return wordExplainComponent.createInstance(context, {
      state: {
        width
      },
      slots: [
        titleSlot,
        subtitleSlot,
        detailSlot
      ]
    });
  }
};
var i18n_en_US = {
  editor: {
    noSelection: "please select the location to insert the resource first!",
    copy: "copy",
    paste: "paste",
    cut: "cut",
    selectAll: "select all",
    insertParagraphAfter: "insert paragraph to after",
    insertParagraphBefore: "insert paragraph to before",
    input: {
      canNotAccessClipboard: "can not access to the clipboard!"
    },
    noUploader: "please add upload function to editor options!"
  },
  plugins: {
    toolbar: {
      audioTool: {
        tooltip: "audio",
        view: {
          title: "audio setting",
          addressLabel: "URL",
          addressPlaceholder: "audio url",
          uploadBtnText: "upload audio",
          errorMessage: "fields is required.",
          switchLabel: "autoplay",
          confirmBtnText: "ok",
          cancelBtnText: "cancel"
        }
      },
      blockBackgroundColorTool: {
        tooltip: "block background",
        view: {
          btnText: "ok",
          paletteText: "palette"
        }
      },
      blockMarginTool: {
        label: "block margin",
        tooltip: "block margin",
        view: {
          topLabel: "margin top",
          topPlaceholder: "margin top",
          rightLabel: "margin right",
          rightPlaceholder: "margin right",
          bottomLabel: "margin bottom",
          bottomPlaceholder: "margin bottom",
          leftLabel: "margin left",
          leftPlaceholder: "margin left",
          confirmBtnText: "ok",
          cancelBtnText: "cancel"
        }
      },
      blockPaddingTool: {
        label: "padding",
        tooltip: "padding",
        view: {
          topLabel: "padding top",
          topPlaceholder: "padding top",
          rightLabel: "padding right",
          rightPlaceholder: "padding right",
          bottomLabel: "padding bottom",
          bottomPlaceholder: "padding bottom",
          leftLabel: "padding left",
          leftPlaceholder: "padding left",
          confirmBtnText: "ok",
          cancelBtnText: "cancel"
        }
      },
      blockquoteTool: {
        tooltip: "blockquote"
      },
      formatPainterTool: {
        tooltip: "format painter"
      },
      boldTool: {
        tooltip: "bold"
      },
      cleanTool: {
        tooltip: "clean format"
      },
      codeTool: {
        tooltip: "Code"
      },
      colorTool: {
        tooltip: "text color",
        view: {
          btnText: "ok",
          recentText: "recent colors",
          backText: "back",
          paletteText: "palette"
        }
      },
      emojiTool: {
        tooltip: "emoji"
      },
      findTool: {
        tooltip: "find and replace",
        view: {
          findLabel: "find",
          findPlaceholder: "find content",
          nextBtnText: "next",
          replaceLabel: "replace",
          replacePlaceholder: "replace to",
          replaceBtnText: "replace",
          replaceAllBtnText: "replace all"
        }
      },
      fontFamilyTool: {
        tooltip: "font family",
        defaultFamilyText: "inherit"
      },
      fontSizeTool: {
        tooltip: "font size",
        defaultSizeText: "inherit"
      },
      headingTool: {
        tooltip: "paragraph and heading",
        h1: "heading 1",
        h2: "heading 2",
        h3: "heading 3",
        h4: "heading 4",
        h5: "heading 5",
        h6: "heading 6",
        div: "div",
        paragraph: "paragraph"
      },
      historyBackTool: {
        tooltip: "back"
      },
      historyForwardTool: {
        tooltip: "forward"
      },
      imageTool: {
        tooltip: "upload picture",
        view: {
          linkLabel: "URL",
          linkInputPlaceholder: "image url",
          uploadLabel: "upload",
          uploadBtnText: "upload image",
          confirmBtnText: "ok"
        }
      },
      inlineMarginTool: {
        label: "inline margin",
        tooltip: "inline margin",
        view: {
          topLabel: "margin top",
          topPlaceholder: "margin top",
          rightLabel: "margin right",
          rightPlaceholder: "margin right",
          bottomLabel: "margin bottom",
          bottomPlaceholder: "margin bottom",
          leftLabel: "margin left",
          leftPlaceholder: "margin left",
          confirmBtnText: "ok",
          cancelBtnText: "cancel"
        }
      },
      inlinePaddingTool: {
        label: "inline padding",
        tooltip: "inline padding",
        view: {
          topLabel: "padding top",
          topPlaceholder: "padding top",
          rightLabel: "padding right",
          rightPlaceholder: "padding right",
          bottomLabel: "padding bottom",
          bottomPlaceholder: "padding bottom",
          leftLabel: "padding left",
          leftPlaceholder: "padding left",
          confirmBtnText: "ok",
          cancelBtnText: "cancel"
        }
      },
      insertObjectTool: {
        sourceCode: "source code",
        lineHeight: "line height",
        letterSpacing: "letter spacing",
        blockBackgroundColor: "block background color",
        emoji: "emoji",
        audio: "audio...",
        video: "video...",
        subscript: "subscript",
        superscript: "superscript",
        code: "Code",
        blockquote: "blockquote",
        leftToRight: "ltr",
        rightToLeft: "rtl"
      },
      insertParagraphAfterTool: {
        tooltip: "insert paragraph to after"
      },
      insertParagraphBeforeTool: {
        tooltip: "insert paragraph to before"
      },
      italicTool: {
        tooltip: "italic"
      },
      leftToRightTool: {
        tooltip: "ltr"
      },
      letterSpacingTool: {
        tooltip: "letter spacing",
        defaultValueLabel: "inherit"
      },
      lineHeightTool: {
        tooltip: "line height",
        defaultValueLabel: "inherit"
      },
      linkTool: {
        tooltip: "link",
        view: {
          linkLabel: "link url",
          linkInputPlaceholder: "url address",
          jumpLabel: "target",
          jumpSelfLabel: "_self",
          jumpBlankLabel: "_blank",
          invalidMessage: "url is invalid"
        }
      },
      olTool: {
        tooltip: "ol"
      },
      preTool: {
        tooltip: "pre",
        defaultLang: "source code"
      },
      rightToLeftTool: {
        tooltip: "rtl"
      },
      strikeThrough: {
        tooltip: "strike"
      },
      subscript: {
        tooltip: "subscript"
      },
      superscript: {
        tooltip: "superscript"
      },
      tableTool: {
        tooltip: "table",
        createTable: "create table",
        editTable: "edit table",
        cellBorderColor: "table cell border color",
        deleteTable: "delete table"
      },
      tableAddTool: {
        tooltip: "insert table",
        view: {
          confirmBtnText: "ok",
          rowLabel: "row count",
          rowPlaceholder: "row count",
          columnLabel: "column count",
          columnPlaceholder: "column count",
          useTextbusStyleLabel: "use Textbus style"
        }
      },
      tableEditTool: {
        tooltip: "edit table",
        addColumnToLeft: "add column to left",
        addColumnToRight: "add column to right",
        insertRowBefore: "insert row to before",
        insertRowAfter: "insert row to after",
        deleteLeftColumn: "delete left column",
        deleteRightColumn: "delete right column",
        deletePrevRow: "delete previous row",
        deleteNextRow: "delete next row",
        mergeCells: "merge cells",
        splitCells: "split cells"
      },
      tableRemoveTool: {
        tooltip: "delete table"
      },
      tdBorderColorTool: {
        tooltip: "table cell border color",
        view: {
          confirmBtnText: "ok"
        }
      },
      textAlignTool: {
        tooltip: "text align",
        left: "align left",
        right: "align right",
        center: "align center",
        justify: "align justify"
      },
      textBackgroundColorTool: {
        tooltip: "text background color",
        view: {
          btnText: "ok",
          recentText: "recent colors",
          backText: "back",
          paletteText: "palette"
        }
      },
      textIndentTool: {
        tooltip: "text indent"
      },
      ulTool: {
        tooltip: "ul"
      },
      underlineTool: {
        tooltip: "underline"
      },
      unlinkTool: {
        tooltip: "remove link"
      },
      verticalAlignTool: {
        tooltip: "vertical align",
        baseline: "baseline",
        super: "super",
        sub: "sub",
        top: "top",
        middle: "middle",
        bottom: "bottom",
        textTop: "text-top",
        textBottom: "text-bottom"
      },
      videoTool: {
        tooltip: "video",
        view: {
          title: "video setting",
          confirmBtnText: "ok",
          cancelBtnText: "cancel",
          linkLabel: "URL",
          linkInputPlaceholder: "video url",
          uploadBtnText: "upload",
          validateErrorMessage: "fields is required.",
          videoWidthLabel: "width",
          videoWidthInputPlaceholder: "support CSS unit",
          videoHeightLabel: "height",
          videoHeightInputPlaceholder: "support CSS unit",
          autoplayLabel: "autoplay"
        }
      },
      componentsTool: {
        tooltip: "component library"
      }
    },
    linkJump: {
      accessLink: "open"
    },
    pasteHandle: {
      title: "source upload",
      confirmBtnText: "ok",
      cancelBtnText: "finish",
      uploadBtnText: "upload",
      imageLabel: "{0} picture",
      videoLabel: "{0} video",
      audioLabel: "{0} audio",
      imagePlaceholder: "please enter image URL",
      videoPlaceholder: "please enter video URL",
      audioPlaceholder: "please enter audio URL"
    }
  },
  components: {
    imageComponent: {
      contextMenu: {
        title: "picture setting",
        linkLabel: "URL",
        linkInputPlaceholder: "image url",
        uploadBtnText: "upload image",
        validateErrorMessage: "fields is required.",
        sizeSetter: {
          label: "size",
          widthPlaceholder: "width",
          heightPlaceholder: "height"
        },
        maxSizeSetter: {
          label: "max size",
          widthPlaceholder: "width",
          heightPlaceholder: "height"
        },
        float: {
          label: "float",
          noFloatLabel: "no",
          floatToLeftLabel: "to left",
          floatToRightLabel: "to right"
        },
        marginLabel: "margin",
        confirmBtnText: "ok",
        cancelBtnText: "cancel"
      }
    },
    tableComponent: {
      addColumnToLeft: "add column to left",
      addColumnToRight: "add column to right",
      insertRowBefore: "insert row to before",
      insertRowAfter: "insert row to after",
      deleteColumns: "delete columns",
      deleteRows: "delete rows",
      mergeCells: "merge cells",
      splitCells: "split cells",
      contextMenuLabel: "table",
      contextMenuRemoveTable: "remove table"
    },
    preComponent: {
      defaultLang: "other",
      contextMenuLabel: "switch language",
      changeTheme: "change theme",
      emphasize: "emphasize",
      cancelEmphasize: "cancel emphasize",
      lineNumber: "line number"
    },
    alertComponent: {
      creator: {
        name: "Alert"
      },
      contextMenu: {
        fill: "fill alert",
        noFill: "cancel fill alert",
        type: "select alert style"
      }
    },
    imageCardComponent: {
      creator: {
        name: "Card"
      },
      setting: {
        title: "card setting",
        srcLabel: "url",
        srcPlaceholder: "please enter the picture url",
        heightLabel: "image height",
        heightPlaceholder: "please enter the picture height",
        confirmBtnText: "ok",
        cancelBtnText: "cancel"
      }
    },
    jumbotronComponent: {
      settingBtn: "setting",
      creator: {
        name: "Jumbotron"
      },
      setting: {
        name: "Jumbotron",
        form: {
          title: "jumbotron setting",
          confirmBtnText: "ok",
          cancelBtnText: "cancel",
          minHeightLabel: "min height",
          minHeightInputPlaceholder: "min height",
          backgroundImageLabel: "background image",
          backgroundImageInputPlaceholder: "background image url",
          uploadBtnText: "upload",
          validateErrorMessage: "fields is required."
        }
      }
    },
    katexComponent: {
      creator: {
        name: "Mathematical formula"
      },
      setter: {
        title: "mathematical formula setting",
        label: "source code",
        placeholder: "please...",
        confirmBtnText: "ok",
        cancelBtnText: "cancel"
      }
    },
    stepsComponent: {
      creator: {
        name: "Steps"
      }
    },
    timelineComponent: {
      creator: {
        name: "Timeline"
      }
    },
    todoListComponent: {
      creator: {
        name: "Todolist"
      }
    },
    wordExplainComponent: {
      creator: {
        name: "Word explain"
      },
      setter: {
        title: "word explain setting",
        confirmBtnText: "ok",
        cancelBtnText: "cancel",
        widthInputPlaceholder: "title box width",
        widthLabel: "width"
      }
    }
  }
};
var i18n_zh_CN = {
  editor: {
    noSelection: "\u8BF7\u5148\u9009\u62E9\u63D2\u5165\u8D44\u6E90\u4F4D\u7F6E\uFF01",
    copy: "\u590D\u5236",
    paste: "\u7C98\u8D34",
    cut: "\u526A\u5207",
    selectAll: "\u5168\u9009",
    insertParagraphAfter: "\u5728\u540E\u9762\u63D2\u5165\u6BB5\u843D",
    insertParagraphBefore: "\u5728\u524D\u9762\u63D2\u5165\u6BB5\u843D",
    input: {
      canNotAccessClipboard: "\u65E0\u6CD5\u8BBF\u95EE\u526A\u5207\u677F\uFF01"
    },
    noUploader: "\u4F60\u6CA1\u6709\u5728\u7F16\u8F91\u5668\u7684\u914D\u7F6E\u9879\u4E2D\u6DFB\u52A0 uploader \u65B9\u6CD5\uFF01"
  },
  plugins: {
    toolbar: {
      audioTool: {
        tooltip: "\u97F3\u9891",
        view: {
          title: "\u97F3\u9891\u8BBE\u7F6E",
          addressLabel: "\u97F3\u9891\u94FE\u63A5\u5730\u5740",
          addressPlaceholder: "\u8BF7\u8F93\u5165\u94FE\u63A5\u5730\u5740",
          uploadBtnText: "\u4E0A\u4F20\u65B0\u97F3\u9891",
          errorMessage: "\u5FC5\u586B\u9879\u4E0D\u80FD\u4E3A\u7A7A",
          switchLabel: "\u81EA\u52A8\u64AD\u653E",
          confirmBtnText: "\u786E\u5B9A",
          cancelBtnText: "\u53D6\u6D88"
        }
      },
      blockBackgroundColorTool: {
        tooltip: "\u5757\u80CC\u666F\u989C\u8272",
        view: {
          btnText: "\u786E\u5B9A"
        }
      },
      blockMarginTool: {
        label: "\u5757\u5916\u8FB9\u8DDD",
        tooltip: "\u5757\u5916\u8FB9\u8DDD",
        view: {
          topLabel: "\u4E0A\u8FB9\u8DDD",
          topPlaceholder: "\u8BF7\u8F93\u5165\u4E0A\u8FB9\u8DDD",
          rightLabel: "\u53F3\u8FB9\u8DDD",
          rightPlaceholder: "\u8BF7\u8F93\u5165\u53F3\u8FB9\u8DDD",
          bottomLabel: "\u4E0B\u8FB9\u8DDD",
          bottomPlaceholder: "\u8BF7\u8F93\u5165\u4E0B\u8FB9\u8DDD",
          leftLabel: "\u5DE6\u8FB9\u8DDD",
          leftPlaceholder: "\u8BF7\u8F93\u5165\u5DE6\u8FB9\u8DDD",
          confirmBtnText: "\u786E\u5B9A",
          cancelBtnText: "\u53D6\u6D88"
        }
      },
      blockPaddingTool: {
        label: "\u5757\u5185\u8FB9\u8DDD",
        tooltip: "\u5757\u5185\u8FB9\u8DDD",
        view: {
          topLabel: "\u4E0A\u8FB9\u8DDD",
          topPlaceholder: "\u8BF7\u8F93\u5165\u4E0A\u8FB9\u8DDD",
          rightLabel: "\u53F3\u8FB9\u8DDD",
          rightPlaceholder: "\u8BF7\u8F93\u5165\u53F3\u8FB9\u8DDD",
          bottomLabel: "\u4E0B\u8FB9\u8DDD",
          bottomPlaceholder: "\u8BF7\u8F93\u5165\u4E0B\u8FB9\u8DDD",
          leftLabel: "\u5DE6\u8FB9\u8DDD",
          leftPlaceholder: "\u8BF7\u8F93\u5165\u5DE6\u8FB9\u8DDD",
          confirmBtnText: "\u786E\u5B9A",
          cancelBtnText: "\u53D6\u6D88"
        }
      },
      blockquoteTool: {
        tooltip: "\u5F15\u7528"
      },
      formatPainterTool: {
        tooltip: "\u683C\u5F0F\u5237"
      },
      boldTool: {
        tooltip: "\u52A0\u7C97"
      },
      cleanTool: {
        tooltip: "\u6E05\u9664\u683C\u5F0F"
      },
      codeTool: {
        tooltip: "\u4EE3\u7801"
      },
      colorTool: {
        tooltip: "\u6587\u5B57\u989C\u8272",
        view: {
          btnText: "\u786E\u5B9A",
          recentText: "\u6700\u8FD1\u4F7F\u7528",
          backText: "\u8FD4\u56DE",
          paletteText: "\u8C03\u8272\u76D8"
        }
      },
      emojiTool: {
        tooltip: "\u8868\u60C5"
      },
      findTool: {
        tooltip: "\u67E5\u627E\u4E0E\u66FF\u6362",
        view: {
          findLabel: "\u67E5\u627E",
          findPlaceholder: "\u8BF7\u8F93\u5165\u67E5\u627E\u5185\u5BB9",
          nextBtnText: "\u4E0B\u4E00\u4E2A",
          replaceLabel: "\u66FF\u6362",
          replacePlaceholder: "\u66FF\u6362\u6210",
          replaceBtnText: "\u66FF\u6362",
          replaceAllBtnText: "\u5168\u90E8\u66FF\u6362"
        }
      },
      fontFamilyTool: {
        tooltip: "\u5B57\u4F53",
        defaultFamilyText: "\u9ED8\u8BA4\u5B57\u4F53"
      },
      fontSizeTool: {
        tooltip: "\u5B57\u4F53\u5927\u5C0F",
        defaultSizeText: "\u9ED8\u8BA4"
      },
      headingTool: {
        tooltip: "\u6BB5\u843D\u4E0E\u6807\u9898",
        h1: "\u6807\u98981",
        h2: "\u6807\u98982",
        h3: "\u6807\u98983",
        h4: "\u6807\u98984",
        h5: "\u6807\u98985",
        h6: "\u6807\u98986",
        div: "div",
        paragraph: "\u6B63\u6587"
      },
      historyBackTool: {
        tooltip: "\u64A4\u9500"
      },
      historyForwardTool: {
        tooltip: "\u91CD\u505A"
      },
      imageTool: {
        tooltip: "\u56FE\u7247",
        view: {
          linkLabel: "\u56FE\u7247\u94FE\u63A5\u5730\u5740",
          linkInputPlaceholder: "\u8BF7\u8F93\u5165\u94FE\u63A5\u5730\u5740",
          uploadLabel: "\u4E0A\u4F20\u56FE\u7247",
          uploadBtnText: " \u70B9\u51FB\u4E0A\u4F20",
          confirmBtnText: "\u786E\u5B9A"
        }
      },
      inlineMarginTool: {
        label: "\u5916\u8FB9\u8DDD",
        tooltip: "\u5916\u8FB9\u8DDD",
        view: {
          topLabel: "\u4E0A\u8FB9\u8DDD",
          topPlaceholder: "\u8BF7\u8F93\u5165\u4E0A\u8FB9\u8DDD",
          rightLabel: "\u53F3\u8FB9\u8DDD",
          rightPlaceholder: "\u8BF7\u8F93\u5165\u53F3\u8FB9\u8DDD",
          bottomLabel: "\u4E0B\u8FB9\u8DDD",
          bottomPlaceholder: "\u8BF7\u8F93\u5165\u4E0B\u8FB9\u8DDD",
          leftLabel: "\u5DE6\u8FB9\u8DDD",
          leftPlaceholder: "\u8BF7\u8F93\u5165\u5DE6\u8FB9\u8DDD",
          confirmBtnText: "\u786E\u5B9A",
          cancelBtnText: "\u53D6\u6D88"
        }
      },
      inlinePaddingTool: {
        label: "\u5185\u8FB9\u8DDD",
        tooltip: "\u5185\u8FB9\u8DDD",
        view: {
          topLabel: "\u4E0A\u8FB9\u8DDD",
          topPlaceholder: "\u8BF7\u8F93\u5165\u4E0A\u8FB9\u8DDD",
          rightLabel: "\u53F3\u8FB9\u8DDD",
          rightPlaceholder: "\u8BF7\u8F93\u5165\u53F3\u8FB9\u8DDD",
          bottomLabel: "\u4E0B\u8FB9\u8DDD",
          bottomPlaceholder: "\u8BF7\u8F93\u5165\u4E0B\u8FB9\u8DDD",
          leftLabel: "\u5DE6\u8FB9\u8DDD",
          leftPlaceholder: "\u8BF7\u8F93\u5165\u5DE6\u8FB9\u8DDD",
          confirmBtnText: "\u786E\u5B9A",
          cancelBtnText: "\u53D6\u6D88"
        }
      },
      insertObjectTool: {
        sourceCode: "\u6E90\u4EE3\u7801",
        lineHeight: "\u884C\u9AD8",
        letterSpacing: "\u5B57\u95F4\u8DDD",
        blockBackgroundColor: "\u533A\u5757\u80CC\u666F\u989C\u8272",
        emoji: "\u8868\u60C5",
        audio: "\u97F3\u9891...",
        video: "\u89C6\u9891...",
        subscript: "\u4E0B\u6807",
        superscript: "\u4E0A\u6807",
        code: "Code",
        blockquote: "\u5F15\u7528",
        leftToRight: "\u4ECE\u5DE6\u5411\u53F3",
        rightToLeft: "\u4ECE\u53F3\u5411\u5DE6"
      },
      insertParagraphAfterTool: {
        tooltip: "\u5728\u540E\u9762\u63D2\u5165\u6BB5\u843D"
      },
      insertParagraphBeforeTool: {
        tooltip: "\u5728\u524D\u9762\u63D2\u5165\u6BB5\u843D"
      },
      italicTool: {
        tooltip: "\u659C\u4F53"
      },
      leftToRightTool: {
        tooltip: "\u4ECE\u5DE6\u5411\u53F3"
      },
      letterSpacingTool: {
        tooltip: "\u5B57\u95F4\u8DDD",
        defaultValueLabel: "\u9ED8\u8BA4"
      },
      lineHeightTool: {
        tooltip: "\u884C\u9AD8",
        defaultValueLabel: "\u9ED8\u8BA4"
      },
      linkTool: {
        tooltip: "\u8D85\u94FE\u63A5",
        view: {
          linkLabel: "\u8DF3\u8F6C\u94FE\u63A5\u5730\u5740",
          linkInputPlaceholder: "\u8BF7\u8F93\u5165\u94FE\u63A5\u5730\u5740",
          jumpLabel: "\u8DF3\u8F6C\u65B9\u5F0F",
          jumpSelfLabel: "\u5F53\u524D\u7A97\u53E3",
          jumpBlankLabel: "\u65B0\u7A97\u53E3",
          invalidMessage: "\u8BF7\u8F93\u5165\u6B63\u786E\u7684\u94FE\u63A5\u5730\u5740"
        }
      },
      olTool: {
        tooltip: "\u6709\u5E8F\u5217\u8868"
      },
      preTool: {
        tooltip: "\u4EE3\u7801\u5757",
        defaultLang: "\u5176\u5B83"
      },
      rightToLeftTool: {
        tooltip: "\u4ECE\u53F3\u5411\u5DE6"
      },
      strikeThrough: {
        tooltip: "\u5220\u9664\u7EBF"
      },
      subscript: {
        tooltip: "\u4E0B\u6807"
      },
      superscript: {
        tooltip: "\u4E0A\u6807"
      },
      tableTool: {
        tooltip: "\u8868\u683C",
        createTable: "\u521B\u5EFA\u8868\u683C",
        editTable: "\u7F16\u8F91\u8868\u683C",
        cellBorderColor: "\u8BBE\u7F6E\u5355\u5143\u683C\u8FB9\u6846\u989C\u8272",
        deleteTable: "\u5220\u9664\u8868\u683C"
      },
      tableAddTool: {
        tooltip: "\u63D2\u5165\u8868\u683C",
        view: {
          confirmBtnText: "\u786E\u5B9A",
          rowLabel: "\u8868\u683C\u884C\u6570",
          rowPlaceholder: "\u8BF7\u8F93\u5165\u8868\u683C\u884C\u6570",
          columnLabel: "\u8868\u683C\u5217\u6570",
          columnPlaceholder: "\u8BF7\u8F93\u5165\u8868\u683C\u5217\u6570",
          useTextbusStyleLabel: "\u4F7F\u7528 Textbus \u6837\u5F0F"
        }
      },
      tableEditTool: {
        tooltip: "\u7F16\u8F91\u8868\u683C",
        addColumnToLeft: "\u5728\u5DE6\u8FB9\u6DFB\u52A0\u5217",
        addColumnToRight: "\u5728\u53F3\u8FB9\u6DFB\u52A0\u5217",
        insertRowBefore: "\u5728\u524D\u9762\u6DFB\u52A0\u884C",
        insertRowAfter: "\u5728\u540E\u9762\u6DFB\u52A0\u884C",
        deleteLeftColumn: "\u5220\u9664\u5DE6\u8FB9\u5217",
        deleteRightColumn: "\u5220\u9664\u53F3\u8FB9\u5217",
        deletePrevRow: "\u5220\u9664\u524D\u4E00\u884C",
        deleteNextRow: "\u5220\u9664\u540E\u4E00\u884C",
        mergeCells: "\u5408\u5E76\u5355\u5143\u683C",
        splitCells: "\u53D6\u6D88\u5408\u5E76\u5355\u5143\u683C"
      },
      tableRemoveTool: {
        tooltip: "\u5220\u9664\u8868\u683C"
      },
      tdBorderColorTool: {
        tooltip: "\u8868\u683C\u8FB9\u6846\u989C\u8272",
        view: {
          confirmBtnText: "\u786E\u5B9A"
        }
      },
      textAlignTool: {
        tooltip: "\u5BF9\u9F50\u65B9\u5F0F",
        left: "\u5DE6\u5BF9\u9F50",
        right: "\u53F3\u5BF9\u9F50",
        center: "\u5C45\u4E2D\u5BF9\u9F50",
        justify: "\u5206\u6563\u5BF9\u9F50"
      },
      textBackgroundColorTool: {
        tooltip: "\u6587\u5B57\u80CC\u666F\u989C\u8272",
        view: {
          btnText: "\u786E\u5B9A",
          recentText: "\u6700\u8FD1\u4F7F\u7528",
          backText: "\u8FD4\u56DE",
          paletteText: "\u8C03\u8272\u76D8"
        }
      },
      textIndentTool: {
        tooltip: "\u9996\u884C\u7F29\u8FDB"
      },
      ulTool: {
        tooltip: "\u65E0\u5E8F\u5217\u8868"
      },
      underlineTool: {
        tooltip: "\u4E0B\u5212\u7EBF"
      },
      unlinkTool: {
        tooltip: "\u53D6\u6D88\u8D85\u94FE\u63A5"
      },
      verticalAlignTool: {
        tooltip: "\u5782\u76F4\u5BF9\u9F50\u65B9\u5F0F",
        baseline: "\u57FA\u7EBF\u5BF9\u9F50",
        super: "\u6587\u672C\u4E0A\u6807",
        sub: "\u6587\u672C\u4E0B\u6807",
        top: "\u9876\u7AEF\u5BF9\u9F50",
        middle: "\u5C45\u4E2D",
        bottom: "\u5E95\u7AEF\u5BF9\u9F50",
        textTop: "\u5B57\u4F53\u9876\u7AEF\u5BF9\u9F50",
        textBottom: "\u5B57\u4F53\u5E95\u7AEF\u5BF9\u9F50"
      },
      videoTool: {
        tooltip: "\u89C6\u9891",
        view: {
          title: "\u89C6\u9891\u8BBE\u7F6E",
          confirmBtnText: "\u786E\u5B9A",
          cancelBtnText: "\u53D6\u6D88",
          linkLabel: "\u89C6\u9891\u94FE\u63A5\u5730\u5740",
          linkInputPlaceholder: "\u8BF7\u8F93\u5165\u94FE\u63A5\u5730\u5740",
          uploadBtnText: "\u4E0A\u4F20\u65B0\u89C6\u9891",
          validateErrorMessage: "\u5FC5\u586B\u9879\u4E0D\u80FD\u4E3A\u7A7A",
          videoWidthLabel: "\u89C6\u9891\u5BBD\u5EA6",
          videoWidthInputPlaceholder: "\u652F\u6301\u4EFB\u610F CSS \u5355\u4F4D",
          videoHeightLabel: "\u89C6\u9891\u9AD8\u5EA6",
          videoHeightInputPlaceholder: "\u652F\u6301\u4EFB\u610F CSS \u5355\u4F4D",
          autoplayLabel: "\u81EA\u52A8\u64AD\u653E"
        }
      },
      componentsTool: {
        tooltip: "\u7EC4\u4EF6\u5E93"
      }
    },
    linkJump: {
      accessLink: "\u8DF3\u8F6C"
    },
    pasteHandle: {
      title: "\u8D44\u6E90\u4E0A\u4F20",
      confirmBtnText: "\u786E\u5B9A",
      cancelBtnText: "\u5B8C\u6210",
      uploadBtnText: "\u4E0A\u4F20",
      imageLabel: "\u7B2C {0} \u5F20\u56FE\u7247",
      videoLabel: "\u7B2C {0} \u4E2A\u89C6\u9891",
      audioLabel: "\u7B2C {0} \u4E2A\u97F3\u9891",
      imagePlaceholder: "\u8BF7\u8F93\u5165\u56FE\u7247\u5730\u5740",
      videoPlaceholder: "\u8BF7\u8F93\u5165\u89C6\u9891\u5730\u5740",
      audioPlaceholder: "\u8BF7\u8F93\u5165\u97F3\u9891\u5730\u5740"
    }
  },
  components: {
    imageComponent: {
      contextMenu: {
        title: "\u56FE\u7247\u8BBE\u7F6E",
        linkLabel: "\u56FE\u7247\u94FE\u63A5\u5730\u5740",
        linkInputPlaceholder: "\u8BF7\u8F93\u5165\u94FE\u63A5\u5730\u5740",
        uploadBtnText: "\u4E0A\u4F20",
        validateErrorMessage: "\u5FC5\u586B\u9879\u4E0D\u80FD\u4E3A\u7A7A",
        sizeSetter: {
          label: "\u5BBD\u9AD8\u8BBE\u7F6E",
          widthPlaceholder: "\u5BBD\u5EA6",
          heightPlaceholder: "\u9AD8\u5EA6"
        },
        maxSizeSetter: {
          label: "\u6700\u5927\u5C3A\u5BF8",
          widthPlaceholder: "\u5BBD\u5EA6",
          heightPlaceholder: "\u9AD8\u5EA6"
        },
        float: {
          label: "\u6D6E\u52A8\u8BBE\u7F6E",
          noFloatLabel: "\u4E0D\u6D6E\u52A8",
          floatToLeftLabel: "\u5230\u5DE6\u8FB9",
          floatToRightLabel: "\u5230\u53F3\u8FB9"
        },
        marginLabel: "\u8FB9\u8DDD\u8BBE\u7F6E",
        confirmBtnText: "\u786E\u5B9A",
        cancelBtnText: "\u53D6\u6D88"
      }
    },
    tableComponent: {
      addColumnToLeft: "\u5728\u5DE6\u8FB9\u6DFB\u52A0\u5217",
      addColumnToRight: "\u5728\u53F3\u8FB9\u6DFB\u52A0\u5217",
      insertRowBefore: "\u5728\u524D\u9762\u6DFB\u52A0\u884C",
      insertRowAfter: "\u5728\u540E\u9762\u6DFB\u52A0\u884C",
      deleteColumns: "\u5220\u9664\u5217",
      deleteRows: "\u5220\u9664\u884C",
      mergeCells: "\u5408\u5E76\u5355\u5143\u683C",
      splitCells: "\u62C6\u5206\u5355\u5143\u683C",
      contextMenuLabel: "\u8868\u683C",
      contextMenuRemoveTable: "\u5220\u9664\u8868\u683C"
    },
    preComponent: {
      defaultLang: "\u5176\u5B83",
      contextMenuLabel: "\u5207\u6362\u4EE3\u7801\u5757\u8BED\u8A00",
      changeTheme: "\u5207\u6362\u4EE3\u7801\u5757\u4E3B\u9898",
      emphasize: "\u5F3A\u8C03",
      cancelEmphasize: "\u53D6\u6D88\u5F3A\u8C03",
      lineNumber: "\u884C\u53F7"
    },
    alertComponent: {
      creator: {
        name: "\u8B66\u544A\u6846"
      },
      contextMenu: {
        fill: "\u586B\u5145\u8B66\u544A\u6846",
        noFill: "\u53D6\u6D88\u586B\u5145\u8B66\u544A\u6846",
        type: "\u8B66\u544A\u6846\u98CE\u683C"
      }
    },
    imageCardComponent: {
      creator: {
        name: "\u5361\u7247"
      },
      setting: {
        title: "\u5361\u7247\u8BBE\u7F6E",
        srcLabel: "\u56FE\u7247\u5730\u5740",
        srcPlaceholder: "\u8BF7\u8F93\u5165\u56FE\u7247\u5730\u5740",
        heightLabel: "\u56FE\u7247\u9AD8\u5EA6",
        heightPlaceholder: "\u8BF7\u8F93\u5165\u56FE\u7247\u9AD8\u5EA6",
        confirmBtnText: "\u786E\u5B9A",
        cancelBtnText: "\u53D6\u6D88"
      }
    },
    jumbotronComponent: {
      settingBtn: "\u8BBE\u7F6E",
      creator: {
        name: "\u5DE8\u5E55"
      },
      setting: {
        name: "\u5DE8\u5E55",
        form: {
          title: "\u5DE8\u5E55\u8BBE\u7F6E",
          confirmBtnText: "\u786E\u5B9A",
          cancelBtnText: "\u53D6\u6D88",
          minHeightLabel: "\u5DE8\u5E55\u6700\u5C0F\u9AD8\u5EA6",
          minHeightInputPlaceholder: "\u8BF7\u8F93\u5165\u5DE8\u5E55\u6700\u5C0F\u9AD8\u5EA6",
          backgroundImageLabel: "\u80CC\u666F\u56FE\u7247\u5730\u5740",
          backgroundImageInputPlaceholder: "\u8BF7\u8F93\u5165\u80CC\u666F\u56FE\u7247\u5730\u5740",
          uploadBtnText: "\u4E0A\u4F20\u65B0\u56FE\u7247",
          validateErrorMessage: "\u5FC5\u586B\u9879\u4E0D\u80FD\u4E3A\u7A7A"
        }
      }
    },
    katexComponent: {
      creator: {
        name: "\u6570\u5B66\u516C\u5F0F"
      },
      setter: {
        title: "\u6570\u5B66\u516C\u5F0F\u8BBE\u7F6E",
        label: "\u6E90\u4EE3\u7801",
        placeholder: "\u8BF7\u8F93\u5165\u4EE3\u7801",
        confirmBtnText: "\u786E\u5B9A",
        cancelBtnText: "\u53D6\u6D88"
      }
    },
    stepsComponent: {
      creator: {
        name: "\u6B65\u9AA4\u6761"
      }
    },
    timelineComponent: {
      creator: {
        name: "\u65F6\u95F4\u8F74"
      }
    },
    todoListComponent: {
      creator: {
        name: "\u5F85\u529E\u4E8B\u9879\u5217\u8868"
      }
    },
    wordExplainComponent: {
      creator: {
        name: "\u540D\u8BCD\u91CA\u4E49"
      },
      setter: {
        title: "\u540D\u8BCD\u91CA\u4E49\u8BBE\u7F6E",
        confirmBtnText: "\u786E\u5B9A",
        cancelBtnText: "\u53D6\u6D88",
        widthInputPlaceholder: "\u8BF7\u8F93\u5165\u6807\u9898\u5BBD\u5EA6",
        widthLabel: "\u6807\u9898\u5BBD\u5EA6"
      }
    }
  }
};
var Layout = class Layout2 {
  get top() {
    if (!this.isAppendTop) {
      this.container.prepend(this._top);
      this.isAppendTop = true;
    }
    return this._top;
  }
  get bottom() {
    if (!this.isAppendBottom) {
      this.container.append(this._bottom);
      this.isAppendBottom = true;
    }
    return this._bottom;
  }
  constructor(autoHeight = false) {
    this._top = createElement("div", {
      classes: ["textbus-ui-top"]
    });
    this._bottom = createElement("div", {
      classes: ["textbus-ui-bottom"]
    });
    this.isAppendTop = false;
    this.isAppendBottom = false;
    this.sub = null;
    this.container = createElement("div", {
      classes: ["textbus-container"],
      children: [
        this.middle = createElement("div", {
          classes: ["textbus-ui-middle"],
          children: [
            this.workbench = createElement("div", {
              classes: ["textbus-ui-workbench"],
              children: [
                this.scroller = createElement("div", {
                  classes: ["textbus-ui-scroller"]
                })
              ]
            })
          ]
        })
      ]
    });
    if (autoHeight) {
      this.container.style.height = "auto";
      this.scroller.style.overflow = "visible";
      this.workbench.style.position = "static";
    }
  }
  setTheme(theme) {
    this.container.classList.add("textbus-theme-" + theme);
  }
  destroy() {
    var _a2;
    (_a2 = this.sub) === null || _a2 === void 0 ? void 0 : _a2.unsubscribe();
  }
};
Layout = __decorate3([
  Injectable(),
  __metadata3("design:paramtypes", [Object])
], Layout);
var Message = class Message2 {
  constructor(layout) {
    this.layout = layout;
    this.messageBox = createElement("div", {
      classes: ["textbus-message"]
    });
    this.layout.workbench.append(this.messageBox);
  }
  message(message, time) {
    this.createMessage("message", message, time);
  }
  info(message, time) {
    this.createMessage("info", message, time);
  }
  success(message, time) {
    this.createMessage("success", message, time);
  }
  warning(message, time) {
    this.createMessage("warning", message, time);
  }
  danger(message, time) {
    this.createMessage("danger", message, time);
  }
  createMessage(type, message, time = 3e3) {
    const tip = createElement("div", {
      classes: ["textbus-message-item", "textbus-message-item-" + type],
      children: [createTextNode(message)]
    });
    this.messageBox.append(tip);
    setTimeout(() => {
      tip.remove();
    }, time);
  }
};
Message = __decorate3([
  Injectable(),
  __metadata3("design:paramtypes", [Layout])
], Message);
var ContextMenu = class {
  constructor() {
    this.eventFromSelf = false;
    this.subs = [];
    this.menuSubscriptions = [];
    this.submenuSubscriptions = [];
  }
  setup(injector) {
    const container = injector.get(VIEW_CONTAINER);
    const i18n = injector.get(I18n);
    const selection = injector.get(Selection);
    const commander = injector.get(Commander);
    const rootComponentRef = injector.get(RootComponentRef);
    const message = injector.get(Message);
    const parser = injector.get(Parser);
    const renderer = injector.get(Renderer);
    this.subs.push(fromEvent(document, "mousedown").subscribe(() => {
      this.hide();
    }), fromEvent(container, "contextmenu").subscribe((ev) => {
      const nativeSelection = document.getSelection();
      const focusNode = nativeSelection.focusNode;
      const offset = nativeSelection.focusOffset;
      const isCollapsed = nativeSelection.isCollapsed;
      setTimeout(() => {
        if (isCollapsed) {
          if (!nativeSelection.isCollapsed) {
            nativeSelection.collapse(focusNode, offset);
          }
        }
      });
      const menus = ContextMenu.makeContextmenu(ev.target, selection, renderer);
      const defaultMenus = [{
        iconClasses: ["textbus-icon-copy"],
        label: i18n.get("editor.copy"),
        disabled: selection.isCollapsed,
        onClick: () => {
          commander.copy();
        }
      }, {
        iconClasses: ["textbus-icon-paste"],
        label: i18n.get("editor.paste"),
        onClick: () => {
          navigator.permissions.query({ name: "clipboard-write" }).then((result) => {
            if (result.state === "granted") {
              navigator.clipboard.read().then((items) => {
                const item = items[0];
                item.types.filter((i2) => i2 === "text/html").forEach((type) => {
                  item.getType(type).then((blob) => {
                    return blob.text();
                  }).then((text2) => {
                    const div = document.createElement("div");
                    div.innerHTML = text2;
                    commander.paste(parser.parse(text2, new Slot([
                      ContentType.BlockComponent,
                      ContentType.Text,
                      ContentType.InlineComponent
                    ])), div.innerText);
                  });
                });
              });
            } else {
              message.danger(i18n.get("editor.input.canNotAccessClipboard"));
            }
          });
        }
      }, {
        iconClasses: ["textbus-icon-cut"],
        label: i18n.get("editor.cut"),
        disabled: selection.isCollapsed,
        onClick: () => {
          commander.cut();
        }
      }, {
        iconClasses: ["textbus-icon-select"],
        label: i18n.get("editor.selectAll"),
        onClick: () => {
          selection.selectAll();
        }
      }];
      this.menu = this.show([
        ...menus,
        defaultMenus,
        [{
          label: i18n.get("editor.insertParagraphBefore"),
          iconClasses: ["textbus-icon-insert-paragraph-before"],
          disabled: selection.commonAncestorComponent === rootComponentRef.component,
          onClick: () => {
            const component = paragraphComponent.createInstance(injector);
            const ref = selection.commonAncestorComponent;
            if (ref) {
              commander.insertBefore(component, ref);
              selection.selectFirstPosition(component);
            }
          }
        }, {
          label: i18n.get("editor.insertParagraphAfter"),
          iconClasses: ["textbus-icon-insert-paragraph-after"],
          disabled: selection.commonAncestorComponent === rootComponentRef.component,
          onClick: () => {
            const component = paragraphComponent.createInstance(injector);
            const ref = selection.commonAncestorComponent;
            if (ref) {
              commander.insertAfter(component, ref);
              selection.selectFirstPosition(component);
            }
          }
        }]
      ], ev.clientX, ev.clientY, this.menuSubscriptions);
      ev.preventDefault();
    }));
  }
  destroy() {
    this.hide();
    this.subs.forEach((i2) => i2.unsubscribe());
    this.subs = [];
  }
  static makeContextmenu(source, selection, renderer) {
    const startSlot = selection.startSlot;
    if (!startSlot) {
      return [];
    }
    let component = null;
    do {
      const location = renderer.getLocationByNativeNode(source);
      if (location) {
        const current = location.slot.getContentAtIndex(location.startIndex);
        if (location.endIndex - location.startIndex === 1 && typeof current === "object") {
          component = current;
        } else {
          component = location.slot.parent;
        }
        break;
      } else {
        source = source.parentNode;
      }
    } while (source);
    if (!component) {
      component = selection.commonAncestorComponent;
    }
    if (!component) {
      return [];
    }
    return triggerContextMenu(component);
  }
  hide() {
    var _a2, _b2, _c, _d;
    this.menuSubscriptions.forEach((i2) => i2.unsubscribe());
    this.menuSubscriptions = [];
    (_b2 = (_a2 = this.menu) === null || _a2 === void 0 ? void 0 : _a2.parentNode) === null || _b2 === void 0 ? void 0 : _b2.removeChild(this.menu);
    (_d = (_c = this.submenu) === null || _c === void 0 ? void 0 : _c.parentNode) === null || _d === void 0 ? void 0 : _d.removeChild(this.submenu);
  }
  show(menus, x2, y2, subs) {
    let groups;
    const container = createElement("div", {
      classes: ["textbus-contextmenu"],
      children: [
        createElement("div", {
          classes: ["textbus-contextmenu-container"],
          children: [
            groups = createElement("div", {
              classes: ["textbus-contextmenu-groups"]
            })
          ]
        })
      ]
    });
    subs.push(fromEvent(container, "contextmenu").subscribe((ev) => {
      ev.preventDefault();
    }), fromEvent(document, "mousedown").subscribe(() => {
      if (!this.eventFromSelf) {
        this.hide();
      }
    }), fromEvent(window, "resize").subscribe(() => {
      setPosition();
    }));
    const setPosition = () => {
      const clientWidth = document.documentElement.clientWidth;
      const clientHeight = document.documentElement.clientHeight;
      if (x2 + menuWidth >= clientWidth) {
        x2 -= menuWidth;
      }
      if (y2 + menuHeight >= clientHeight - 20) {
        y2 = clientHeight - menuHeight - 20;
      }
      if (y2 < 20) {
        y2 = 20;
      }
      Object.assign(container.style, {
        left: x2 + "px",
        top: y2 + "px"
      });
      container.style.maxHeight = clientHeight - y2 - 20 + "px";
    };
    let itemCount = 0;
    const wrappers = [];
    menus.forEach((actions) => {
      itemCount += actions.length;
      if (actions.length === 0) {
        return;
      }
      groups.appendChild(createElement("div", {
        classes: ["textbus-contextmenu-group"],
        children: actions.map((item) => {
          if (Array.isArray(item.submenu)) {
            return Object.assign(Object.assign({}, ContextMenu.createMenuView(item, true)), { item });
          }
          return Object.assign(Object.assign({}, ContextMenu.createMenuView(item)), { item });
        }).map((i2) => {
          const { wrapper, btn, item } = i2;
          wrappers.push(wrapper);
          subs.push(fromEvent(btn, "mouseenter").subscribe(() => {
            var _a2;
            if (item.disabled) {
              return;
            }
            if (subs === this.menuSubscriptions) {
              if (this.submenu) {
                (_a2 = this.submenu.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.submenu);
                this.submenuSubscriptions.forEach((i3) => i3.unsubscribe());
                this.submenuSubscriptions = [];
              }
              wrappers.forEach((i3) => i3.classList.remove("textbus-contextmenu-item-active"));
              if (Array.isArray(item.submenu)) {
                const rect = wrapper.getBoundingClientRect();
                const submenu = this.show([item.submenu], rect.left + rect.width, rect.top, this.submenuSubscriptions);
                wrapper.classList.add("textbus-contextmenu-item-active");
                this.submenu = submenu;
              }
            }
          }));
          if (!item.disabled && typeof item.onClick === "function") {
            btn.addEventListener("mousedown", (ev) => {
              this.eventFromSelf = true;
              ev.stopPropagation();
            });
            btn.addEventListener("click", () => {
              this.hide();
              item.onClick();
              this.eventFromSelf = false;
            });
          }
          return i2.wrapper;
        })
      }));
    });
    const menuWidth = 180 + 10;
    const menuHeight = itemCount * 26 + menus.length * 10 + menus.length + 10;
    setPosition();
    document.body.appendChild(container);
    return container;
  }
  static createMenuView(item, isHostNode = false) {
    const btn = createElement("button", {
      attrs: {
        type: "button"
      },
      classes: ["textbus-contextmenu-item-btn"],
      props: {
        disabled: item.disabled
      },
      children: [
        createElement("span", {
          classes: ["textbus-contextmenu-item-icon"],
          children: [
            createElement("span", {
              classes: item.iconClasses || []
            })
          ]
        }),
        createElement("span", {
          classes: ["textbus-contextmenu-item-label"],
          children: [createTextNode(item.label)]
        }),
        isHostNode ? createElement("span", {
          classes: ["textbus-contextmenu-item-arrow"]
        }) : null
      ]
    });
    const wrapper = createElement("div", {
      classes: item.disabled ? ["textbus-contextmenu-item", "textbus-contextmenu-item-disabled"] : ["textbus-contextmenu-item"],
      children: [
        btn
      ]
    });
    return {
      wrapper,
      btn
    };
  }
};
var LinkJumpTipPlugin = class {
  constructor() {
    this.link = document.createElement("a");
    this.subs = [];
  }
  setup(injector) {
    const selection = injector.get(Selection);
    const nativeSelectionBridge = injector.get(SelectionBridge);
    const container = injector.get(VIEW_CONTAINER);
    const i18n = injector.get(I18n);
    this.link.innerText = i18n.get("plugins.linkJump.accessLink") || "\u8DF3\u8F6C";
    this.link.target = "_blank";
    this.link.className = "textbus-link-jump-plugin";
    this.subs.push(selection.onChange.pipe(delay()).subscribe(() => {
      this.onSelectionChange(document, selection, nativeSelectionBridge, container);
    }));
  }
  onDestroy() {
    this.subs.forEach((i2) => i2.unsubscribe());
  }
  onSelectionChange(contentDocument, selection, bridge, container) {
    var _a2;
    const nativeSelection = contentDocument.getSelection();
    const firstNativeRange = nativeSelection.rangeCount ? nativeSelection.getRangeAt(0) : null;
    if (firstNativeRange) {
      const focusNode = firstNativeRange.commonAncestorContainer;
      if (focusNode) {
        const node = focusNode.nodeType === Node.TEXT_NODE ? focusNode.parentNode : focusNode;
        const linkElement = this.getLinkByDOMTree(node);
        if (linkElement && (linkElement.href || linkElement.dataset.href)) {
          this.link.href = linkElement.href || linkElement.dataset.href || "";
          const rect = bridge.getRect({
            slot: selection.startSlot,
            offset: selection.startOffset
          });
          const offsetRect = container.getBoundingClientRect();
          if (nativeSelection.isCollapsed) {
            Object.assign(this.link.style, {
              left: rect.left - offsetRect.left + "px",
              top: rect.top - offsetRect.top + "px"
            });
          } else {
            const rect2 = bridge.getRect({
              slot: selection.endSlot,
              offset: selection.endOffset
            });
            Object.assign(this.link.style, {
              left: (rect.left + rect2.left) / 2 - offsetRect.left + "px",
              top: rect.top - offsetRect.top + "px"
            });
          }
          if (!this.link.parentNode) {
            container.appendChild(this.link);
          }
          return;
        }
      }
    }
    (_a2 = this.link.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.link);
  }
  getLinkByDOMTree(node) {
    if (node.nodeType === Node.ELEMENT_NODE) {
      if (node.tagName.toLowerCase() === "a") {
        return node;
      }
      if (node.parentNode) {
        return this.getLinkByDOMTree(node.parentNode);
      }
    }
    return null;
  }
};
function createButton(config) {
  const button = createElement("button", {
    classes: ["textbus-toolbar-button"],
    attrs: {
      title: config.tooltip || "",
      type: "button",
      "data-keymap": JSON.stringify(config.keymap)
    },
    children: [
      createElement("span", {
        classes: config.iconClasses ? [...config.iconClasses, "textbus-toolbar-button-icon"] : ["textbus-toolbar-button-icon"]
      }),
      createElement("span", {
        classes: ["textbus-toolbar-label"],
        children: [config.label ? createTextNode(config.label) : null]
      })
    ],
    on: {
      click() {
        config.onClick();
      }
    }
  });
  const element = createElement("span", {
    classes: ["textbus-toolbar-item"],
    children: [
      button
    ]
  });
  let highlight = false;
  let disabled = false;
  return {
    elementRef: element,
    get highlight() {
      return highlight;
    },
    set highlight(v2) {
      highlight = v2;
      if (v2) {
        button.classList.add("textbus-toolbar-button-active");
      } else {
        button.classList.remove("textbus-toolbar-button-active");
      }
    },
    get disabled() {
      return disabled;
    },
    set disabled(v2) {
      disabled = v2;
      button.disabled = v2;
    }
  };
}
function fixPosition(wrapper, menu, stickyElement) {
  const r2 = stickyElement.getBoundingClientRect();
  const distance = r2.left + r2.width - (wrapper.getBoundingClientRect().left + menu.offsetWidth);
  menu.style.left = `${Math.min(0, distance)}px`;
}
function createDropdown$1(button, menu, stickyElement) {
  const menuWrapper = createElement("div", {
    classes: ["textbus-toolbar-dropdown-menu"],
    children: [menu],
    on: {
      mousedown(ev) {
        ev.stopPropagation();
      }
    }
  });
  const element = createElement("div", {
    classes: ["textbus-toolbar-dropdown"],
    children: [
      createElement("div", {
        classes: ["textbus-toolbar-dropdown-button"],
        children: [button]
      }),
      menuWrapper
    ]
  });
  function updatePosition() {
    if (element.classList.contains("textbus-toolbar-dropdown-open")) {
      return;
    }
    fixPosition(element, menuWrapper, stickyElement);
  }
  const unListen = fromEvent(window, "resize").subscribe(() => {
    updatePosition();
  });
  const dropdown = {
    elementRef: element,
    toggle() {
      if (element.classList.contains("textbus-toolbar-dropdown-open")) {
        dropdown.hide();
        return;
      }
      dropdown.open();
    },
    open() {
      updatePosition();
      element.classList.add("textbus-toolbar-dropdown-open");
    },
    hide() {
      element.classList.remove("textbus-toolbar-dropdown-open");
    },
    destroy() {
      unListen.unsubscribe();
    }
  };
  return dropdown;
}
function createSegmentDropdown(config) {
  const icon = config.iconClasses ? createElement("span", {
    classes: config.iconClasses
  }) : null;
  const label = config.label ? createElement("span", {
    classes: ["textbus-dropdown-label"],
    children: [createTextNode(config.label)]
  }) : null;
  const leftButton = createElement("button", {
    classes: ["textbus-toolbar-button", "textbus-toolbar-dropdown-left-button"],
    attrs: {
      type: "button"
    },
    children: [icon, label],
    on: {
      click() {
        isSelfClick = true;
        dropdown.hide();
        config.onLeftButtonClick();
      }
    }
  });
  const rightButton = createElement("button", {
    classes: ["textbus-toolbar-button", "textbus-toolbar-dropdown-right-button"],
    attrs: {
      type: "button"
    },
    children: [
      createElement("span", {
        classes: ["textbus-dropdown-caret"]
      })
    ],
    on: {
      mousedown() {
        isSelfClick = true;
        dropdown.toggle();
      }
    }
  });
  const buttonElement = createElement("span", {
    classes: ["textbus-toolbar-item", "textbus-toolbar-dropdown-button-wrap"],
    attrs: {
      title: config.tooltip || ""
    },
    children: [
      leftButton,
      rightButton
    ]
  });
  const dropdown = createDropdown$1(buttonElement, config.menuView, config.stickyElement);
  let isSelfClick = false;
  const unClick = fromEvent(document, "mousedown").subscribe(() => {
    if (!isSelfClick) {
      dropdown.hide();
    }
    isSelfClick = false;
  });
  let highlight = false;
  let disabled = false;
  return {
    elementRef: dropdown.elementRef,
    leftButton,
    destroy() {
      unClick.unsubscribe();
      dropdown.destroy();
    },
    hide() {
      dropdown.hide();
    },
    get highlight() {
      return highlight;
    },
    set highlight(v2) {
      highlight = v2;
      if (v2) {
        leftButton.classList.add("textbus-toolbar-button-active");
      } else {
        leftButton.classList.remove("textbus-toolbar-button-active");
      }
    },
    get disabled() {
      return disabled;
    },
    set disabled(v2) {
      disabled = v2;
      leftButton.disabled = v2;
      rightButton.disabled = v2;
    }
  };
}
function createDropdown(config) {
  const label = createElement("span", {
    classes: ["textbus-toolbar-dropdown-label"],
    children: [config.label ? createTextNode(config.label) : null]
  });
  let isSelfClick = false;
  const button = createElement("button", {
    classes: ["textbus-toolbar-button"],
    attrs: {
      title: config.tooltip || "",
      type: "button"
    },
    children: [
      config.iconClasses ? createElement("span", {
        classes: [...config.iconClasses]
      }) : null,
      label,
      createElement("span", {
        classes: ["textbus-dropdown-caret"]
      })
    ],
    on: {
      mousedown() {
        isSelfClick = true;
        dropdown.toggle();
      }
    }
  });
  const unClick = fromEvent(document, "mousedown").subscribe(() => {
    if (!isSelfClick) {
      dropdown.hide();
    }
    isSelfClick = false;
  });
  const dropdownButton = createElement("span", {
    classes: ["textbus-toolbar-item", "textbus-toolbar-dropdown"],
    children: [
      button
    ]
  });
  const dropdown = createDropdown$1(dropdownButton, config.menuView, config.stickyElement);
  let highlight = false;
  let disabled = false;
  return {
    elementRef: dropdown.elementRef,
    hide() {
      dropdown.hide();
    },
    destroy() {
      dropdown.destroy();
      unClick.unsubscribe();
    },
    get highlight() {
      return highlight;
    },
    set highlight(v2) {
      highlight = v2;
      if (v2) {
        button.classList.add("textbus-toolbar-button-active");
      } else {
        button.classList.remove("textbus-toolbar-button-active");
      }
    },
    get disabled() {
      return disabled;
    },
    set disabled(v2) {
      disabled = v2;
      button.disabled = v2;
    }
  };
}
function createKeymap(config) {
  const _isMac = isMac();
  const arr = [];
  if (config.ctrlKey) {
    arr.push(_isMac ? "textbus-icon-command" : "Ctrl");
  }
  if (config.shiftKey) {
    arr.push(_isMac ? "textbus-icon-shift" : "Shift");
  }
  if (config.altKey) {
    arr.push(_isMac ? "textbus-icon-opt" : "Alt");
  }
  const keys = Array.isArray(config.key) ? config.key.map((i2) => i2.toUpperCase()).join("/") : typeof config.key === "string" ? config.key.toUpperCase() : Array.isArray(config.key.name) ? config.key.name.map((i2) => i2.toUpperCase()).join("/") : config.key.name.toLowerCase();
  const result = [];
  if (_isMac) {
    result.push(...arr.map((s2) => {
      return createElement("span", {
        classes: [s2]
      });
    }), createTextNode(keys));
  } else {
    arr.push(keys);
    arr.forEach((value, index) => {
      if (index - 1 > -1) {
        result.push(createElement("span", {
          classes: ["textbus-toolbar-keymap-join"],
          children: [createTextNode("+")]
        }));
      }
      result.push(createTextNode(value));
    });
  }
  return result;
}
function createOption(config) {
  return createElement("button", {
    attrs: {
      type: "button"
    },
    classes: ["textbus-toolbar-option", ...config.disabled ? ["textbus-toolbar-option-disabled"] : []],
    children: [
      config.iconClasses ? createElement("span", {
        classes: ["textbus-toolbar-option-icon", ...config.iconClasses || []]
      }) : null,
      createElement("span", {
        classes: ["textbus-toolbar-option-label", ...config.classes || []],
        children: config.label ? [createTextNode(config.label)] : []
      }),
      config.keymap ? createElement("span", {
        classes: ["textbus-toolbar-option-keymap"],
        children: createKeymap(config.keymap)
      }) : null
    ],
    on: config.disabled ? {} : {
      click() {
        config.onClick();
      }
    }
  });
}
function createSelect(config) {
  const label = createElement("span", {
    classes: ["textbus-toolbar-select-label"].concat(config.mini ? ["textbus-toolbar-select-label-mini"] : [])
  });
  let isSelfClick = false;
  const button = createElement("button", {
    classes: ["textbus-toolbar-button"],
    attrs: {
      title: config.tooltip || "",
      type: "button"
    },
    children: [
      config.iconClasses ? createElement("span", {
        classes: [...config.iconClasses, "textbus-toolbar-select-icon"]
      }) : null,
      label,
      createElement("span", {
        classes: ["textbus-dropdown-caret"]
      })
    ],
    on: {
      click() {
        isSelfClick = true;
        dropdown.toggle();
      }
    }
  });
  const unClick = fromEvent(document, "click").subscribe(() => {
    if (!isSelfClick) {
      dropdown.hide();
    }
    isSelfClick = false;
  });
  const dropdownButton = createElement("span", {
    classes: ["textbus-toolbar-item", "textbus-toolbar-dropdown"],
    children: [
      button
    ]
  });
  const menu = createElement("div", {
    classes: ["textbus-toolbar-select-options"],
    children: config.options.map((option) => {
      if (option.default) {
        label.innerText = option.label;
      }
      return createOption(Object.assign(Object.assign({}, option), { onClick() {
        dropdown.hide();
        config.onSelected(option.value);
      } }));
    })
  });
  const dropdown = createDropdown$1(dropdownButton, menu, config.stickyElement);
  let highlight = false;
  let disabled = false;
  return {
    elementRef: dropdown.elementRef,
    destroy() {
      dropdown.destroy();
      unClick.unsubscribe();
    },
    setLabel(text2) {
      label.innerText = text2;
    },
    get highlight() {
      return highlight;
    },
    set highlight(v2) {
      highlight = v2;
      if (v2) {
        button.classList.add("textbus-toolbar-button-active");
      } else {
        button.classList.remove("textbus-toolbar-button-active");
      }
    },
    get disabled() {
      return disabled;
    },
    set disabled(v2) {
      disabled = v2;
      button.disabled = v2;
    }
  };
}
var ButtonTool = class {
  constructor(factory) {
    this.factory = factory;
  }
  setup(injector) {
    this.config = this.factory(injector);
    this.controller = injector.get(Controller);
    const keyboard = injector.get(Keyboard);
    const viewer = createButton(Object.assign(Object.assign({}, this.config), { onClick: () => {
      this.config.onClick();
    } }));
    if (this.config.keymap) {
      keyboard.addShortcut({
        keymap: this.config.keymap,
        action: () => {
          this.config.onClick();
        }
      });
    }
    this.viewer = viewer;
    return viewer.elementRef;
  }
  refreshState() {
    if (!this.config.queryState) {
      return;
    }
    const viewer = this.viewer;
    if (this.controller.readonly) {
      viewer.disabled = true;
      viewer.highlight = false;
      return;
    }
    const state = this.config.queryState();
    switch (state.state) {
      case QueryStateType.Disabled:
        viewer.disabled = true;
        viewer.highlight = false;
        break;
      case QueryStateType.Enabled:
        viewer.disabled = false;
        viewer.highlight = true;
        break;
      case QueryStateType.Normal:
        viewer.disabled = false;
        viewer.highlight = false;
    }
  }
  disabled(is) {
    if (is) {
      this.viewer.disabled = true;
      this.viewer.highlight = false;
    }
  }
  onDestroy() {
    var _a2, _b2;
    (_b2 = (_a2 = this.config).onDestroy) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
  }
};
var DialogTool = class {
  constructor(factory) {
    this.factory = factory;
    this.subs = [];
  }
  setup(injector) {
    const config = this.factory(injector);
    this.controller = injector.get(Controller);
    this.config = config;
    const keyboard = injector.get(Keyboard);
    const dialog = injector.get(Dialog);
    const initValue = {};
    let prevValue = initValue;
    const button = createButton(Object.assign(Object.assign({}, this.config), { onClick: () => {
      dialog.show(config.viewController.elementRef);
    } }));
    this.subs.push(config.viewController.onComplete.subscribe((value) => {
      prevValue = value;
      dialog.hide();
      config.useValue(prevValue);
    }), config.viewController.onCancel.subscribe(() => {
      dialog.hide();
    }));
    if (config.keymap) {
      keyboard.addShortcut({
        keymap: config.keymap,
        action() {
          if (!button.disabled && prevValue !== initValue) {
            config.useValue(prevValue);
          }
        }
      });
    }
    this.viewer = button;
    return button.elementRef;
  }
  refreshState() {
    const viewer = this.viewer;
    if (this.controller.readonly) {
      viewer.disabled = true;
      viewer.highlight = false;
      return;
    }
    const state = this.config.queryState();
    if (state.value) {
      this.config.viewController.update(state.value);
    } else {
      this.config.viewController.reset();
    }
    switch (state.state) {
      case QueryStateType.Enabled:
        viewer.disabled = false;
        viewer.highlight = true;
        break;
      case QueryStateType.Normal:
        viewer.disabled = false;
        viewer.highlight = false;
        break;
      case QueryStateType.Disabled:
        viewer.disabled = true;
        viewer.highlight = false;
        break;
    }
  }
  disabled(is) {
    if (is) {
      this.viewer.disabled = true;
      this.viewer.highlight = false;
    }
  }
  onDestroy() {
    var _a2, _b2;
    this.subs.forEach((i2) => i2.unsubscribe());
    (_b2 = (_a2 = this.config).onDestroy) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
  }
};
var DropdownTool = class {
  constructor(factory) {
    this.factory = factory;
    this.subs = [];
  }
  setup(injector, limitElement) {
    const config = this.factory(injector);
    this.config = config;
    this.controller = injector.get(Controller);
    const keyboard = injector.get(Keyboard);
    const initValue = {};
    let prevValue = initValue;
    this.subs.push(config.viewController.onComplete.subscribe((value) => {
      prevValue = value;
      form.hide();
      config.useValue(prevValue);
    }));
    const form = createDropdown(Object.assign(Object.assign({}, config), { stickyElement: limitElement, menuView: config.viewController.elementRef }));
    if (config.keymap) {
      keyboard.addShortcut({
        keymap: config.keymap,
        action() {
          if (!form.disabled && prevValue !== initValue) {
            config.useValue(prevValue);
          }
        }
      });
    }
    this.viewer = form;
    return form.elementRef;
  }
  refreshState() {
    const viewer = this.viewer;
    if (this.controller.readonly) {
      viewer.disabled = true;
      viewer.highlight = false;
      return;
    }
    const state = this.config.queryState();
    if (state.value) {
      this.config.viewController.update(state.value);
    } else {
      this.config.viewController.reset();
    }
    switch (state.state) {
      case QueryStateType.Enabled:
        viewer.disabled = false;
        viewer.highlight = true;
        break;
      case QueryStateType.Normal:
        viewer.disabled = false;
        viewer.highlight = false;
        break;
      case QueryStateType.Disabled:
        viewer.disabled = true;
        viewer.highlight = false;
        break;
    }
  }
  disabled(is) {
    if (is) {
      this.viewer.disabled = true;
      this.viewer.highlight = false;
    }
  }
  onDestroy() {
    var _a2, _b2;
    this.subs.forEach((i2) => i2.unsubscribe());
    (_b2 = (_a2 = this.config).onDestroy) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
  }
};
var ToolType;
(function(ToolType2) {
  ToolType2[ToolType2["Select"] = 0] = "Select";
  ToolType2[ToolType2["Button"] = 1] = "Button";
  ToolType2[ToolType2["Dropdown"] = 2] = "Dropdown";
  ToolType2[ToolType2["Dialog"] = 3] = "Dialog";
})(ToolType || (ToolType = {}));
var GroupTool = class {
  constructor(factory) {
    this.factory = factory;
    this.menus = [];
  }
  setup(injector, limitElement) {
    const config = this.factory(injector);
    const keyboard = injector.get(Keyboard);
    const dialog = injector.get(Dialog);
    this.controller = injector.get(Controller);
    this.config = config;
    const menus = config.items.map((i2) => {
      switch (i2.type) {
        case ToolType.Button:
          return this.createButton(i2, keyboard);
        case ToolType.Select:
          return this.createSelect(i2, keyboard);
        case ToolType.Dropdown:
          return this.createDropdown(i2, keyboard);
        case ToolType.Dialog:
          return this.createDialog(i2, keyboard, dialog);
      }
    });
    this.menus = menus;
    const groupItemGroup = createElement("div", {
      classes: ["textbus-toolbar-group-menu"],
      children: menus.map((i2) => i2.elementRef)
    });
    const dropdown = createDropdown(Object.assign(Object.assign({}, config), { menuView: groupItemGroup, stickyElement: limitElement }));
    this.controller.onReadonlyStateChange.subscribe((v2) => {
      dropdown.disabled = v2;
      menus.forEach((i2) => {
        i2.disabled(v2);
      });
    });
    this.uiDropdown = dropdown;
    return dropdown.elementRef;
  }
  refreshState() {
    this.menus.forEach((i2) => i2.refreshState());
  }
  disabled() {
  }
  createDialog(config, keyboard, dialog) {
    const item = this._createItem(Object.assign(Object.assign({}, config), { label: config.label || "", isDropdown: false }));
    fromEvent(item.elementRef, "click").subscribe(() => {
      dialog.show(config.viewController.elementRef);
      this.uiDropdown.hide();
    });
    const defaultValue = {};
    let prevValue = defaultValue;
    config.viewController.onComplete.subscribe((value) => {
      prevValue = value;
      config.useValue(value);
      dialog.hide();
    });
    config.viewController.onCancel.subscribe(() => {
      dialog.hide();
    });
    if (config.keymap) {
      keyboard.addShortcut({
        keymap: config.keymap,
        action() {
          if (!item.disabled && prevValue !== defaultValue) {
            config.useValue(prevValue);
          }
        }
      });
    }
    const controller = this.controller;
    return {
      elementRef: item.elementRef,
      disabled(is) {
        item.disabled = is;
      },
      refreshState() {
        if (!config.queryState) {
          return;
        }
        const viewer = item;
        if (controller.readonly) {
          viewer.disabled = true;
          viewer.highlight = false;
          return;
        }
        const state = config.queryState();
        switch (state.state) {
          case QueryStateType.Disabled:
            viewer.disabled = true;
            viewer.highlight = false;
            config.viewController.reset();
            break;
          case QueryStateType.Enabled:
            viewer.disabled = false;
            viewer.highlight = true;
            config.viewController.update(state.value);
            break;
          case QueryStateType.Normal:
            viewer.disabled = false;
            viewer.highlight = false;
            config.viewController.reset();
        }
      }
    };
  }
  createDropdown(config, keyboard) {
    const item = this._createItem(Object.assign(Object.assign({}, config), { label: config.label || "", isDropdown: true }));
    const menu = createElement("div", {
      classes: ["textbus-toolbar-submenu"],
      children: [
        config.viewController.elementRef
      ]
    });
    const defaultValue = {};
    let prevValue = defaultValue;
    config.viewController.onComplete.subscribe((v2) => {
      prevValue = v2;
      config.useValue(v2);
      this.uiDropdown.hide();
    });
    if (config.keymap) {
      keyboard.addShortcut({
        keymap: config.keymap,
        action() {
          if (!item.disabled && prevValue !== defaultValue) {
            config.useValue(prevValue);
          }
        }
      });
    }
    item.elementRef.appendChild(menu);
    const controller = this.controller;
    return {
      elementRef: item.elementRef,
      disabled(is) {
        item.disabled = is;
      },
      refreshState() {
        if (!config.queryState) {
          return;
        }
        const viewer = item;
        if (controller.readonly) {
          viewer.disabled = true;
          viewer.highlight = false;
          return;
        }
        const state = config.queryState();
        switch (state.state) {
          case QueryStateType.Disabled:
            viewer.disabled = true;
            viewer.highlight = false;
            config.viewController.reset();
            break;
          case QueryStateType.Enabled:
            viewer.disabled = false;
            viewer.highlight = true;
            config.viewController.update(state.value);
            break;
          case QueryStateType.Normal:
            viewer.disabled = false;
            viewer.highlight = false;
            config.viewController.reset();
        }
      }
    };
  }
  createSelect(config, keyboard) {
    const item = this._createItem(Object.assign(Object.assign({}, config), { isDropdown: true }));
    const map2 = /* @__PURE__ */ new Map();
    const menu = createElement("div", {
      classes: ["textbus-toolbar-submenu"],
      children: [
        createElement("div", {
          classes: ["textbus-toolbar-select-options"],
          children: config.options.map((option) => {
            const el = createOption(Object.assign(Object.assign({}, option), { onClick: () => {
              config.onChecked(option.value);
              this.uiDropdown.hide();
            } }));
            map2.set(option, el);
            if (option.keymap) {
              keyboard.addShortcut({
                keymap: option.keymap,
                action() {
                  if (!item.disabled) {
                    config.onChecked(option.value);
                  }
                }
              });
            }
            return el;
          })
        })
      ]
    });
    item.elementRef.appendChild(menu);
    const controller = this.controller;
    return {
      elementRef: item.elementRef,
      disabled(is) {
        item.disabled = is;
      },
      refreshState() {
        if (!config.queryState) {
          return;
        }
        const viewer = item;
        if (controller.readonly) {
          viewer.disabled = true;
          viewer.highlight = false;
          return;
        }
        const state = config.queryState();
        switch (state.state) {
          case QueryStateType.Disabled:
            viewer.disabled = true;
            viewer.highlight = false;
            break;
          case QueryStateType.Enabled:
            viewer.disabled = false;
            viewer.highlight = true;
            map2.forEach((el, config2) => {
              if (config2.value === state.value) {
                el.classList.add("textbus-toolbar-option-active");
              } else {
                el.classList.remove("textbus-toolbar-option-active");
              }
            });
            break;
          case QueryStateType.Normal:
            viewer.disabled = false;
            viewer.highlight = false;
            map2.forEach((el) => {
              el.classList.remove("textbus-toolbar-option-active");
            });
        }
      }
    };
  }
  createButton(config, keyboard) {
    const item = this._createItem(Object.assign(Object.assign({}, config), { label: config.label || "", isDropdown: false }));
    fromEvent(item.elementRef, "click").subscribe(() => {
      config.onClick();
      this.uiDropdown.hide();
    });
    if (config.keymap) {
      keyboard.addShortcut({
        keymap: config.keymap,
        action() {
          if (!item.disabled) {
            config.onClick();
          }
        }
      });
    }
    const controller = this.controller;
    return {
      elementRef: item.elementRef,
      disabled(is) {
        item.disabled = is;
      },
      refreshState() {
        if (!config.queryState) {
          return;
        }
        const viewer = item;
        if (controller.readonly) {
          viewer.disabled = true;
          viewer.highlight = false;
          return;
        }
        const state = config.queryState();
        switch (state.state) {
          case QueryStateType.Disabled:
            viewer.disabled = true;
            viewer.highlight = false;
            break;
          case QueryStateType.Enabled:
            viewer.disabled = false;
            viewer.highlight = true;
            break;
          case QueryStateType.Normal:
            viewer.disabled = false;
            viewer.highlight = false;
        }
      }
    };
  }
  _createItem(config) {
    const button = createElement("button", {
      attrs: {
        type: "button"
      },
      classes: ["textbus-toolbar-group-button"],
      children: [
        config.iconClasses ? createElement("span", {
          classes: [...config.iconClasses, "textbus-toolbar-group-button-icon"]
        }) : null,
        createElement("span", {
          classes: ["textbus-toolbar-group-button-label"],
          children: [
            createTextNode(config.label)
          ]
        }),
        config.keymap ? createElement("span", {
          classes: ["textbus-toolbar-group-button-keymap"],
          children: createKeymap(config.keymap)
        }) : null,
        config.isDropdown ? createElement("span", {
          classes: ["textbus-toolbar-group-button-caret"]
        }) : null
      ]
    });
    const wrapper = createElement("div", {
      classes: ["textbus-toolbar-group-item"],
      children: [
        button
      ]
    });
    let highlight = false;
    let disabled = false;
    return {
      elementRef: wrapper,
      get highlight() {
        return highlight;
      },
      set highlight(v2) {
        highlight = v2;
        if (v2) {
          button.classList.add("textbus-toolbar-group-button-active");
        } else {
          button.classList.remove("textbus-toolbar-group-button-active");
        }
      },
      get disabled() {
        return disabled;
      },
      set disabled(v2) {
        disabled = v2;
        button.disabled = v2;
      }
    };
  }
};
var SegmentDropdownTool = class {
  constructor(factory) {
    this.factory = factory;
    this.subs = [];
  }
  setup(injector, limitElement) {
    var _a2;
    const config = this.factory(injector);
    this.controller = injector.get(Controller);
    this.config = config;
    const keyboard = injector.get(Keyboard);
    const view = config.viewController.elementRef;
    const dropdown = createSegmentDropdown(Object.assign(Object.assign({}, config), { menuView: view, stickyElement: limitElement, onLeftButtonClick() {
      var _a3;
      if (!dropdown.disabled && prevValue !== initValue) {
        (_a3 = config.useValue) === null || _a3 === void 0 ? void 0 : _a3.call(config, prevValue);
      }
    } }));
    const initValue = {};
    let prevValue = initValue;
    this.subs.push(config.viewController.onComplete.subscribe((value) => {
      var _a3;
      prevValue = value;
      (_a3 = config.useValue) === null || _a3 === void 0 ? void 0 : _a3.call(config, value);
      dropdown.hide();
    }));
    if (config.keymap) {
      keyboard.addShortcut({
        keymap: config.keymap,
        action() {
          var _a3;
          if (!dropdown.disabled && prevValue !== initValue) {
            (_a3 = config.useValue) === null || _a3 === void 0 ? void 0 : _a3.call(config, prevValue);
          }
        }
      });
    }
    this.viewer = dropdown;
    (_a2 = config.onInit) === null || _a2 === void 0 ? void 0 : _a2.call(config, dropdown);
    return dropdown.elementRef;
  }
  disabled(is) {
    if (is) {
      this.viewer.disabled = true;
      this.viewer.highlight = false;
    }
  }
  refreshState() {
    if (!this.config.queryState) {
      return;
    }
    const viewer = this.viewer;
    if (this.controller.readonly) {
      viewer.disabled = true;
      viewer.highlight = false;
      return;
    }
    const state = this.config.queryState();
    this.config.viewController.update(state.value);
    switch (state.state) {
      case QueryStateType.Enabled:
        viewer.disabled = false;
        viewer.highlight = true;
        break;
      case QueryStateType.Normal:
        viewer.disabled = false;
        viewer.highlight = false;
        break;
      case QueryStateType.Disabled:
        viewer.disabled = true;
        viewer.highlight = false;
        break;
    }
  }
  onDestroy() {
    var _a2, _b2;
    this.subs.forEach((i2) => i2.unsubscribe());
    (_b2 = (_a2 = this.config).onDestroy) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
  }
};
var SelectTool = class {
  constructor(factory) {
    this.factory = factory;
  }
  setup(injector, limitElement) {
    const config = this.factory(injector);
    this.controller = injector.get(Controller);
    this.config = config;
    const keyboard = injector.get(Keyboard);
    const dropdown = createSelect(Object.assign(Object.assign({}, config), { stickyElement: limitElement, onSelected: (value) => {
      config.onChecked(value);
    } }));
    config.options.filter((i2) => i2.keymap).forEach((i2) => {
      keyboard.addShortcut({
        keymap: i2.keymap,
        action: () => {
          if (!dropdown.disabled) {
            this.config.onChecked(i2.value);
          }
        }
      });
    });
    this.viewer = dropdown;
    return dropdown.elementRef;
  }
  refreshState() {
    if (!this.config.queryState) {
      return;
    }
    const dropdown = this.viewer;
    if (this.controller.readonly) {
      dropdown.disabled = true;
      dropdown.highlight = false;
      return;
    }
    const state = this.config.queryState();
    if (state.value) {
      const option = this.config.options.find((i2) => {
        return i2.value === state.value;
      });
      if (option) {
        dropdown.setLabel(option.label);
        dropdown.disabled = false;
        dropdown.highlight = true;
        return;
      }
    }
    dropdown.highlight = false;
    dropdown.disabled = state.state === QueryStateType.Disabled;
    let defaultOption;
    for (const op of this.config.options) {
      if (op.default) {
        defaultOption = op;
        break;
      }
    }
    if (defaultOption) {
      dropdown.setLabel(defaultOption.label);
    }
  }
  disabled(is) {
    if (is) {
      this.viewer.disabled = true;
      this.viewer.highlight = false;
    }
  }
  onDestroy() {
    var _a2, _b2;
    (_b2 = (_a2 = this.config).onDestroy) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
  }
};
function audioToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  const uploader = injector.get(FileUploader);
  const childI18n = i18n.getContext("plugins.toolbar.audioTool.view");
  const form = new Form({
    title: childI18n.get("title"),
    cancelBtnText: childI18n.get("cancelBtnText"),
    confirmBtnText: childI18n.get("confirmBtnText"),
    items: [
      new FormTextField({
        label: childI18n.get("addressLabel"),
        name: "src",
        placeholder: childI18n.get("addressPlaceholder"),
        canUpload: true,
        uploadType: "audio",
        uploadBtnText: childI18n.get("uploadBtnText"),
        fileUploader: uploader,
        validateFn(value) {
          if (!value) {
            return childI18n.get("errorMessage");
          }
          return false;
        }
      }),
      new FormSwitch({
        label: childI18n.get("switchLabel"),
        checked: false,
        name: "autoplay"
      }),
      new FormHidden({
        name: "controls",
        value: "controls"
      })
    ]
  });
  return {
    iconClasses: ["textbus-icon-music"],
    tooltip: i18n.get("plugins.toolbar.audioTool.tooltip"),
    viewController: form,
    queryState() {
      const state = query.queryComponent(audioComponent);
      if (state.state === QueryStateType.Enabled) {
        return {
          state: QueryStateType.Enabled,
          value: state.value.extends.toJSON()
        };
      }
      return {
        state: state.state,
        value: null
      };
    },
    useValue(value) {
      if (value) {
        const state = query.queryComponent(audioComponent);
        if (state.state === QueryStateType.Enabled) {
          state.value.extends.mergeProps(value);
        } else {
          commander.insert(audioComponent.createInstance(injector, {
            state: value
          }));
        }
      }
    }
  };
}
function audioTool() {
  return new DialogTool(audioToolConfigFactory);
}
function blockquoteToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  const selection = injector.get(Selection);
  return {
    iconClasses: ["textbus-icon-quotes-right"],
    tooltip: i18n.get("plugins.toolbar.blockquoteTool.tooltip"),
    keymap: /win(dows|32|64)/i.test(navigator.userAgent) ? {
      altKey: true,
      key: "'"
    } : {
      ctrlKey: true,
      key: "'"
    },
    queryState() {
      return query.queryComponent(blockquoteComponent);
    },
    onClick() {
      const state = query.queryComponent(blockquoteComponent);
      if (state.state === QueryStateType.Enabled) {
        const current = state.value;
        const parent = current.parent;
        const index = parent.indexOf(current);
        parent.retain(index);
        commander.removeComponent(current);
        current.slots.get(0).sliceContent().forEach((i2) => {
          parent.insert(i2);
        });
      } else {
        const block = blockquoteComponent.createInstance(injector);
        const slot = block.slots.get(0);
        if (selection.startSlot === selection.endSlot) {
          const parentComponent = selection.startSlot.parent;
          const parentSlot = parentComponent.parent;
          const position = parentSlot.indexOf(parentComponent);
          slot.insert(parentComponent);
          parentSlot.retain(position);
          parentSlot.insert(block);
        } else {
          const commonAncestorSlot = selection.commonAncestorSlot;
          const scope = selection.getCommonAncestorSlotScope();
          commonAncestorSlot.cut(scope.startOffset, scope.endOffset).sliceContent().forEach((i2) => {
            slot.insert(i2);
          });
          commonAncestorSlot.retain(scope.startOffset);
          commonAncestorSlot.insert(block);
        }
      }
    }
  };
}
function blockquoteTool() {
  return new ButtonTool(blockquoteToolConfigFactory);
}
function boldToolConfigFactory(injector) {
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  const i18n = injector.get(I18n);
  return {
    iconClasses: ["textbus-icon-bold"],
    tooltip: i18n.get("plugins.toolbar.boldTool.tooltip"),
    keymap: {
      ctrlKey: true,
      key: "b"
    },
    queryState() {
      return query.queryFormat(boldFormatter);
    },
    onClick() {
      const state = query.queryFormat(boldFormatter);
      const b2 = state.state === QueryStateType.Enabled;
      b2 ? commander.unApplyFormat(boldFormatter) : commander.applyFormat(boldFormatter, true);
    }
  };
}
function boldTool() {
  return new ButtonTool(boldToolConfigFactory);
}
function cleanToolConfigFactory(injector) {
  const selection = injector.get(Selection);
  const commander = injector.get(Commander);
  const i18n = injector.get(I18n);
  return {
    iconClasses: ["textbus-icon-clear-formatting"],
    tooltip: i18n.get("plugins.toolbar.cleanTool.tooltip"),
    keymap: {
      ctrlKey: true,
      shiftKey: true,
      altKey: true,
      key: "c"
    },
    queryState() {
      return {
        state: selection.isCollapsed ? QueryStateType.Disabled : QueryStateType.Normal,
        value: null
      };
    },
    onClick() {
      commander.cleanFormats([linkFormatter]);
      commander.cleanAttributes();
    }
  };
}
function cleanTool() {
  return new ButtonTool(cleanToolConfigFactory);
}
function codeToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    iconClasses: ["textbus-icon-code"],
    tooltip: i18n.get("plugins.toolbar.codeTool.tooltip"),
    keymap: {
      key: ";",
      ctrlKey: true
    },
    queryState() {
      return query.queryFormat(codeFormatter);
    },
    onClick() {
      const state = query.queryFormat(codeFormatter);
      const b2 = state.state === QueryStateType.Enabled;
      b2 ? commander.unApplyFormat(codeFormatter) : commander.applyFormat(codeFormatter, true);
    }
  };
}
function codeTool() {
  return new ButtonTool(codeToolConfigFactory);
}
var Palette = class {
  constructor(styleName, btnText, recentText, backText, paletteText) {
    this.styleName = styleName;
    this.elementRef = document.createElement("div");
    this.completeEvent = new Subject();
    this.elementRef.classList.add("textbus-toolbar-palette");
    this.onComplete = this.completeEvent.asObservable();
    this.picker = createPicker(this.elementRef, {
      recentText,
      btnText,
      backText,
      paletteText
    });
    this.picker.onSelected.subscribe((ev) => {
      if (!ev.rgba) {
        this.completeEvent.next(null);
      } else if (ev.rgba.a === 1) {
        this.completeEvent.next(ev.hex);
      } else {
        const { r: r2, g: g2, b: b2, a: a2 } = ev.rgba;
        this.completeEvent.next(`rgba(${r2},${g2},${b2},${a2})`);
      }
    });
  }
  update(d2) {
    const color = d2 || "#f00";
    if (/^#/.test(color)) {
      this.picker.hex = color;
    } else if (/^rgba/.test(color)) {
      this.picker.rgba = parseCss(color);
    } else if (/^rgb/.test(color)) {
      this.picker.hex = rgb2Hex(parseCss(color));
    } else if (/^hsl/.test(color)) {
      this.picker.hex = hsl2Hex(parseCss(color));
    }
  }
};
Palette.defaultColors = [
  "#f8f8f9",
  "#e9eaec",
  "#dddee1",
  "#bbbec4",
  "#80848f",
  "#495060",
  "#1c2838",
  "#e74f5e",
  "#ff9900",
  "#15bd9a",
  "#6ad1ec",
  "#1296db"
];
function colorToolCreator(injector, palette, formatter) {
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  let viewer;
  return {
    viewController: {
      elementRef: palette.elementRef,
      onComplete: palette.onComplete,
      onCancel: new Observable(),
      reset() {
        palette.update();
      },
      update(newValue) {
        palette.update(newValue);
      }
    },
    onInit(ui) {
      viewer = ui;
    },
    useValue(value) {
      viewer.leftButton.style.color = value;
      commander.applyFormat(formatter, value);
    },
    queryState() {
      return query.queryFormat(formatter);
    }
  };
}
function colorToolConfigFactory(injector) {
  const i18n = injector.get(I18n).getContext("plugins.toolbar.colorTool");
  const palette = new Palette("color", i18n.get("view.btnText"), i18n.get("view.recentText"), i18n.get("view.backText"), i18n.get("view.paletteText"));
  return Object.assign({ iconClasses: ["textbus-icon-color"], tooltip: i18n.get("tooltip"), keymap: {
    ctrlKey: true,
    shiftKey: true,
    key: "c"
  } }, colorToolCreator(injector, palette, colorFormatter));
}
function colorTool() {
  return new SegmentDropdownTool(colorToolConfigFactory);
}
function createViewer(content, name) {
  const wrapper = document.createElement("div");
  wrapper.classList.add("textbus-component-example-item");
  const card = document.createElement("div");
  card.classList.add("textbus-component-example");
  const exampleContent = document.createElement("div");
  exampleContent.classList.add("textbus-component-example-content");
  if (typeof content === "string") {
    exampleContent.innerHTML = content;
  } else if (content instanceof HTMLElement) {
    exampleContent.appendChild(content);
  }
  card.appendChild(exampleContent);
  const mask2 = document.createElement("div");
  mask2.classList.add("textbus-component-example-mask");
  card.appendChild(mask2);
  wrapper.appendChild(card);
  const nameWrapper = document.createElement("div");
  nameWrapper.classList.add("textbus-component-example-name");
  nameWrapper.innerText = name || "";
  wrapper.appendChild(nameWrapper);
  return {
    wrapper,
    card
  };
}
function createExample(injector, example, controller) {
  const { wrapper, card } = createViewer(example.example, example.name);
  const commander = injector.get(Commander);
  const selection = injector.get(Selection);
  card.addEventListener("click", () => {
    const t2 = example.factory(injector);
    if (t2 instanceof Promise) {
      t2.then((instance) => {
        commander.insert(instance);
        selection.selectFirstPosition(instance);
        controller.next();
      });
    } else {
      commander.insert(t2);
      selection.selectFirstPosition(t2);
      controller.next();
    }
  });
  return wrapper;
}
function componentsToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const elementRef = createElement("div", {
    classes: ["textbus-component-stage-list"]
  });
  const configs = [{
    name: i18n.get("components.imageCardComponent.creator.name"),
    example: `<img src="data:image/svg+xml;charset=UTF-8,${encodeURIComponent('<svg width="100" height="70" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="bg" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f90"/><stop offset="100%" stop-color="#fff"/></linearGradient></defs><g><rect fill="url(#bg)" height="50" width="100%"/></g><g><path fill="#f00" opacity="0.2" d="M81.25 28.125c0 5.178-4.197 9.375-9.375 9.375s-9.375-4.197-9.375-9.375 4.197-9.375 9.375-9.375 9.375 4.197 9.375 9.375z"></path><path fill="#0e0" opacity="0.3" d="M87.5 81.25h-75v-12.5l21.875-37.5 25 31.25h6.25l21.875-18.75z"></path></g><g><rect fill="#fff" height="20" width="100%" y="50"></rect></g><g><text font-family="Helvetica, Arial, sans-serif" font-size="12" y="63" x="50%" text-anchor="middle" stroke-width="0" stroke="#000" fill="#000000">\u63CF\u8FF0\u6587\u5B57</text></g></svg>')}" alt="">`,
    factory() {
      return imageCardComponent.createInstance(injector);
    }
  }, {
    name: i18n.get("components.todoListComponent.creator.name"),
    example: `<img alt="\u9ED8\u8BA4\u56FE\u7247" src="data:image/svg+xml;charset=UTF-8,${encodeURIComponent('<svg width="100" height="70" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" ><g><rect fill="#fff" height="100%" width="100%"/></g><defs><g id="item"><rect fill="#fff" stroke="#1296db" height="8" width="8" rx="2" x="15" y="12"/><text font-family="Helvetica, Arial, sans-serif" font-size="8" x="28" y="19"  stroke-width="0" stroke="#000" fill="#000000">\u5F85\u529E\u4E8B\u9879...</text></g></defs><use xlink:href="#item"></use><use xlink:href="#item" transform="translate(0, 12)"></use><use xlink:href="#item" transform="translate(0, 24)"></use><use xlink:href="#item" transform="translate(0, 36)"></use></svg>')}">`,
    factory() {
      return todolistComponent.createInstance(injector, {
        slots: [
          new Slot([ContentType.Text, ContentType.InlineComponent], {
            active: false,
            disabled: false
          })
        ]
      });
    }
  }, {
    name: i18n.get("components.jumbotronComponent.creator.name"),
    example: `<img src="data:image/svg+xml;charset=UTF-8,${encodeURIComponent('<svg width="100" height="70" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><linearGradient id="bg" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#6ad1ec"/><stop offset="100%" stop-color="#fff"/></linearGradient></defs><g><rect fill="url(#bg)" height="100%" width="100%"/></g><path fill="#fff" opacity="0.3" d="M81.25 28.125c0 5.178-4.197 9.375-9.375 9.375s-9.375-4.197-9.375-9.375 4.197-9.375 9.375-9.375 9.375 4.197 9.375 9.375z"></path><path fill="#fff" opacity="0.3"  d="M87.5 81.25h-75v-12.5l21.875-37.5 25 31.25h6.25l21.875-18.75z"></path><text font-family="Helvetica, Arial, sans-serif" font-size="12" x="10" y="25" stroke-width="0.3" stroke="#000" fill="#000000">Hello, world!</text><text font-family="Helvetica, Arial, sans-serif" font-size="6" x="10" y="40" stroke-width="0" stroke="#000" fill="#000000">\u4F60\u597D\uFF0C\u6211\u662F Textbus\uFF0C\u4E00\u4E2A\u7ED9\u4F60\u5E26\u6765\u5168\u65B0\u4F53\u9A8C\u7684\u5BCC\u6587\u672C\u5F00\u53D1\u6846\u67B6\u3002</text><text font-family="Helvetica, Arial, sans-serif" font-size="6" x="10" y="50" stroke-width="0" stroke="#000" fill="#000000">\u73B0\u5728\u6211\u4EEC\u5F00\u59CB\u5427\uFF01</text></svg>')}">`,
    factory() {
      return jumbotronComponent.createInstance(injector);
    }
  }, {
    name: i18n.get("components.katexComponent.creator.name"),
    example: `<img src="data:image/svg+xml;charset=UTF-8,${encodeURIComponent('<svg width="100" height="70" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 120 40.541"><path d="M4.618 27.925c-.299.299-.591.478-.874.538-.284.06-1.039.105-2.264.135H0v2.062h.493c.508-.09 2.66-.135 6.456-.135 3.796 0 5.948.045 6.456.135h.493v-2.062h-1.48c-1.764-.029-2.765-.209-3.004-.538-.09-.119-.135-1.584-.135-4.394v-4.259l2.062-2.018a83.544 83.544 0 002.063-1.972c.209-.209.388-.373.538-.493l3.901 5.873c2.331 3.587 3.661 5.62 3.99 6.098.09.179.135.359.135.538 0 .778-.688 1.166-2.062 1.166h-.359v2.062h.493c.628-.09 2.764-.135 6.412-.135.269 0 .673.008 1.211.022.538.015.956.022 1.255.022.298 0 .68.008 1.143.022.463.015.807.03 1.031.045.224.015.366.022.426.022h.359v-2.062h-.942c-1.255-.029-2.152-.194-2.69-.493a3.197 3.197 0 01-1.076-1.031l-5.179-7.779c-3.273-4.917-4.91-7.39-4.91-7.42 0-.029 1.33-1.33 3.99-3.901 2.66-2.57 4.065-3.93 4.215-4.08C26.6 2.817 28.379 2.219 30.62 2.1h.628V.037h-.269c-.03 0-.135.008-.314.022-.179.015-.434.03-.762.045a18.99 18.99 0 01-.852.022c-.209 0-.523.008-.942.022-.419.015-.747.022-.986.022-3.408 0-5.366-.045-5.873-.135h-.448v2.062h.179l.202.022.247.022c.836.209 1.255.643 1.255 1.3-.06.24-.12.404-.179.493-.06.12-2.272 2.317-6.636 6.591l-6.546 6.367-.045-6.95c0-4.663.015-7.024.045-7.084.06-.508.897-.762 2.511-.762h2.062V.037h-.493c-.509.09-2.661.135-6.456.135C3.152.172 1 .127.492.037H0v2.062h1.48c1.225.03 1.98.075 2.264.135.284.06.575.24.874.538v25.153zm34.924-16.858h1.793v-.269c.029-.119.074-.478.135-1.076.239-3.198.836-5.201 1.793-6.008.747-.628 1.763-1.046 3.049-1.255.298-.029 1.15-.045 2.556-.045h1.211c.687 0 1.113.022 1.278.067.164.045.291.202.381.471.029.06.045 4.23.045 12.509v12.375c-.24.329-.613.538-1.121.628-1.076.09-2.421.135-4.035.135h-1.345v2.062h.583c.628-.09 3.377-.135 8.25-.135 4.872 0 7.622.045 8.25.135h.583v-2.062h-1.345c-1.614 0-2.959-.045-4.035-.135-.509-.09-.882-.298-1.121-.628V15.461c0-8.279.015-12.449.045-12.509.09-.269.216-.426.381-.471.164-.045.59-.067 1.278-.067h1.211c1.674 0 2.825.075 3.452.224 1.136.329 1.957.807 2.466 1.435.747.867 1.225 2.75 1.435 5.649.06.598.104.957.135 1.076v.269h1.793v-.269c0-.06-.134-1.763-.404-5.111C67.97 2.34 67.82.636 67.791.576v-.27H40.394v.269c0 .06-.135 1.764-.404 5.111-.269 3.348-.419 5.052-.448 5.111v.27zm60.461 19.593v-2.062h-.359c-.658-.06-1.226-.254-1.704-.583-.478-.329-.717-.702-.717-1.121 0-.209.015-.329.045-.359.029-.09 1.031-1.629 3.004-4.618.448-.687.836-1.293 1.166-1.816.329-.523.605-.956.829-1.3.224-.343.411-.62.56-.829.149-.209.254-.343.314-.404l.135-.135 1.659 2.556a514.118 514.118 0 013.273 5.111c1.076 1.704 1.614 2.6 1.614 2.69 0 .209-.314.397-.942.56-.628.165-1.196.247-1.704.247h-.269v2.062h.493c.687-.09 2.869-.135 6.546-.135 3.318 0 5.201.045 5.649.135H120v-2.062h-1.39c-1.166-.029-1.958-.09-2.376-.179-.419-.09-.747-.269-.986-.538-.09-.09-1.667-2.526-4.73-7.308-3.064-4.782-4.596-7.203-4.596-7.263 0-.029.986-1.584 2.959-4.663 2.092-3.139 3.183-4.753 3.273-4.842 1.016-1.046 2.75-1.614 5.201-1.704h.762V.037h-.359c-.359.09-2.003.135-4.932.135-3.468 0-5.396-.045-5.784-.135h-.404v2.062h.359c.926.09 1.614.389 2.062.897.388.389.493.747.314 1.076 0 .03-.778 1.248-2.331 3.654-1.555 2.406-2.347 3.609-2.376 3.609-.06 0-.979-1.397-2.757-4.192-1.779-2.795-2.668-4.237-2.668-4.327.06-.149.404-.306 1.031-.471.628-.164 1.195-.247 1.704-.247h.224V.037h-.493c-.658.09-2.84.135-6.546.135-3.318 0-5.201-.045-5.649-.135h-.404v2.062h1.525c1.614 0 2.69.224 3.228.673.09.09 1.464 2.212 4.125 6.367 2.66 4.155 3.99 6.262 3.99 6.322 0 .03-1.188 1.868-3.564 5.515a2726.32 2726.32 0 01-3.744 5.739c-.957 1.166-2.765 1.793-5.425 1.883h-.763v2.062h.359c.359-.09 2.002-.135 4.932-.135 3.467 0 5.395.045 5.784.135h.448z"/><path d="M37.736 15.499h-3.429c-2.264 0-3.396-.011-3.396-.034l1.715-5.077 1.681-5.043.672 1.984a629.242 629.242 0 011.715 5.077l1.042 3.093zm-6.153 8.573v-1.547h-.168c-.493 0-.958-.095-1.395-.286-.437-.19-.723-.431-.857-.723a.491.491 0 01-.101-.303c0-.134.224-.863.672-2.185l.672-1.984h7.834l.807 2.387c.538 1.614.807 2.443.807 2.488 0 .403-.785.605-2.353.605h-.437v1.547h.336c.336-.067 1.95-.101 4.841-.101 2.51 0 3.934.034 4.27.101h.303v-1.547h-1.009c-1.166-.022-1.872-.146-2.118-.37a1.261 1.261 0 01-.235-.336c-.516-1.591-1.855-5.581-4.018-11.969C37.271 3.461 36.178.256 36.156.233c-.09-.132-.359-.21-.808-.233h-.303c-.359 0-.572.09-.639.269-.023.023-.611 1.754-1.765 5.194a16100.31 16100.31 0 01-5.262 15.65c-.449.874-1.479 1.345-3.093 1.412h-.504v1.547h.235c.269-.067 1.401-.101 3.396-.101 2.174 0 3.463.034 3.866.101h.304zm36.735 13.734c-.299.299-.591.478-.874.538-.284.06-1.039.105-2.264.135H63.7v2.062h26.229v-.135c.06-.09.381-2.085.964-5.986s.889-5.896.919-5.986v-.135h-1.793v.135c-.03.06-.105.464-.224 1.211-.269 1.793-.613 3.244-1.031 4.349-.509 1.375-1.248 2.399-2.219 3.071-.972.673-2.324 1.114-4.058 1.323-.419.03-1.973.045-4.663.045h-2.287c-1.375 0-2.152-.074-2.331-.224-.09-.06-.15-.164-.179-.314-.03-.06-.045-2.107-.045-6.142v-6.008h2.421c1.943.03 3.139.12 3.587.269.836.24 1.405.666 1.704 1.278.298.613.478 1.547.538 2.802v.897h1.793V18.437h-1.793v.897c-.06 1.255-.24 2.19-.538 2.802-.299.613-.867 1.039-1.704 1.278-.448.15-1.644.24-3.587.269h-2.421v-5.425c0-3.646.015-5.499.045-5.56.09-.298.269-.463.538-.493.239-.06 1.853-.09 4.842-.09 1.733 0 2.75.015 3.049.045 2.451.15 4.177.74 5.179 1.771 1.001 1.031 1.681 2.952 2.04 5.761.06.538.104.852.135.942v.179h1.793v-.179c0-.029-.209-1.763-.628-5.201l-.628-5.201v-.179H63.7v2.062h1.48c1.225.03 1.98.075 2.264.135.284.06.575.24.874.538v25.018z"/></svg>')}">`,
    factory() {
      return katexComponent.createInstance(injector, {
        state: {
          source: ""
        }
      });
    }
  }, {
    name: i18n.get("components.wordExplainComponent.creator.name"),
    example: `<img alt="\u793A\u4F8B" src="data:image/svg+xml;charset=UTF-8,${encodeURIComponent('<svg width="100" height="70" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g><rect fill="#fff" height="100%" width="100%"/></g><defs><g id="item"><rect fill="#eee" height="18" width="90" rx="2" x="5" y="6"/><line x1="26" y1="9" x2="26" y2="20.5" stroke="#000" stroke-dasharray="0.8 0.8" stroke-width="0.1"></line><text font-family="Helvetica, Arial, sans-serif" font-size="6" x="10" y="14" stroke-width="0" stroke="#000" fill="#000000">\u540D\u8BCD</text><text font-family="Helvetica, Arial, sans-serif" font-size="5" x="12" y="20" stroke-width="0" stroke="#000" fill="#000000">\u8BF4\u660E</text><text font-family="Helvetica, Arial, sans-serif" font-size="6" x="30" y="14" stroke-width="0" stroke="#000" fill="#000000">\u8BE6\u7EC6\u89E3\u91CA...</text></g></defs><use xlink:href="#item"></use><use xlink:href="#item" transform="translate(0, 20)"></use><use xlink:href="#item" transform="translate(0, 40)"></use></svg>')}">`,
    factory() {
      const { Text, InlineComponent } = ContentType;
      const titleSlot = new Slot([Text, InlineComponent]);
      const subtitleSlot = new Slot([Text, InlineComponent]);
      const detailSlot = new Slot([Text, InlineComponent]);
      titleSlot.insert("\u6807\u9898", boldFormatter, true);
      subtitleSlot.insert("\u526F\u6807\u9898");
      titleSlot.setAttribute(textAlignFormatter, "right");
      subtitleSlot.setAttribute(textAlignFormatter, "right");
      detailSlot.insert("\u6B63\u6587...");
      return wordExplainComponent.createInstance(injector, {
        slots: [
          titleSlot,
          subtitleSlot,
          detailSlot
        ]
      });
    }
  }, {
    name: i18n.get("components.timelineComponent.creator.name"),
    example: `<img alt="\u793A\u4F8B" src="data:image/svg+xml;charset=UTF-8,${encodeURIComponent('<svg width="100" height="70" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g><rect fill="#fff" height="100%" width="100%"/></g><defs><g id="item"><circle r="2" cx="10" cy="12"></circle><line x1="10" y1="12" x2="10" y2="24" stroke-width="0.5"></line><text font-family="Helvetica, Arial, sans-serif" font-size="5" x="16" y="14" stroke-width="0" stroke="#000" fill="#000000">\u4E8B\u4EF6\u4E3B\u9898</text><text font-family="Helvetica, Arial, sans-serif" font-size="4.5" x="38" y="13.5" stroke-width="0" stroke="#000" fill="#888">2020-08-08</text><text font-family="Helvetica, Arial, sans-serif" font-size="4.5" x="16" y="20" stroke-width="0" stroke="#000" fill="#000000">\u8BE6\u7EC6\u8BF4\u660E...</text></g></defs><use xlink:href="#item" fill="#1296db" stroke="#1296db"></use><use xlink:href="#item" transform="translate(0, 14)" fill="#15bd9a" stroke="#15bd9a"></use><use xlink:href="#item" transform="translate(0, 28)" fill="#495060" stroke="#495060"></use><use xlink:href="#item" transform="translate(0, 42)" fill="#E74F5E" stroke="#E74F5E"></use></svg>')}">`,
    factory() {
      return timelineComponent.createInstance(injector);
    }
  }, {
    name: i18n.get("components.stepsComponent.creator.name"),
    example: `<img alt="\u793A\u4F8B" src="data:image/svg+xml;charset=UTF-8,${encodeURIComponent('<svg width="100" height="70" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g><rect fill="#fff" height="100%" width="100%"/></g><defs><g id="item"><circle r="2" cx="10" cy="12"></circle><line x1="12" y1="12" x2="38" y2="12" stroke-width="0.5"></line><text font-family="Helvetica, Arial, sans-serif" font-size="5" x="8" y="22" stroke-width="0" stroke="#000" fill="#000000">\u6807\u9898</text><text font-family="Helvetica, Arial, sans-serif" font-size="4.5" x="8" y="27" stroke-width="0" stroke="#000" fill="#000">\u63CF\u8FF0\u4FE1\u606F...</text></g></defs><use xlink:href="#item" transform="translate(0, 20)" fill="#15bd9a" stroke="#15bd9a"></use><use xlink:href="#item" transform="translate(30, 20)" fill="#1296db" stroke="#1296db"></use><use xlink:href="#item" transform="translate(60, 20)" fill="#aaa" stroke="#aaa"></use></svg>')}">`,
    factory() {
      return stepComponent.createInstance(injector);
    }
  }, {
    name: i18n.get("components.alertComponent.creator.name"),
    example: `<img src="data:image/svg+xml;charset=UTF-8,${encodeURIComponent('<svg width="100" height="70" xmlns="http://www.w3.org/2000/svg"><g><rect fill="#fff" height="100%" width="100%"/></g><rect width="90%" height="20" fill="#eee" stroke="#dedede" rx="5" ry="5" x="5" y="25"></rect><text font-family="Helvetica, Arial, sans-serif" font-size="10" x="10" y="35" stroke-width="0" stroke="#000" fill="#000000">\u6587\u672C\u5185\u5BB9</text></svg>')}">`,
    factory() {
      return alertComponent.createInstance(injector);
    }
  }];
  const onComplete = new Subject();
  configs.forEach((i2) => {
    elementRef.append(createExample(injector, i2, onComplete));
  });
  return {
    iconClasses: ["textbus-icon-components"],
    tooltip: i18n.get("plugins.toolbar.componentsTool.tooltip"),
    viewController: {
      elementRef,
      onComplete,
      onCancel: new Observable(),
      reset() {
      },
      update() {
      }
    },
    queryState() {
      return {
        state: QueryStateType.Normal,
        value: null
      };
    },
    useValue() {
    }
  };
}
function componentsTool() {
  return new DropdownTool(componentsToolConfigFactory);
}
function superscriptToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    iconClasses: ["textbus-icon-superscript"],
    tooltip: i18n.get("plugins.toolbar.superscript.tooltip"),
    queryState() {
      return query.queryFormat(superscriptFormatter);
    },
    onClick() {
      const state = query.queryFormat(superscriptFormatter);
      const b2 = state.state === QueryStateType.Enabled;
      b2 ? commander.unApplyFormat(superscriptFormatter) : commander.applyFormat(superscriptFormatter, true);
    }
  };
}
function superscriptTool() {
  return new ButtonTool(superscriptToolConfigFactory);
}
function subscriptToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    iconClasses: ["textbus-icon-subscript"],
    tooltip: i18n.get("plugins.tooltip.subscript.tooltip"),
    queryState() {
      return query.queryFormat(subscriptFormatter);
    },
    onClick() {
      const state = query.queryFormat(subscriptFormatter);
      const b2 = state.state === QueryStateType.Enabled;
      b2 ? commander.unApplyFormat(subscriptFormatter) : commander.applyFormat(subscriptFormatter, true);
    }
  };
}
function subscriptTool() {
  return new ButtonTool(subscriptToolConfigFactory);
}
function preToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  const selection = injector.get(Selection);
  return {
    iconClasses: ["textbus-icon-source-code"],
    tooltip: i18n.get("plugins.toolbar.preTool.tooltip"),
    mini: true,
    options: [{
      label: "JavaScript",
      value: "JavaScript"
    }, {
      label: "HTML",
      value: "HTML"
    }, {
      label: "CSS",
      value: "CSS"
    }, {
      label: "TypeScript",
      value: "TypeScript"
    }, {
      label: "Java",
      value: "Java"
    }, {
      label: "C",
      value: "C"
    }, {
      label: "C++",
      value: "CPP"
    }, {
      label: "C#",
      value: "CSharp"
    }, {
      label: "Swift",
      value: "Swift"
    }, {
      label: "Go",
      value: "Go"
    }, {
      label: "JSON",
      value: "JSON"
    }, {
      label: "Less",
      value: "Less"
    }, {
      label: "SCSS",
      value: "SCSS"
    }, {
      label: "Stylus",
      value: "Stylus"
    }, {
      label: "Jsx",
      value: "Jsx"
    }, {
      label: "Tsx",
      value: "Tsx"
    }, {
      label: i18n.get("plugins.toolbar.preTool.defaultLang"),
      value: "",
      default: true
    }],
    queryState() {
      const state = query.queryComponent(preComponent);
      return {
        state: state.state,
        value: state.value ? state.value.toJSON().state.lang : null
      };
    },
    onChecked(value) {
      const state = query.queryComponent(preComponent);
      if (state.state === QueryStateType.Enabled) {
        state.value.updateState((draft) => {
          draft.lang = value;
        });
      } else {
        const component = preComponent.createInstance(injector, {
          state: {
            lang: value,
            theme: "light"
          },
          slots: [createCodeSlot()]
        });
        commander.insert(component);
        selection.setPosition(component.slots.get(0), 0);
      }
    }
  };
}
function preTool() {
  return new SelectTool(preToolConfigFactory);
}
function lineHeightToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    tooltip: i18n.get("plugins.toolbar.lineHeightTool.tooltip"),
    iconClasses: ["textbus-icon-line-height"],
    mini: true,
    options: [{
      label: i18n.get("plugins.toolbar.lineHeightTool.defaultValueLabel"),
      classes: ["textbus-toolbar-line-height-inherit"],
      value: "",
      default: true
    }, {
      label: "1x",
      classes: ["textbus-toolbar-line-height-1"],
      value: "1em"
    }, {
      label: "1.2x",
      classes: ["textbus-toolbar-line-height-1_2"],
      value: "1.2em"
    }, {
      label: "1.4x",
      classes: ["textbus-toolbar-line-height-1_4"],
      value: "1.4em"
    }, {
      label: "1.6x",
      classes: ["textbus-toolbar-line-height-1_6"],
      value: "1.6em"
    }, {
      label: "1.8x",
      classes: ["textbus-toolbar-line-height-1_8"],
      value: "1.8em"
    }, {
      label: "2x",
      classes: ["textbus-toolbar-line-height-2"],
      value: "2em"
    }, {
      label: "3x",
      classes: ["textbus-toolbar-line-height-3"],
      value: "3em"
    }, {
      label: "4x",
      classes: ["textbus-toolbar-line-height-4"],
      value: "4em"
    }],
    queryState() {
      return query.queryFormat(lineHeightFormatter);
    },
    onChecked(value) {
      if (value) {
        commander.applyFormat(lineHeightFormatter, value);
      } else {
        commander.unApplyFormat(lineHeightFormatter);
      }
    }
  };
}
function lineHeightTool() {
  return new SelectTool(lineHeightToolConfigFactory);
}
function letterSpacingToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    tooltip: i18n.get("plugins.toolbar.letterSpacingTool.tooltip"),
    iconClasses: ["textbus-icon-letter-spacing"],
    mini: true,
    options: [{
      label: i18n.get("plugins.toolbar.letterSpacingTool.defaultValueLabel"),
      value: "",
      classes: ["textbus-toolbar-letter-spacing-inherit"],
      default: true
    }, {
      label: "0px",
      value: "0px",
      classes: ["textbus-toolbar-letter-spacing-0"]
    }, {
      label: "1px",
      classes: ["textbus-toolbar-letter-spacing-1"],
      value: "1px"
    }, {
      label: "2px",
      classes: ["textbus-toolbar-letter-spacing-2"],
      value: "2px"
    }, {
      label: "3px",
      classes: ["textbus-toolbar-letter-spacing-3"],
      value: "3px"
    }, {
      label: "4px",
      classes: ["textbus-toolbar-letter-spacing-4"],
      value: "4px"
    }, {
      label: "5px",
      classes: ["textbus-toolbar-letter-spacing-5"],
      value: "5px"
    }],
    queryState() {
      return query.queryFormat(letterSpacingFormatter);
    },
    onChecked(value) {
      if (value) {
        commander.applyFormat(letterSpacingFormatter, value);
      } else {
        commander.unApplyFormat(letterSpacingFormatter);
      }
    }
  };
}
function letterSpacingTool() {
  return new SelectTool(letterSpacingToolConfigFactory);
}
var Emoji = class {
  constructor() {
    this.elementRef = document.createElement("div");
    this.onCancel = new Observable();
    this.checkEvent = new Subject();
    this.onComplete = this.checkEvent.asObservable();
    this.elementRef.classList.add("textbus-toolbar-emoji-menu");
    const emoji = [];
    for (let i2 = 128512; i2 <= 128591; i2++) {
      emoji.push(i2.toString(16).toUpperCase());
    }
    const fragment = document.createDocumentFragment();
    const buttons = emoji.map((s2) => {
      const button = document.createElement("button");
      button.type = "button";
      button.classList.add("textbus-toolbar-emoji-menu-item");
      button.innerHTML = `&#x${s2};`;
      fragment.appendChild(button);
      return button;
    });
    this.elementRef.addEventListener("click", (ev) => {
      const target = ev.target;
      for (const btn of buttons) {
        if (target === btn) {
          this.checkEvent.next(btn.innerHTML);
          break;
        }
      }
    });
    this.elementRef.appendChild(fragment);
  }
  update() {
  }
  reset() {
  }
};
function emojiToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const commander = injector.get(Commander);
  return {
    iconClasses: ["textbus-icon-emoji"],
    tooltip: i18n.get("plugins.toolbar.emojiTool.tooltip"),
    viewController: new Emoji(),
    queryState() {
      return {
        state: QueryStateType.Normal,
        value: null
      };
    },
    useValue(value) {
      commander.insert(value);
    }
  };
}
function emojiTool() {
  return new DropdownTool(emojiToolConfigFactory);
}
function leftToRightToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    iconClasses: ["textbus-icon-ltr"],
    tooltip: i18n.get("plugins.toolbar.leftToRightTool.tooltip"),
    queryState() {
      const state = query.queryAttribute(dirFormatter);
      return {
        state: state.value === "ltr" ? QueryStateType.Enabled : QueryStateType.Normal,
        value: state.value
      };
    },
    onClick() {
      const state = query.queryAttribute(dirFormatter);
      const b2 = state.value === "ltr";
      b2 ? commander.unApplyAttribute(dirFormatter) : commander.applyAttribute(dirFormatter, "ltr");
    }
  };
}
function leftToRightTool() {
  return new ButtonTool(leftToRightToolConfigFactory);
}
function rightToLeftToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    iconClasses: ["textbus-icon-rtl"],
    tooltip: i18n.get("plugins.toolbar.rightToLeftTool.tooltip"),
    queryState() {
      const state = query.queryAttribute(dirFormatter);
      return {
        state: state.value === "rtl" ? QueryStateType.Enabled : QueryStateType.Normal,
        value: state.value
      };
    },
    onClick() {
      const state = query.queryAttribute(dirFormatter);
      const b2 = state.value === "rtl";
      b2 ? commander.unApplyAttribute(dirFormatter) : commander.applyAttribute(dirFormatter, "rtl");
    }
  };
}
function rightToLeftTool() {
  return new ButtonTool(rightToLeftToolConfigFactory);
}
function videoToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  const uploader = injector.get(FileUploader);
  const childI18n = i18n.getContext("plugins.toolbar.videoTool.view");
  const form = new Form({
    title: childI18n.get("title"),
    confirmBtnText: childI18n.get("confirmBtnText"),
    cancelBtnText: childI18n.get("cancelBtnText"),
    items: [
      new FormTextField({
        label: childI18n.get("linkLabel"),
        name: "src",
        placeholder: childI18n.get("linkInputPlaceholder"),
        canUpload: true,
        uploadType: "video",
        fileUploader: uploader,
        uploadBtnText: childI18n.get("uploadBtnText"),
        validateFn(value) {
          if (!value) {
            return childI18n.get("validateErrorMessage");
          }
          return false;
        }
      }),
      new FormHidden({
        name: "controls",
        value: "controls"
      }),
      new FormTextField({
        label: childI18n.get("videoWidthLabel"),
        name: "width",
        placeholder: childI18n.get("videoWidthInputPlaceholder"),
        value: "100%"
      }),
      new FormTextField({
        label: childI18n.get("videoHeightLabel"),
        name: "height",
        placeholder: childI18n.get("videoHeightInputPlaceholder"),
        value: "auto"
      }),
      new FormSwitch({
        label: childI18n.get("autoplayLabel"),
        checked: false,
        name: "autoplay"
      })
    ]
  });
  return {
    iconClasses: ["textbus-icon-video"],
    tooltip: i18n.get("plugins.toolbar.videoTool.tooltip"),
    viewController: form,
    queryState() {
      const state = query.queryComponent(videoComponent);
      if (state.state === QueryStateType.Enabled) {
        return {
          state: QueryStateType.Enabled,
          value: state.value.toJSON().state
        };
      }
      return {
        state: state.state,
        value: null
      };
    },
    useValue(value) {
      if (value) {
        const state = query.queryComponent(videoComponent);
        if (state.state === QueryStateType.Enabled) {
          state.value.extends.mergeProps(value);
        } else {
          commander.insert(videoComponent.createInstance(injector, {
            state: value
          }));
        }
      }
    }
  };
}
function videoTool() {
  return new DialogTool(videoToolConfigFactory);
}
function defaultGroupToolFactory(injector) {
  const i18n = injector.get(I18n);
  return {
    iconClasses: ["textbus-icon-plus"],
    items: [Object.assign(Object.assign({}, preToolConfigFactory(injector)), { type: ToolType.Select, label: i18n.get("plugins.toolbar.insertObjectTool.sourceCode") }), Object.assign(Object.assign({}, lineHeightToolConfigFactory(injector)), { type: ToolType.Select, label: i18n.get("plugins.toolbar.insertObjectTool.lineHeight") }), Object.assign(Object.assign({}, letterSpacingToolConfigFactory(injector)), { type: ToolType.Select, label: i18n.get("plugins.toolbar.insertObjectTool.letterSpacing") }), Object.assign(Object.assign({}, emojiToolConfigFactory(injector)), { type: ToolType.Dropdown, label: i18n.get("plugins.toolbar.insertObjectTool.emoji") }), Object.assign(Object.assign({}, audioToolConfigFactory(injector)), { type: ToolType.Dialog, label: i18n.get("plugins.toolbar.insertObjectTool.audio") }), Object.assign(Object.assign({}, videoToolConfigFactory(injector)), { type: ToolType.Dialog, label: i18n.get("plugins.toolbar.insertObjectTool.video") }), Object.assign(Object.assign({}, superscriptToolConfigFactory(injector)), { type: ToolType.Button, label: i18n.get("plugins.toolbar.insertObjectTool.superscript") }), Object.assign(Object.assign({}, subscriptToolConfigFactory(injector)), { type: ToolType.Button, label: i18n.get("plugins.toolbar.insertObjectTool.subscript") }), Object.assign(Object.assign({}, codeToolConfigFactory(injector)), { type: ToolType.Button, label: i18n.get("plugins.toolbar.insertObjectTool.code") }), Object.assign(Object.assign({}, blockquoteToolConfigFactory(injector)), { type: ToolType.Button, label: i18n.get("plugins.toolbar.insertObjectTool.blockquote") }), Object.assign(Object.assign({}, leftToRightToolConfigFactory(injector)), { type: ToolType.Button, label: i18n.get("plugins.toolbar.insertObjectTool.leftToRight") }), Object.assign(Object.assign({}, rightToLeftToolConfigFactory(injector)), { type: ToolType.Button, label: i18n.get("plugins.toolbar.insertObjectTool.rightToLeft") })]
  };
}
function defaultGroupTool() {
  return new GroupTool(defaultGroupToolFactory);
}
var isSupportFont = function() {
  const fullbackFontName = "Arial";
  const text2 = "HeRe-is*SoMe%tEst +99.? !@ #~ &^teXtWw L$VEY$U0";
  const fontSize = 20;
  const width = 200;
  const height = 50;
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  canvas.width = width;
  canvas.height = height;
  context.textAlign = "center";
  context.fillStyle = "black";
  context.textBaseline = "middle";
  function checker(fontName) {
    context.clearRect(0, 0, width, height);
    context.font = fontSize + "px " + fontName + ", " + fullbackFontName;
    context.fillText(text2, width / 2, height / 2);
    const data = context.getImageData(0, 0, width, height).data;
    return Array.from(data).filter((n2) => n2 !== 0);
  }
  return function(fontName) {
    if (fontName.toLowerCase() === fullbackFontName.toLowerCase()) {
      return true;
    }
    return checker(fullbackFontName).join("") !== checker(fontName).join("");
  };
}();
function fontFamilyToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    tooltip: i18n.get("plugins.toolbar.fontFamilyTool.tooltip"),
    options: [{
      label: i18n.get("plugins.toolbar.fontFamilyTool.defaultFamilyText"),
      classes: ["textbus-toolbar-font-family-inherit"],
      value: "",
      default: true
    }, {
      label: "\u5B8B\u4F53",
      classes: ["textbus-toolbar-font-family-SimSun"],
      value: "SimSun, STSong"
    }, {
      label: "\u9ED1\u4F53",
      classes: ["textbus-toolbar-font-family-SimHei"],
      value: "SimHei, STHeiti"
    }, {
      label: "\u5FAE\u8F6F\u96C5\u9ED1",
      classes: ["textbus-toolbar-font-family-Microsoft-YaHei"],
      value: "Microsoft YaHei"
    }, {
      label: "\u6977\u4F53",
      classes: ["textbus-toolbar-font-family-KaiTi"],
      value: "KaiTi, STKaiti"
    }, {
      label: "\u4EFF\u5B8B",
      classes: ["textbus-toolbar-font-family-FangSong"],
      value: "FangSong, STFangsong"
    }, {
      label: "\u51AC\u9752\u9ED1\u7B80\u4F53\u4E2D\u6587",
      classes: ["textbus-toolbar-font-family-DongQingHei"],
      value: '"Hiragino Sans GB", \u51AC\u9752\u9ED1\u7B80\u4F53\u4E2D\u6587'
    }, {
      label: "\u82F9\u65B9",
      classes: ["textbus-toolbar-font-family-PingFang"],
      value: '"PingFang SC", \u82F9\u65B9'
    }, {
      label: "\u96B6\u4E66",
      classes: ["textbus-toolbar-font-family-SimLi"],
      value: "SimLi"
    }, {
      label: "Andale Mono",
      classes: ["textbus-toolbar-font-family-andale-mono"],
      value: "Andale Mono"
    }, {
      label: "Arial",
      classes: ["textbus-toolbar-font-family-Arial"],
      value: "Arial"
    }, {
      label: "Helvetica",
      classes: ["textbus-toolbar-font-family-Helvetica"],
      value: "Helvetica"
    }, {
      label: "Impact",
      classes: ["textbus-toolbar-font-family-Impact"],
      value: "Impact"
    }, {
      label: "Times New Roman",
      classes: ["textbus-toolbar-font-family-Times-New-Roman"],
      value: "Times New Roman"
    }].map((i2) => {
      if (i2.value) {
        if (!i2.value.split(",").map((i3) => isSupportFont(i3.trim())).some((v2) => v2)) {
          i2.disabled = true;
        }
      }
      return i2;
    }),
    queryState() {
      return query.queryFormat(fontFamilyFormatter);
    },
    onChecked(value) {
      value ? commander.applyFormat(fontFamilyFormatter, value) : commander.unApplyFormat(fontFamilyFormatter);
    }
  };
}
function fontFamilyTool() {
  return new SelectTool(fontFamilyToolConfigFactory);
}
function fontSizeToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    tooltip: i18n.get("plugins.toolbar.fontSizeTool.tooltip"),
    iconClasses: ["textbus-icon-font-size"],
    mini: true,
    options: [{
      label: i18n.get("plugins.toolbar.fontSizeTool.defaultSizeText"),
      classes: ["textbus-toolbar-font-size-inherit"],
      value: "",
      default: true
    }, {
      label: "12px",
      classes: ["textbus-toolbar-font-size-12"],
      value: "12px"
    }, {
      label: "13px",
      classes: ["textbus-toolbar-font-size-13"],
      value: "13px"
    }, {
      label: "14px",
      classes: ["textbus-toolbar-font-size-14"],
      value: "14px"
    }, {
      label: "15px",
      classes: ["textbus-toolbar-font-size-15"],
      value: "15px"
    }, {
      label: "16px",
      classes: ["textbus-toolbar-font-size-16"],
      value: "16px"
    }, {
      label: "18px",
      classes: ["textbus-toolbar-font-size-18"],
      value: "18px"
    }, {
      label: "20px",
      classes: ["textbus-toolbar-font-size-20"],
      value: "20px"
    }, {
      label: "24px",
      classes: ["textbus-toolbar-font-size-24"],
      value: "24px"
    }, {
      label: "36px",
      classes: ["textbus-toolbar-font-size-36"],
      value: "36px"
    }, {
      label: "48px",
      classes: ["textbus-toolbar-font-size-48"],
      value: "48px"
    }],
    queryState() {
      return query.queryFormat(fontSizeFormatter);
    },
    onChecked(value) {
      !value ? commander.unApplyFormat(fontSizeFormatter) : commander.applyFormat(fontSizeFormatter, value);
    }
  };
}
function fontSizeTool() {
  return new SelectTool(fontSizeToolConfigFactory);
}
function formatPainterToolConfigFactory(injector) {
  const selection = injector.get(Selection);
  const commander = injector.get(Commander);
  const doc = injector.get(VIEW_DOCUMENT);
  const i18n = injector.get(I18n);
  const registry = injector.get(Registry);
  let isActive = false;
  return {
    iconClasses: ["textbus-icon-brush"],
    tooltip: i18n.get("plugins.toolbar.formatPainterTool.tooltip"),
    queryState() {
      if (isActive) {
        return {
          state: QueryStateType.Enabled,
          value: null
        };
      }
      return {
        state: selection.isSelected ? QueryStateType.Normal : QueryStateType.Disabled,
        value: null
      };
    },
    onClick() {
      if (!selection.isSelected) {
        return;
      }
      isActive = true;
      const startSlot = selection.startSlot;
      const formats = startSlot.extractFormatsByIndex(selection.startOffset);
      const parentComponent = startSlot.parent;
      const multipleComponent = [
        listComponent,
        todolistComponent
      ];
      const canTransformComponentNames = [
        paragraphComponent,
        blockComponent,
        listComponent,
        todolistComponent,
        headingComponent
      ].map((i2) => i2.name);
      let componentName = paragraphComponent.name;
      let state = null;
      if (canTransformComponentNames.includes(parentComponent.name)) {
        componentName = parentComponent.name;
        state = typeof parentComponent.state === "object" && parentComponent.state !== null ? JSON.parse(JSON.stringify(parentComponent.state)) : parentComponent.state;
      }
      startSlot.changeMarker.forceMarkChanged();
      const { Text, InlineComponent, BlockComponent } = ContentType;
      fromEvent(doc, "mouseup").pipe(take(1), delay(10)).subscribe(() => {
        isActive = false;
        commander.cleanFormats([linkFormatter]);
        formats.forEach((i2) => {
          commander.applyFormat(i2[0], i2[1]);
        });
        commander.transform({
          multipleSlot: multipleComponent.map((i2) => i2.name).includes(componentName),
          target: registry.getComponent(componentName),
          slotFactory() {
            return new Slot(componentName === blockComponent.name ? [
              Text,
              InlineComponent,
              BlockComponent
            ] : [
              Text,
              InlineComponent
            ], startSlot.state);
          },
          stateFactory() {
            return state;
          }
        });
      });
    }
  };
}
function formatPainterTool() {
  return new ButtonTool(formatPainterToolConfigFactory);
}
function headingToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    tooltip: i18n.get("plugins.toolbar.headingTool.tooltip"),
    options: [{
      label: i18n.get("plugins.toolbar.headingTool.h1"),
      classes: ["textbus-toolbar-h1"],
      value: "h1",
      keymap: {
        ctrlKey: true,
        key: "1"
      }
    }, {
      label: i18n.get("plugins.toolbar.headingTool.h2"),
      classes: ["textbus-toolbar-h2"],
      value: "h2",
      keymap: {
        ctrlKey: true,
        key: "2"
      }
    }, {
      label: i18n.get("plugins.toolbar.headingTool.h3"),
      classes: ["textbus-toolbar-h3"],
      value: "h3",
      keymap: {
        ctrlKey: true,
        key: "3"
      }
    }, {
      label: i18n.get("plugins.toolbar.headingTool.h4"),
      classes: ["textbus-toolbar-h4"],
      value: "h4",
      keymap: {
        ctrlKey: true,
        key: "4"
      }
    }, {
      label: i18n.get("plugins.toolbar.headingTool.h5"),
      classes: ["textbus-toolbar-h5"],
      value: "h5",
      keymap: {
        ctrlKey: true,
        key: "5"
      }
    }, {
      label: i18n.get("plugins.toolbar.headingTool.h6"),
      classes: ["textbus-toolbar-h6"],
      value: "h6",
      keymap: {
        ctrlKey: true,
        key: "6"
      }
    }, {
      label: i18n.get("plugins.toolbar.headingTool.paragraph"),
      value: "p",
      default: true,
      keymap: {
        ctrlKey: true,
        key: "0"
      }
    }],
    queryState() {
      const headingState = query.queryComponent(headingComponent);
      if (headingState.state === QueryStateType.Enabled) {
        return {
          state: QueryStateType.Enabled,
          value: headingState.value.extends.type
        };
      }
      const paragraphState = query.queryComponent(paragraphComponent);
      return {
        state: paragraphState.state,
        value: paragraphState.state === QueryStateType.Enabled ? "p" : null
      };
    },
    onChecked(value) {
      const isHeading = /h[1-6]/.test(value);
      commander.transform({
        target: isHeading ? headingComponent : paragraphComponent,
        multipleSlot: false,
        slotFactory() {
          return new Slot([
            ContentType.Text,
            ContentType.InlineComponent
          ]);
        },
        stateFactory() {
          if (isHeading) {
            return value;
          }
        }
      });
    }
  };
}
function headingTool() {
  return new SelectTool(headingToolConfigFactory);
}
function historyBackToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const history = injector.get(History);
  return {
    iconClasses: ["textbus-icon-history-back"],
    tooltip: i18n.get("plugins.toolbar.historyBackTool.tooltip"),
    keymap: {
      ctrlKey: true,
      key: "z"
    },
    queryState() {
      return {
        state: history.canBack ? QueryStateType.Normal : QueryStateType.Disabled,
        value: null
      };
    },
    onClick() {
      history.back();
    }
  };
}
function historyBackTool() {
  return new ButtonTool(historyBackToolConfigFactory);
}
function historyForwardToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const history = injector.get(History);
  return {
    iconClasses: ["textbus-icon-history-forward"],
    tooltip: i18n.get("plugins.toolbar.historyForwardTool.tooltip"),
    keymap: {
      ctrlKey: true,
      shiftKey: true,
      key: "z"
    },
    queryState() {
      return {
        state: history.canForward ? QueryStateType.Normal : QueryStateType.Disabled,
        value: null
      };
    },
    onClick() {
      history.forward();
    }
  };
}
function historyForwardTool() {
  return new ButtonTool(historyForwardToolConfigFactory);
}
function imageToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const commander = injector.get(Commander);
  const fileUploader = injector.get(FileUploader);
  const childI18n = i18n.getContext("plugins.toolbar.imageTool.view");
  const form = new Form({
    mini: true,
    confirmBtnText: childI18n.get("confirmBtnText"),
    items: [
      new FormTextField({
        label: childI18n.get("linkLabel"),
        name: "src",
        placeholder: childI18n.get("linkInputPlaceholder")
      }),
      new FormButton({
        name: "",
        value: "",
        label: childI18n.get("uploadLabel"),
        btnText: childI18n.get("uploadBtnText"),
        iconClasses: ["textbus-icon-upload"],
        onClick() {
          fileUploader.upload({
            multiple: true,
            uploadType: "image",
            currentValue: ""
          }).subscribe((value) => {
            if (typeof value === "string") {
              value = [value];
            }
            value.forEach((i2) => {
              commander.insert(imageComponent.createInstance(injector, {
                state: {
                  src: i2
                }
              }));
            });
          });
        }
      })
    ]
  });
  return {
    iconClasses: ["textbus-icon-image"],
    tooltip: i18n.get("plugins.toolbar.imageTool.tooltip"),
    queryState() {
      return {
        state: QueryStateType.Normal,
        value: null
      };
    },
    viewController: form,
    useValue(value) {
      if (!value) {
        return;
      }
      commander.insert(imageComponent.createInstance(injector, {
        state: {
          src: value.src
        }
      }));
    }
  };
}
function imageTool() {
  return new DropdownTool(imageToolConfigFactory);
}
function insertParagraphAfterToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const commander = injector.get(Commander);
  const selection = injector.get(Selection);
  return {
    iconClasses: ["textbus-icon-insert-paragraph-after"],
    tooltip: i18n.get("plugins.toolbar.insertParagraphAfterTool.tooltip"),
    keymap: {
      ctrlKey: true,
      key: "p"
    },
    queryState() {
      var _a2;
      if (selection.isSelected) {
        if ((_a2 = selection.commonAncestorComponent) === null || _a2 === void 0 ? void 0 : _a2.parent) {
          return {
            state: QueryStateType.Normal,
            value: null
          };
        }
      }
      return {
        state: QueryStateType.Disabled,
        value: null
      };
    },
    onClick() {
      const p2 = paragraphComponent.createInstance(injector);
      commander.insertAfter(p2, selection.commonAncestorComponent);
      selection.setPosition(p2.slots.get(0), 0);
    }
  };
}
function insertParagraphAfterTool() {
  return new ButtonTool(insertParagraphAfterToolConfigFactory);
}
function insertParagraphBeforeToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const commander = injector.get(Commander);
  const selection = injector.get(Selection);
  return {
    iconClasses: ["textbus-icon-insert-paragraph-before"],
    tooltip: i18n.get("plugins.toolbar.insertParagraphBeforeTool.tooltip"),
    keymap: {
      ctrlKey: true,
      shiftKey: true,
      key: "p"
    },
    queryState() {
      var _a2;
      if (selection.isSelected) {
        if ((_a2 = selection.commonAncestorComponent) === null || _a2 === void 0 ? void 0 : _a2.parent) {
          return {
            state: QueryStateType.Normal,
            value: null
          };
        }
      }
      return {
        state: QueryStateType.Disabled,
        value: null
      };
    },
    onClick() {
      const p2 = paragraphComponent.createInstance(injector);
      commander.insertBefore(p2, selection.commonAncestorComponent);
      selection.setPosition(p2.slots.get(0), 0);
    }
  };
}
function insertParagraphBeforeTool() {
  return new ButtonTool(insertParagraphBeforeToolConfigFactory);
}
function italicToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    iconClasses: ["textbus-icon-italic"],
    tooltip: i18n.get("plugins.toolbar.italicTool.tooltip"),
    keymap: {
      ctrlKey: true,
      key: "i"
    },
    queryState() {
      return query.queryFormat(italicFormatter);
    },
    onClick() {
      const state = query.queryFormat(italicFormatter);
      const b2 = state.state === QueryStateType.Enabled;
      b2 ? commander.unApplyFormat(italicFormatter) : commander.applyFormat(italicFormatter, true);
    }
  };
}
function italicTool() {
  return new ButtonTool(italicToolConfigFactory);
}
function linkToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  const selection = injector.get(Selection);
  const childI18n = i18n.getContext("plugins.toolbar.linkTool.view");
  const form = new Form({
    mini: true,
    items: [
      new FormTextField({
        label: childI18n.get("linkLabel"),
        name: "href",
        placeholder: childI18n.get("linkInputPlaceholder"),
        validateFn(value) {
          const a2 = document.createElement("a");
          a2.href = value;
          if (a2.hostname) {
            return false;
          }
          return childI18n.get("invalidMessage");
        }
      }),
      new FormRadio({
        label: childI18n.get("jumpLabel"),
        name: "target",
        values: [{
          label: childI18n.get("jumpSelfLabel"),
          value: "_self",
          default: true
        }, {
          label: childI18n.get("jumpBlankLabel"),
          value: "_blank"
        }]
      })
    ]
  });
  return {
    iconClasses: ["textbus-icon-link"],
    tooltip: i18n.get("plugins.toolbar.linkTool.tooltip"),
    viewController: form,
    queryState() {
      return query.queryFormat(linkFormatter);
    },
    useValue(value) {
      if (selection.isCollapsed) {
        const slot = selection.startSlot;
        slot.getFormatRangesByFormatter(linkFormatter, 0, slot.length).filter((f2) => {
          return f2.startIndex < selection.startOffset && f2.endIndex >= selection.endOffset;
        }).forEach((f2) => {
          slot.retain(f2.startIndex);
          slot.retain(f2.endIndex - f2.startIndex, linkFormatter, value);
        });
      }
      commander.applyFormat(linkFormatter, value);
    }
  };
}
function linkTool() {
  return new DropdownTool(linkToolConfigFactory);
}
function listToolCreator(injector, type) {
  const selection = injector.get(Selection);
  const commander = injector.get(Commander);
  const instance = {
    queryState() {
      const component = selection.commonAncestorComponent;
      if ((component === null || component === void 0 ? void 0 : component.name) === listComponent.name && component.extends.type === type) {
        return {
          state: QueryStateType.Enabled,
          value: component
        };
      }
      return {
        state: QueryStateType.Normal,
        value: null
      };
    },
    onClick() {
      const queryState = instance.queryState();
      if (queryState.state === QueryStateType.Normal) {
        instance.toList();
      } else {
        instance.toParagraph();
      }
    },
    toParagraph() {
      commander.transform({
        target: paragraphComponent,
        multipleSlot: false,
        slotFactory() {
          return new Slot([
            ContentType.Text,
            ContentType.InlineComponent
          ]);
        }
      });
    },
    toList() {
      commander.transform({
        target: listComponent,
        multipleSlot: true,
        slotFactory() {
          return new Slot([
            ContentType.Text,
            ContentType.InlineComponent
          ]);
        },
        stateFactory() {
          return type;
        }
      });
    }
  };
  return instance;
}
function olToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  return Object.assign({ iconClasses: ["textbus-icon-list-numbered"], tooltip: i18n.get("plugins.toolbar.olTool.tooltip"), keymap: {
    shiftKey: true,
    ctrlKey: true,
    key: "o"
  } }, listToolCreator(injector, "ol"));
}
function olTool() {
  return new ButtonTool(olToolConfigFactory);
}
function strikeThroughToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    iconClasses: ["textbus-icon-strikethrough"],
    tooltip: i18n.get("plugins.toolbar.strikeThrough.tooltip"),
    keymap: {
      ctrlKey: true,
      key: "d"
    },
    queryState() {
      return query.queryFormat(strikeThroughFormatter);
    },
    onClick() {
      const state = query.queryFormat(strikeThroughFormatter);
      const b2 = state.state === QueryStateType.Enabled;
      b2 ? commander.unApplyFormat(strikeThroughFormatter) : commander.applyFormat(strikeThroughFormatter, true);
    }
  };
}
function strikeThroughTool() {
  return new ButtonTool(strikeThroughToolConfigFactory);
}
function tableAddToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const commander = injector.get(Commander);
  const selection = injector.get(Selection);
  const childI18n = i18n.getContext("plugins.toolbar.tableAddTool.view");
  const form = new Form({
    mini: true,
    confirmBtnText: childI18n.get("confirmBtnText"),
    items: [
      new FormNumber({
        name: "rows",
        label: childI18n.get("rowLabel"),
        placeholder: childI18n.get("rowPlaceholder")
      }),
      new FormNumber({
        name: "cols",
        label: childI18n.get("columnLabel"),
        placeholder: childI18n.get("columnPlaceholder")
      }),
      new FormSwitch({
        label: childI18n.get("useTextbusStyleLabel"),
        name: "useTextbusStyle",
        checked: true
      })
    ]
  });
  const quickSelector = document.createElement("div");
  quickSelector.classList.add("textbus-toolbar-table-quick-selector");
  const map2 = /* @__PURE__ */ new Map();
  for (let row = 0; row < 10; row++) {
    for (let col = 0; col < 10; col++) {
      ((row2, col2) => {
        const cell = document.createElement("div");
        quickSelector.appendChild(cell);
        map2.set(cell, {
          row: row2,
          col: col2
        });
      })(row, col);
    }
  }
  let flag = false;
  quickSelector.addEventListener("mouseover", (ev) => {
    if (flag) {
      return;
    }
    const srcElement = ev.target;
    const config = map2.get(srcElement);
    if (config) {
      map2.forEach((value, key) => {
        if (value.row <= config.row && value.col <= config.col) {
          key.classList.add("textbus-toolbar-table-quick-selector-selected");
        } else {
          key.classList.remove("textbus-toolbar-table-quick-selector-selected");
        }
      });
      form.update({
        cols: config.col + 1,
        rows: config.row + 1
      });
    }
  });
  quickSelector.addEventListener("mouseleave", () => {
    if (!flag) {
      Array.from(map2.keys()).forEach((el) => el.classList.remove("textbus-toolbar-table-quick-selector-selected"));
      form.update({});
    }
    flag = false;
  });
  quickSelector.addEventListener("click", () => {
    flag = true;
  });
  form.elementRef.insertBefore(quickSelector, form.elementRef.childNodes[0]);
  return {
    iconClasses: ["textbus-icon-table"],
    tooltip: i18n.get("plugins.toolbar.tableAddTool.tooltip"),
    viewController: form,
    queryState() {
      return {
        state: QueryStateType.Normal,
        value: null
      };
    },
    useValue(value) {
      function create(rows, columns) {
        const result = [];
        const size = rows * columns;
        for (let i2 = 0; i2 < size; i2++) {
          result.push(createCell());
        }
        return result;
      }
      const component = tableComponent.createInstance(injector, {
        slots: create(value.rows || 4, value.cols || 6),
        state: {
          useTextbusStyle: value.useTextbusStyle,
          columnCount: value.cols || 6,
          rowCount: value.rows || 4
        }
      });
      commander.insert(component);
      selection.setPosition(component.slots.get(0), 0);
    }
  };
}
function tableAddTool() {
  return new DropdownTool(tableAddToolConfigFactory);
}
function tableRemoveToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    iconClasses: ["textbus-icon-table-remove"],
    tooltip: i18n.get("plugins.toolbar.tableRemoveTool.tooltip"),
    queryState() {
      const s2 = query.queryComponent(tableComponent);
      if (s2.state !== QueryStateType.Enabled) {
        s2.state = QueryStateType.Disabled;
      } else if (s2.state === QueryStateType.Enabled) {
        s2.state = QueryStateType.Normal;
      }
      return s2;
    },
    onClick() {
      const s2 = query.queryComponent(tableComponent);
      if (s2.state === QueryStateType.Enabled) {
        commander.removeComponent(s2.value);
      }
    }
  };
}
function tableRemoveTool() {
  return new ButtonTool(tableRemoveToolConfigFactory);
}
function textAlignToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    tooltip: i18n.get("plugins.toolbar.textAlignTool.tooltip"),
    options: [{
      label: i18n.get("plugins.toolbar.textAlignTool.left"),
      iconClasses: ["textbus-icon-paragraph-left"],
      value: "left",
      keymap: {
        ctrlKey: true,
        key: "l"
      },
      default: true
    }, {
      label: i18n.get("plugins.toolbar.textAlignTool.right"),
      iconClasses: ["textbus-icon-paragraph-right"],
      value: "right",
      keymap: {
        ctrlKey: true,
        key: "r"
      }
    }, {
      label: i18n.get("plugins.toolbar.textAlignTool.center"),
      iconClasses: ["textbus-icon-paragraph-center"],
      value: "center",
      keymap: {
        ctrlKey: true,
        key: "e"
      }
    }, {
      label: i18n.get("plugins.toolbar.textAlignTool.justify"),
      iconClasses: ["textbus-icon-paragraph-justify"],
      value: "justify",
      keymap: {
        ctrlKey: true,
        key: "j"
      }
    }],
    queryState() {
      return query.queryAttribute(textAlignFormatter);
    },
    onChecked(value) {
      commander.applyAttribute(textAlignFormatter, value);
    }
  };
}
function textAlignTool() {
  return new SelectTool(textAlignToolConfigFactory);
}
function textBackgroundToolConfigFactory(injector) {
  const i18n = injector.get(I18n).getContext("plugins.toolbar.textBackgroundColorTool");
  const palette = new Palette("color", i18n.get("view.btnText"), i18n.get("view.recentText"), i18n.get("view.backText"), i18n.get("view.paletteText"));
  return Object.assign({ iconClasses: ["textbus-icon-background-color"], tooltip: i18n.get("tooltip") }, colorToolCreator(injector, palette, textBackgroundColorFormatter));
}
function textBackgroundTool() {
  return new SegmentDropdownTool(textBackgroundToolConfigFactory);
}
function textIndentToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    tooltip: i18n.get("plugins.toolbar.textIndentTool.tooltip"),
    iconClasses: ["textbus-icon-text-indent"],
    mini: true,
    options: [{
      label: "0x",
      value: "0",
      classes: ["textbus-toolbar-text-indent-0"],
      default: true
    }, {
      label: "1x",
      value: "1em",
      classes: ["textbus-toolbar-text-indent-1"]
    }, {
      label: "2x",
      classes: ["textbus-toolbar-text-indent-2"],
      value: "2em"
    }, {
      label: "4x",
      classes: ["textbus-toolbar-text-indent-4"],
      value: "4em"
    }],
    queryState() {
      return query.queryAttribute(textIndentFormatter);
    },
    onChecked(value) {
      value === "0" ? commander.unApplyAttribute(textIndentFormatter) : commander.applyAttribute(textIndentFormatter, value);
    }
  };
}
function textIndentTool() {
  return new SelectTool(textIndentToolConfigFactory);
}
function ulToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  return Object.assign({ iconClasses: ["textbus-icon-list"], tooltip: i18n.get("plugins.toolbar.ulTool.tooltip"), keymap: {
    shiftKey: true,
    ctrlKey: true,
    key: "u"
  } }, listToolCreator(injector, "ul"));
}
function ulTool() {
  return new ButtonTool(ulToolConfigFactory);
}
function underlineToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    iconClasses: ["textbus-icon-underline"],
    tooltip: i18n.get("plugins.toolbar.underlineTool.tooltip"),
    keymap: {
      ctrlKey: true,
      key: "u"
    },
    queryState() {
      return query.queryFormat(underlineFormatter);
    },
    onClick() {
      const state = query.queryFormat(underlineFormatter);
      const b2 = state.state === QueryStateType.Enabled;
      b2 ? commander.unApplyFormat(underlineFormatter) : commander.applyFormat(underlineFormatter, true);
    }
  };
}
function underlineTool() {
  return new ButtonTool(underlineToolConfigFactory);
}
function unlinkToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const selection = injector.get(Selection);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  return {
    tooltip: i18n.get("plugins.toolbar.unlinkTool.tooltip"),
    iconClasses: ["textbus-icon-unlink"],
    queryState() {
      const state = query.queryFormat(linkFormatter);
      if (state.state === QueryStateType.Normal) {
        state.state = QueryStateType.Disabled;
      }
      return state;
    },
    onClick() {
      if (selection.isCollapsed) {
        const slot = selection.startSlot;
        slot.getFormatRangesByFormatter(linkFormatter, 0, slot.length).filter((f2) => {
          return f2.startIndex < selection.startOffset && f2.endIndex >= selection.endOffset;
        }).forEach((f2) => {
          slot.retain(f2.startIndex);
          slot.retain(f2.endIndex - f2.startIndex, linkFormatter, null);
        });
      } else {
        commander.unApplyFormat(linkFormatter);
      }
    }
  };
}
function unlinkTool() {
  return new ButtonTool(unlinkToolConfigFactory);
}
function verticalAlignToolConfigFactory(injector) {
  const i18n = injector.get(I18n);
  const query = injector.get(Query);
  const commander = injector.get(Commander);
  const childI18n = i18n.getContext("plugins.toolbar.verticalAlignTool");
  return {
    tooltip: childI18n.get("tooltip"),
    mini: true,
    options: [{
      label: childI18n.get("baseline"),
      value: "baseline",
      default: true
    }, {
      label: childI18n.get("super"),
      value: "super"
    }, {
      label: childI18n.get("sub"),
      value: "sub"
    }, {
      label: childI18n.get("top"),
      value: "top"
    }, {
      label: childI18n.get("middle"),
      value: "middle"
    }, {
      label: childI18n.get("bottom"),
      value: "bottom"
    }, {
      label: childI18n.get("textTop"),
      value: "text-top"
    }, {
      label: childI18n.get("textBottom"),
      value: "text-bottom"
    }],
    queryState() {
      return query.queryAttribute(textAlignFormatter);
    },
    onChecked(value) {
      commander.applyFormat(fontSizeFormatter, value);
    }
  };
}
function verticalAlignTool() {
  return new SelectTool(verticalAlignToolConfigFactory);
}
var toolbarErrorFn = makeError("Toolbar");
var Toolbar = class {
  constructor(toolFactories = [], host) {
    this.toolFactories = toolFactories;
    this.host = host;
    this.subs = [];
    this.tools = toolFactories.map((i2) => {
      return Array.isArray(i2) ? i2.map((j2) => j2()) : i2();
    });
  }
  setup(injector) {
    const layout = injector.get(Layout);
    const selection = injector.get(Selection);
    const renderer = injector.get(Renderer);
    const options = injector.get(EDITOR_OPTIONS);
    this.elementRef = createElement("div", {
      classes: ["textbus-toolbar"],
      children: [
        this.toolWrapper = createElement("div", {
          classes: ["textbus-toolbar-wrapper"]
        }),
        this.keymapPrompt = createElement("div", {
          classes: ["textbus-toolbar-keymap-prompt"]
        })
      ]
    });
    if (options.theme) {
      this.elementRef.classList.add("textbus-toolbar-" + options.theme);
    }
    const selector = this.host;
    if (selector) {
      let host;
      if (typeof selector === "string") {
        host = document.querySelector(selector);
      } else {
        host = selector;
      }
      if (!host || !(host instanceof HTMLElement)) {
        throw toolbarErrorFn("selector is not an HTMLElement, or the CSS selector cannot find a DOM element in the document.");
      }
      host.append(this.elementRef);
    } else {
      layout.top.append(this.elementRef);
    }
    this.tools.forEach((tool) => {
      const group = document.createElement("div");
      group.classList.add("textbus-toolbar-group");
      this.toolWrapper.appendChild(group);
      if (Array.isArray(tool)) {
        tool.forEach((t2) => {
          group.appendChild(t2.setup(injector, this.toolWrapper));
        });
        return;
      }
      group.appendChild(tool.setup(injector, this.toolWrapper));
    });
    const tools = this.tools.flat();
    this.subs.push(merge(selection.onChange, renderer.onViewUpdated).pipe(auditTime(100)).subscribe(() => {
      tools.forEach((tool) => {
        tool.refreshState();
      });
    }), fromEvent(this.elementRef, "mouseover").subscribe((ev) => {
      const keymap = this.findNeedShowKeymapHandler(ev.target);
      if (keymap) {
        try {
          const config = JSON.parse(keymap);
          this.keymapPrompt.innerHTML = "";
          this.keymapPrompt.append(...createKeymap(config));
          this.keymapPrompt.classList.add("textbus-toolbar-keymap-prompt-show");
          return;
        } catch (e) {
        }
      }
      this.keymapPrompt.classList.remove("textbus-toolbar-keymap-prompt-show");
    }));
  }
  onDestroy() {
    this.subs.forEach((i2) => i2.unsubscribe());
  }
  findNeedShowKeymapHandler(el) {
    if (el === this.elementRef) {
      return "";
    }
    if (el.dataset.keymap) {
      return el.dataset.keymap;
    }
    return this.findNeedShowKeymapHandler(el.parentNode);
  }
};
var rootComponent = defineComponent({
  type: ContentType.BlockComponent,
  name: "RootComponent",
  setup(data) {
    const injector = useContext();
    const selection = injector.get(Selection);
    const options = injector.get(EDITOR_OPTIONS);
    const docContainer = injector.get(VIEW_DOCUMENT);
    const self2 = useSelf();
    const slots = useSlots((data === null || data === void 0 ? void 0 : data.slots) || [new Slot([
      ContentType.Text,
      ContentType.BlockComponent,
      ContentType.InlineComponent
    ])]);
    onContentInsert((ev) => {
      if (typeof ev.data.content === "string" || ev.data.content.type !== ContentType.BlockComponent) {
        const p2 = paragraphComponent.createInstance(injector);
        const slot = p2.slots.get(0);
        slot.insert(ev.data.content);
        ev.target.insert(p2);
        selection.setPosition(slot, slot.index);
        ev.preventDefault();
      }
    });
    onBreak((ev) => {
      const p2 = paragraphComponent.createInstance(injector);
      const slot = slots.get(0);
      slot.insert(p2);
      selection.setPosition(p2.slots.get(0), 0);
      ev.preventDefault();
    });
    onSlotRemove((ev) => {
      ev.preventDefault();
    });
    const rootNode = useRef();
    const subscription = new Subscription();
    onViewInit(() => {
      subscription.add(fromEvent(docContainer, "click").subscribe((ev) => {
        var _a2;
        const rect = rootNode.current.getBoundingClientRect();
        const firstSlot = slots.first;
        if (ev.clientY > rect.top + rect.height - 30) {
          const lastContent = firstSlot.getContentAtIndex(firstSlot.length - 1);
          if (!firstSlot.isEmpty && typeof lastContent !== "string" && lastContent.name !== paragraphComponent.name) {
            const index = firstSlot.index;
            firstSlot.retain(firstSlot.length);
            const p2 = paragraphComponent.createInstance(injector);
            firstSlot.insert(p2);
            firstSlot.retain(index);
            selection.setPosition(p2.slots.get(0), 0);
          }
        } else if (ev.target === rootNode.current) {
          let parentComponent = (_a2 = selection.focusSlot) === null || _a2 === void 0 ? void 0 : _a2.parent;
          while (parentComponent && parentComponent.parentComponent !== self2) {
            parentComponent = parentComponent.parentComponent;
          }
          if (!parentComponent) {
            return;
          }
          const index = firstSlot.indexOf(parentComponent);
          if (index > -1) {
            if (ev.clientX - rect.left < 4) {
              selection.setPosition(firstSlot, index);
              selection.restore();
            } else if (rect.left + rect.width - ev.clientX < 4) {
              selection.setPosition(firstSlot, index + 1);
              selection.restore();
            }
          }
        }
      }));
    });
    onDestroy(() => {
      subscription.unsubscribe();
    });
    onCompositionStart(() => {
      var _a2;
      (_a2 = rootNode.current) === null || _a2 === void 0 ? void 0 : _a2.setAttribute("data-placeholder", "");
    });
    return {
      render(slotRender) {
        return slotRender(slots.get(0), (children) => {
          var _a2;
          return new VElement("div", {
            "textbus-document": "true",
            "ref": rootNode,
            "class": "tb-root",
            "data-placeholder": ((_a2 = slots.get(0)) === null || _a2 === void 0 ? void 0 : _a2.isEmpty) ? options.placeholder || "" : ""
          }, children);
        });
      }
    };
  }
});
var rootComponentLoader = {
  match() {
    return true;
  },
  read(element, context, slotParser) {
    const slot = new Slot([
      ContentType.Text,
      ContentType.BlockComponent,
      ContentType.InlineComponent
    ]);
    slotParser(slot, element);
    return rootComponent.createInstance(context, {
      state: null,
      slots: [slot]
    });
  }
};
var editorErrorFn = makeError("Editor");
var Editor = class extends Viewer {
  constructor(options = {}) {
    super(options.rootComponent || rootComponent, options.rootComponentLoader || rootComponentLoader, (() => {
      const editorProviders = [
        {
          provide: Layout,
          useFactory: () => {
            return this.layout;
          }
        },
        {
          provide: I18n,
          useValue: new I18n(i18n_zh_CN, options.i18n)
        },
        {
          provide: Editor,
          useFactory: () => {
            return this;
          }
        },
        {
          provide: FileUploader,
          useFactory(selection, message, i18n) {
            return {
              upload: (config) => {
                if (!selection.isSelected) {
                  selection.usePaths({
                    anchor: [0, 0],
                    focus: [0, 0]
                  });
                  selection.restore();
                }
                if (typeof options.uploader === "function") {
                  const result = options.uploader(config);
                  if (result instanceof Observable) {
                    return result;
                  } else if (result instanceof Promise) {
                    return fromPromise(result);
                  } else if (typeof result === "string") {
                    return of(result);
                  } else if (Array.isArray(result)) {
                    return of(result);
                  }
                }
                message.message(i18n.get("editor.noUploader"));
                return config.multiple ? of([]) : of("");
              }
            };
          },
          deps: [Selection, Message, I18n]
        },
        Dialog,
        Message
      ];
      options.providers = options.providers || [];
      options.providers.push(...editorProviders);
      options.editingStyleSheets = options.editingStyleSheets || [];
      options.editingStyleSheets.push("[textbus-document=true]::before {content: attr(data-placeholder); position: absolute; opacity: 0.6;}");
      return options;
    })());
    this.host = null;
    this.readyEvent = new Subject();
    this.onReady = this.readyEvent.asObservable();
    this.layout = new Layout(options.autoHeight);
    if (options.theme) {
      this.layout.setTheme(options.theme);
    }
    if (options.autoHeight) {
      this.layout.scroller.style.overflow = "visible";
    }
  }
  mount(selector) {
    if (typeof selector === "string") {
      this.host = document.querySelector(selector);
    } else {
      this.host = selector;
    }
    if (!this.host || !(this.host instanceof HTMLElement)) {
      throw editorErrorFn("selector is not an HTMLElement, or the CSS selector cannot find a DOM element in the document.");
    }
    this.host.append(this.layout.container);
    return super.mount(this.layout.scroller).then((rootInjector) => {
      if (this.destroyed) {
        return rootInjector;
      }
      if (!this.options.autoHeight) {
        const scrollContainer = this.layout.scroller;
        const input = rootInjector.get(Input);
        input.caret.correctScrollTop({
          onScroll: fromEvent(scrollContainer, "scroll"),
          getLimit() {
            const rect = scrollContainer.getBoundingClientRect();
            return {
              top: rect.top,
              bottom: rect.top + rect.height
            };
          },
          setOffset(offset) {
            scrollContainer.scrollTop += offset;
          }
        });
      }
      this.readyEvent.next(rootInjector);
      return rootInjector;
    });
  }
  destroy() {
    var _a2;
    if (this.destroyed) {
      return;
    }
    const types = [
      Dialog
    ];
    types.forEach((i2) => {
      this.get(i2).destroy();
    });
    this.layout.destroy();
    (_a2 = this.layout.container.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.layout.container);
    super.destroy();
  }
};
function styleInject(css, ref) {
  if (ref === void 0)
    ref = {};
  var insertAt = ref.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z$1 = '.tb-jumbotron-setting {\n  display: none;\n  border-radius: 4px;\n  font-size: 14px;\n  position: absolute;\n  right: 10px;\n  top: 10px;\n  background: #fff;\n  box-shadow: 1px 2px 3px rgba(0, 0, 0, 0.1);\n  color: #333;\n  border: 0;\n  outline: none;\n  cursor: pointer;\n}\n\n.tb-jumbotron-setting:hover {\n  color: #1296db;\n}\n\ntb-jumbotron:hover .tb-jumbotron-setting {\n  display: block;\n}\n\n.tb-step-item-add {\n  position: absolute;\n  right: 0;\n  top: 0;\n  display: none;\n  cursor: pointer;\n}\n\n.tb-step-item-add:hover {\n  transform: scale(1.2);\n}\n\n.tb-step-item-add:after {\n  content: "+";\n}\n\n.tb-step-item:hover .tb-step-item-add {\n  display: block;\n}\n\n.tb-step-item-icon {\n  cursor: pointer;\n}\n\n.td-table-multiple-select *::selection {\n  background-color: transparent !important;\n}\n\n.tb-timeline-icon:hover {\n  transform: scale(1.2);\n  cursor: pointer;\n}\n\n.tb-timeline-add {\n  display: none;\n  position: absolute;\n  right: 0;\n  top: 0;\n  font-size: 20px;\n  line-height: 1;\n  cursor: pointer;\n}\n\n.tb-timeline-add:before {\n  content: "+";\n}\n\n.tb-timeline-add:hover {\n  transform: scale(1.2);\n}\n\n.tb-timeline-item:hover .tb-timeline-add {\n  display: block;\n}\n\n.tb-timeline-content {\n  overflow: hidden;\n}\n\ntb-word-explain {\n  position: relative;\n}\n\ntb-word-explain:hover .tb-word-explain-close {\n  display: block;\n}\n\n.tb-word-explain-close {\n  display: none;\n  position: absolute;\n  right: 10px;\n  top: 0;\n  font-size: 20px;\n  line-height: 1;\n  cursor: pointer;\n}\n\n.tb-word-explain-close:hover {\n  transform: scale(1.2);\n}\n\n.tb-word-explain-close:before {\n  content: "u00d7";\n}';
styleInject(css_248z$1);
var css_248z = '.tb-alert {\n  display: block;\n  padding: 10px 15px;\n  border-radius: 6px;\n  border: 1px solid #e9eaec;\n  background-color: #f8f8f9;\n  margin-top: 1em;\n  margin-bottom: 1em;\n}\n\n.tb-alert.tb-alert-primary {\n  border-color: rgba(18, 150, 219, 0.3);\n  background-color: rgba(18, 150, 219, 0.15);\n}\n\n.tb-alert.tb-alert-primary.tb-alert-fill {\n  color: #fff;\n  background-color: #1296db;\n}\n\n.tb-alert.tb-alert-success {\n  border-color: rgba(21, 189, 154, 0.3);\n  background-color: rgba(21, 189, 154, 0.15);\n}\n\n.tb-alert.tb-alert-success.tb-alert-fill {\n  color: #fff;\n  background-color: #15bd9a;\n}\n\n.tb-alert.tb-alert-info {\n  border-color: rgba(106, 209, 236, 0.3);\n  background-color: rgba(106, 209, 236, 0.15);\n}\n\n.tb-alert.tb-alert-info.tb-alert-fill {\n  color: #fff;\n  background-color: #6ad1ec;\n}\n\n.tb-alert.tb-alert-warning {\n  border-color: rgba(255, 153, 0, 0.3);\n  background-color: rgba(255, 153, 0, 0.15);\n}\n\n.tb-alert.tb-alert-warning.tb-alert-fill {\n  color: #fff;\n  background-color: #f90;\n}\n\n.tb-alert.tb-alert-danger {\n  border-color: rgba(231, 79, 94, 0.3);\n  background-color: rgba(231, 79, 94, 0.15);\n}\n\n.tb-alert.tb-alert-danger.tb-alert-fill {\n  color: #fff;\n  background-color: #E74F5E;\n}\n\n.tb-alert.tb-alert-dark {\n  border-color: rgba(73, 80, 96, 0.3);\n  background-color: rgba(73, 80, 96, 0.15);\n}\n\n.tb-alert.tb-alert-dark.tb-alert-fill {\n  color: #fff;\n  background-color: #495060;\n}\n\n.tb-alert.tb-alert-gray {\n  border-color: rgba(187, 190, 196, 0.3);\n  background-color: rgba(187, 190, 196, 0.15);\n}\n\n.tb-alert.tb-alert-gray.tb-alert-fill {\n  color: #fff;\n  background-color: #bbbec4;\n}\n\n.tb-alert-fill code {\n  background-color: rgba(255, 255, 255, 0.2);\n  border: none;\n}\n\n.tb-blockquote {\n  padding: 10px 15px;\n  border-left: 10px solid #dddee1;\n  background-color: #f8f8f9;\n  margin: 1em 0;\n  border-radius: 4px;\n}\n\n.tb-blockquote > *:first-child {\n  margin-top: 0;\n}\n\n.tb-blockquote > *:last-child {\n  margin-bottom: 0;\n}\n\ntb-image-card {\n  display: block;\n  margin-top: 10px;\n  margin-bottom: 20px;\n  box-shadow: 1px 2px 3px rgba(0, 0, 0, 0.1);\n  border-radius: 3px;\n  overflow: hidden;\n}\n\ntb-image-card > div > img {\n  width: 100%;\n  display: block;\n  min-height: 40px;\n}\n\ntb-image-card > p {\n  margin: 0;\n  text-align: center;\n  font-size: 15px;\n  color: #aaa;\n  height: 24px;\n  line-height: 24px;\n  padding: 6px 20px;\n  box-sizing: content-box;\n}\n\n.tb-img {\n  max-width: 100%;\n}\n\ntb-jumbotron {\n  display: block;\n  min-height: 200px;\n  margin-bottom: 1em;\n  background-color: #eee;\n  padding: 20px;\n  position: relative;\n  border-radius: 4px;\n  overflow: hidden;\n}\n\ntb-katex, .katex-display, .katex, .katex-html {\n  display: inline-block;\n}\n\ntb-katex {\n  margin-left: 0.5em;\n  margin-right: 0.5em;\n}\n\n.tb-list-item {\n  margin-top: 0.5em;\n  margin-bottom: 0.5em;\n}\n\n.tb-hl-keyword {\n  font-weight: bold;\n}\n\n.tb-hl-string {\n  color: rgb(221, 17, 68);\n}\n\n.tb-hl-function {\n  color: rgb(0, 134, 179);\n}\n\n.tb-hl-number {\n  color: #388138;\n}\n\n.tb-hl-tag {\n  color: rgb(0, 0, 128);\n}\n\n.tb-hl-comment {\n  color: rgb(153, 153, 136);\n  font-style: italic;\n}\n\n.tb-hl-boolean {\n  color: #388138;\n  font-weight: bold;\n}\n\n.tb-hl-builtin {\n  color: rgb(0, 134, 179);\n}\n\n.tb-hl-regex {\n  color: #f60;\n}\n\n.tb-hl-attr-name {\n  color: rgb(0, 134, 179);\n}\n\n.tb-hl-attr-value {\n  color: rgb(221, 17, 68);\n}\n\n.tb-hl-class-name {\n  color: rgb(0, 134, 179);\n  font-weight: bold;\n}\n\n.tb-hl-selector {\n  color: rgb(0, 134, 179);\n  font-weight: bold;\n}\n\n.tb-pre[theme=dark] .tb-hl-keyword {\n  color: rgb(0, 134, 179);\n}\n\n.tb-pre[theme=dark] .tb-hl-tag {\n  color: rgb(0, 134, 179);\n}\n\n.tb-pre[theme=dark] .tb-hl-comment {\n  color: #4c5156;\n}\n\n.tb-pre[theme=dark] .tb-hl-string {\n  color: #ce5a70;\n}\n\n.tb-pre[theme=dark] .tb-hl-attr-value {\n  color: #ce5a70;\n}\n\n.tb-pre[theme=dark] .tb-hl-regex {\n  color: #af741d;\n}\n\n.tb-pre[theme=dark] .tb-hl-selector {\n  color: #ce5a70;\n  font-weight: normal;\n}\n\n.tb-pre[theme=dark] .tb-pre-content {\n  color: #a9aeb2;\n  background-color: #1c2838;\n  border-color: #353535;\n}\n\n.tb-pre[theme=dark] .tb-color-content-highlight {\n  background-color: #263140;\n}\n\n.tb-pre[theme=dark] .tb-color-content-highlight .tb-code-line-emphasize {\n  opacity: 1;\n  background-color: #1c2838;\n}\n\n.tb-pre[theme=dark] .tb-code-line::before {\n  color: #536171;\n}\n\n.tb-pre[theme=dark] .tb-code-line-number-bg {\n  background-color: #2d3a48;\n  border-right-color: #292929;\n}\n\n.tb-pre[theme=vitality] .tb-hl-function {\n  color: #5e5eb9;\n}\n\n.tb-pre[theme=vitality] .tb-pre-content {\n  background-color: #fafafa;\n  border: none;\n}\n\n.tb-pre[theme=vitality] .tb-color-content-highlight {\n  background: none;\n}\n\n.tb-pre[theme=vitality] .tb-color-content-highlight .tb-code-line-emphasize {\n  opacity: 1;\n  background-color: #fdfdfd;\n}\n\n.tb-pre[theme=vitality] .tb-hl-keyword {\n  color: #659311;\n}\n\n.tb-pre[theme=vitality] .tb-hl-tag {\n  color: #5e5eb9;\n  font-weight: bold;\n}\n\n.tb-pre[theme=vitality] .tb-hl-string {\n  color: #f80;\n}\n\n.tb-pre[theme=vitality] .tb-hl-attr-name {\n  color: #659311;\n}\n\n.tb-pre[theme=vitality] .tb-hl-attr-value {\n  color: #f80;\n}\n\n.tb-pre[theme=vitality] .tb-hl-regex {\n  color: #af741d;\n}\n\n.tb-pre[theme=vitality] .tb-hl-selector {\n  color: #5e5eb9;\n  font-weight: normal;\n}\n\n.tb-pre[theme=vitality] .tb-code-line::before {\n  color: rgba(0, 0, 0, 0.3);\n}\n\n.tb-pre[theme=vitality] .tb-code-line-number-bg {\n  background: none;\n  border: none;\n}\n\n.tb-pre[theme=starry] .tb-hl-keyword {\n  color: #71b155;\n  font-weight: bold;\n}\n\n.tb-pre[theme=starry] .tb-hl-string {\n  color: #dd7600;\n}\n\n.tb-pre[theme=starry] .tb-hl-function {\n  color: #2e89c1;\n}\n\n.tb-pre[theme=starry] .tb-hl-number {\n  color: #388138;\n}\n\n.tb-pre[theme=starry] .tb-hl-tag {\n  color: #2e89c1;\n}\n\n.tb-pre[theme=starry] .tb-hl-comment {\n  color: #5c6d6e;\n  font-style: italic;\n}\n\n.tb-pre[theme=starry] .tb-hl-boolean {\n  color: #388138;\n  font-weight: bold;\n}\n\n.tb-pre[theme=starry] .tb-hl-builtin {\n  color: #2e89c1;\n}\n\n.tb-pre[theme=starry] .tb-hl-regex {\n  color: #f60;\n}\n\n.tb-pre[theme=starry] .tb-hl-attr-name {\n  color: #71b155;\n}\n\n.tb-pre[theme=starry] .tb-hl-attr-value {\n  color: #dd7600;\n}\n\n.tb-pre[theme=starry] .tb-hl-class-name {\n  color: #2e89c1;\n  font-weight: bold;\n}\n\n.tb-pre[theme=starry] .tb-hl-selector {\n  color: #2e89c1;\n  font-weight: bold;\n}\n\n.tb-pre[theme=starry] .tb-pre-content {\n  color: #a9aeb2;\n  background-color: #182324;\n  border: none;\n}\n\n.tb-pre[theme=starry] .tb-color-content-highlight {\n  background: rgba(0, 0, 0, 0.2);\n}\n\n.tb-pre[theme=starry] .tb-color-content-highlight .tb-code-line-emphasize {\n  opacity: 1;\n  background-color: #182324;\n}\n\n.tb-pre[theme=starry] .tb-code-line::before {\n  color: #536171;\n}\n\n.tb-pre[theme=starry] .tb-code-line-number-bg {\n  background: none;\n  border: none;\n}\n\ncode, .tb-pre {\n  background-color: #fefefe;\n}\n\n.tb-pre code {\n  padding: 0;\n  border: none;\n  background: none;\n  border-radius: 0;\n  vertical-align: inherit;\n}\n\ncode {\n  padding: 1px 5px;\n  border-radius: 3px;\n  vertical-align: middle;\n  border: 1px solid rgba(0, 0, 0, 0.08);\n}\n\n.tb-pre {\n  position: relative;\n}\n\n.tb-pre-content {\n  border-radius: 5px;\n  border: 1px solid #efefef;\n  line-height: 1.418em;\n  display: flex;\n  position: relative;\n  word-break: break-all;\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  overflow: hidden;\n}\n\ncode, kbd, pre, samp {\n  font-family: Microsoft YaHei Mono, Menlo, Monaco, Consolas, Courier New, monospace;\n}\n\n.tb-code-line-number-bg {\n  background-color: #f9f9f9;\n  border-right: 1px solid #eee;\n  width: 3em;\n}\n\n.tb-pre.tb-pre-hide-line-number .tb-code-line-number-bg {\n  display: none;\n}\n.tb-pre.tb-pre-hide-line-number .tb-code-line {\n  padding-left: 20px;\n}\n\n.tb-code-content {\n  flex: 1;\n  padding: 15px 0 15px 0;\n  counter-reset: codeNum;\n}\n\n.tb-color-content-highlight {\n  background-color: #eee;\n}\n\n.tb-color-content-highlight .tb-code-line {\n  opacity: 0.56;\n}\n\n.tb-code-line {\n  position: relative;\n  display: block;\n  padding: 0 20px 0 0.5em;\n}\n\n.tb-code-line::before {\n  counter-increment: codeNum;\n  content: counter(codeNum);\n  position: absolute;\n  left: -5.3em;\n  top: 0;\n  width: 4em;\n  text-align: right;\n  padding: 0 0.8em 0 0.5em;\n  overflow: hidden;\n  white-space: nowrap;\n  color: #aeaeae;\n}\n\n.tb-color-content-highlight .tb-code-line-emphasize {\n  opacity: 1;\n  background-color: #fefefe;\n}\n\n.tb-pre-lang {\n  position: absolute;\n  right: 0;\n  top: 0;\n  opacity: 0.5;\n  pointer-events: none;\n  font-size: 13px;\n  padding: 4px 10px;\n}\n\n.tb-pre[theme=simple-dark] .tb-pre-content {\n  color: #a9aeb2;\n  background-color: #1c2838;\n  border-color: #353535;\n}\n\n.tb-pre[theme=simple-dark] .tb-color-content-highlight {\n  background-color: #263140;\n}\n\n.tb-pre[theme=simple-dark] .tb-color-content-highlight .tb-code-line-emphasize {\n  opacity: 1;\n  background-color: #1c2838;\n}\n\n.tb-pre[theme=simple-dark] .tb-hl-keyword {\n  color: rgb(0, 134, 179);\n}\n\n.tb-pre[theme=simple-dark] .tb-hl-tag {\n  color: rgb(0, 134, 179);\n}\n\n.tb-pre[theme=simple-dark] .tb-hl-comment {\n  color: #4c5156;\n}\n\n.tb-pre[theme=simple-dark] .tb-hl-string {\n  color: #ce5a70;\n}\n\n.tb-pre[theme=simple-dark] .tb-hl-attr-value {\n  color: #ce5a70;\n}\n\n.tb-pre[theme=simple-dark] .tb-hl-regex {\n  color: #af741d;\n}\n\n.tb-pre[theme=simple-dark] .tb-hl-selector {\n  color: #ce5a70;\n  font-weight: normal;\n}\n\n.tb-pre[theme=simple-dark] .tb-code-line::before {\n  color: #536171;\n}\n\n.tb-pre[theme=simple-dark] .tb-code-line-number-bg {\n  background-color: #2d3a48;\n  border-right-color: #292929;\n}\n\ntb-step {\n  display: flex;\n}\n\n.tb-step-item {\n  position: relative;\n  flex: 1;\n}\n\n.tb-step-item:last-child .tb-step-item-line {\n  display: none;\n}\n\n.tb-step-item.tb-complete .tb-step-item-line {\n  border-top-color: #15bd9a;\n}\n\n.tb-step-item.tb-complete .tb-step-item-icon {\n  background-color: #15bd9a;\n}\n\n.tb-step-item.tb-current .tb-step-item-line {\n  border-top-style: dashed;\n}\n\n.tb-step-item.tb-current .tb-step-item-icon {\n  background-color: #1296db;\n}\n\n.tb-step-item.tb-waiting .tb-step-item-line {\n  border-top-style: dashed;\n}\n\n.tb-step-item.tb-waiting .tb-step-item-icon {\n  background-color: #bbbec4;\n}\n\n.tb-step-item.tb-waiting .tb-step-item-content {\n  opacity: 0.8;\n}\n\n.tb-step-item-header {\n  position: relative;\n  margin-bottom: 1em;\n}\n\n.tb-step-item-icon {\n  width: 1.6em;\n  height: 1.6em;\n  border-radius: 50%;\n  position: relative;\n  text-align: center;\n  line-height: 1.6em;\n  color: #fff;\n  font-weight: 500;\n}\n\n.tb-step-item-line {\n  position: absolute;\n  top: 50%;\n  left: 0;\n  right: 0;\n  border-top: 1px solid #dddee1;\n}\n\n.tb-step-item-content {\n  padding-right: 15px;\n}\n\n.tb-step-title {\n  font-weight: 500;\n  margin: 0;\n  font-size: 1.2em;\n}\n\n.tb-step-title > small {\n  font-weight: normal;\n  opacity: 0.8;\n}\n\n.tb-step-content {\n  font-weight: normal;\n  margin: 0;\n}\n\n.tb-table td, .tb-table th {\n  border-width: 1px;\n  border-style: solid;\n  padding: 3px 8px;\n}\n\n.tb-table {\n  border-spacing: 0;\n  border-collapse: collapse;\n  width: 100%;\n}\n\n.tb-table-textbus td, th {\n  border-color: #aaa;\n}\n\ntb-timeline {\n  display: block;\n  padding-top: 1em;\n  padding-left: 5px;\n}\n\n.tb-timeline-item {\n  display: block;\n  position: relative;\n  padding-left: 1.5em;\n  padding-bottom: 0.5em;\n  opacity: 0.76;\n}\n\n.tb-timeline-item:first-of-type > .tb-timeline-line {\n  top: 1em;\n}\n\n.tb-timeline-item:last-of-type > .tb-timeline-line {\n  bottom: calc(100% - 1em);\n}\n\n.tb-timeline-line {\n  position: absolute;\n  left: 0;\n  top: 0;\n  bottom: 0;\n  width: 0;\n  border-left: 1px solid #dddee1;\n}\n\n.tb-timeline-icon {\n  box-sizing: border-box;\n  position: absolute;\n  width: 9px;\n  height: 9px;\n  border-radius: 50%;\n  left: -4px;\n  top: 0.5em;\n  background-color: #fff;\n  border: 1px solid #bbbec4;\n}\n\n.tb-timeline-item-primary {\n  opacity: 1;\n}\n\n.tb-timeline-item-primary > .tb-timeline-icon {\n  border-color: #1296db;\n  background-color: #1296db;\n}\n\n.tb-timeline-item-primary > .tb-timeline-line {\n  border-color: #1296db;\n}\n\n.tb-timeline-item-info {\n  opacity: 1;\n}\n\n.tb-timeline-item-info > .tb-timeline-icon {\n  border-color: #6ad1ec;\n  background-color: #6ad1ec;\n}\n\n.tb-timeline-item-info > .tb-timeline-line {\n  border-color: #6ad1ec;\n}\n\n.tb-timeline-item-success {\n  opacity: 1;\n}\n\n.tb-timeline-item-success > .tb-timeline-icon {\n  border-color: #15bd9a;\n  background-color: #15bd9a;\n}\n\n.tb-timeline-item-success > .tb-timeline-line {\n  border-color: #15bd9a;\n}\n\n.tb-timeline-item-warning {\n  opacity: 1;\n}\n\n.tb-timeline-item-warning > .tb-timeline-icon {\n  border-color: #ff9900;\n  background-color: #ff9900;\n}\n\n.tb-timeline-item-warning > .tb-timeline-line {\n  border-color: #ff9900;\n}\n\n.tb-timeline-item-danger {\n  opacity: 1;\n}\n\n.tb-timeline-item-danger > .tb-timeline-icon {\n  border-color: #E74F5E;\n  background-color: #E74F5E;\n}\n\n.tb-timeline-item-danger > .tb-timeline-line {\n  border-color: #E74F5E;\n}\n\n.tb-timeline-item-dark {\n  opacity: 1;\n}\n\n.tb-timeline-item-dark > .tb-timeline-icon {\n  border-color: #495060;\n  background-color: #495060;\n}\n\n.tb-timeline-item-dark > .tb-timeline-line {\n  border-color: #495060;\n}\n\n.tb-timeline-item-gray {\n  opacity: 1;\n}\n\n.tb-timeline-item-gray > .tb-timeline-icon {\n  border-color: #bbbec4;\n  background-color: #bbbec4;\n}\n\n.tb-timeline-item-gray > .tb-timeline-line {\n  border-color: #bbbec4;\n}\n\ntb-todolist {\n  display: block;\n  margin-top: 1em;\n  margin-bottom: 1em;\n}\n\n.tb-todolist-item {\n  padding-top: 0.2em;\n  padding-bottom: 0.2em;\n  display: flex;\n}\n\n.tb-todolist-btn {\n  margin-right: 0.6em;\n}\n\n.tb-todolist-state {\n  display: inline-block;\n  margin-top: 3px;\n  width: 12px;\n  height: 12px;\n  border: 2px solid #1296db;\n  background: #fff;\n  border-radius: 3px;\n  cursor: pointer;\n  position: relative;\n  box-sizing: content-box;\n}\n\n.tb-todolist-state:after {\n  content: "";\n  position: absolute;\n  border-right: 2px solid #fff;\n  border-bottom: 2px solid #fff;\n  box-sizing: content-box;\n  left: 3px;\n  top: 1px;\n  width: 4px;\n  height: 6px;\n  transform: rotateZ(45deg);\n}\n\n.tb-todolist-state-active:after {\n  border-color: #1296db;\n}\n\n.tb-todolist-state-disabled {\n  opacity: 0.5;\n}\n\n.tb-todolist-content {\n  flex: 1;\n}\n\ntb-word-explain {\n  display: flex;\n  margin-top: 1em;\n  margin-bottom: 1em;\n  padding: 10px 20px;\n  background-color: #f8f8f9;\n  border-radius: 10px;\n}\n\n.tb-word-explain-title-group {\n  width: 140px;\n  padding-right: 20px;\n}\n\n.tb-word-explain-title {\n  margin: 0;\n  font-size: inherit;\n}\n\n.tb-word-explain-subtitle {\n  margin: 0;\n  font-weight: 300;\n  font-size: 0.9em;\n}\n\n.tb-word-explain-detail {\n  flex: 1;\n  padding-left: 20px;\n  border-left: 1px solid #ddd;\n}\n\n@media screen and (max-width: 767px) {\n  tb-word-explain {\n    display: block;\n  }\n  .tb-word-explain-title-group {\n    width: auto !important;\n    padding-right: 0;\n    display: flex;\n    align-items: baseline;\n    padding-bottom: 0.5em;\n    margin-bottom: 0.5em;\n  }\n  .tb-word-explain-subtitle {\n    margin-left: 0.5em;\n    font-weight: 300;\n    font-size: 0.9em;\n  }\n  .tb-word-explain-detail {\n    padding-left: 0;\n    border-left: none;\n  }\n}\n.tb-root {\n  padding: 8px 8px 30px;\n}';
styleInject(css_248z);
var defaultComponentLoaders = [
  imageCardComponentLoader,
  todolistComponentLoader,
  katexComponentLoader,
  wordExplainComponentLoader,
  timelineComponentLoader,
  stepComponentLoader,
  alertComponentLoader,
  jumbotronComponentLoader,
  audioComponentLoader,
  blockquoteComponentLoader,
  blockComponentLoader,
  headingComponentLoader,
  imageComponentLoader,
  listComponentLoader,
  paragraphComponentLoader,
  preComponentLoader,
  tableComponentLoader,
  videoComponentLoader
];
var defaultFormatLoaders = [
  boldFormatLoader,
  italicFormatLoader,
  colorFormatLoader,
  fontFamilyFormatLoader,
  fontSizeFormatLoader,
  letterSpacingFormatLoader,
  lineHeightFormatLoader,
  strikeThroughFormatLoader,
  subscriptFormatLoader,
  superscriptFormatLoader,
  underlineFormatLoader,
  codeFormatLoader,
  linkFormatLoader,
  textBackgroundColorFormatLoader,
  verticalAlignFormatLoader
];
var defaultAttributeLoaders = [
  blockBackgroundColorFormatLoader,
  textAlignFormatLoader,
  textIndentFormatLoader,
  dirFormatLoader
];
var defaultComponents = [
  audioComponent,
  blockComponent,
  blockquoteComponent,
  headingComponent,
  imageComponent,
  listComponent,
  paragraphComponent,
  preComponent,
  tableComponent,
  videoComponent,
  imageCardComponent,
  todolistComponent,
  katexComponent,
  wordExplainComponent,
  timelineComponent,
  stepComponent,
  alertComponent,
  jumbotronComponent
];
var defaultFormatters = [
  boldFormatter,
  italicFormatter,
  colorFormatter,
  fontFamilyFormatter,
  fontSizeFormatter,
  letterSpacingFormatter,
  lineHeightFormatter,
  strikeThroughFormatter,
  subscriptFormatter,
  superscriptFormatter,
  underlineFormatter,
  codeFormatter,
  linkFormatter,
  textBackgroundColorFormatter,
  verticalAlignFormatter
];
var defaultAttributes = [
  blockBackgroundColorFormatter,
  textAlignFormatter,
  textIndentFormatter,
  dirFormatter
];
var defaultOptions = {
  editingStyleSheets: [
    `[textbus-document=true] [style*=color]:not([style*=background-color])
     [textbus-document=true] a {color: inherit;}
     [textbus-document=true] a {text-decoration: underline; color: #449fdb; cursor: text;}
     [textbus-document=true] {line-height: 1.5}`,
    css_248z$1
  ],
  styleSheets: [css_248z],
  components: defaultComponents,
  formatters: defaultFormatters,
  componentLoaders: defaultComponentLoaders,
  formatLoaders: defaultFormatLoaders,
  attributes: defaultAttributes,
  attributeLoaders: defaultAttributeLoaders
};
var defaultTools = [
  [historyBackTool, historyForwardTool],
  [defaultGroupTool],
  [componentsTool],
  [headingTool],
  [boldTool, italicTool, strikeThroughTool, underlineTool],
  [olTool, ulTool],
  [fontSizeTool, textIndentTool],
  [colorTool, textBackgroundTool],
  [insertParagraphBeforeTool, insertParagraphAfterTool],
  [fontFamilyTool],
  [linkTool, unlinkTool],
  [imageTool],
  [textAlignTool],
  [tableAddTool, tableRemoveTool],
  [formatPainterTool],
  [cleanTool]
];
function createEditor(options = {}) {
  return new Editor(Object.assign(Object.assign({ plugins: [
    new Toolbar(defaultTools),
    new LinkJumpTipPlugin(),
    new ContextMenu()
  ] }, defaultOptions), options));
}
export {
  BlockAttrFormatter,
  BlockAttrLoader,
  BlockStyleFormatLoader,
  BlockStyleFormatter,
  ButtonTool,
  CodeStyleFormatter,
  ContextMenu,
  Dialog,
  DialogTool,
  DropdownTool,
  Editor,
  FileUploader,
  Form,
  FormButton,
  FormHidden,
  FormNumber,
  FormRadio,
  FormSelect,
  FormStatic,
  FormSwitch,
  FormTextField,
  FormTextarea,
  GroupTool,
  I18n,
  InlineElementFormatter,
  InlineStyleFormatLoader,
  InlineStyleFormatter,
  InlineTagFormatLoader,
  InlineTagLeafStyleFormatter,
  InlineTagStyleFormatLoader,
  InlineTagStyleFormatter,
  Layout,
  LinkFormatLoader,
  LinkFormatter,
  LinkJumpTipPlugin,
  Matcher,
  Message,
  OuterStyleFormatLoader,
  OuterStyleFormatter,
  SegmentDropdownTool,
  SelectTool,
  TableComponentSelectionAwarenessDelegate,
  ToolType,
  Toolbar,
  alertComponent,
  alertComponentLoader,
  audioComponent,
  audioComponentLoader,
  audioTool,
  audioToolConfigFactory,
  autoComplete,
  blockBackgroundColorFormatLoader,
  blockBackgroundColorFormatter,
  blockComponent,
  blockComponentLoader,
  blockTags,
  blockquoteComponent,
  blockquoteComponentLoader,
  blockquoteTool,
  blockquoteToolConfigFactory,
  boldFormatLoader,
  boldFormatter,
  boldTool,
  boldToolConfigFactory,
  cleanTool,
  cleanToolConfigFactory,
  codeFormatLoader,
  codeFormatter,
  codeStyleFormatter,
  codeStyles,
  codeTool,
  codeToolConfigFactory,
  colorFormatLoader,
  colorFormatter,
  colorTool,
  colorToolConfigFactory,
  componentsTool,
  componentsToolConfigFactory,
  createCell,
  createCodeSlot,
  createEditor,
  createJumbotronSlot,
  createStepSlot,
  createTimelineItem,
  defaultAttributeLoaders,
  defaultAttributes,
  defaultComponentLoaders,
  defaultComponents,
  defaultFormatLoaders,
  defaultFormatters,
  defaultGroupTool,
  defaultGroupToolFactory,
  defaultOptions,
  defaultTools,
  dirFormatLoader,
  dirFormatter,
  emojiTool,
  emojiToolConfigFactory,
  findFocusCell,
  fontFamilyFormatLoader,
  fontFamilyFormatter,
  fontFamilyTool,
  fontFamilyToolConfigFactory,
  fontSizeFormatLoader,
  fontSizeFormatter,
  fontSizeTool,
  fontSizeToolConfigFactory,
  formatPainterTool,
  formatPainterToolConfigFactory,
  headingComponent,
  headingComponentLoader,
  headingTool,
  headingToolConfigFactory,
  historyBackTool,
  historyBackToolConfigFactory,
  historyForwardTool,
  historyForwardToolConfigFactory,
  i18n_en_US,
  i18n_zh_CN,
  imageCardComponent,
  imageCardComponentLoader,
  imageComponent,
  imageComponentLoader,
  imageTool,
  imageToolConfigFactory,
  inlineTags,
  insertParagraphAfterTool,
  insertParagraphAfterToolConfigFactory,
  insertParagraphBeforeTool,
  insertParagraphBeforeToolConfigFactory,
  isSupportFont,
  italicFormatLoader,
  italicFormatter,
  italicTool,
  italicToolConfigFactory,
  jumbotronComponent,
  jumbotronComponentLoader,
  katexComponent,
  katexComponentLoader,
  languageList,
  leftToRightTool,
  leftToRightToolConfigFactory,
  letterSpacingFormatLoader,
  letterSpacingFormatter,
  letterSpacingTool,
  letterSpacingToolConfigFactory,
  lineHeightFormatLoader,
  lineHeightFormatter,
  lineHeightTool,
  lineHeightToolConfigFactory,
  linkFormatLoader,
  linkFormatter,
  linkTool,
  linkToolConfigFactory,
  listComponent,
  listComponentLoader,
  olTool,
  olToolConfigFactory,
  paragraphComponent,
  paragraphComponentLoader,
  preComponent,
  preComponentLoader,
  preTool,
  preToolConfigFactory,
  rightToLeftTool,
  rightToLeftToolConfigFactory,
  rootComponent,
  rootComponentLoader,
  selectCells,
  serialize,
  slotsToTable,
  stepComponent,
  stepComponentLoader,
  strikeThroughFormatLoader,
  strikeThroughFormatter,
  strikeThroughTool,
  strikeThroughToolConfigFactory,
  subscriptFormatLoader,
  subscriptFormatter,
  subscriptTool,
  subscriptToolConfigFactory,
  superscriptFormatLoader,
  superscriptFormatter,
  superscriptTool,
  superscriptToolConfigFactory,
  tableAddTool,
  tableAddToolConfigFactory,
  tableComponent,
  tableComponentLoader,
  tableRemoveTool,
  tableRemoveToolConfigFactory,
  textAlignFormatLoader,
  textAlignFormatter,
  textAlignTool,
  textAlignToolConfigFactory,
  textBackgroundColorFormatLoader,
  textBackgroundColorFormatter,
  textBackgroundTool,
  textBackgroundToolConfigFactory,
  textIndentFormatLoader,
  textIndentFormatter,
  textIndentTool,
  textIndentToolConfigFactory,
  timelineComponent,
  timelineComponentLoader,
  todolistComponent,
  todolistComponentLoader,
  ulTool,
  ulToolConfigFactory,
  underlineFormatLoader,
  underlineFormatter,
  underlineTool,
  underlineToolConfigFactory,
  unlinkTool,
  unlinkToolConfigFactory,
  useDragResize,
  useEnterBreaking,
  useTableMultipleRange,
  verticalAlignFormatLoader,
  verticalAlignFormatter,
  verticalAlignTool,
  verticalAlignToolConfigFactory,
  videoComponent,
  videoComponentLoader,
  videoTool,
  videoToolConfigFactory,
  wordExplainComponent,
  wordExplainComponentLoader
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
//# sourceMappingURL=@textbus_editor.js.map
