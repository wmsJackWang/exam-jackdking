import "./chunk-HUBM7RA2.js";

// node_modules/typenet/src/utils/index.ts
function sleep(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
function createTextNode(text) {
  return document.createTextNode(text);
}
function createTextElement(text, style) {
  const node = document.createElement("span");
  node.textContent = text;
  node.style.cssText = style;
  return node;
}
function createLineFeed() {
  return document.createElement("br");
}

// node_modules/typenet/src/heplers.ts
var INSERT = "INSERT";
var REMOVE = "REMOVE";
var MOVE = "MOVE";
function createCursor(typeInstance) {
  var _a;
  const cursorNode = document.createElement("div");
  cursorNode.textContent = "|";
  cursorNode.className = "flicker";
  (_a = typeInstance.typeContainer) == null ? void 0 : _a.appendChild(cursorNode);
}
function insert(node, container) {
  const cursor = container.querySelector(".flicker");
  container.insertBefore(node, cursor);
}
function move(node, container) {
  const cursor = container.querySelector(".flicker");
  container.insertBefore(cursor, node);
}
function createTypeContainer(typeInstance) {
  var _a;
  const container = typeInstance.typeContainer = document.createElement("div");
  container.className = "type-container";
  container.style.cssText = typeInstance.options.style || "";
  (_a = typeInstance.root) == null ? void 0 : _a.appendChild(typeInstance.typeContainer);
}
function getCurrentChildNodes(root) {
  const nodes = Array.from(root.childNodes), childNodes = [];
  for (const node of nodes) {
    if (node.nodeType === 3 || node.nodeType == 1 && node.className != "flicker") {
      childNodes.push(node);
    }
  }
  return childNodes;
}
function handingText(container, node, speed, type) {
  return new Promise((resolve) => {
    setTimeout(() => {
      switch (type) {
        case INSERT:
          insert(node, container);
          break;
        case REMOVE:
          container.removeChild(node);
          break;
        case MOVE:
          move(node, container);
          break;
        default:
          break;
      }
      resolve(1);
    }, speed);
  });
}

// node_modules/typenet/index.ts
import "E:/github/exam-jackdking/source/vue/codecv/node_modules/typenet/src/css/animate.css";
var defaultTypeEffectOptions = { speed: 100 };
var TypeEffect = class {
  constructor(el, options = defaultTypeEffectOptions) {
    this.el = el;
    this.options = options;
    this.typeContainer = document.body;
    this.callbacks = [];
    this.cursorPosition = 0;
    this.root = document.querySelector(el);
    if (!this.root) {
      console.error("please give the correct container.");
      return;
    }
  }
  type(text, options) {
    this.callbacks.push(async () => {
      for (let i = 0, n = text.length; i < n; i++) {
        const textNode = (options == null ? void 0 : options.style) ? createTextElement(text[i], options == null ? void 0 : options.style) : createTextNode(text[i]);
        const speed = (options == null ? void 0 : options.speed) || this.options.speed;
        await handingText(this.typeContainer, textNode, speed, INSERT);
        this.cursorPosition++;
      }
    });
    return this;
  }
  remove(characters = 1, options) {
    this.callbacks.push(async () => {
      const childNodes = getCurrentChildNodes(this.typeContainer);
      let actualCharactersLength = Math.min(characters, this.cursorPosition);
      while (actualCharactersLength--) {
        const lastChildNode = childNodes[--this.cursorPosition];
        const speed = (options == null ? void 0 : options.speed) || this.options.speed;
        await handingText(this.typeContainer, lastChildNode, speed, REMOVE);
      }
    });
    return this;
  }
  move(characters = 1, options) {
    this.callbacks.push(async () => {
      const childNodes = getCurrentChildNodes(this.typeContainer), direction = characters > 0 ? "forward" : "backward";
      const dict = {
        forward: {
          actualCharactersLength: Math.min(
            characters,
            childNodes.length - this.cursorPosition
          ),
          add: 1
        },
        backward: {
          actualCharactersLength: Math.min(-characters, this.cursorPosition),
          add: -1
        }
      };
      while (dict[direction].actualCharactersLength--) {
        const siblingNode = childNodes[this.cursorPosition += dict[direction].add];
        const speed = (options == null ? void 0 : options.speed) || this.options.speed;
        await handingText(this.typeContainer, siblingNode, speed, MOVE);
      }
    });
    return this;
  }
  sleep(time) {
    this.callbacks.push(async () => await sleep(time));
    return this;
  }
  line() {
    this.callbacks.push(async () => {
      const br = createLineFeed();
      this.typeContainer.insertBefore(
        br,
        this.typeContainer.childNodes[this.cursorPosition++]
      );
    });
    return this;
  }
  async start() {
    createTypeContainer(this);
    createCursor(this);
    for (const cb of this.callbacks)
      await cb.apply(this);
  }
};
export {
  TypeEffect as default,
  defaultTypeEffectOptions
};
//# sourceMappingURL=typenet.js.map
