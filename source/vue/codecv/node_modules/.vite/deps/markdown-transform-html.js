import "./chunk-HUBM7RA2.js";

// node_modules/markdown-transform-html/lib/core/parseImage.ts
function parseImage(s) {
  let result = "";
  while (matchImage.test(s)) {
    let altStartIdx = s.indexOf("![");
    let prefix = s.slice(0, altStartIdx);
    result += prefix;
    s = s.slice(altStartIdx + 2);
    let altEndIdx = s.indexOf("](");
    let alt = s.slice(0, altEndIdx);
    s = s.slice(altEndIdx + 2);
    let linkEnd = s.indexOf(")");
    let link = s.slice(0, linkEnd);
    s = s.slice(linkEnd + 1);
    result += `<img alt=${alt} src=${link} />`;
  }
  return result + s;
}

// node_modules/markdown-transform-html/lib/core/parseSuperLink.ts
function parseSuperLink(s) {
  let result = "";
  while (matchSuperLink.test(s)) {
    let altStartIdx = s.indexOf("[");
    let prefix = s.slice(0, altStartIdx);
    result += prefix;
    s = s.slice(altStartIdx + 1);
    let altEndIdx = s.indexOf("](");
    let alt = s.slice(0, altEndIdx);
    s = s.slice(altEndIdx + 2);
    let linkEnd = s.indexOf(")");
    let link = s.slice(0, linkEnd);
    s = s.slice(linkEnd + 1);
    result += `<a href=${link} target="_blank">${alt}</a>`;
  }
  return result + s;
}

// node_modules/markdown-transform-html/lib/core/parseText.ts
function parseNormalText(text, inner = false) {
  let result = processStrongText(text);
  result = processObliqueText(result);
  result = parseSingleLineCode(result);
  result = processDeleteText(result);
  result = parseImage(result);
  result = parseSuperLink(result);
  result = parseIcon(result);
  return inner ? result : `<p>${result}</p>`;
}
function processStrongText(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf("**")) != -1) {
    result += text.slice(0, idx);
    text = text.slice(idx + 2);
    let lastIdx = text.indexOf("**");
    if (lastIdx == -1) {
      text = "**" + text;
      break;
    }
    result += `<strong>${text.slice(0, lastIdx)}</strong>`;
    text = text.slice(lastIdx + 2);
  }
  text && (result += text);
  return result;
}
function processObliqueText(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf("*")) != -1) {
    result += text.slice(0, idx);
    text = text.slice(idx + 1);
    let lastIdx = text.indexOf("*");
    if (lastIdx == -1) {
      text = "*" + text;
      break;
    }
    result += `<i>${text.slice(0, lastIdx)}</i>`;
    text = text.slice(lastIdx + 1);
  }
  text && (result += text);
  return result;
}
function processDeleteText(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf("~~")) != -1) {
    result += text.slice(0, idx);
    text = text.slice(idx + 2);
    let lastIdx = text.indexOf("~~");
    if (lastIdx == -1) {
      text = "~~" + text;
      break;
    }
    result += `<del>${text.slice(0, lastIdx)}</del>`;
    text = text.slice(lastIdx + 2);
  }
  text && (result += text);
  return result;
}
function parseSingleLineCode(text) {
  let result = "", idx = -1;
  while ((idx = text.indexOf("`")) != -1) {
    result += text.slice(0, idx);
    text = text.slice(idx + 1);
    let lastIdx = text.indexOf("`");
    if (lastIdx == -1) {
      text = "`" + text;
      break;
    }
    result += `<code class=single-code>${text.slice(0, lastIdx)}</code>`;
    text = text.slice(lastIdx + 1);
  }
  text && (result += text);
  return result;
}
function parseIcon(text) {
  return text.replace(/icon:(\w+)(\s|\b)/g, ($, $1) => {
    return `<i class='iconfont icon-${$1}'></i>`;
  });
}

// node_modules/markdown-transform-html/utils/index.ts
var matchTitle = /(#+)\s(.*)/g;
var matchOrderList = /^\s*(\d+)\.\s(.+)/;
var matchSuperLink = /\[(.*)\]\((.*)\)/;
var matchImage = /!\[(.*)\]\((.*)\)/;
function processFormat(list) {
  if (/^\s+/.test(list[0])) {
    list[0] = list[0].replace(/^(\s+)/g, ($1) => "\n");
  }
  if (!list[0].startsWith("\n")) {
    list[0] = "\n" + list[0];
  }
}
function processListItem(nodes, order) {
  let s = order ? "<ol>" : "<ul>";
  for (const node of nodes) {
    s += `<li>${parseNormalText(
      node.content + genTemplateStringOfNodes(node.children),
      true
    )}</li>`;
  }
  s += order ? "</ol>" : "</ul>";
  return s;
}
function genTemplateStringOfNodes(nodes) {
  let s = "", i = 0, n = nodes.length;
  if (n === 0)
    return "";
  while (i < n) {
    const order_list = [], no_order_list = [];
    while (i < n && nodes[i].type === "no_order") {
      no_order_list.push(nodes[i]);
      i++;
    }
    s += processListItem(no_order_list, false);
    while (i < n && nodes[i].type === "order") {
      order_list.push(nodes[i]);
      i++;
    }
    s += processListItem(order_list, true);
  }
  return s.replace(/<ul><\/ul>/, "").replace(/<ol><\/ol>/, "");
}
function isOrderList(s) {
  return matchOrderList.test(s);
}
function isNoOrderList(s) {
  let idx = s.indexOf("- ");
  return idx == 0 || idx != -1 && !s.slice(0, idx).trim();
}
function isTitle(s) {
  return s.indexOf("#") != -1;
}
function isPreCode(s) {
  return s.startsWith("```");
}
function isBLock(s) {
  return /^>/.test(s.trim());
}
function isHorizontalLine(s) {
  return s.trim() === "---";
}
function isTable(s) {
  return s.trim()[0] === "|";
}
function native(s) {
  return s.replace(/</g, "&lt;");
}
function isMultColumnStart(s) {
  return s.trim() === "::: start" || s.trim() === ":::start";
}
function isMultColumnEnd(s) {
  return s.trim() === "::: end" || s.trim() === ":::end";
}
function isMultColumn(s) {
  return s.trim() === ":::";
}
function isHeadLayoutStart(s) {
  return s.trim() === "::: headStart" || s.trim() === ":::headStart";
}
function isHeadLayoutEnd(s) {
  return s.trim() === "::: headEnd" || s.trim() === ":::headEnd";
}
function isMainLayoutStart(s) {
  return s.trim() === "::: mainStart" || s.trim() === ":::mainStart";
}
function isMainLayoutEnd(s) {
  return s.trim() === "::: mainEnd" || s.trim() === ":::mainEnd";
}

// node_modules/markdown-transform-html/lib/core/parseBlock.ts
function parseBlock(text) {
  return `<blockquote>${text.slice(1)}</blockquote>`;
}

// node_modules/markdown-transform-html/lib/core/parseCode.ts
function parseCode(templates, i, templateLength, options) {
  let result = "", language = templates[i].slice(3).trim().toLowerCase();
  ++i;
  while (i < templateLength && !templates[i].startsWith("```")) {
    result += templates[i] + "\n";
    i++;
  }
  templates[i] = "";
  const highlight = options.highlight ? `language-${language}` : "", lineNumber = options.lineNumber ? "line-numbers" : "", classes = [highlight, lineNumber].join(" ");
  result = `<pre><code ${classes && `class='${classes}'`}>${result}</code></pre>`;
  return { startIdx: i, result };
}

// node_modules/markdown-transform-html/lib/core/parseHorLine.ts
function parseHorizontalLine(text) {
  if (text.length !== 3) {
    return text;
  }
  return text === "---" ? `<hr/>` : text;
}

// node_modules/markdown-transform-html/lib/core/parseTitle.ts
function getTitleLevel(level) {
  return level.length > 6 ? 6 : level.length;
}
function parseTitle(s) {
  return s.trim().replace(matchTitle, ($1, $2, $3) => {
    return `<h${getTitleLevel($2)}>${parseNormalText($3, true)}</h${getTitleLevel($2)}>`;
  });
}

// node_modules/markdown-transform-html/lib/core/parseTable.ts
function parseTable(templates, i, templateLength) {
  let result = "<table>";
  result += processTableTHead(templates[i]);
  result += `<tbody >`;
  ++i;
  for (; i < templateLength; i++) {
    if (templates[i].trim()[0] === "|") {
      result += processTabletBody(templates[i]);
    } else {
      break;
    }
  }
  result += `</tbody></table>`;
  result = result.replace(/<tr><\/tr>/, "");
  return { startIdx: i - 1, result };
}
function processTableTHead(s) {
  let preIdx = -1, template = "<thead><tr>";
  for (let i = 0, n = s.length; i < n; i++) {
    if (s[i] == "|" && isValidedSplitChar(s, i - 1) && isValidedSplitChar(s, i + 1)) {
      if (preIdx != -1) {
        template += `<th>${parseNormalText(s.slice(preIdx + 1, i))}</th>`;
      }
      preIdx = i;
    }
  }
  return template + `</tr></thead>`;
}
function processTabletBody(s) {
  let preIdx = -1, template = "<tr>";
  for (let i = 0, n = s.length; i < n; i++) {
    if (s[i] == "|" && isValidedSplitChar(s, i - 1) && isValidedSplitChar(s, i + 1)) {
      if (preIdx != -1) {
        let cnts = s.slice(preIdx + 1, i);
        if (cnts.trim()[0] === "-") {
          continue;
        }
        template += `<td>${parseNormalText(cnts)}</td>`;
      }
      preIdx = i;
    }
  }
  return template + `</tr>`;
}
function isValidedSplitChar(s, i) {
  return s[i] === " " || s[i] == void 0;
}

// node_modules/markdown-transform-html/lib/core/parseHeadLayout.ts
function parseHeadLayout(templates, i, templateLength, options) {
  let resultStr = `<div class=head-layout>`, subStr = "";
  ++i;
  while (i < templateLength && !isHeadLayoutEnd(templates[i])) {
    if (templates[i].trim()) {
      subStr += templates[i] + "\n";
    }
    i++;
  }
  resultStr += markdownToHTML(subStr, { ...options, xss: false }) + "</div>";
  return { result: resultStr, startIdx: i };
}

// node_modules/markdown-transform-html/lib/core/parseLayout.ts
function parseLayout(templates, i, templateLength, options) {
  let resultStr = `<div class=flex-layout>`, tmpS = "";
  ++i;
  while (i < templateLength && !isMultColumnEnd(templates[i])) {
    if (isMultColumnStart(templates[i])) {
      const { result, startIdx } = parseLayout(templates, i, templateLength, options);
      tmpS += result;
      i = startIdx;
    } else if (isHeadLayoutStart(templates[i])) {
      const { result, startIdx } = parseHeadLayout(templates, i, templateLength, options);
      tmpS += result;
      i = startIdx;
    } else if (isMultColumn(templates[i])) {
      resultStr += `<div class=flex-layout-item>${markdownToHTML(tmpS, { ...options, xss: false })}</div>`;
      tmpS = "";
    } else {
      tmpS += templates[i].trim() ? "\n" + templates[i] + "\n" : "";
    }
    i++;
  }
  resultStr += `<div class=flex-layout-item>${markdownToHTML(tmpS, { ...options, xss: false })}</div>`;
  resultStr += `</div>`;
  return { result: resultStr, startIdx: i };
}

// node_modules/markdown-transform-html/lib/core/parseMainLayout.ts
function parseMainLayout(templates, i, templateLength, options) {
  let resultStr = `<div class=main-layout>`, subStr = "";
  ++i;
  while (i < templateLength && !isMainLayoutEnd(templates[i])) {
    if (templates[i].trim()) {
      subStr += templates[i] + "\n";
    }
    i++;
  }
  resultStr += markdownToHTML(subStr, { ...options, xss: false }) + "</div>";
  return { result: resultStr, startIdx: i };
}

// node_modules/markdown-transform-html/lib/core/parseListItem.ts
function parseListItem(templates, i, templateLength) {
  let result = "";
  for (; i < templateLength; i++) {
    if (!templates[i].trim()) {
      continue;
    }
    if (isOrderList(templates[i]) || isNoOrderList(templates[i])) {
      result += templates[i] + "\n";
    } else {
      break;
    }
  }
  result = processList(result);
  return { startIdx: i, result };
}
function processList(template) {
  const list = template.match(/(\s)*(-|\d+\.)\s(.+)/g);
  if (!list) {
    return template;
  }
  processFormat(list);
  const nodes = parseNoOrderSyntax(list);
  const root = genTemplateStringOfNodes(nodes);
  return root;
}
function parseNoOrderSyntax(list) {
  const lines = list;
  const result = [];
  const stack = [];
  lines.forEach((line) => {
    if (line.trim() === "") {
      return;
    }
    const leadingSpaces = line.length - line.trimLeft().length;
    const lineContent = line.trim();
    while (stack.length && leadingSpaces <= stack[stack.length - 1].indent) {
      stack.pop();
    }
    let item = null;
    if (/^-\s/.test(lineContent)) {
      item = { type: "no_order", content: lineContent.slice(2), children: [] };
    } else if (/^(\d+\.)\s/.test(lineContent)) {
      item = {
        type: "order",
        content: lineContent.slice(RegExp.$1.length),
        children: []
      };
    }
    if (item) {
      if (stack.length) {
        stack[stack.length - 1].item.children.push(item);
      } else {
        result.push(item);
      }
      stack.push({ indent: leadingSpaces, item });
    }
  });
  return result;
}

// node_modules/markdown-transform-html/lib/core/parseToHTML.ts
var defaultOptions = {
  lineNumber: false,
  highlight: false,
  xss: true
};
function markdownToHTML(template, options) {
  let op = options || defaultOptions, templateStr = "";
  op = Object.assign({ ...defaultOptions }, op);
  let templates = op.xss ? native(template).split("\n") : template.split("\n"), len = (templates == null ? void 0 : templates.length) || 0;
  for (let i = 0; i < len; ) {
    if (isTitle(templates[i])) {
      templateStr += parseTitle(templates[i]);
    } else if (isHeadLayoutStart(templates[i])) {
      const { result, startIdx } = parseHeadLayout(templates, i, len, op);
      i = startIdx;
      templateStr += result;
    } else if (isMainLayoutStart(templates[i])) {
      const { result, startIdx } = parseMainLayout(templates, i, len, op);
      i = startIdx;
      templateStr += result;
    } else if (isMultColumnStart(templates[i])) {
      const { result, startIdx } = parseLayout(templates, i, len, op);
      i = startIdx;
      templateStr += result;
    } else if (isHorizontalLine(templates[i])) {
      templateStr += parseHorizontalLine(templates[i]);
      ++i;
    } else if (isTable(templates[i])) {
      const { result, startIdx } = parseTable(templates, i, len);
      i = startIdx;
      templateStr += result;
    } else if (isNoOrderList(templates[i]) || isOrderList(templates[i])) {
      const { result, startIdx } = parseListItem(templates, i, len);
      i = startIdx - 1;
      templateStr += result;
    } else if (isPreCode(templates[i])) {
      const { result, startIdx } = parseCode(templates, i, len, op);
      i = startIdx;
      templateStr += result;
    } else if (isBLock(templates[i].trim())) {
      templateStr += parseBlock(templates[i].trim());
    } else {
      if (templates[i] = templates[i].trim()) {
        templateStr += parseNormalText(templates[i]);
      }
    }
    i++;
  }
  return templateStr;
}
export {
  markdownToHTML
};
//# sourceMappingURL=markdown-transform-html.js.map
